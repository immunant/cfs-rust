#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
#![feature(c_variadic, extern_types)]
#![allow(unused_variables)]
#![allow(unused_unsafe)]
#![allow(static_mut_refs)]
#![allow(path_statements)]
#![allow(unused_must_use)]
use memoffset::offset_of;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type CFE_MissionLib_SoftwareBus_Interface;
    pub type EdsLib_DatabaseObject;
    pub type __dirstream;
    pub type sockaddr_x25;
    pub type sockaddr_un;
    pub type sockaddr_ns;
    pub type sockaddr_iso;
    pub type sockaddr_ipx;
    pub type sockaddr_inarp;
    pub type sockaddr_eon;
    pub type sockaddr_dl;
    pub type sockaddr_ax25;
    pub type sockaddr_at;
    fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
    fn pthread_exit(__retval: *mut libc::c_void) -> !;
    fn pthread_join(__th: pthread_t, __thread_return: *mut *mut libc::c_void) -> libc::c_int;
    fn pthread_detach(__th: pthread_t) -> libc::c_int;
    fn pthread_self() -> pthread_t;
    fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> libc::c_int;
    fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
    fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> libc::c_int;
    fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: libc::c_int,
    ) -> libc::c_int;
    fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> libc::c_int;
    fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> libc::c_int;
    fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: libc::c_int,
    ) -> libc::c_int;
    fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: libc::c_int,
    ) -> libc::c_int;
    fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t, __stacksize: size_t) -> libc::c_int;
    fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: libc::c_int,
        __param: *const sched_param,
    ) -> libc::c_int;
    fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut libc::c_int,
        __param: *mut sched_param,
    ) -> libc::c_int;
    fn pthread_setschedprio(__target_thread: pthread_t, __prio: libc::c_int) -> libc::c_int;
    fn pthread_setname_np(__target_thread: pthread_t, __name: *const libc::c_char) -> libc::c_int;
    fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: size_t,
        __cpuset: *const cpu_set_t,
    ) -> libc::c_int;
    fn pthread_setcancelstate(__state: libc::c_int, __oldstate: *mut libc::c_int) -> libc::c_int;
    fn pthread_setcanceltype(__type: libc::c_int, __oldtype: *mut libc::c_int) -> libc::c_int;
    fn pthread_cancel(__th: pthread_t) -> libc::c_int;
    fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
    fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
    fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
    fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: libc::c_int) -> libc::c_int;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
    fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
    fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: libc::c_int,
    ) -> libc::c_int;
    fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: libc::c_int,
    ) -> libc::c_int;
    fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
    fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
    fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
    fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> libc::c_int;
    fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> libc::c_int;
    fn timer_delete(__timerid: timer_t) -> libc::c_int;
    fn timer_settime(
        __timerid: timer_t,
        __flags: libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> libc::c_int;
    fn __sysconf(__name: libc::c_int) -> libc::c_long;
    fn sched_get_priority_min(__algorithm: libc::c_int) -> libc::c_int;
    fn sched_get_priority_max(__algorithm: libc::c_int) -> libc::c_int;
    fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
    fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
    fn pthread_cond_wait(__cond: *mut pthread_cond_t, __mutex: *mut pthread_mutex_t)
        -> libc::c_int;
    fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
    fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn pthread_getspecific(__key: pthread_key_t) -> *mut libc::c_void;
    fn pthread_setspecific(__key: pthread_key_t, __pointer: *const libc::c_void) -> libc::c_int;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> libc::c_int;
    fn fgetc(__stream: *mut FILE) -> libc::c_int;
    fn fgets(__s: *mut libc::c_char, __n: libc::c_int, __stream: *mut FILE) -> *mut libc::c_char;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn perror(__s: *const libc::c_char);
    fn strtol(_: *const libc::c_char, _: *mut *mut libc::c_char, _: libc::c_int) -> libc::c_long;
    fn strtoul(_: *const libc::c_char, _: *mut *mut libc::c_char, _: libc::c_int) -> libc::c_ulong;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
    fn remove(__filename: *const libc::c_char) -> libc::c_int;
    fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn abort() -> !;
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn memmove(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
        -> *mut libc::c_void;
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn memcmp(_: *const libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> libc::c_int;
    fn memchr(_: *const libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncpy(_: *mut libc::c_char, _: *const libc::c_char, _: libc::c_ulong)
        -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn toupper(_: libc::c_int) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __errno_location() -> *mut libc::c_int;
    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: size_t) -> ssize_t;
    fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
    fn execlp(__file: *const libc::c_char, __arg: *const libc::c_char, _: ...) -> libc::c_int;
    fn sysconf(__name: libc::c_int) -> libc::c_long;
    fn getpid() -> __pid_t;
    fn geteuid() -> __uid_t;
    fn getegid() -> __gid_t;
    fn fork() -> __pid_t;
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn rmdir(__path: *const libc::c_char) -> libc::c_int;
    fn gethostname(__name: *mut libc::c_char, __len: size_t) -> libc::c_int;
    fn gethostid() -> libc::c_long;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    static mut optarg: *mut libc::c_char;
    fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
    fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, _: ...) -> libc::c_int;
    fn fchmod(__fd: libc::c_int, __mode: __mode_t) -> libc::c_int;
    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;
    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
    fn kill(__pid: __pid_t, __sig: libc::c_int) -> libc::c_int;
    fn sigfillset(__set: *mut sigset_t) -> libc::c_int;
    fn sigdelset(__set: *mut sigset_t, __signo: libc::c_int) -> libc::c_int;
    fn sigprocmask(
        __how: libc::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> libc::c_int;
    fn sigismember(__set: *const sigset_t, __signo: libc::c_int) -> libc::c_int;
    fn sigsuspend(__set: *const sigset_t) -> libc::c_int;
    fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> libc::c_int;
    fn __libc_current_sigrtmax() -> libc::c_int;
    fn waitpid(__pid: __pid_t, __stat_loc: *mut libc::c_int, __options: libc::c_int) -> __pid_t;
    fn sigaddset(__set: *mut sigset_t, __signo: libc::c_int) -> libc::c_int;
    fn __libc_current_sigrtmin() -> libc::c_int;
    fn sigemptyset(__set: *mut sigset_t) -> libc::c_int;
    fn pthread_sigmask(
        __how: libc::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> libc::c_int;
    fn sigwait(__set: *const sigset_t, __sig: *mut libc::c_int) -> libc::c_int;
    fn pthread_kill(__threadid: pthread_t, __signo: libc::c_int) -> libc::c_int;
    fn sigaction(
        __sig: libc::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> libc::c_int;
    fn sem_init(__sem: *mut sem_t, __pshared: libc::c_int, __value: libc::c_uint) -> libc::c_int;
    fn mq_receive(
        __mqdes: mqd_t,
        __msg_ptr: *mut libc::c_char,
        __msg_len: size_t,
        __msg_prio: *mut libc::c_uint,
    ) -> ssize_t;
    fn mq_timedreceive(
        __mqdes: mqd_t,
        __msg_ptr: *mut libc::c_char,
        __msg_len: size_t,
        __msg_prio: *mut libc::c_uint,
        __abs_timeout: *const timespec,
    ) -> ssize_t;
    fn mq_timedsend(
        __mqdes: mqd_t,
        __msg_ptr: *const libc::c_char,
        __msg_len: size_t,
        __msg_prio: libc::c_uint,
        __abs_timeout: *const timespec,
    ) -> libc::c_int;
    fn sem_wait(__sem: *mut sem_t) -> libc::c_int;
    fn sem_post(__sem: *mut sem_t) -> libc::c_int;
    fn mq_unlink(__name: *const libc::c_char) -> libc::c_int;
    fn mq_close(__mqdes: mqd_t) -> libc::c_int;
    fn mq_open(__name: *const libc::c_char, __oflag: libc::c_int, _: ...) -> mqd_t;
    fn sem_destroy(__sem: *mut sem_t) -> libc::c_int;
    fn sem_getvalue(__sem: *mut sem_t, __sval: *mut libc::c_int) -> libc::c_int;
    fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> libc::c_int;
    fn opendir(__name: *const libc::c_char) -> *mut DIR;
    fn closedir(__dirp: *mut DIR) -> libc::c_int;
    fn readdir(__dirp: *mut DIR) -> *mut dirent;
    fn rewinddir(__dirp: *mut DIR);
    fn statvfs(__file: *const libc::c_char, __buf: *mut statvfs) -> libc::c_int;
    fn dlerror() -> *mut libc::c_char;
    fn dlclose(__handle: *mut libc::c_void) -> libc::c_int;
    fn dlsym(__handle: *mut libc::c_void, __name: *const libc::c_char) -> *mut libc::c_void;
    fn dlopen(__file: *const libc::c_char, __mode: libc::c_int) -> *mut libc::c_void;
    fn sendto(
        __fd: libc::c_int,
        __buf: *const libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __addr_len: socklen_t,
    ) -> ssize_t;
    fn recvfrom(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __n: size_t,
        __flags: libc::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> ssize_t;
    fn accept(__fd: libc::c_int, __addr: __SOCKADDR_ARG, __addr_len: *mut socklen_t)
        -> libc::c_int;
    fn shutdown(__fd: libc::c_int, __how: libc::c_int) -> libc::c_int;
    fn connect(__fd: libc::c_int, __addr: __CONST_SOCKADDR_ARG, __len: socklen_t) -> libc::c_int;
    fn getsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *mut libc::c_void,
        __optlen: *mut socklen_t,
    ) -> libc::c_int;
    fn bind(__fd: libc::c_int, __addr: __CONST_SOCKADDR_ARG, __len: socklen_t) -> libc::c_int;
    fn listen(__fd: libc::c_int, __n: libc::c_int) -> libc::c_int;
    fn socket(__domain: libc::c_int, __type: libc::c_int, __protocol: libc::c_int) -> libc::c_int;
    fn setsockopt(
        __fd: libc::c_int,
        __level: libc::c_int,
        __optname: libc::c_int,
        __optval: *const libc::c_void,
        __optlen: socklen_t,
    ) -> libc::c_int;
    fn htons(__hostshort: uint16_t) -> uint16_t;
    fn ntohs(__netshort: uint16_t) -> uint16_t;
    fn inet_pton(
        __af: libc::c_int,
        __cp: *const libc::c_char,
        __buf: *mut libc::c_void,
    ) -> libc::c_int;
    fn inet_ntop(
        __af: libc::c_int,
        __cp: *const libc::c_void,
        __buf: *mut libc::c_char,
        __len: socklen_t,
    ) -> *const libc::c_char;
    fn backtrace(__array: *mut *mut libc::c_void, __size: libc::c_int) -> libc::c_int;
    fn shmat(
        __shmid: libc::c_int,
        __shmaddr: *const libc::c_void,
        __shmflg: libc::c_int,
    ) -> *mut libc::c_void;
    static mut _init: libc::c_uint;
    static mut _fini: libc::c_uint;
    fn ftok(__pathname: *const libc::c_char, __proj_id: libc::c_int) -> key_t;
    fn shmget(__key: key_t, __size: size_t, __shmflg: libc::c_int) -> libc::c_int;
    fn shmctl(__shmid: libc::c_int, __cmd: libc::c_int, __buf: *mut shmid_ds) -> libc::c_int;
    fn getopt_long(
        ___argc: libc::c_int,
        ___argv: *const *mut libc::c_char,
        __shortopts: *const libc::c_char,
        __longopts: *const option,
        __longind: *mut libc::c_int,
    ) -> libc::c_int;
    fn mmap(
        __addr: *mut libc::c_void,
        __len: size_t,
        __prot: libc::c_int,
        __flags: libc::c_int,
        __fd: libc::c_int,
        __offset: __off_t,
    ) -> *mut libc::c_void;
    fn poll(__fds: *mut pollfd, __nfds: nfds_t, __timeout: libc::c_int) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __clock_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type size_t = libc::c_ulong;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type pid_t = __pid_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sched_param {
    pub sched_priority: libc::c_int,
}
pub type __cpu_mask = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: libc::c_int,
    pub sigev_notify: libc::c_int,
    pub _sigev_un: C2RustUnnamed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub _pad: [libc::c_int; 12],
    pub _tid: __pid_t,
    pub _sigev_thread: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub _function: Option<unsafe extern "C" fn(__sigval_t) -> ()>,
    pub _attribute: *mut pthread_attr_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
pub type __sigval_t = sigval;
#[derive(Copy, Clone)]
#[repr(C)]
pub union sigval {
    pub sival_int: libc::c_int,
    pub sival_ptr: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __atomic_wide_counter {
    pub __value64: libc::c_ulonglong,
    pub __value32: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_key_t = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
pub type __jmp_buf = [libc::c_long; 8];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
    pub __saved_mask: __sigset_t,
}
pub type C2RustUnnamed_2 = libc::c_uint;
pub const PTHREAD_CREATE_DETACHED: C2RustUnnamed_2 = 1;
pub const PTHREAD_CREATE_JOINABLE: C2RustUnnamed_2 = 0;
pub type C2RustUnnamed_3 = libc::c_uint;
pub const PTHREAD_MUTEX_FAST_NP: C2RustUnnamed_3 = 0;
pub const PTHREAD_MUTEX_DEFAULT: C2RustUnnamed_3 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: C2RustUnnamed_3 = 2;
pub const PTHREAD_MUTEX_RECURSIVE: C2RustUnnamed_3 = 1;
pub const PTHREAD_MUTEX_NORMAL: C2RustUnnamed_3 = 0;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: C2RustUnnamed_3 = 3;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: C2RustUnnamed_3 = 2;
pub const PTHREAD_MUTEX_RECURSIVE_NP: C2RustUnnamed_3 = 1;
pub const PTHREAD_MUTEX_TIMED_NP: C2RustUnnamed_3 = 0;
pub type C2RustUnnamed_4 = libc::c_uint;
pub const PTHREAD_PRIO_PROTECT: C2RustUnnamed_4 = 2;
pub const PTHREAD_PRIO_INHERIT: C2RustUnnamed_4 = 1;
pub const PTHREAD_PRIO_NONE: C2RustUnnamed_4 = 0;
pub type C2RustUnnamed_5 = libc::c_uint;
pub const PTHREAD_EXPLICIT_SCHED: C2RustUnnamed_5 = 1;
pub const PTHREAD_INHERIT_SCHED: C2RustUnnamed_5 = 0;
pub type C2RustUnnamed_6 = libc::c_uint;
pub const PTHREAD_CANCEL_DISABLE: C2RustUnnamed_6 = 1;
pub const PTHREAD_CANCEL_ENABLE: C2RustUnnamed_6 = 0;
pub type C2RustUnnamed_7 = libc::c_uint;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: C2RustUnnamed_7 = 1;
pub const PTHREAD_CANCEL_DEFERRED: C2RustUnnamed_7 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1],
    pub __pad: [*mut libc::c_void; 4],
}
pub type va_list = __builtin_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type uid_t = __uid_t;
pub type key_t = __key_t;
pub type int8_t = __int8_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
pub type sigset_t = __sigset_t;
pub type __fd_mask = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16],
}
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type uintptr_t = libc::c_ulong;
pub type ptrdiff_t = libc::c_long;
pub type int8 = int8_t;
pub type int16 = int16_t;
pub type int32 = int32_t;
pub type int64 = int64_t;
pub type uint8 = uint8_t;
pub type uint16 = uint16_t;
pub type uint32 = uint32_t;
pub type uint64 = uint64_t;
pub type cpuaddr = uintptr_t;
pub type osal_id_t = uint32;
pub type osal_blockcount_t = size_t;
pub type osal_index_t = uint32;
pub type osal_objtype_t = uint32;
pub type osal_status_t = int32;
pub type OS_ArgCallback_t = Option<unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> ()>;
pub type OS_Event_t = libc::c_uint;
pub const OS_EVENT_MAX: OS_Event_t = 5;
pub const OS_EVENT_TASK_STARTUP: OS_Event_t = 4;
pub const OS_EVENT_RESOURCE_DELETED: OS_Event_t = 3;
pub const OS_EVENT_RESOURCE_CREATED: OS_Event_t = 2;
pub const OS_EVENT_RESOURCE_ALLOCATED: OS_Event_t = 1;
pub const OS_EVENT_RESERVED: OS_Event_t = 0;
pub type OS_EventHandler_t =
    Option<unsafe extern "C" fn(OS_Event_t, osal_id_t, *mut libc::c_void) -> int32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Target_CfeConfigData {
    pub System1HzISR: System_1HzISRFunc_t,
    pub SystemMain: System_MainFunc_t,
    pub SystemNotify: System_NotifyFunc_t,
    pub CdsSize: uint32,
    pub ResetAreaSize: uint32,
    pub UserReservedSize: uint32,
    pub RamDiskSectorSize: uint32,
    pub RamDiskTotalSectors: uint32,
    pub NonvolMountPoint: *const libc::c_char,
    pub RamdiskMountPoint: *const libc::c_char,
    pub NonvolStartupFile: *const libc::c_char,
}
pub type System_NotifyFunc_t = Option<unsafe extern "C" fn() -> ()>;
pub type System_MainFunc_t =
    Option<unsafe extern "C" fn(uint32, uint32, uint32, *const libc::c_char) -> ()>;
pub type System_1HzISRFunc_t = Option<unsafe extern "C" fn() -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Target_ConfigData {
    pub MissionName: *const libc::c_char,
    pub MissionVersion: *const libc::c_char,
    pub CfeVersion: *const libc::c_char,
    pub OsalVersion: *const libc::c_char,
    pub Config: *const libc::c_char,
    pub Date: *const libc::c_char,
    pub User: *const libc::c_char,
    pub Default_CpuName: *const libc::c_char,
    pub Default_CpuId: uint16,
    pub Default_SpacecraftId: uint16,
    pub Default_ModuleExtension: *const libc::c_char,
    pub Default_CoreFilename: *const libc::c_char,
    pub CfeConfig: *const Target_CfeConfigData,
    pub PspModuleList: *const CFE_StaticModuleLoadEntry_t,
    pub BuildEnvironment: *const CFE_ConfigKeyValue_t,
    pub ModuleVersionList: *const CFE_ConfigKeyValue_t,
    pub CoreModuleList: *const CFE_ConfigName_t,
    pub StaticAppList: *const CFE_ConfigName_t,
    pub EdsDb: *const CFE_EdsDbObject_t,
    pub DynamicEdsDb: *mut CFE_EdsDbObject_t,
    pub SbIntfDb: *const CFE_SbIntfDbObject_t,
}
pub type CFE_SbIntfDbObject_t = CFE_MissionLib_SoftwareBus_Interface;
pub type CFE_EdsDbObject_t = EdsLib_DatabaseObject;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ConfigName_t {
    pub Name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ConfigKeyValue_t {
    pub Key: *const libc::c_char,
    pub Value: *const libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_StaticModuleLoadEntry_t {
    pub Name: *const libc::c_char,
    pub Api: *const libc::c_void,
}
pub type CFE_StaticModuleApi_t = ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ResetData_t {
    pub ERLog: [CFE_ES_ERLog_MetaData_t; 20],
    pub ERLogIndex: uint32,
    pub ERLogEntries: uint32,
    pub LastAppId: uint32,
    pub SystemLog: [libc::c_char; 3072],
    pub SystemLogWriteIdx: size_t,
    pub SystemLogEndIdx: size_t,
    pub SystemLogMode: uint32,
    pub SystemLogEntryNum: uint32,
    pub Perf: CFE_ES_PerfData_t,
    pub ResetVars: CFE_ES_ResetVariables_t,
    pub TimeResetVars: CFE_TIME_ResetVars_t,
    pub EVS_Log: CFE_EVS_Log_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_Log_t {
    pub Next: uint16,
    pub LogCount: uint16,
    pub LogFullFlag: uint8,
    pub LogMode: uint8,
    pub LogOverflowCounter: uint16,
    pub LogEntry: [CFE_EVS_LongEventTlm_t; 20],
}
pub type CFE_EVS_LongEventTlm_t = CFE_EVS_LongEventTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_LongEventTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_EVS_LongEventTlm_Payload_t,
}
pub type CFE_EVS_LongEventTlm_Payload_t = CFE_EVS_LongEventTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_LongEventTlm_Payload {
    pub PacketID: CFE_EVS_PacketID_t,
    pub Message: [libc::c_char; 122],
    pub Spare1: uint8,
    pub Spare2: uint8,
}
pub type CFE_EVS_PacketID_t = CFE_EVS_PacketID;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_PacketID {
    pub AppName: [libc::c_char; 20],
    pub EventID: uint16,
    pub EventType: uint16,
    pub SpacecraftID: uint32,
    pub ProcessorID: uint32,
}
pub type CFE_MSG_TelemetryHeader_t = CFE_MSG_TelemetryHeader;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_MSG_TelemetryHeader {
    pub Msg: CFE_MSG_Message_t,
    pub Sec: CFE_MSG_TelemetrySecondaryHeader_t,
    pub Spare: [uint8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_MSG_TelemetrySecondaryHeader_t {
    pub Time: [uint8; 6],
}
pub type CFE_MSG_Message_t = CFE_MSG_Message;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_MSG_Message {
    pub CCSDS: CCSDS_SpacePacket_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CCSDS_SpacePacket_t {
    pub Pri: CCSDS_PrimaryHeader_t,
}
pub type CCSDS_PrimaryHeader_t = CCSDS_PrimaryHeader;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CCSDS_PrimaryHeader {
    pub StreamId: [uint8; 2],
    pub Sequence: [uint8; 2],
    pub Length: [uint8; 2],
}
pub type CFE_TIME_ResetVars_t = CFE_TIME_ResetVars;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_ResetVars {
    pub Signature: uint32,
    pub LeapSeconds: int16,
    pub ClockSignal: uint16,
    pub CurrentMET: CFE_TIME_SysTime_t,
    pub CurrentSTCF: CFE_TIME_SysTime_t,
    pub CurrentDelay: CFE_TIME_SysTime_t,
}
pub type CFE_TIME_SysTime_t = CFE_TIME_SysTime;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SysTime {
    pub Seconds: uint32,
    pub Subseconds: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ResetVariables_t {
    pub ResetType: uint32,
    pub ResetSubtype: uint32,
    pub BootSource: uint32,
    pub ES_CausedReset: uint32,
    pub ProcessorResetCount: uint32,
    pub MaxProcessorResetCount: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_PerfData_t {
    pub MetaData: CFE_ES_PerfMetaData_t,
    pub DataBuffer: [CFE_ES_PerfDataEntry_t; 10000],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_PerfDataEntry_t {
    pub Data: uint32,
    pub TimerUpper32: uint32,
    pub TimerLower32: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_PerfMetaData_t {
    pub Version: uint8,
    pub Endian: uint8,
    pub Spare: [uint8; 2],
    pub TimerTicksPerSecond: uint32,
    pub TimerLow32Rollover: uint32,
    pub State: uint32,
    pub Mode: uint32,
    pub TriggerCount: uint32,
    pub DataStart: uint32,
    pub DataEnd: uint32,
    pub DataCount: uint32,
    pub InvalidMarkerReported: uint32,
    pub FilterTriggerMaskSize: uint32,
    pub FilterMask: [uint32; 4],
    pub TriggerMask: [uint32; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ERLog_MetaData_t {
    pub BaseInfo: CFE_ES_ERLog_BaseInfo_t,
    pub AppID: CFE_ES_AppId_t,
    pub PspContextId: uint32,
}
pub type CFE_ES_AppId_t = CFE_ResourceId_t;
pub type CFE_ResourceId_t = uint32;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ERLog_BaseInfo_t {
    pub LogEntryType: uint32,
    pub ResetType: uint32,
    pub ResetSubtype: uint32,
    pub BootSource: uint32,
    pub ProcessorResetCount: uint32,
    pub MaxProcessorResetCount: uint32,
    pub DebugVars: CFE_ES_DebugVariables_t,
    pub TimeCode: CFE_TIME_SysTime_t,
    pub Description: [libc::c_char; 80],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_DebugVariables_t {
    pub DebugFlag: uint32,
    pub WatchdogWriteFlag: uint32,
    pub PrintfEnabledFlag: uint32,
    pub LastAppId: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_BackgroundTaskState_t {
    pub TaskID: CFE_ES_TaskId_t,
    pub WorkSem: osal_id_t,
    pub NumJobsRunning: uint32,
}
pub type CFE_ES_TaskId_t = CFE_ResourceId_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_Global_t {
    pub DebugVars: CFE_ES_DebugVariables_t,
    pub SharedDataMutex: osal_id_t,
    pub PerfDataMutex: osal_id_t,
    pub SystemState: sig_atomic_t,
    pub RegisteredTasks: uint32,
    pub TaskTable: [CFE_ES_TaskRecord_t; 64],
    pub RegisteredCoreApps: uint32,
    pub RegisteredExternalApps: uint32,
    pub LastAppId: CFE_ResourceId_t,
    pub AppTable: [CFE_ES_AppRecord_t; 32],
    pub RegisteredLibs: uint32,
    pub LastLibId: CFE_ResourceId_t,
    pub LibTable: [CFE_ES_LibRecord_t; 10],
    pub LastCounterId: CFE_ResourceId_t,
    pub CounterTable: [CFE_ES_GenCounterRecord_t; 8],
    pub CDSVars: CFE_ES_CDS_Instance_t,
    pub CDSIsAvailable: bool,
    pub BackgroundTask: CFE_ES_BackgroundTaskState_t,
    pub LastMemPoolId: CFE_ResourceId_t,
    pub MemPoolTable: [CFE_ES_MemPoolRecord_t; 10],
    pub BackgroundERLogDumpState: CFE_ES_BackgroundLogDumpGlobal_t,
    pub BackgroundPerfDumpState: CFE_ES_PerfDumpGlobal_t,
    pub BackgroundAppScanState: CFE_ES_AppTableScanState_t,
    pub TaskData: CFE_ES_TaskData_t,
    pub ResetDataPtr: *mut CFE_ES_ResetData_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_TaskData_t {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub HkPacket: CFE_ES_HousekeepingTlm_t,
    pub OneAppPacket: CFE_ES_OneAppTlm_t,
    pub MemStatsPacket: CFE_ES_MemStatsTlm_t,
    pub CmdPipe: CFE_SB_PipeId_t,
}
pub type CFE_SB_PipeId_t = CFE_ResourceId_t;
pub type CFE_ES_MemStatsTlm_t = CFE_ES_MemStatsTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_MemStatsTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_ES_PoolStatsTlm_Payload_t,
}
pub type CFE_ES_PoolStatsTlm_Payload_t = CFE_ES_PoolStatsTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_PoolStatsTlm_Payload {
    pub PoolHandle: CFE_ES_MemHandle_t,
    pub PoolStats: CFE_ES_MemPoolStats_t,
}
pub type CFE_ES_MemPoolStats_t = CFE_ES_MemPoolStats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_MemPoolStats {
    pub PoolSize: CFE_ES_MemOffset_t,
    pub NumBlocksRequested: uint32,
    pub CheckErrCtr: uint32,
    pub NumFreeBytes: CFE_ES_MemOffset_t,
    pub BlockStats: [CFE_ES_BlockStats_t; 17],
}
pub type CFE_ES_BlockStats_t = CFE_ES_BlockStats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_BlockStats {
    pub BlockSize: CFE_ES_MemOffset_t,
    pub NumCreated: uint32,
    pub NumFree: uint32,
}
pub type CFE_ES_MemOffset_t = uint32;
pub type CFE_ES_MemHandle_t = CFE_ResourceId_t;
pub type CFE_ES_OneAppTlm_t = CFE_ES_OneAppTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_OneAppTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_ES_OneAppTlm_Payload_t,
}
pub type CFE_ES_OneAppTlm_Payload_t = CFE_ES_OneAppTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_OneAppTlm_Payload {
    pub AppInfo: CFE_ES_AppInfo_t,
}
pub type CFE_ES_AppInfo_t = CFE_ES_AppInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_AppInfo {
    pub ResourceId: CFE_ResourceId_t,
    pub Type: uint32,
    pub Name: [libc::c_char; 20],
    pub EntryPoint: [libc::c_char; 20],
    pub FileName: [libc::c_char; 64],
    pub StackSize: CFE_ES_MemOffset_t,
    pub AddressesAreValid: uint32,
    pub CodeAddress: CFE_ES_MemAddress_t,
    pub CodeSize: CFE_ES_MemOffset_t,
    pub DataAddress: CFE_ES_MemAddress_t,
    pub DataSize: CFE_ES_MemOffset_t,
    pub BSSAddress: CFE_ES_MemAddress_t,
    pub BSSSize: CFE_ES_MemOffset_t,
    pub StartAddress: CFE_ES_MemAddress_t,
    pub ExceptionAction: CFE_ES_ExceptionAction_Enum_t,
    pub Priority: CFE_ES_TaskPriority_Atom_t,
    pub MainTaskId: CFE_ES_TaskId_t,
    pub ExecutionCounter: uint32,
    pub MainTaskName: [libc::c_char; 20],
    pub NumOfChildTasks: uint32,
}
pub type CFE_ES_TaskPriority_Atom_t = uint16;
pub type CFE_ES_ExceptionAction_Enum_t = uint8;
pub type CFE_ES_MemAddress_t = uint32;
pub type CFE_ES_HousekeepingTlm_t = CFE_ES_HousekeepingTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_HousekeepingTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_ES_HousekeepingTlm_Payload_t,
}
pub type CFE_ES_HousekeepingTlm_Payload_t = CFE_ES_HousekeepingTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_HousekeepingTlm_Payload {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub CFECoreChecksum: uint16,
    pub CFEMajorVersion: uint8,
    pub CFEMinorVersion: uint8,
    pub CFERevision: uint8,
    pub CFEMissionRevision: uint8,
    pub OSALMajorVersion: uint8,
    pub OSALMinorVersion: uint8,
    pub OSALRevision: uint8,
    pub OSALMissionRevision: uint8,
    pub PSPMajorVersion: uint8,
    pub PSPMinorVersion: uint8,
    pub PSPRevision: uint8,
    pub PSPMissionRevision: uint8,
    pub SysLogBytesUsed: CFE_ES_MemOffset_t,
    pub SysLogSize: CFE_ES_MemOffset_t,
    pub SysLogEntries: uint32,
    pub SysLogMode: uint32,
    pub ERLogIndex: uint32,
    pub ERLogEntries: uint32,
    pub RegisteredCoreApps: uint32,
    pub RegisteredExternalApps: uint32,
    pub RegisteredTasks: uint32,
    pub RegisteredLibs: uint32,
    pub ResetType: uint32,
    pub ResetSubtype: uint32,
    pub ProcessorResets: uint32,
    pub MaxProcessorResets: uint32,
    pub BootSource: uint32,
    pub PerfState: uint32,
    pub PerfMode: uint32,
    pub PerfTriggerCount: uint32,
    pub PerfFilterMask: [uint32; 4],
    pub PerfTriggerMask: [uint32; 4],
    pub PerfDataStart: uint32,
    pub PerfDataEnd: uint32,
    pub PerfDataCount: uint32,
    pub PerfDataToWrite: uint32,
    pub HeapBytesFree: CFE_ES_MemOffset_t,
    pub HeapBlocksFree: CFE_ES_MemOffset_t,
    pub HeapMaxBlockSize: CFE_ES_MemOffset_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_AppTableScanState_t {
    pub PendingAppStateChanges: uint32,
    pub BackgroundScanTimer: uint32,
    pub LastScanCommandCount: uint8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_PerfDumpGlobal_t {
    pub CurrentState: CFE_ES_PerfDumpState_t,
    pub PendingState: CFE_ES_PerfDumpState_t,
    pub DataFileName: [libc::c_char; 64],
    pub FileDesc: osal_id_t,
    pub WorkCredit: uint32,
    pub StateCounter: uint32,
    pub DataPos: uint32,
    pub FileSize: size_t,
}
pub type CFE_ES_PerfDumpState_t = libc::c_uint;
pub const CFE_ES_PerfDumpState_MAX: CFE_ES_PerfDumpState_t = 11;
pub const CFE_ES_PerfDumpState_CLOSE_FILE: CFE_ES_PerfDumpState_t = 10;
pub const CFE_ES_PerfDumpState_UNLOCK_DATA: CFE_ES_PerfDumpState_t = 9;
pub const CFE_ES_PerfDumpState_CLEANUP: CFE_ES_PerfDumpState_t = 8;
pub const CFE_ES_PerfDumpState_WRITE_PERF_ENTRIES: CFE_ES_PerfDumpState_t = 7;
pub const CFE_ES_PerfDumpState_WRITE_PERF_METADATA: CFE_ES_PerfDumpState_t = 6;
pub const CFE_ES_PerfDumpState_WRITE_FS_HDR: CFE_ES_PerfDumpState_t = 5;
pub const CFE_ES_PerfDumpState_LOCK_DATA: CFE_ES_PerfDumpState_t = 4;
pub const CFE_ES_PerfDumpState_DELAY: CFE_ES_PerfDumpState_t = 3;
pub const CFE_ES_PerfDumpState_OPEN_FILE: CFE_ES_PerfDumpState_t = 2;
pub const CFE_ES_PerfDumpState_INIT: CFE_ES_PerfDumpState_t = 1;
pub const CFE_ES_PerfDumpState_IDLE: CFE_ES_PerfDumpState_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_BackgroundLogDumpGlobal_t {
    pub FileWrite: CFE_FS_FileWriteMetaData_t,
    pub EntryBuffer: CFE_ES_ERLog_FileEntry_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ERLog_FileEntry_t {
    pub BaseInfo: CFE_ES_ERLog_BaseInfo_t,
    pub ContextSize: uint32,
    pub AppID: uint32,
    pub Context: [uint8; 256],
}
pub type CFE_FS_FileWriteMetaData_t = CFE_FS_FileWriteMetaData;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_FS_FileWriteMetaData {
    pub IsPending: bool,
    pub FileName: [libc::c_char; 64],
    pub FileSubType: uint32,
    pub Description: [libc::c_char; 32],
    pub GetData: CFE_FS_FileWriteGetData_t,
    pub OnEvent: CFE_FS_FileWriteOnEvent_t,
}
pub type CFE_FS_FileWriteOnEvent_t = Option<
    unsafe extern "C" fn(
        *mut libc::c_void,
        CFE_FS_FileWriteEvent_t,
        int32,
        uint32,
        size_t,
        size_t,
    ) -> (),
>;
pub type CFE_FS_FileWriteEvent_t = libc::c_uint;
pub const CFE_FS_FileWriteEvent_MAX: CFE_FS_FileWriteEvent_t = 5;
pub const CFE_FS_FileWriteEvent_RECORD_WRITE_ERROR: CFE_FS_FileWriteEvent_t = 4;
pub const CFE_FS_FileWriteEvent_HEADER_WRITE_ERROR: CFE_FS_FileWriteEvent_t = 3;
pub const CFE_FS_FileWriteEvent_CREATE_ERROR: CFE_FS_FileWriteEvent_t = 2;
pub const CFE_FS_FileWriteEvent_COMPLETE: CFE_FS_FileWriteEvent_t = 1;
pub const CFE_FS_FileWriteEvent_UNDEFINED: CFE_FS_FileWriteEvent_t = 0;
pub type CFE_FS_FileWriteGetData_t = Option<
    unsafe extern "C" fn(*mut libc::c_void, uint32, *mut *mut libc::c_void, *mut size_t) -> bool,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_MemPoolRecord_t {
    pub Pool: CFE_ES_GenPoolRecord_t,
    pub PoolID: CFE_ES_MemHandle_t,
    pub BaseAddr: cpuaddr,
    pub OwnerAppID: CFE_ES_AppId_t,
    pub MutexId: osal_id_t,
}
pub type CFE_ES_GenPoolRecord_t = CFE_ES_GenPoolRecord;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_GenPoolRecord {
    pub PoolTotalSize: size_t,
    pub PoolMaxOffset: size_t,
    pub AlignMask: size_t,
    pub TailPosition: size_t,
    pub Retrieve: CFE_ES_PoolRetrieve_Func_t,
    pub Commit: CFE_ES_PoolCommit_Func_t,
    pub AllocationCount: uint32,
    pub ValidationErrorCount: uint32,
    pub NumBuckets: uint16,
    pub Buckets: [CFE_ES_GenPoolBucket_t; 17],
}
pub type CFE_ES_GenPoolBucket_t = CFE_ES_GenPoolBucket;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_GenPoolBucket {
    pub BlockSize: size_t,
    pub FirstOffset: size_t,
    pub AllocationCount: uint32,
    pub ReleaseCount: uint32,
    pub RecycleCount: uint32,
}
pub type CFE_ES_PoolCommit_Func_t = Option<
    unsafe extern "C" fn(*mut CFE_ES_GenPoolRecord_t, size_t, *const CFE_ES_GenPoolBD_t) -> int32,
>;
pub type CFE_ES_GenPoolBD_t = CFE_ES_GenPoolBD;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_GenPoolBD {
    pub CheckBits: uint16,
    pub Allocated: uint16,
    pub ActualSize: size_t,
    pub NextOffset: size_t,
}
pub type CFE_ES_PoolRetrieve_Func_t = Option<
    unsafe extern "C" fn(
        *mut CFE_ES_GenPoolRecord_t,
        size_t,
        *mut *mut CFE_ES_GenPoolBD_t,
    ) -> int32,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CDS_Instance_t {
    pub Pool: CFE_ES_GenPoolRecord_t,
    pub Cache: CFE_ES_CDS_AccessCache_t,
    pub GenMutex: osal_id_t,
    pub TotalSize: size_t,
    pub DataSize: size_t,
    pub LastCDSBlockId: CFE_ResourceId_t,
    pub Registry: [CFE_ES_CDS_RegRec_t; 512],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CDS_RegRec_t {
    pub BlockID: CFE_ES_CDSHandle_t,
    pub BlockOffset: size_t,
    pub BlockSize: size_t,
    pub Name: [libc::c_char; 40],
    pub Table: bool,
}
pub type CFE_ES_CDSHandle_t = CFE_ResourceId_t;
pub type CFE_ES_CDS_AccessCache_t = CFE_ES_CDS_AccessCache;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CDS_AccessCache {
    pub Data: CFE_ES_CDS_AccessCacheData_t,
    pub Offset: size_t,
    pub Size: size_t,
    pub AccessStatus: int32,
}
pub type CFE_ES_CDS_AccessCacheData_t = CFE_ES_CDS_AccessCacheData;
#[derive(Copy, Clone)]
#[repr(C)]
pub union CFE_ES_CDS_AccessCacheData {
    pub Sig: [libc::c_char; 8],
    pub RegistrySize: uint32,
    pub Zero: [uint32; 4],
    pub Desc: CFE_ES_GenPoolBD_t,
    pub BlockHeader: CFE_ES_CDS_BlockHeader_t,
    pub RegEntry: CFE_ES_CDS_RegRec_t,
}
pub type CFE_ES_CDS_BlockHeader_t = CFE_ES_CDSBlockHeader;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CDSBlockHeader {
    pub Crc: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_GenCounterRecord_t {
    pub CounterId: CFE_ES_CounterId_t,
    pub Counter: uint32,
    pub CounterName: [libc::c_char; 20],
}
pub type CFE_ES_CounterId_t = CFE_ResourceId_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_LibRecord_t {
    pub LibId: CFE_ES_LibId_t,
    pub LibName: [libc::c_char; 20],
    pub LoadParams: CFE_ES_ModuleLoadParams_t,
    pub LoadStatus: CFE_ES_ModuleLoadStatus_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ModuleLoadStatus_t {
    pub ModuleId: osal_id_t,
    pub InitSymbolAddress: cpuaddr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ModuleLoadParams_t {
    pub InitSymbolName: [libc::c_char; 20],
    pub FileName: [libc::c_char; 64],
}
pub type CFE_ES_LibId_t = CFE_ResourceId_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_AppRecord_t {
    pub AppId: CFE_ES_AppId_t,
    pub AppName: [libc::c_char; 20],
    pub AppState: CFE_ES_AppState_Enum_t,
    pub Type: CFE_ES_AppType_Enum_t,
    pub StartParams: CFE_ES_AppStartParams_t,
    pub LoadStatus: CFE_ES_ModuleLoadStatus_t,
    pub ControlReq: CFE_ES_ControlReq_t,
    pub MainTaskId: CFE_ES_TaskId_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ControlReq_t {
    pub AppControlRequest: uint32,
    pub AppTimerMsec: int32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_AppStartParams_t {
    pub BasicInfo: CFE_ES_ModuleLoadParams_t,
    pub MainTaskInfo: CFE_ES_TaskStartParams_t,
    pub ExceptionAction: CFE_ES_ExceptionAction_Enum_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_TaskStartParams_t {
    pub StackSize: size_t,
    pub Priority: CFE_ES_TaskPriority_Atom_t,
}
pub type CFE_ES_AppType_Enum_t = uint8;
pub type CFE_ES_AppState_Enum_t = uint32;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_TaskRecord_t {
    pub TaskId: CFE_ES_TaskId_t,
    pub TaskName: [libc::c_char; 20],
    pub AppId: CFE_ES_AppId_t,
    pub StartParams: CFE_ES_TaskStartParams_t,
    pub EntryFunc: CFE_ES_TaskEntryFuncPtr_t,
    pub ExecutionCounter: uint32,
}
pub type CFE_ES_TaskEntryFuncPtr_t = Option<unsafe extern "C" fn() -> ()>;
pub type sig_atomic_t = __sig_atomic_t;
pub type OS_object_token_t = OS_object_token;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_object_token {
    pub lock_mode: OS_lock_mode_t,
    pub lock_key: osal_key_t,
    pub obj_type: osal_objtype_t,
    pub obj_idx: osal_index_t,
    pub obj_id: osal_id_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct osal_key_t {
    pub key_value: uint32,
}
pub type OS_lock_mode_t = libc::c_uint;
pub const OS_LOCK_MODE_RESERVED: OS_lock_mode_t = 4;
pub const OS_LOCK_MODE_EXCLUSIVE: OS_lock_mode_t = 3;
pub const OS_LOCK_MODE_REFCOUNT: OS_lock_mode_t = 2;
pub const OS_LOCK_MODE_GLOBAL: OS_lock_mode_t = 1;
pub const OS_LOCK_MODE_NONE: OS_lock_mode_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_binsem_internal_record_t {
    pub id: pthread_mutex_t,
    pub cv: pthread_cond_t,
    pub flush_request: sig_atomic_t,
    pub current_value: sig_atomic_t,
}
pub const LOCAL_OBJID_TYPE: C2RustUnnamed_30 = 4;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_BSP_GenericLinuxGlobalData_t {
    pub EnableTermControl: bool,
    pub AccessMutex: pthread_mutex_t,
    pub AccessCancelState: libc::c_int,
}
pub type OS_SharedGlobalVars_t = OS_shared_global_vars;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_shared_global_vars {
    pub GlobalState: uint32,
    pub PrintfConsoleId: osal_id_t,
    pub PrintfEnabled: bool,
    pub MicroSecPerTick: uint32,
    pub TicksPerSecond: uint32,
    pub EventHandler: OS_EventHandler_t,
    pub DebugLevel: uint8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_objtype_lock_t {
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_objtype_state_t {
    pub last_id_issued: osal_id_t,
    pub transaction_count: uint32,
    pub owner_key: osal_key_t,
}
pub type OS_common_record_t = OS_common_record;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_common_record {
    pub name_entry: *const libc::c_char,
    pub active_id: osal_id_t,
    pub creator: osal_id_t,
    pub refcount: uint16,
}
pub const OS_CONDVAR_BASE: C2RustUnnamed_29 = 292;
pub const OS_CONSOLE_BASE: C2RustUnnamed_29 = 291;
pub const OS_FILESYS_BASE: C2RustUnnamed_29 = 277;
pub const OS_MODULE_BASE: C2RustUnnamed_29 = 257;
pub const OS_TIMECB_BASE: C2RustUnnamed_29 = 247;
pub const OS_TIMEBASE_BASE: C2RustUnnamed_29 = 242;
pub const OS_DIR_BASE: C2RustUnnamed_29 = 238;
pub const OS_STREAM_BASE: C2RustUnnamed_29 = 188;
pub const OS_MUTEX_BASE: C2RustUnnamed_29 = 168;
pub const OS_COUNTSEM_BASE: C2RustUnnamed_29 = 148;
pub const OS_BINSEM_BASE: C2RustUnnamed_29 = 128;
pub const OS_QUEUE_BASE: C2RustUnnamed_29 = 64;
pub const OS_TASK_BASE: C2RustUnnamed_29 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union OS_VoidPtrValueWrapper_t {
    pub opaque_arg: *mut libc::c_void,
    pub arg_callback_func: OS_ArgCallback_t,
    pub id: osal_id_t,
    pub idx: osal_index_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct POSIX_GlobalVars_t {
    pub EnableTaskPriorities: bool,
    pub TruncateQueueDepth: osal_blockcount_t,
    pub ClockAccuracyNsec: uint32,
    pub ThreadKey: pthread_key_t,
    pub MaximumSigMask: sigset_t,
    pub NormalSigMask: sigset_t,
    pub PageSize: size_t,
    pub PriLimits: POSIX_PriorityLimits_t,
    pub SelectedRtScheduler: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct POSIX_PriorityLimits_t {
    pub PriorityMax: libc::c_int,
    pub PriorityMin: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_console_internal_record_t {
    pub device_name: [libc::c_char; 20],
    pub BufBase: *mut libc::c_char,
    pub BufSize: size_t,
    pub ReadPos: size_t,
    pub WritePos: size_t,
    pub OverflowEvents: uint32,
    pub IsAsync: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union sem_t {
    pub __size: [libc::c_char; 32],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_console_internal_record_t {
    pub data_sem: sem_t,
}
pub const CFE_ES_SystemState_OPERATIONAL: CFE_ES_SystemState = 5;
pub type CFE_Status_t = int32;
pub const CFE_ES_LogMode_OVERWRITE: CFE_ES_LogMode = 0;
pub const _ISspace: C2RustUnnamed_39 = 8192;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_Reference_t {
    pub AtToneMET: CFE_TIME_SysTime_t,
    pub AtToneSTCF: CFE_TIME_SysTime_t,
    pub AtToneLeapSeconds: int16,
    pub ClockSetState: int16,
    pub ClockFlyState: int16,
    pub DelayDirection: int16,
    pub AtToneDelay: CFE_TIME_SysTime_t,
    pub AtToneLatch: CFE_TIME_SysTime_t,
    pub CurrentLatch: CFE_TIME_SysTime_t,
    pub TimeSinceTone: CFE_TIME_SysTime_t,
    pub CurrentMET: CFE_TIME_SysTime_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_Global_t {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub HkPacket: CFE_TIME_HousekeepingTlm_t,
    pub DiagPacket: CFE_TIME_DiagnosticTlm_t,
    pub CmdPipe: CFE_SB_PipeId_t,
    pub ClockSource: int16,
    pub ClockSignal: int16,
    pub ServerFlyState: int16,
    pub PendingMET: CFE_TIME_SysTime_t,
    pub PendingSTCF: CFE_TIME_SysTime_t,
    pub PendingLeaps: int16,
    pub PendingState: CFE_TIME_ClockState_Enum_t,
    pub OneTimeAdjust: CFE_TIME_SysTime_t,
    pub OneHzAdjust: CFE_TIME_SysTime_t,
    pub OneTimeDirection: int16,
    pub OneHzDirection: int16,
    pub ToneSignalLatch: CFE_TIME_SysTime_t,
    pub ToneDataLatch: CFE_TIME_SysTime_t,
    pub ToneMatchCounter: uint32,
    pub ToneMatchErrorCounter: uint32,
    pub ToneSignalCounter: uint32,
    pub ToneDataCounter: uint32,
    pub ToneIntCounter: uint32,
    pub ToneIntErrorCounter: uint32,
    pub ToneTaskCounter: uint32,
    pub VirtualMET: uint32,
    pub LocalIntCounter: uint32,
    pub LocalTaskCounter: uint32,
    pub InternalCount: uint32,
    pub ExternalCount: uint32,
    pub ReferenceState: [CFE_TIME_ReferenceState_t; 4],
    pub LastVersionCounter: uint32,
    pub ResetVersionCounter: uint32,
    pub MinElapsed: uint32,
    pub MaxElapsed: uint32,
    pub MaxLocalClock: CFE_TIME_SysTime_t,
    pub Forced2Fly: bool,
    pub AutoStartFly: bool,
    pub IsToneGood: bool,
    pub GetReferenceFail: bool,
    pub LocalOneHzCmd: CFE_TIME_OneHzCmd_t,
    pub ToneDataCmd: CFE_TIME_ToneDataCmd_t,
    pub ToneSignalCmd: CFE_TIME_ToneSignalCmd_t,
    pub ToneSendCmd: CFE_TIME_FakeToneCmd_t,
    pub LocalSemaphore: osal_id_t,
    pub ToneSemaphore: osal_id_t,
    pub LocalTaskID: CFE_ES_TaskId_t,
    pub ToneTaskID: CFE_ES_TaskId_t,
    pub MaxDelta: CFE_TIME_SysTime_t,
    pub ToneOverLimit: uint32,
    pub ToneUnderLimit: uint32,
    pub DataStoreStatus: uint32,
    pub SynchCallback: [CFE_TIME_SynchCallbackRegEntry_t; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SynchCallbackRegEntry_t {
    pub Ptr: CFE_TIME_SynchCallbackPtr_t,
}
pub type CFE_TIME_SynchCallbackPtr_t = Option<unsafe extern "C" fn() -> int32>;
pub type CFE_TIME_FakeToneCmd_t = CFE_TIME_FakeToneCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_FakeToneCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_MSG_CommandHeader_t = CFE_MSG_CommandHeader;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_MSG_CommandHeader {
    pub Msg: CFE_MSG_Message_t,
    pub Sec: CFE_MSG_CommandSecondaryHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_MSG_CommandSecondaryHeader_t {
    pub FunctionCode: uint8,
    pub Checksum: uint8,
}
pub type CFE_TIME_ToneSignalCmd_t = CFE_TIME_ToneSignalCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_ToneSignalCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_TIME_ToneDataCmd_t = CFE_TIME_ToneDataCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_ToneDataCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_ToneDataCmd_Payload_t,
}
pub type CFE_TIME_ToneDataCmd_Payload_t = CFE_TIME_ToneDataCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_ToneDataCmd_Payload {
    pub AtToneMET: CFE_TIME_SysTime_t,
    pub AtToneSTCF: CFE_TIME_SysTime_t,
    pub AtToneLeapSeconds: int16,
    pub AtToneState: CFE_TIME_ClockState_Enum_t,
}
pub type CFE_TIME_ClockState_Enum_t = int16;
pub type CFE_TIME_OneHzCmd_t = CFE_TIME_OneHzCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_OneHzCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_ReferenceState_t {
    pub StateVersion: uint32,
    pub AtToneLeapSeconds: int16,
    pub ClockSetState: int16,
    pub ClockFlyState: int16,
    pub DelayDirection: int16,
    pub AtToneMET: CFE_TIME_SysTime_t,
    pub AtToneSTCF: CFE_TIME_SysTime_t,
    pub AtToneDelay: CFE_TIME_SysTime_t,
    pub AtToneLatch: CFE_TIME_SysTime_t,
}
pub type CFE_TIME_DiagnosticTlm_t = CFE_TIME_DiagnosticTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_DiagnosticTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_TIME_DiagnosticTlm_Payload_t,
}
pub type CFE_TIME_DiagnosticTlm_Payload_t = CFE_TIME_DiagnosticTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_DiagnosticTlm_Payload {
    pub AtToneMET: CFE_TIME_SysTime_t,
    pub AtToneSTCF: CFE_TIME_SysTime_t,
    pub AtToneDelay: CFE_TIME_SysTime_t,
    pub AtToneLatch: CFE_TIME_SysTime_t,
    pub AtToneLeapSeconds: int16,
    pub ClockStateAPI: CFE_TIME_ClockState_Enum_t,
    pub TimeSinceTone: CFE_TIME_SysTime_t,
    pub CurrentLatch: CFE_TIME_SysTime_t,
    pub CurrentMET: CFE_TIME_SysTime_t,
    pub CurrentTAI: CFE_TIME_SysTime_t,
    pub CurrentUTC: CFE_TIME_SysTime_t,
    pub ClockSetState: int16,
    pub ClockFlyState: int16,
    pub ClockSource: int16,
    pub ClockSignal: int16,
    pub ServerFlyState: int16,
    pub Forced2Fly: int16,
    pub ClockStateFlags: uint16,
    pub OneTimeDirection: int16,
    pub OneHzDirection: int16,
    pub DelayDirection: int16,
    pub OneTimeAdjust: CFE_TIME_SysTime_t,
    pub OneHzAdjust: CFE_TIME_SysTime_t,
    pub ToneSignalLatch: CFE_TIME_SysTime_t,
    pub ToneDataLatch: CFE_TIME_SysTime_t,
    pub ToneMatchCounter: uint32,
    pub ToneMatchErrorCounter: uint32,
    pub ToneSignalCounter: uint32,
    pub ToneDataCounter: uint32,
    pub ToneIntCounter: uint32,
    pub ToneIntErrorCounter: uint32,
    pub ToneTaskCounter: uint32,
    pub VersionCounter: uint32,
    pub LocalIntCounter: uint32,
    pub LocalTaskCounter: uint32,
    pub VirtualMET: uint32,
    pub MinElapsed: uint32,
    pub MaxElapsed: uint32,
    pub MaxLocalClock: CFE_TIME_SysTime_t,
    pub ToneOverLimit: uint32,
    pub ToneUnderLimit: uint32,
    pub DataStoreStatus: uint32,
}
pub type CFE_TIME_HousekeepingTlm_t = CFE_TIME_HousekeepingTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_HousekeepingTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_TIME_HousekeepingTlm_Payload_t,
}
pub type CFE_TIME_HousekeepingTlm_Payload_t = CFE_TIME_HousekeepingTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_HousekeepingTlm_Payload {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub ClockStateFlags: uint16,
    pub ClockStateAPI: CFE_TIME_ClockState_Enum_t,
    pub LeapSeconds: int16,
    pub SecondsMET: uint32,
    pub SubsecsMET: uint32,
    pub SecondsSTCF: uint32,
    pub SubsecsSTCF: uint32,
    pub Seconds1HzAdj: uint32,
    pub Subsecs1HzAdj: uint32,
}
pub const CFE_TIME_A_LT_B: CFE_TIME_Compare = -1;
pub type CFE_TIME_Compare_t = CFE_TIME_Compare;
pub type CFE_TIME_Compare = libc::c_int;
pub const CFE_TIME_A_GT_B: CFE_TIME_Compare = 1;
pub const CFE_TIME_EQUAL: CFE_TIME_Compare = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_time_t {
    pub ticks: int64,
}
pub const OS_TIME_TICKS_PER_SECOND: C2RustUnnamed_31 = 10000000;
pub const OS_TIME_TICK_RESOLUTION_NS: C2RustUnnamed_31 = 100;
pub const OS_TIME_TICKS_PER_USEC: C2RustUnnamed_31 = 10;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_mutex_internal_record_t {
    pub id: pthread_mutex_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_mutex_internal_record_t {
    pub obj_name: [libc::c_char; 20],
    pub last_owner: osal_id_t,
}
pub const osal_src_os_shared_src_osapi_mutex_c__LOCAL_OBJID_TYPE: C2RustUnnamed_42 = 5;
pub const CFE_ES_AppState_RUNNING: CFE_ES_AppState = 3;
pub const CFE_ES_SystemState_APPS_INIT: CFE_ES_SystemState = 4;
pub const CFE_ES_AppState_LATE_INIT: CFE_ES_AppState = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_file_internal_record_t {
    pub fd: libc::c_int,
    pub selectable: bool,
}
pub const osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE: C2RustUnnamed_38 = 6;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub AppId: CFE_ES_AppId_t,
    pub LibId: CFE_ES_LibId_t,
}
pub type CFE_ES_LibraryEntryFuncPtr_t = Option<unsafe extern "C" fn(CFE_ES_LibId_t) -> int32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_module_internal_record_t {
    pub dl_handle: *mut libc::c_void,
}
pub const OS_MODULE_TYPE_DYNAMIC: OS_module_type_t = 1;
pub type OS_module_type_t = libc::c_uint;
pub const OS_MODULE_TYPE_STATIC: OS_module_type_t = 2;
pub const OS_MODULE_TYPE_UNKNOWN: OS_module_type_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_module_internal_record_t {
    pub module_name: [libc::c_char; 20],
    pub file_name: [libc::c_char; 64],
    pub module_type: OS_module_type_t,
    pub flags: uint32,
    pub entry_point: cpuaddr,
}
pub const osal_src_os_shared_src_osapi_module_c__LOCAL_OBJID_TYPE: C2RustUnnamed_41 = 10;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_static_symbol_record_t {
    pub Name: *const libc::c_char,
    pub Address: Option<unsafe extern "C" fn() -> ()>,
    pub Module: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_condvar_internal_record_t {
    pub mut_0: pthread_mutex_t,
    pub cv: pthread_cond_t,
}
pub type DIR = __dirstream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_dir_internal_record_t {
    pub dp: *mut DIR,
}
pub const osal_src_os_shared_src_osapi_dir_c__LOCAL_OBJID_TYPE: C2RustUnnamed_37 = 7;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_timebase_internal_record_t {
    pub handler_thread: pthread_t,
    pub handler_mutex: pthread_mutex_t,
    pub host_timerid: timer_t,
    pub assigned_signal: libc::c_int,
    pub sigset: sigset_t,
    pub reset_flag: sig_atomic_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_timecb_internal_record_t {
    pub timer_name: [libc::c_char; 20],
    pub flags: uint32,
    pub timebase_token: OS_object_token_t,
    pub prev_cb: osal_id_t,
    pub next_cb: osal_id_t,
    pub backlog_resets: uint32,
    pub wait_time: int32,
    pub interval_time: int32,
    pub callback_ptr: OS_ArgCallback_t,
    pub callback_arg: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_timebase_internal_record_t {
    pub timebase_name: [libc::c_char; 20],
    pub external_sync: OS_TimerSync_t,
    pub accuracy_usec: uint32,
    pub first_cb: osal_id_t,
    pub freerun_time: uint32,
    pub nominal_start_time: uint32,
    pub nominal_interval_time: uint32,
}
pub type OS_TimerSync_t = Option<unsafe extern "C" fn(osal_id_t) -> uint32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_countsem_internal_record_t {
    pub id: sem_t,
}
pub const osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE: C2RustUnnamed_36 = 3;
pub type mqd_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_queue_internal_record_t {
    pub id: mqd_t,
}
pub const osal_src_os_shared_src_osapi_queue_c__LOCAL_OBJID_TYPE: C2RustUnnamed_43 = 2;
pub type osal_task = ();
pub type osal_task_entry = Option<unsafe extern "C" fn() -> osal_task>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_impl_task_internal_record_t {
    pub id: pthread_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_task_internal_record_t {
    pub task_name: [libc::c_char; 20],
    pub stack_size: size_t,
    pub priority: osal_priority_t,
    pub entry_function_pointer: osal_task_entry,
    pub delete_hook_pointer: osal_task_entry,
    pub entry_arg: *mut libc::c_void,
    pub stack_pointer: osal_stackptr_t,
}
pub type osal_stackptr_t = *mut libc::c_void;
pub type osal_priority_t = uint8_t;
pub const osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE: C2RustUnnamed_46 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_object_iter_t {
    pub base: *mut OS_common_record_t,
    pub match_0: OS_ObjectMatchFunc_t,
    pub arg: *mut libc::c_void,
    pub limit: osal_index_t,
    pub token: OS_object_token_t,
}
pub type OS_ObjectMatchFunc_t = Option<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const OS_object_token_t,
        *const OS_common_record_t,
    ) -> bool,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_creator_filter_t {
    pub creator_id: osal_id_t,
    pub user_callback: OS_ArgCallback_t,
    pub user_arg: *mut libc::c_void,
}
pub type OS_ObjectIdIteratorProcessFunc_t =
    Option<unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> int32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_IdleTaskState_t {
    pub ThreadID: pthread_t,
    pub ShutdownReq: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_filesys_internal_record_t {
    pub device_name: [libc::c_char; 32],
    pub volume_name: [libc::c_char; 32],
    pub system_mountpt: [libc::c_char; 128],
    pub virtual_mountpt: [libc::c_char; 64],
    pub address: *mut libc::c_char,
    pub blocksize: size_t,
    pub numblocks: osal_blockcount_t,
    pub flags: uint8,
    pub fstype: uint8,
}
pub const osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE: C2RustUnnamed_40 = 11;
pub const CFE_ES_LIBID_BASE: C2RustUnnamed_56 = 1179648;
pub const CFE_ES_APPID_BASE: C2RustUnnamed_56 = 1114112;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sigaction {
    pub __sigaction_handler: C2RustUnnamed_9,
    pub sa_mask: __sigset_t,
    pub sa_flags: libc::c_int,
    pub sa_restorer: Option<unsafe extern "C" fn() -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction:
        Option<unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct siginfo_t {
    pub si_signo: libc::c_int,
    pub si_errno: libc::c_int,
    pub si_code: libc::c_int,
    pub __pad0: libc::c_int,
    pub _sifields: C2RustUnnamed_10,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_10 {
    pub _pad: [libc::c_int; 28],
    pub _kill: C2RustUnnamed_19,
    pub _timer: C2RustUnnamed_18,
    pub _rt: C2RustUnnamed_17,
    pub _sigchld: C2RustUnnamed_16,
    pub _sigfault: C2RustUnnamed_13,
    pub _sigpoll: C2RustUnnamed_12,
    pub _sigsys: C2RustUnnamed_11,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub _call_addr: *mut libc::c_void,
    pub _syscall: libc::c_int,
    pub _arch: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub si_band: libc::c_long,
    pub si_fd: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub si_addr: *mut libc::c_void,
    pub si_addr_lsb: libc::c_short,
    pub _bounds: C2RustUnnamed_14,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_14 {
    pub _addr_bnd: C2RustUnnamed_15,
    pub _pkey: __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_15 {
    pub _lower: *mut libc::c_void,
    pub _upper: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: libc::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub si_tid: libc::c_int,
    pub si_overrun: libc::c_int,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
pub type __sighandler_t = Option<unsafe extern "C" fn(libc::c_int) -> ()>;
pub type CFE_PSP_Exception_LogData_t = CFE_PSP_Exception_LogData;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_Exception_LogData {
    pub context_id: uint32,
    pub context_size: uint32,
    pub sys_task_id: CFE_PSP_Exception_SysTaskId_t,
    pub context_info: CFE_PSP_Exception_ContextDataEntry_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_Exception_ContextDataEntry_t {
    pub event_time: timespec,
    pub si: siginfo_t,
    pub bt_addrs: [*mut libc::c_void; 16],
}
pub type CFE_PSP_Exception_SysTaskId_t = pthread_t;
pub type CFE_PSP_ExceptionStorage_t = CFE_PSP_ExceptionStorage;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_ExceptionStorage {
    pub NumWritten: uint32,
    pub NumRead: uint32,
    pub Entries: [CFE_PSP_Exception_LogData; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_ReservedMemoryMap_t {
    pub BootPtr: *mut CFE_PSP_ReservedMemoryBootRecord_t,
    pub ExceptionStoragePtr: *mut CFE_PSP_ExceptionStorage_t,
    pub ResetMemory: CFE_PSP_MemoryBlock_t,
    pub VolatileDiskMemory: CFE_PSP_MemoryBlock_t,
    pub CDSMemory: CFE_PSP_MemoryBlock_t,
    pub UserReservedMemory: CFE_PSP_MemoryBlock_t,
    pub SysMemoryTable: [CFE_PSP_MemTable_t; 10],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_MemTable_t {
    pub MemoryType: uint32,
    pub WordSize: size_t,
    pub StartAddr: cpuaddr,
    pub Size: size_t,
    pub Attributes: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_MemoryBlock_t {
    pub BlockPtr: *mut libc::c_void,
    pub BlockSize: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_ReservedMemoryBootRecord_t {
    pub ValidityFlag: uint32,
    pub NextResetType: uint32,
}
pub type PthreadFuncPtr_t = Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>;
pub const CFE_ES_RunStatus_APP_RUN: CFE_ES_RunStatus = 1;
pub const CFE_ES_AppType_EXTERNAL: CFE_ES_AppType = 2;
pub const CFE_ES_ExceptionAction_PROC_RESTART: CFE_ES_ExceptionAction = 1;
pub const CFE_ES_ExceptionAction_RESTART_APP: CFE_ES_ExceptionAction = 0;
pub type CFE_FS_FileCategory_t = libc::c_uint;
pub const CFE_FS_FileCategory_MAX: CFE_FS_FileCategory_t = 6;
pub const CFE_FS_FileCategory_TEMP: CFE_FS_FileCategory_t = 5;
pub const CFE_FS_FileCategory_SCRIPT: CFE_FS_FileCategory_t = 4;
pub const CFE_FS_FileCategory_TEXT_LOG: CFE_FS_FileCategory_t = 3;
pub const CFE_FS_FileCategory_BINARY_DATA_DUMP: CFE_FS_FileCategory_t = 2;
pub const CFE_FS_FileCategory_DYNAMIC_MODULE: CFE_FS_FileCategory_t = 1;
pub const CFE_FS_FileCategory_UNKNOWN: CFE_FS_FileCategory_t = 0;
pub const EXTENSION_COMPONENT: C2RustUnnamed_20 = 5;
pub const EXTENSION_SEPARATOR: C2RustUnnamed_20 = 4;
pub const PATHNAME_SEPARATOR: C2RustUnnamed_20 = 2;
pub const FILENAME_COMPONENT: C2RustUnnamed_20 = 3;
pub const PATHNAME_COMPONENT: C2RustUnnamed_20 = 1;
pub type C2RustUnnamed_20 = libc::c_uint;
pub const END_COMPONENT: C2RustUnnamed_20 = 6;
pub const PROCESS_INIT: C2RustUnnamed_20 = 0;
pub const OS_STREAM_STATE_READABLE: C2RustUnnamed_44 = 4;
pub const OS_STREAM_STATE_WRITABLE: C2RustUnnamed_44 = 8;
pub const OS_FILE_FLAG_NONE: C2RustUnnamed_33 = 0;
pub const OS_FILE_FLAG_TRUNCATE: C2RustUnnamed_33 = 2;
pub const OS_FILE_FLAG_CREATE: C2RustUnnamed_33 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_stream_internal_record_t {
    pub stream_name: [libc::c_char; 64],
    pub socket_domain: uint8,
    pub socket_type: uint8,
    pub stream_state: uint16,
}
pub const CFE_ES_SystemState_CORE_READY: CFE_ES_SystemState = 3;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ObjectTable_t {
    pub ObjectType: uint32,
    pub ObjectName: [libc::c_char; 20],
    pub FuncPtrUnion: CFE_ES_FuncPtrUnion_t,
    pub ObjectPriority: uint32,
    pub ObjectSize: uint32,
    pub ObjectFlags: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union CFE_ES_FuncPtrUnion_t {
    pub FunctionPtr: CFE_ES_EarlyInitFuncPtr_t,
    pub MainTaskPtr: CFE_ES_TaskEntryFuncPtr_t,
    pub VoidPtr: *mut libc::c_void,
}
pub type CFE_ES_EarlyInitFuncPtr_t = Option<unsafe extern "C" fn() -> int32>;
pub const CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR: CFE_ES_RunStatus = 9;
pub const CFE_ES_AppState_STOPPED: CFE_ES_AppState = 5;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct shmid_ds {
    pub shm_perm: ipc_perm,
    pub shm_segsz: size_t,
    pub shm_atime: __time_t,
    pub shm_dtime: __time_t,
    pub shm_ctime: __time_t,
    pub shm_cpid: __pid_t,
    pub shm_lpid: __pid_t,
    pub shm_nattch: shmatt_t,
    pub __glibc_reserved5: __syscall_ulong_t,
    pub __glibc_reserved6: __syscall_ulong_t,
}
pub type shmatt_t = __syscall_ulong_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ipc_perm {
    pub __key: __key_t,
    pub uid: __uid_t,
    pub gid: __gid_t,
    pub cuid: __uid_t,
    pub cgid: __gid_t,
    pub mode: __mode_t,
    pub __seq: libc::c_ushort,
    pub __pad2: libc::c_ushort,
    pub __glibc_reserved1: __syscall_ulong_t,
    pub __glibc_reserved2: __syscall_ulong_t,
}
pub type CFE_ES_LogEntryType_Enum_t = uint8;
pub const CFE_ES_LogEntryType_CORE: CFE_ES_LogEntryType = 1;
pub const CFE_ES_RunStatus_CORE_APP_INIT_ERROR: CFE_ES_RunStatus = 8;
pub const CFE_ES_AppType_CORE: CFE_ES_AppType = 1;
pub const CFE_ES_RunStatus_APP_ERROR: CFE_ES_RunStatus = 3;
pub const CFE_ES_RunStatus_MAX: CFE_ES_RunStatus = 10;
pub const CFE_ES_RunStatus_UNDEFINED: CFE_ES_RunStatus = 0;
pub type CFE_SB_Buffer_t = CFE_SB_Msg;
#[derive(Copy, Clone)]
#[repr(C)]
pub union CFE_SB_Msg {
    pub Msg: CFE_MSG_Message_t,
    pub LongInt: libc::c_longlong,
    pub LongDouble: f128::f128,
}
pub type CFE_SB_MsgId_Atom_t = uint32;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_MsgId_t {
    pub Value: CFE_SB_MsgId_Atom_t,
}
pub const CFE_EVS_EventType_ERROR: CFE_EVS_EventType = 3;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EVS_AppData_t {
    pub AppID: CFE_ES_AppId_t,
    pub UnregAppID: CFE_ES_AppId_t,
    pub BinFilters: [EVS_BinFilter_t; 8],
    pub ActiveFlag: uint8,
    pub EventTypesActiveFlag: uint8,
    pub EventCount: uint16,
    pub LastSquelchCreditableTime: OS_time_t,
    pub SquelchTokens: int32,
    pub SquelchedCount: uint8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EVS_BinFilter_t {
    pub EventID: uint16,
    pub Mask: uint16,
    pub Count: uint16,
    pub Padding: uint16,
}
pub type CFE_EVS_HousekeepingTlm_Payload_t = CFE_EVS_HousekeepingTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_HousekeepingTlm_Payload {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub MessageFormatMode: uint8,
    pub MessageTruncCounter: uint8,
    pub UnregisteredAppCounter: uint8,
    pub OutputPort: uint8,
    pub LogFullFlag: uint8,
    pub LogMode: uint8,
    pub MessageSendCounter: uint16,
    pub LogOverflowCounter: uint16,
    pub LogEnabled: uint8,
    pub Spare1: uint8,
    pub Spare2: uint8,
    pub Spare3: uint8,
    pub AppData: [CFE_EVS_AppTlmData_t; 16],
}
pub type CFE_EVS_AppTlmData_t = CFE_EVS_AppTlmData;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AppTlmData {
    pub AppID: CFE_ES_AppId_t,
    pub AppMessageSentCounter: uint16,
    pub AppEnableStatus: uint8,
    pub AppMessageSquelchedCounter: uint8,
}
pub type CFE_EVS_HousekeepingTlm_t = CFE_EVS_HousekeepingTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_HousekeepingTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_EVS_HousekeepingTlm_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_Global_t {
    pub AppData: [EVS_AppData_t; 32],
    pub EVS_LogPtr: *mut CFE_EVS_Log_t,
    pub EVS_TlmPkt: CFE_EVS_HousekeepingTlm_t,
    pub EVS_CommandPipe: CFE_SB_PipeId_t,
    pub EVS_SharedDataMutexID: osal_id_t,
    pub EVS_AppID: CFE_ES_AppId_t,
    pub EVS_EventBurstMax: uint32,
}
pub type CFE_EVS_ShortEventTlm_t = CFE_EVS_ShortEventTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_ShortEventTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_EVS_ShortEventTlm_Payload_t,
}
pub type CFE_EVS_ShortEventTlm_Payload_t = CFE_EVS_ShortEventTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_ShortEventTlm_Payload {
    pub PacketID: CFE_EVS_PacketID_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_Global_t {
    pub SharedDataMutexId: osal_id_t,
    pub SubscriptionReporting: uint32,
    pub AppId: CFE_ES_AppId_t,
    pub StopRecurseFlags: [uint32; 64],
    pub PipeTbl: [CFE_SB_PipeD_t; 64],
    pub HKTlmMsg: CFE_SB_HousekeepingTlm_t,
    pub StatTlmMsg: CFE_SB_StatsTlm_t,
    pub CmdPipe: CFE_SB_PipeId_t,
    pub Mem: CFE_SB_MemParams_t,
    pub PrevSubMsg: CFE_SB_AllSubscriptionsTlm_t,
    pub EventFilters: [CFE_EVS_BinFilter_t; 8],
    pub Default_Qos: CFE_SB_Qos_t,
    pub LastPipeId: CFE_ResourceId_t,
    pub BackgroundFile: CFE_SB_BackgroundFileStateInfo_t,
    pub InTransitList: CFE_SB_BufferLink_t,
    pub ZeroCopyList: CFE_SB_BufferLink_t,
}
pub type CFE_SB_BufferLink_t = CFE_SB_BufferLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_BufferLink {
    pub Next: *mut CFE_SB_BufferLink,
    pub Prev: *mut CFE_SB_BufferLink,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_BackgroundFileStateInfo_t {
    pub FileWrite: CFE_FS_FileWriteMetaData_t,
    pub Buffer: CFE_SB_BackgroundFileBuffer_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union CFE_SB_BackgroundFileBuffer_t {
    pub RouteInfo: CFE_SB_BackgroundRouteInfoBuffer_t,
    pub PipeInfo: CFE_SB_PipeInfoEntry_t,
    pub MsgMapInfo: CFE_SB_MsgMapFileEntry_t,
}
pub type CFE_SB_MsgMapFileEntry_t = CFE_SB_MsgMapFileEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_MsgMapFileEntry {
    pub MsgId: CFE_SB_MsgId_t,
    pub Index: CFE_SB_RouteId_Atom_t,
}
pub type CFE_SB_RouteId_Atom_t = uint16;
pub type CFE_SB_PipeInfoEntry_t = CFE_SB_PipeInfoEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_PipeInfoEntry {
    pub PipeId: CFE_SB_PipeId_t,
    pub AppId: CFE_ES_AppId_t,
    pub PipeName: [libc::c_char; 20],
    pub AppName: [libc::c_char; 20],
    pub MaxQueueDepth: uint16,
    pub CurrentQueueDepth: uint16,
    pub PeakQueueDepth: uint16,
    pub SendErrors: uint16,
    pub Opts: uint8,
    pub Spare: [uint8; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_BackgroundRouteInfoBuffer_t {
    pub NumDestinations: uint32,
    pub DestEntries: [CFE_SB_RoutingFileEntry_t; 16],
}
pub type CFE_SB_RoutingFileEntry_t = CFE_SB_RoutingFileEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_RoutingFileEntry {
    pub MsgId: CFE_SB_MsgId_t,
    pub PipeId: CFE_SB_PipeId_t,
    pub State: uint8,
    pub MsgCnt: uint16,
    pub AppName: [libc::c_char; 20],
    pub PipeName: [libc::c_char; 20],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_Qos_t {
    pub Priority: uint8,
    pub Reliability: uint8,
}
pub type CFE_EVS_BinFilter_t = CFE_EVS_BinFilter;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_BinFilter {
    pub EventID: uint16,
    pub Mask: uint16,
}
pub type CFE_SB_AllSubscriptionsTlm_t = CFE_SB_AllSubscriptionsTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_AllSubscriptionsTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_SB_AllSubscriptionsTlm_Payload_t,
}
pub type CFE_SB_AllSubscriptionsTlm_Payload_t = CFE_SB_AllSubscriptionsTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_AllSubscriptionsTlm_Payload {
    pub PktSegment: uint32,
    pub TotalSegments: uint32,
    pub Entries: uint32,
    pub Entry: [CFE_SB_SubEntries_t; 20],
}
pub type CFE_SB_SubEntries_t = CFE_SB_SubEntries;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_SubEntries {
    pub MsgId: CFE_SB_MsgId_t,
    pub Qos: CFE_SB_Qos_t,
    pub Pipe: CFE_SB_PipeId_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_MemParams_t {
    pub PoolHdl: CFE_ES_MemHandle_t,
    pub Partition: C2RustUnnamed_21,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_21 {
    pub Align: CFE_ES_PoolAlign_t,
    pub Data: [uint8; 524288],
}
pub type CFE_ES_PoolAlign_t = CFE_ES_PoolAlign;
#[derive(Copy, Clone)]
#[repr(C)]
pub union CFE_ES_PoolAlign {
    pub Ptr: *mut libc::c_void,
    pub LongInt: libc::c_longlong,
    pub LongDouble: f128::f128,
}
pub type CFE_SB_StatsTlm_t = CFE_SB_StatsTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_StatsTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_SB_StatsTlm_Payload_t,
}
pub type CFE_SB_StatsTlm_Payload_t = CFE_SB_StatsTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_StatsTlm_Payload {
    pub MsgIdsInUse: uint32,
    pub PeakMsgIdsInUse: uint32,
    pub MaxMsgIdsAllowed: uint32,
    pub PipesInUse: uint32,
    pub PeakPipesInUse: uint32,
    pub MaxPipesAllowed: uint32,
    pub MemInUse: uint32,
    pub PeakMemInUse: uint32,
    pub MaxMemAllowed: uint32,
    pub SubscriptionsInUse: uint32,
    pub PeakSubscriptionsInUse: uint32,
    pub MaxSubscriptionsAllowed: uint32,
    pub SBBuffersInUse: uint32,
    pub PeakSBBuffersInUse: uint32,
    pub MaxPipeDepthAllowed: uint32,
    pub PipeDepthStats: [CFE_SB_PipeDepthStats_t; 64],
}
pub type CFE_SB_PipeDepthStats_t = CFE_SB_PipeDepthStats;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_PipeDepthStats {
    pub PipeId: CFE_SB_PipeId_t,
    pub MaxQueueDepth: uint16,
    pub CurrentQueueDepth: uint16,
    pub PeakQueueDepth: uint16,
    pub Spare: uint16,
}
pub type CFE_SB_HousekeepingTlm_t = CFE_SB_HousekeepingTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_HousekeepingTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_SB_HousekeepingTlm_Payload_t,
}
pub type CFE_SB_HousekeepingTlm_Payload_t = CFE_SB_HousekeepingTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_HousekeepingTlm_Payload {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub NoSubscribersCounter: uint8,
    pub MsgSendErrorCounter: uint8,
    pub MsgReceiveErrorCounter: uint8,
    pub InternalErrorCounter: uint8,
    pub CreatePipeErrorCounter: uint8,
    pub SubscribeErrorCounter: uint8,
    pub PipeOptsErrorCounter: uint8,
    pub DuplicateSubscriptionsCounter: uint8,
    pub GetPipeIdByNameErrorCounter: uint8,
    pub Spare2Align: [uint8; 1],
    pub PipeOverflowErrorCounter: uint16,
    pub MsgLimitErrorCounter: uint16,
    pub MemPoolHandle: CFE_ES_MemHandle_t,
    pub MemInUse: uint32,
    pub UnmarkedMem: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_PipeD_t {
    pub PipeId: CFE_SB_PipeId_t,
    pub Opts: uint8,
    pub Spare: uint8,
    pub AppId: CFE_ES_AppId_t,
    pub SysQueueId: osal_id_t,
    pub SendErrors: uint16,
    pub MaxQueueDepth: uint16,
    pub CurrentQueueDepth: uint16,
    pub PeakQueueDepth: uint16,
    pub LastBuffer: *mut CFE_SB_BufferD_t,
}
pub type CFE_SB_BufferD_t = CFE_SB_BufferD;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_BufferD {
    pub Link: CFE_SB_BufferLink_t,
    pub MsgId: CFE_SB_MsgId_t,
    pub AppId: CFE_ES_AppId_t,
    pub AllocatedSize: size_t,
    pub ContentSize: size_t,
    pub ContentType: CFE_MSG_Type_t,
    pub NeedsUpdate: bool,
    pub UseCount: uint16,
    pub Content: CFE_SB_Buffer_t,
}
pub type CFE_MSG_Type_t = CFE_MSG_Type;
pub type CFE_MSG_Type = libc::c_uint;
pub const CFE_MSG_Type_Tlm: CFE_MSG_Type = 2;
pub const CFE_MSG_Type_Cmd: CFE_MSG_Type = 1;
pub const CFE_MSG_Type_Invalid: CFE_MSG_Type = 0;
pub type CFE_MSG_Size_t = size_t;
pub type CFE_ES_TaskInfo_t = CFE_ES_TaskInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_TaskInfo {
    pub TaskId: CFE_ES_TaskId_t,
    pub ExecutionCounter: uint32,
    pub TaskName: [libc::c_char; 20],
    pub AppId: CFE_ES_AppId_t,
    pub AppName: [libc::c_char; 20],
    pub StackSize: CFE_ES_MemOffset_t,
    pub Priority: CFE_ES_TaskPriority_Atom_t,
    pub Spare: [uint8; 2],
}
pub const CFE_EVS_EventType_INFORMATION: CFE_EVS_EventType = 2;
pub const CFE_EVS_EventType_CRITICAL: CFE_EVS_EventType = 4;
pub const CFE_EVS_EventType_DEBUG: CFE_EVS_EventType = 1;
pub const OS_TIME_TICKS_PER_MSEC: C2RustUnnamed_31 = 10000;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SBR_RouteId_t {
    pub RouteId: CFE_SB_RouteId_Atom_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_SendErrEventBuf_t {
    pub EventId: uint32,
    pub OsStatus: int32,
    pub PipeId: CFE_SB_PipeId_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_EventBuf_t {
    pub EvtsToSnd: uint32,
    pub EvtBuf: [CFE_SB_SendErrEventBuf_t; 16],
}
pub const CFE_SB_PIPEID_BASE: C2RustUnnamed_56 = 1441792;
pub const CFE_ES_PERF_IDLE: CFE_ES_PerfState = 0;
pub const CFE_ES_PerfTrigger_END: CFE_ES_PerfMode = 2;
pub const CFE_ES_PerfTrigger_CENTER: CFE_ES_PerfMode = 1;
pub const CFE_ES_PerfTrigger_START: CFE_ES_PerfMode = 0;
pub const CFE_ES_PERF_TRIGGERED: CFE_ES_PerfState = 2;
pub const CFE_ES_PERF_WAITING_FOR_TRIGGER: CFE_ES_PerfState = 1;
pub type CFE_ES_MemPoolBuf_t = *mut libc::c_void;
pub const CFE_ES_POOLID_BASE: C2RustUnnamed_56 = 1310720;
pub type CFE_SB_DestinationD_t = CFE_SB_DestinationD;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_DestinationD {
    pub PipeId: CFE_SB_PipeId_t,
    pub Active: uint8,
    pub MsgId2PipeLim: uint16,
    pub BuffCount: uint16,
    pub DestCnt: uint16,
    pub Scope: uint8,
    pub Spare: [uint8; 3],
    pub Prev: *mut CFE_SB_DestinationD,
    pub Next: *mut CFE_SB_DestinationD,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_queue_internal_record_t {
    pub queue_name: [libc::c_char; 20],
    pub max_size: size_t,
    pub max_depth: osal_blockcount_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SBR_RouteEntry_t {
    pub ListHeadPtr: *mut CFE_SB_DestinationD_t,
    pub MsgId: CFE_SB_MsgId_t,
    pub SeqCnt: CFE_MSG_SequenceCount_t,
}
pub type CFE_MSG_SequenceCount_t = uint16;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cfe_sbr_route_data_t {
    pub RoutingTbl: [CFE_SBR_RouteEntry_t; 256],
    pub RouteIdxTop: CFE_SB_RouteId_Atom_t,
}
pub type CFE_MSG_Checksum_t = uint32;
pub type CFE_MSG_SegmentationFlag_t = CFE_MSG_SegmentationFlag;
pub type CFE_MSG_SegmentationFlag = libc::c_uint;
pub const CFE_MSG_SegFlag_Unsegmented: CFE_MSG_SegmentationFlag = 4;
pub const CFE_MSG_SegFlag_Last: CFE_MSG_SegmentationFlag = 3;
pub const CFE_MSG_SegFlag_First: CFE_MSG_SegmentationFlag = 2;
pub const CFE_MSG_SegFlag_Continue: CFE_MSG_SegmentationFlag = 1;
pub const CFE_MSG_SegFlag_Invalid: CFE_MSG_SegmentationFlag = 0;
pub type CFE_MSG_ApId_t = uint16;
pub type CFE_MSG_HeaderVersion_t = uint16;
pub const CFE_EVS_MsgFormat_SHORT: CFE_EVS_MsgFormat = 0;
pub const CFE_EVS_MsgFormat_LONG: CFE_EVS_MsgFormat = 1;
pub const CFE_EVS_LogMode_DISCARD: CFE_EVS_LogMode = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_Global_t {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub SuccessValCounter: uint8,
    pub FailedValCounter: uint8,
    pub NumValRequests: uint8,
    pub LastTblUpdated: int16,
    pub HkPacket: CFE_TBL_HousekeepingTlm_t,
    pub TblRegPacket: CFE_TBL_TableRegistryTlm_t,
    pub NotifyMsg: CFE_TBL_NotifyCmd_t,
    pub CmdPipe: CFE_SB_PipeId_t,
    pub TableTaskAppId: CFE_ES_AppId_t,
    pub HkTlmTblRegIndex: int16,
    pub ValidationCounter: uint16,
    pub RegistryMutex: osal_id_t,
    pub WorkBufMutex: osal_id_t,
    pub CritRegHandle: CFE_ES_CDSHandle_t,
    pub LoadBuffs: [CFE_TBL_LoadBuff_t; 4],
    pub Handles: [CFE_TBL_AccessDescriptor_t; 256],
    pub Registry: [CFE_TBL_RegistryRec_t; 128],
    pub CritReg: [CFE_TBL_CritRegRec_t; 32],
    pub Buf: CFE_TBL_BufParams_t,
    pub ValidationResults: [CFE_TBL_ValidationResult_t; 10],
    pub DumpControlBlocks: [CFE_TBL_DumpControl_t; 4],
    pub RegDumpState: CFE_TBL_RegDumpStateInfo_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_RegDumpStateInfo_t {
    pub FileWrite: CFE_FS_FileWriteMetaData_t,
    pub FileExisted: bool,
    pub DumpRecord: CFE_TBL_RegDumpRec_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_RegDumpRec_t {
    pub Size: CFE_ES_MemOffset_t,
    pub TimeOfLastUpdate: CFE_TIME_SysTime_t,
    pub NumUsers: uint32,
    pub LoadInProgress: int32,
    pub FileCreateTimeSecs: uint32,
    pub FileCreateTimeSubSecs: uint32,
    pub Crc: uint32,
    pub ValidationFunc: bool,
    pub TableLoadedOnce: bool,
    pub LoadPending: bool,
    pub DumpOnly: bool,
    pub DoubleBuffered: bool,
    pub Name: [libc::c_char; 40],
    pub LastFileLoaded: [libc::c_char; 64],
    pub OwnerAppName: [libc::c_char; 20],
    pub CriticalTable: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_DumpControl_t {
    pub State: CFE_TBL_DumpState_t,
    pub Size: size_t,
    pub DumpBufferPtr: *mut CFE_TBL_LoadBuff_t,
    pub RegRecPtr: *mut CFE_TBL_RegistryRec_t,
    pub TableName: [libc::c_char; 40],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_RegistryRec_t {
    pub OwnerAppId: CFE_ES_AppId_t,
    pub Size: size_t,
    pub NotificationMsgId: CFE_SB_MsgId_t,
    pub NotificationParam: uint32,
    pub Buffers: [CFE_TBL_LoadBuff_t; 2],
    pub ValidationFuncPtr: CFE_TBL_CallbackFuncPtr_t,
    pub TimeOfLastUpdate: CFE_TIME_SysTime_t,
    pub HeadOfAccessList: CFE_TBL_Handle_t,
    pub LoadInProgress: int32,
    pub ValidateActiveIndex: int32,
    pub ValidateInactiveIndex: int32,
    pub DumpControlIndex: int32,
    pub CDSHandle: CFE_ES_CDSHandle_t,
    pub NotificationCC: CFE_MSG_FcnCode_t,
    pub CriticalTable: bool,
    pub TableLoadedOnce: bool,
    pub LoadPending: bool,
    pub DumpOnly: bool,
    pub DoubleBuffered: bool,
    pub UserDefAddr: bool,
    pub NotifyByMsg: bool,
    pub ActiveBufferIndex: uint8,
    pub Name: [libc::c_char; 40],
    pub LastFileLoaded: [libc::c_char; 64],
}
pub type CFE_MSG_FcnCode_t = uint16;
pub type CFE_TBL_Handle_t = int16;
pub type CFE_TBL_CallbackFuncPtr_t = Option<unsafe extern "C" fn(*mut libc::c_void) -> int32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_LoadBuff_t {
    pub BufferPtr: *mut libc::c_void,
    pub FileCreateTimeSecs: uint32,
    pub FileCreateTimeSubSecs: uint32,
    pub Crc: uint32,
    pub Taken: bool,
    pub Validated: bool,
    pub DataSource: [libc::c_char; 64],
}
pub type CFE_TBL_DumpState_t = libc::c_uint;
pub const CFE_TBL_DUMP_PERFORMED: CFE_TBL_DumpState_t = 2;
pub const CFE_TBL_DUMP_PENDING: CFE_TBL_DumpState_t = 1;
pub const CFE_TBL_DUMP_FREE: CFE_TBL_DumpState_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_ValidationResult_t {
    pub State: CFE_TBL_ValidationState_t,
    pub Result_0: int32,
    pub CrcOfTable: uint32,
    pub ActiveBuffer: bool,
    pub TableName: [libc::c_char; 40],
}
pub type CFE_TBL_ValidationState_t = libc::c_uint;
pub const CFE_TBL_VALIDATION_PERFORMED: CFE_TBL_ValidationState_t = 2;
pub const CFE_TBL_VALIDATION_PENDING: CFE_TBL_ValidationState_t = 1;
pub const CFE_TBL_VALIDATION_FREE: CFE_TBL_ValidationState_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_BufParams_t {
    pub PoolHdl: CFE_ES_MemHandle_t,
    pub Partition: C2RustUnnamed_22,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_22 {
    pub Align: CFE_ES_PoolAlign_t,
    pub Data: [uint8; 524288],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_CritRegRec_t {
    pub CDSHandle: CFE_ES_CDSHandle_t,
    pub FileCreateTimeSecs: uint32,
    pub FileCreateTimeSubSecs: uint32,
    pub TimeOfLastUpdate: CFE_TIME_SysTime_t,
    pub LastFileLoaded: [libc::c_char; 64],
    pub Name: [libc::c_char; 40],
    pub TableLoadedOnce: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_AccessDescriptor_t {
    pub AppId: CFE_ES_AppId_t,
    pub RegIndex: int16,
    pub PrevLink: CFE_TBL_Handle_t,
    pub NextLink: CFE_TBL_Handle_t,
    pub UsedFlag: bool,
    pub LockFlag: bool,
    pub Updated: bool,
    pub BufferIndex: uint8,
}
pub type CFE_TBL_NotifyCmd_t = CFE_TBL_NotifyCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_NotifyCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_NotifyCmd_Payload_t,
}
pub type CFE_TBL_NotifyCmd_Payload_t = CFE_TBL_NotifyCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_NotifyCmd_Payload {
    pub Parameter: uint32,
}
pub type CFE_TBL_TableRegistryTlm_t = CFE_TBL_TableRegistryTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_TableRegistryTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_TBL_TblRegPacket_Payload_t,
}
pub type CFE_TBL_TblRegPacket_Payload_t = CFE_TBL_TblRegPacket_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_TblRegPacket_Payload {
    pub Size: CFE_ES_MemOffset_t,
    pub Crc: uint32,
    pub ActiveBufferAddr: CFE_ES_MemAddress_t,
    pub InactiveBufferAddr: CFE_ES_MemAddress_t,
    pub ValidationFuncPtr: CFE_ES_MemAddress_t,
    pub TimeOfLastUpdate: CFE_TIME_SysTime_t,
    pub FileCreateTimeSecs: uint32,
    pub FileCreateTimeSubSecs: uint32,
    pub TableLoadedOnce: bool,
    pub LoadPending: bool,
    pub DumpOnly: bool,
    pub DoubleBuffered: bool,
    pub Name: [libc::c_char; 40],
    pub LastFileLoaded: [libc::c_char; 64],
    pub OwnerAppName: [libc::c_char; 20],
    pub Critical: bool,
    pub ByteAlign4: uint8,
}
pub type CFE_TBL_HousekeepingTlm_t = CFE_TBL_HousekeepingTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_HousekeepingTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_TBL_HousekeepingTlm_Payload_t,
}
pub type CFE_TBL_HousekeepingTlm_Payload_t = CFE_TBL_HousekeepingTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_HousekeepingTlm_Payload {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub NumTables: uint16,
    pub NumLoadPending: uint16,
    pub ValidationCounter: uint16,
    pub LastValCrc: uint32,
    pub LastValStatus: int32,
    pub ActiveBuffer: bool,
    pub LastValTableName: [libc::c_char; 40],
    pub SuccessValCounter: uint8,
    pub FailedValCounter: uint8,
    pub NumValRequests: uint8,
    pub NumFreeSharedBufs: uint8,
    pub ByteAlignPad1: uint8,
    pub MemPoolHandle: CFE_ES_MemHandle_t,
    pub LastUpdateTime: CFE_TIME_SysTime_t,
    pub LastUpdatedTable: [libc::c_char; 40],
    pub LastFileLoaded: [libc::c_char; 64],
    pub LastFileDumped: [libc::c_char; 64],
    pub LastTableLoaded: [libc::c_char; 40],
}
pub const CFE_TBL_INC_ERR_CTR: CFE_TBL_CmdProcRet_t = -872415190;
pub type CFE_TBL_CmdProcRet_t = libc::c_int;
pub const CFE_TBL_INC_CMD_CTR: CFE_TBL_CmdProcRet_t = 0;
pub const CFE_TBL_DONT_INC_CTR: CFE_TBL_CmdProcRet_t = 1207959553;
pub const CFE_TBL_CMD_MSGTYPE: CFE_TBL_MsgType_t = 2;
pub type CFE_TBL_MsgType_t = libc::c_uint;
pub const CFE_TBL_MSG_MSGTYPE: CFE_TBL_MsgType_t = 1;
pub const CFE_TBL_TERM_MSGTYPE: CFE_TBL_MsgType_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_CmdHandlerTblRec_t {
    pub MsgId: CFE_SB_MsgId_t,
    pub CmdCode: CFE_MSG_FcnCode_t,
    pub ExpectedLength: size_t,
    pub MsgProcFuncPtr: CFE_TBL_MsgProcFuncPtr_t,
    pub MsgTypes: CFE_TBL_MsgType_t,
}
pub type CFE_TBL_MsgProcFuncPtr_t = Option<unsafe extern "C" fn(*const libc::c_void) -> int32>;
pub type CFE_TBL_AbortLoadCmd_t = CFE_TBL_AbortLoadCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_AbortLoadCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_AbortLoadCmd_Payload_t,
}
pub type CFE_TBL_AbortLoadCmd_Payload_t = CFE_TBL_AbortLoadCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_AbortLoadCmd_Payload {
    pub TableName: [libc::c_char; 40],
}
pub type CFE_TBL_DeleteCDSCmd_t = CFE_TBL_DeleteCDSCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_DeleteCDSCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_DelCDSCmd_Payload_t,
}
pub type CFE_TBL_DelCDSCmd_Payload_t = CFE_TBL_DelCDSCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_DelCDSCmd_Payload {
    pub TableName: [libc::c_char; 40],
}
pub type CFE_PSP_Status_t = int32;
pub type CFE_TBL_SendRegistryCmd_t = CFE_TBL_SendRegistryCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_SendRegistryCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_SendRegistryCmd_Payload_t,
}
pub type CFE_TBL_SendRegistryCmd_Payload_t = CFE_TBL_SendRegistryCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_SendRegistryCmd_Payload {
    pub TableName: [libc::c_char; 40],
}
pub type CFE_TBL_DumpRegistryCmd_t = CFE_TBL_DumpRegistryCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_DumpRegistryCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_DumpRegistryCmd_Payload_t,
}
pub type CFE_TBL_DumpRegistryCmd_Payload_t = CFE_TBL_DumpRegistryCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_DumpRegistryCmd_Payload {
    pub DumpFilename: [libc::c_char; 64],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_FS_Global_t {
    pub SharedDataMutexId: osal_id_t,
    pub FileDump: CFE_FS_BackgroundFileDumpState_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_FS_BackgroundFileDumpState_t {
    pub RequestCount: uint32,
    pub CompleteCount: uint32,
    pub Entries: [CFE_FS_BackgroundFileDumpEntry_t; 4],
    pub Current: CFE_FS_CurrentFileState_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_FS_CurrentFileState_t {
    pub Fd: osal_id_t,
    pub Credit: int32,
    pub RecordNum: uint32,
    pub FileSize: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_FS_BackgroundFileDumpEntry_t {
    pub RequestorAppId: CFE_ES_AppId_t,
    pub Meta: *mut CFE_FS_FileWriteMetaData_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct os_fstat_t {
    pub FileModeBits: uint32,
    pub FileTime: OS_time_t,
    pub FileSize: size_t,
}
pub const OS_FILESTAT_MODE_EXEC: C2RustUnnamed_32 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub const OS_FILESTAT_MODE_WRITE: C2RustUnnamed_32 = 2;
pub const OS_FILESTAT_MODE_READ: C2RustUnnamed_32 = 4;
pub const OS_FILESTAT_MODE_DIR: C2RustUnnamed_32 = 65536;
pub const CFE_FS_SubType_TBL_REG: CFE_FS_SubType = 9;
pub type CFE_TBL_ActivateCmd_t = CFE_TBL_ActivateCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_ActivateCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_ActivateCmd_Payload_t,
}
pub type CFE_TBL_ActivateCmd_Payload_t = CFE_TBL_ActivateCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_ActivateCmd_Payload {
    pub TableName: [libc::c_char; 40],
}
pub type CFE_TBL_ValidateCmd_t = CFE_TBL_ValidateCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_ValidateCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_ValidateCmd_Payload_t,
}
pub type CFE_TBL_ValidateCmd_Payload_t = CFE_TBL_ValidateCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_ValidateCmd_Payload {
    pub ActiveTableFlag: uint16,
    pub TableName: [libc::c_char; 40],
}
pub type CFE_ES_CrcType_Enum_t = CFE_ES_CrcType_Enum;
pub type CFE_ES_CrcType_Enum = libc::c_uint;
pub const CFE_ES_CrcType_CRC_32: CFE_ES_CrcType_Enum = 4;
pub const CFE_ES_CrcType_CRC_8: CFE_ES_CrcType_Enum = 3;
pub const CFE_ES_CrcType_CRC_16: CFE_ES_CrcType_Enum = 1;
pub const CFE_ES_CrcType_MAX: CFE_ES_CrcType_Enum = 2;
pub const CFE_ES_CrcType_16_ARC: CFE_ES_CrcType_Enum = 1;
pub const CFE_ES_CrcType_NONE: CFE_ES_CrcType_Enum = 0;
pub type CFE_ES_ComputeCRC_Algo_t =
    Option<unsafe extern "C" fn(*const libc::c_void, size_t, uint32) -> uint32>;
pub type CFE_ES_ComputeCRC_Params_t = CFE_ES_ComputeCRC_Params;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ComputeCRC_Params {
    pub InitialValue: uint32,
    pub FinalXOR: uint32,
    pub Algorithm: CFE_ES_ComputeCRC_Algo_t,
}
pub const CFE_TBL_BufferSelect_INACTIVE: CFE_TBL_BufferSelect = 0;
pub const CFE_TBL_BufferSelect_ACTIVE: CFE_TBL_BufferSelect = 1;
pub type CFE_TBL_DumpCmd_t = CFE_TBL_DumpCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_DumpCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_DumpCmd_Payload_t,
}
pub type CFE_TBL_DumpCmd_Payload_t = CFE_TBL_DumpCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_DumpCmd_Payload {
    pub ActiveTableFlag: uint16,
    pub TableName: [libc::c_char; 40],
    pub DumpFilename: [libc::c_char; 64],
}
pub type CFE_TBL_File_Hdr_t = CFE_TBL_File_Hdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_File_Hdr {
    pub Reserved: uint32,
    pub Offset: uint32,
    pub NumBytes: uint32,
    pub TableName: [libc::c_char; 40],
}
pub type CFE_FS_Header_t = CFE_FS_Header;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_FS_Header {
    pub ContentType: uint32,
    pub SubType: uint32,
    pub Length: uint32,
    pub SpacecraftID: uint32,
    pub ProcessorID: uint32,
    pub ApplicationID: uint32,
    pub TimeSeconds: uint32,
    pub TimeSubSeconds: uint32,
    pub Description: [libc::c_char; 32],
}
pub const CFE_FS_SubType_TBL_IMG: CFE_FS_SubType = 8;
pub type CFE_TBL_LoadCmd_t = CFE_TBL_LoadCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_LoadCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TBL_LoadCmd_Payload_t,
}
pub type CFE_TBL_LoadCmd_Payload_t = CFE_TBL_LoadCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_LoadCmd_Payload {
    pub LoadFilename: [libc::c_char; 64],
}
pub type CFE_TBL_ResetCountersCmd_t = CFE_TBL_ResetCountersCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_ResetCountersCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_TBL_NoopCmd_t = CFE_TBL_NoopCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_NoopCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_TBL_SendHkCmd_t = CFE_TBL_SendHkCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_SendHkCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub const CFE_ES_SystemState_SHUTDOWN: CFE_ES_SystemState = 6;
pub const CFE_ES_AppState_EARLY_INIT: CFE_ES_AppState = 1;
pub type CFE_SB_SingleSubscriptionTlm_t = CFE_SB_SingleSubscriptionTlm;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_SingleSubscriptionTlm {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CFE_SB_SingleSubscriptionTlm_Payload_t,
}
pub type CFE_SB_SingleSubscriptionTlm_Payload_t = CFE_SB_SingleSubscriptionTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_SingleSubscriptionTlm_Payload {
    pub SubType: uint8,
    pub MsgId: CFE_SB_MsgId_t,
    pub Qos: CFE_SB_Qos_t,
    pub Pipe: CFE_SB_PipeId_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mq_attr {
    pub mq_flags: __syscall_slong_t,
    pub mq_maxmsg: __syscall_slong_t,
    pub mq_msgsize: __syscall_slong_t,
    pub mq_curmsgs: __syscall_slong_t,
    pub __pad: [__syscall_slong_t; 4],
}
pub const CFE_EVS_EventFilter_BINARY: CFE_EVS_EventFilter = 0;
pub type CFE_TIME_SubOneHzAdjustmentCmd_t = CFE_TIME_SubOneHzAdjustmentCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SubOneHzAdjustmentCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_OneHzAdjustmentCmd_Payload_t,
}
pub type CFE_TIME_OneHzAdjustmentCmd_Payload_t = CFE_TIME_OneHzAdjustmentCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_OneHzAdjustmentCmd_Payload {
    pub Seconds: uint32,
    pub Subseconds: uint32,
}
pub type CFE_TIME_AdjustDirection_Enum_t = uint8;
pub const CFE_TIME_AdjustDirection_SUBTRACT: CFE_TIME_AdjustDirection = 2;
pub type CFE_TIME_AddOneHzAdjustmentCmd_t = CFE_TIME_AddOneHzAdjustmentCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_AddOneHzAdjustmentCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_OneHzAdjustmentCmd_Payload_t,
}
pub const CFE_TIME_AdjustDirection_ADD: CFE_TIME_AdjustDirection = 1;
pub type CFE_TIME_SubAdjustCmd_t = CFE_TIME_SubAdjustCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SubAdjustCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
pub type CFE_TIME_TimeCmd_Payload_t = CFE_TIME_TimeCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_TimeCmd_Payload {
    pub Seconds: uint32,
    pub MicroSeconds: uint32,
}
pub type CFE_TIME_AddAdjustCmd_t = CFE_TIME_AddAdjustCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_AddAdjustCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
pub type CFE_TIME_SetLeapSecondsCmd_t = CFE_TIME_SetLeapSecondsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SetLeapSecondsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_LeapsCmd_Payload_t,
}
pub type CFE_TIME_LeapsCmd_Payload_t = CFE_TIME_LeapsCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_LeapsCmd_Payload {
    pub LeapSeconds: int16,
}
pub type CFE_TIME_SetSTCFCmd_t = CFE_TIME_SetSTCFCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SetSTCFCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
pub type CFE_TIME_SetMETCmd_t = CFE_TIME_SetMETCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SetMETCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
pub type CFE_TIME_SetTimeCmd_t = CFE_TIME_SetTimeCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SetTimeCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
pub type CFE_TIME_SubDelayCmd_t = CFE_TIME_SubDelayCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SubDelayCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
pub type CFE_TIME_AddDelayCmd_t = CFE_TIME_AddDelayCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_AddDelayCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
pub type CFE_TIME_SetSignalCmd_t = CFE_TIME_SetSignalCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SetSignalCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_SignalCmd_Payload_t,
}
pub type CFE_TIME_SignalCmd_Payload_t = CFE_TIME_SignalCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SignalCmd_Payload {
    pub ToneSource: int16,
}
pub const CFE_TIME_ToneSignalSelect_REDUNDANT: CFE_TIME_ToneSignalSelect = 2;
pub const CFE_TIME_ToneSignalSelect_PRIMARY: CFE_TIME_ToneSignalSelect = 1;
pub type CFE_TIME_SetSourceCmd_t = CFE_TIME_SetSourceCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SetSourceCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_SourceCmd_Payload_t,
}
pub type CFE_TIME_SourceCmd_Payload_t = CFE_TIME_SourceCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SourceCmd_Payload {
    pub TimeSource: int16,
}
pub const CFE_TIME_SourceSelect_EXTERNAL: CFE_TIME_SourceSelect = 2;
pub const CFE_TIME_SourceSelect_INTERNAL: CFE_TIME_SourceSelect = 1;
pub type CFE_TIME_SetStateCmd_t = CFE_TIME_SetStateCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SetStateCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_TIME_StateCmd_Payload_t,
}
pub type CFE_TIME_StateCmd_Payload_t = CFE_TIME_StateCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_StateCmd_Payload {
    pub ClockState: CFE_TIME_ClockState_Enum_t,
}
pub const CFE_TIME_ClockState_VALID: CFE_TIME_ClockState = 0;
pub const CFE_TIME_ClockState_INVALID: CFE_TIME_ClockState = -1;
pub const CFE_TIME_SetState_NOT_SET: CFE_TIME_SetState = 0;
pub const CFE_TIME_SetState_WAS_SET: CFE_TIME_SetState = 1;
pub const CFE_TIME_FlywheelState_IS_FLY: CFE_TIME_FlywheelState = 1;
pub const CFE_TIME_ClockState_FLYWHEEL: CFE_TIME_ClockState = 1;
pub type CFE_TIME_SendDiagnosticCmd_t = CFE_TIME_SendDiagnosticCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SendDiagnosticCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub const CFE_TIME_FlywheelState_NO_FLY: CFE_TIME_FlywheelState = 0;
pub type CFE_TIME_ResetCountersCmd_t = CFE_TIME_ResetCountersCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_ResetCountersCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_TIME_NoopCmd_t = CFE_TIME_NoopCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_NoopCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_TIME_SendHkCmd_t = CFE_TIME_SendHkCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TIME_SendHkCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_ES_StackPointer_t = *mut libc::c_void;
pub type CFE_ES_ChildTaskMainFuncPtr_t = CFE_ES_TaskEntryFuncPtr_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_bin_sem_internal_record_t {
    pub obj_name: [libc::c_char; 20],
}
pub type CFE_ES_DumpCDSRegistryCmd_t = CFE_ES_DumpCDSRegistryCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_DumpCDSRegistryCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_DumpCDSRegistryCmd_Payload_t,
}
pub type CFE_ES_DumpCDSRegistryCmd_Payload_t = CFE_ES_DumpCDSRegistryCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_DumpCDSRegistryCmd_Payload {
    pub DumpFilename: [libc::c_char; 64],
}
pub type CFE_ES_CDSRegDumpRec_t = CFE_ES_CDSRegDumpRec;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CDSRegDumpRec {
    pub Handle: CFE_ES_CDSHandle_t,
    pub Size: CFE_ES_MemOffset_t,
    pub Table: bool,
    pub Name: [libc::c_char; 40],
    pub ByteAlignSpare: [uint8; 3],
}
pub const CFE_FS_SubType_ES_CDS_REG: CFE_FS_SubType = 6;
pub type CFE_ES_SendMemPoolStatsCmd_t = CFE_ES_SendMemPoolStatsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SendMemPoolStatsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_SendMemPoolStatsCmd_Payload_t,
}
pub type CFE_ES_SendMemPoolStatsCmd_Payload_t = CFE_ES_SendMemPoolStatsCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SendMemPoolStatsCmd_Payload {
    pub Application: [libc::c_char; 20],
    pub PoolHandle: CFE_ES_MemHandle_t,
}
pub type CFE_ES_DeleteCDSCmd_t = CFE_ES_DeleteCDSCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_DeleteCDSCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_DeleteCDSCmd_Payload_t,
}
pub type CFE_ES_DeleteCDSCmd_Payload_t = CFE_ES_DeleteCDSCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_DeleteCDSCmd_Payload {
    pub CdsName: [libc::c_char; 40],
}
pub type CFE_ES_SetMaxPRCountCmd_t = CFE_ES_SetMaxPRCountCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SetMaxPRCountCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_SetMaxPRCountCmd_Payload_t,
}
pub type CFE_ES_SetMaxPRCountCmd_Payload_t = CFE_ES_SetMaxPRCountCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SetMaxPRCountCmd_Payload {
    pub MaxPRCount: uint16,
}
pub type CFE_ES_ResetPRCountCmd_t = CFE_ES_ResetPRCountCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ResetPRCountCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_ES_SetPerfTriggerMaskCmd_t = CFE_ES_SetPerfTriggerMaskCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SetPerfTriggerMaskCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_SetPerfTrigMaskCmd_Payload_t,
}
pub type CFE_ES_SetPerfTrigMaskCmd_Payload_t = CFE_ES_SetPerfTrigMaskCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SetPerfTrigMaskCmd_Payload {
    pub TriggerMaskNum: uint32,
    pub TriggerMask: uint32,
}
pub type CFE_ES_SetPerfFilterMaskCmd_t = CFE_ES_SetPerfFilterMaskCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SetPerfFilterMaskCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_SetPerfFilterMaskCmd_Payload_t,
}
pub type CFE_ES_SetPerfFilterMaskCmd_Payload_t = CFE_ES_SetPerfFilterMaskCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SetPerfFilterMaskCmd_Payload {
    pub FilterMaskNum: uint32,
    pub FilterMask: uint32,
}
pub type CFE_ES_StopPerfDataCmd_t = CFE_ES_StopPerfDataCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_StopPerfDataCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_StopPerfCmd_Payload_t,
}
pub type CFE_ES_StopPerfCmd_Payload_t = CFE_ES_StopPerfCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_StopPerfCmd_Payload {
    pub DataFileName: [libc::c_char; 64],
}
pub type CFE_ES_StartPerfDataCmd_t = CFE_ES_StartPerfDataCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_StartPerfDataCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_StartPerfCmd_Payload_t,
}
pub type CFE_ES_StartPerfCmd_Payload_t = CFE_ES_StartPerfCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_StartPerfCmd_Payload {
    pub TriggerMode: CFE_ES_PerfMode_Enum_t,
}
pub type CFE_ES_PerfMode_Enum_t = uint32;
pub type CFE_ES_WriteERLogCmd_t = CFE_ES_WriteERLogCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_WriteERLogCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_FileNameCmd_Payload_t,
}
pub type CFE_ES_FileNameCmd_Payload_t = CFE_ES_FileNameCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_FileNameCmd_Payload {
    pub FileName: [libc::c_char; 64],
}
pub const CFE_FS_SubType_ES_ERLOG: CFE_FS_SubType = 1;
pub type CFE_ES_ClearERLogCmd_t = CFE_ES_ClearERLogCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ClearERLogCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_ES_OverWriteSysLogCmd_t = CFE_ES_OverWriteSysLogCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_OverWriteSysLogCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_OverWriteSysLogCmd_Payload_t,
}
pub type CFE_ES_OverWriteSysLogCmd_Payload_t = CFE_ES_OverWriteSysLogCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_OverWriteSysLogCmd_Payload {
    pub Mode: uint32,
}
pub type CFE_ES_LogMode_Enum_t = uint8;
pub const CFE_ES_LogMode_DISCARD: CFE_ES_LogMode = 1;
pub type CFE_ES_WriteSysLogCmd_t = CFE_ES_WriteSysLogCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_WriteSysLogCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_FileNameCmd_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SysLogReadBuffer_t {
    pub SizeLeft: size_t,
    pub BlockSize: size_t,
    pub EndIdx: size_t,
    pub LastOffset: size_t,
    pub Data: [libc::c_char; 444],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_23 {
    pub LogData: CFE_ES_SysLogReadBuffer_t,
    pub FileHdr: CFE_FS_Header_t,
}
pub const CFE_FS_SubType_ES_SYSLOG: CFE_FS_SubType = 2;
pub type CFE_ES_ClearSysLogCmd_t = CFE_ES_ClearSysLogCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ClearSysLogCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_ES_QueryAllTasksCmd_t = CFE_ES_QueryAllTasksCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_QueryAllTasksCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_FileNameCmd_Payload_t,
}
pub const CFE_FS_SubType_ES_QUERYALLTASKS: CFE_FS_SubType = 23;
pub type CFE_ES_QueryAllCmd_t = CFE_ES_QueryAllCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_QueryAllCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_FileNameCmd_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_module_address_t {
    pub valid: uint32,
    pub flags: uint32,
    pub code_address: cpuaddr,
    pub code_size: cpuaddr,
    pub data_address: cpuaddr,
    pub data_size: cpuaddr,
    pub bss_address: cpuaddr,
    pub bss_size: cpuaddr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_module_prop_t {
    pub entry_point: cpuaddr,
    pub host_module_id: cpuaddr,
    pub filename: [libc::c_char; 64],
    pub name: [libc::c_char; 20],
    pub addr: OS_module_address_t,
}
pub const CFE_ES_AppType_LIBRARY: CFE_ES_AppType = 3;
pub const CFE_FS_SubType_ES_QUERYALL: CFE_FS_SubType = 3;
pub type CFE_ES_QueryOneCmd_t = CFE_ES_QueryOneCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_QueryOneCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_AppNameCmd_Payload_t,
}
pub type CFE_ES_AppNameCmd_Payload_t = CFE_ES_AppNameCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_AppNameCmd_Payload {
    pub Application: [libc::c_char; 20],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_24 {
    pub AppId: CFE_ES_AppId_t,
    pub LibId: CFE_ES_LibId_t,
    pub ResourceID: CFE_ResourceId_t,
}
pub type CFE_ES_ReloadAppCmd_t = CFE_ES_ReloadAppCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ReloadAppCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_AppReloadCmd_Payload_t,
}
pub type CFE_ES_AppReloadCmd_Payload_t = CFE_ES_AppReloadCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_AppReloadCmd_Payload {
    pub Application: [libc::c_char; 20],
    pub AppFileName: [libc::c_char; 64],
}
pub const CFE_ES_RunStatus_SYS_RELOAD: CFE_ES_RunStatus = 6;
pub type CFE_ES_RestartAppCmd_t = CFE_ES_RestartAppCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_RestartAppCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_AppNameCmd_Payload_t,
}
pub const CFE_ES_RunStatus_SYS_RESTART: CFE_ES_RunStatus = 5;
pub type CFE_ES_StopAppCmd_t = CFE_ES_StopAppCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_StopAppCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_AppNameCmd_Payload_t,
}
pub const CFE_ES_RunStatus_SYS_DELETE: CFE_ES_RunStatus = 7;
pub type CFE_ES_StartAppCmd_t = CFE_ES_StartApp;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_StartApp {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_StartAppCmd_Payload_t,
}
pub type CFE_ES_StartAppCmd_Payload_t = CFE_ES_StartAppCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_StartAppCmd_Payload {
    pub Application: [libc::c_char; 20],
    pub AppEntryPoint: [libc::c_char; 20],
    pub AppFileName: [libc::c_char; 64],
    pub StackSize: CFE_ES_MemOffset_t,
    pub ExceptionAction: CFE_ES_ExceptionAction_Enum_t,
    pub Priority: CFE_ES_TaskPriority_Atom_t,
}
pub type CFE_ES_RestartCmd_t = CFE_ES_RestartCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_RestartCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_ES_RestartCmd_Payload_t,
}
pub type CFE_ES_RestartCmd_Payload_t = CFE_ES_RestartCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_RestartCmd_Payload {
    pub RestartType: uint16,
}
pub type CFE_ES_ResetCountersCmd_t = CFE_ES_ResetCountersCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_ResetCountersCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_ES_NoopCmd_t = CFE_ES_NoopCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_NoopCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_ConfigId_t = CFE_ResourceId_t;
pub const CFE_ConfigIdOffset_CORE_BUILDINFO_HOST: CFE_ConfigIdOffset = 13;
pub const CFE_CONFIGID_BASE: C2RustUnnamed_56 = 1507328;
pub type CFE_Config_ValueBuffer_t = CFE_Config_ValueBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub union CFE_Config_ValueBuffer {
    pub AsInteger: uint32,
    pub AsPointer: *const libc::c_void,
}
pub type CFE_Config_ValueEntry_t = CFE_Config_ValueEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_Config_ValueEntry {
    pub ActualType: CFE_ConfigType_t,
    pub Datum: CFE_Config_ValueBuffer_t,
}
pub type CFE_ConfigType_t = CFE_ConfigType;
pub type CFE_ConfigType = libc::c_uint;
pub const CFE_ConfigType_POINTER: CFE_ConfigType = 3;
pub const CFE_ConfigType_STRING: CFE_ConfigType = 2;
pub const CFE_ConfigType_VALUE: CFE_ConfigType = 1;
pub const CFE_ConfigType_UNDEFINED: CFE_ConfigType = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_Config_Global_t {
    pub UnknownString: *const libc::c_char,
    pub Table: [CFE_Config_ValueEntry_t; 34],
}
pub const CFE_ConfigIdOffset_MAX: CFE_ConfigIdOffset = 34;
pub const CFE_ConfigIdOffset_CORE_BUILDINFO_USER: CFE_ConfigIdOffset = 12;
pub const CFE_ConfigIdOffset_CORE_BUILDINFO_DATE: CFE_ConfigIdOffset = 11;
pub type CFE_ES_SendHkCmd_t = CFE_ES_SendHkCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_SendHkCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_heap_prop_t {
    pub free_bytes: size_t,
    pub free_blocks: osal_blockcount_t,
    pub largest_free_block: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_BackgroundJobEntry_t {
    pub RunFunc: Option<unsafe extern "C" fn(uint32, *mut libc::c_void) -> bool>,
    pub JobArg: *mut libc::c_void,
    pub ActivePeriod: uint32,
    pub IdlePeriod: uint32,
}
pub const CFE_ES_LogEntryType_APPLICATION: CFE_ES_LogEntryType = 2;
pub const FPE_FLTSUB: C2RustUnnamed_51 = 8;
pub const FPE_FLTINV: C2RustUnnamed_51 = 7;
pub const FPE_FLTRES: C2RustUnnamed_51 = 6;
pub const FPE_FLTUND: C2RustUnnamed_51 = 5;
pub const FPE_FLTOVF: C2RustUnnamed_51 = 4;
pub const FPE_FLTDIV: C2RustUnnamed_51 = 3;
pub const FPE_INTOVF: C2RustUnnamed_51 = 2;
pub const FPE_INTDIV: C2RustUnnamed_51 = 1;
pub const CFE_FS_SubType_ES_PERFDATA: CFE_FS_SubType = 4;
pub type CFE_EVS_EventType_Enum_t = uint16;
pub const CFE_ES_RunStatus_SYS_EXCEPTION: CFE_ES_RunStatus = 4;
pub const CFE_ES_RunStatus_APP_EXIT: CFE_ES_RunStatus = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CleanupState_t {
    pub ErrorFlag: uint32,
    pub FoundObjects: uint32,
    pub PrevFoundObjects: uint32,
    pub DeletedObjects: uint32,
    pub OverallStatus: int32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SBR_Throttle_t {
    pub StartIndex: uint32,
    pub MaxLoop: uint32,
    pub NextIndex: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_RemovePipeCallback_t {
    pub FullName: *const libc::c_char,
    pub PipeId: CFE_SB_PipeId_t,
}
pub type CFE_SBR_CallbackPtr_t =
    Option<unsafe extern "C" fn(CFE_SBR_RouteId_t, *mut libc::c_void) -> ()>;
pub const CFE_ES_AppState_WAITING: CFE_ES_AppState = 4;
pub type CFE_Config_Callback_t =
    Option<unsafe extern "C" fn(*mut libc::c_void, CFE_ConfigId_t, *const libc::c_char) -> ()>;
pub type CFE_Config_IdNameEntry_t = CFE_Config_IdNameEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_Config_IdNameEntry {
    pub Name: *const libc::c_char,
}
pub const CFE_ConfigIdOffset_MISSION_SRCVER: CFE_ConfigIdOffset = 1;
pub type CFE_SB_WriteMapInfoCmd_t = CFE_SB_WriteMapInfoCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_WriteMapInfoCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_SB_WriteFileInfoCmd_Payload_t,
}
pub type CFE_SB_WriteFileInfoCmd_Payload_t = CFE_SB_WriteFileInfoCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_WriteFileInfoCmd_Payload {
    pub Filename: [libc::c_char; 64],
}
pub const CFE_FS_SubType_SB_MAPDATA: CFE_FS_SubType = 22;
pub type CFE_SB_WritePipeInfoCmd_t = CFE_SB_WritePipeInfoCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_WritePipeInfoCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_SB_WriteFileInfoCmd_Payload_t,
}
pub const CFE_FS_SubType_SB_PIPEDATA: CFE_FS_SubType = 20;
pub type CFE_SB_DisableRouteCmd_t = CFE_SB_DisableRouteCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_DisableRouteCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_SB_RouteCmd_Payload_t,
}
pub type CFE_SB_RouteCmd_Payload_t = CFE_SB_RouteCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_RouteCmd_Payload {
    pub MsgId: CFE_SB_MsgId_t,
    pub Pipe: CFE_SB_PipeId_t,
    pub Spare: uint8,
}
pub type CFE_SB_EnableRouteCmd_t = CFE_SB_EnableRouteCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_EnableRouteCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_SB_RouteCmd_Payload_t,
}
pub type CFE_SB_WriteRoutingInfoCmd_t = CFE_SB_WriteRoutingInfoCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_WriteRoutingInfoCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_SB_WriteFileInfoCmd_Payload_t,
}
pub const CFE_FS_SubType_SB_ROUTEDATA: CFE_FS_SubType = 21;
pub type CFE_SB_SendSbStatsCmd_t = CFE_SB_SendSbStatsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_SendSbStatsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_SB_ResetCountersCmd_t = CFE_SB_ResetCountersCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_ResetCountersCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_SB_NoopCmd_t = CFE_SB_NoopCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_NoopCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_SB_DisableSubReportingCmd_t = CFE_SB_DisableSubReportingCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_DisableSubReportingCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_SB_EnableSubReportingCmd_t = CFE_SB_EnableSubReportingCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_EnableSubReportingCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_SB_SendPrevSubsCmd_t = CFE_SB_SendPrevSubsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_SendPrevSubsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_SB_SendHkCmd_t = CFE_SB_SendHkCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_SB_SendHkCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_EVS_SendHkCmd_t = CFE_EVS_SendHkCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_SendHkCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_EVS_WriteLogDataFileCmd_t = CFE_EVS_WriteLogDataFileCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_WriteLogDataFileCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_LogFileCmd_Payload_t,
}
pub type CFE_EVS_LogFileCmd_Payload_t = CFE_EVS_LogFileCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_LogFileCmd_Payload {
    pub LogFilename: [libc::c_char; 64],
}
pub const CFE_FS_SubType_EVS_EVENTLOG: CFE_FS_SubType = 16;
pub type CFE_EVS_ClearLogCmd_t = CFE_EVS_ClearLogCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_ClearLogCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_EVS_SetLogModeCmd_t = CFE_EVS_SetLogModeCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_SetLogModeCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_SetLogMode_Payload_t,
}
pub type CFE_EVS_SetLogMode_Payload_t = CFE_EVS_SetLogMode_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_SetLogMode_Payload {
    pub LogMode: CFE_EVS_LogMode_Enum_t,
    pub Spare: uint8,
}
pub type CFE_EVS_LogMode_Enum_t = uint8;
pub const CFE_EVS_LogMode_OVERWRITE: CFE_EVS_LogMode = 0;
pub type CFE_EVS_WriteAppDataFileCmd_t = CFE_EVS_WriteAppDataFileCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_WriteAppDataFileCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppDataCmd_Payload_t,
}
pub type CFE_EVS_AppDataCmd_Payload_t = CFE_EVS_AppDataCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AppDataCmd_Payload {
    pub AppDataFilename: [libc::c_char; 64],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AppDataFile_t {
    pub AppName: [libc::c_char; 20],
    pub ActiveFlag: uint8,
    pub EventTypesActiveFlag: uint8,
    pub EventCount: uint16,
    pub SquelchedCount: uint8,
    pub Spare: [uint8; 3],
    pub Filters: [EVS_BinFilter_t; 8],
}
pub const CFE_FS_SubType_EVS_APPDATA: CFE_FS_SubType = 15;
pub type CFE_EVS_DeleteEventFilterCmd_t = CFE_EVS_DeleteEventFilterCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_DeleteEventFilterCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameEventIDCmd_Payload_t,
}
pub type CFE_EVS_AppNameEventIDCmd_Payload_t = CFE_EVS_AppNameEventIDCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AppNameEventIDCmd_Payload {
    pub AppName: [libc::c_char; 20],
    pub EventID: uint16,
}
pub type CFE_EVS_AddEventFilterCmd_t = CFE_EVS_AddEventFilterCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AddEventFilterCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameEventIDMaskCmd_Payload_t,
}
pub type CFE_EVS_AppNameEventIDMaskCmd_Payload_t = CFE_EVS_AppNameEventIDMaskCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AppNameEventIDMaskCmd_Payload {
    pub AppName: [libc::c_char; 20],
    pub EventID: uint16,
    pub Mask: uint16,
}
pub type CFE_EVS_ResetAllFiltersCmd_t = CFE_EVS_ResetAllFiltersCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_ResetAllFiltersCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameCmd_Payload_t,
}
pub type CFE_EVS_AppNameCmd_Payload_t = CFE_EVS_AppNameCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AppNameCmd_Payload {
    pub AppName: [libc::c_char; 20],
}
pub type CFE_EVS_ResetFilterCmd_t = CFE_EVS_ResetFilterCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_ResetFilterCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameEventIDCmd_Payload_t,
}
pub type CFE_EVS_DisablePortsCmd_t = CFE_EVS_DisablePortsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_DisablePortsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_BitMaskCmd_Payload_t,
}
pub type CFE_EVS_BitMaskCmd_Payload_t = CFE_EVS_BitMaskCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_BitMaskCmd_Payload {
    pub BitMask: uint8,
    pub Spare: uint8,
}
pub type CFE_EVS_EnablePortsCmd_t = CFE_EVS_EnablePortsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_EnablePortsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_BitMaskCmd_Payload_t,
}
pub type CFE_EVS_SetFilterCmd_t = CFE_EVS_SetFilterCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_SetFilterCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameEventIDMaskCmd_Payload_t,
}
pub type CFE_EVS_ResetAppCounterCmd_t = CFE_EVS_ResetAppCounterCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_ResetAppCounterCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameCmd_Payload_t,
}
pub type CFE_EVS_DisableAppEventsCmd_t = CFE_EVS_DisableAppEventsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_DisableAppEventsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameCmd_Payload_t,
}
pub type CFE_EVS_EnableAppEventsCmd_t = CFE_EVS_EnableAppEventsCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_EnableAppEventsCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameCmd_Payload_t,
}
pub type CFE_EVS_DisableAppEventTypeCmd_t = CFE_EVS_DisableAppEventTypeCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_DisableAppEventTypeCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameBitMaskCmd_Payload_t,
}
pub type CFE_EVS_AppNameBitMaskCmd_Payload_t = CFE_EVS_AppNameBitMaskCmd_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_AppNameBitMaskCmd_Payload {
    pub AppName: [libc::c_char; 20],
    pub BitMask: uint8,
    pub Spare: uint8,
}
pub type CFE_EVS_EnableAppEventTypeCmd_t = CFE_EVS_EnableAppEventTypeCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_EnableAppEventTypeCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_AppNameBitMaskCmd_Payload_t,
}
pub type CFE_EVS_SetEventFormatModeCmd_t = CFE_EVS_SetEventFormatModeCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_SetEventFormatModeCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_SetEventFormatMode_Payload_t,
}
pub type CFE_EVS_SetEventFormatMode_Payload_t = CFE_EVS_SetEventFormatCode_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_SetEventFormatCode_Payload {
    pub MsgFormat: CFE_EVS_MsgFormat_Enum_t,
    pub Spare: uint8,
}
pub type CFE_EVS_MsgFormat_Enum_t = uint8;
pub type CFE_EVS_DisableEventTypeCmd_t = CFE_EVS_DisableEventTypeCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_DisableEventTypeCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_BitMaskCmd_Payload_t,
}
pub type CFE_EVS_EnableEventTypeCmd_t = CFE_EVS_EnableEventTypeCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_EnableEventTypeCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: CFE_EVS_BitMaskCmd_Payload_t,
}
pub type CFE_EVS_ResetCountersCmd_t = CFE_EVS_ResetCountersCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_ResetCountersCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub type CFE_EVS_NoopCmd_t = CFE_EVS_NoopCmd;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_EVS_NoopCmd {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
pub const CFE_ES_CDSBLOCKID_BASE: C2RustUnnamed_56 = 1376256;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_25 {
    pub Byte: libc::c_char,
    pub Align: CFE_ES_PoolAlign_t,
}
pub type CFE_ES_CDS_PersistentHeader_t = CFE_ES_CDS_PersistentHeader;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CDS_PersistentHeader {
    pub SignatureBegin: [uint32; 2],
    pub RegistrySize: [uint32; 1],
    pub RegistryContent: [uint32; 9216],
}
pub type CFE_ES_CDS_PersistentTrailer_t = CFE_ES_CDS_PersistentTrailer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_ES_CDS_PersistentTrailer {
    pub SignatureEnd: [uint32; 2],
}
pub const CFE_ConfigIdOffset_CORE_VERSION_DESCRIPTION: CFE_ConfigIdOffset = 10;
pub const CFE_ConfigIdOffset_CORE_VERSION_BASELINE: CFE_ConfigIdOffset = 9;
pub const CFE_ConfigIdOffset_CORE_VERSION_BUILDNUM: CFE_ConfigIdOffset = 8;
pub const CFE_ConfigIdOffset_CORE_VERSION_MISSION_REV: CFE_ConfigIdOffset = 7;
pub const CFE_ConfigIdOffset_CORE_VERSION_REVISION: CFE_ConfigIdOffset = 6;
pub const CFE_ConfigIdOffset_CORE_VERSION_MINOR: CFE_ConfigIdOffset = 5;
pub const CFE_ConfigIdOffset_CORE_VERSION_MAJOR: CFE_ConfigIdOffset = 4;
pub const CFE_ConfigIdOffset_MISSION_SBINTF_DB: CFE_ConfigIdOffset = 3;
pub const CFE_ConfigIdOffset_MISSION_EDS_DB: CFE_ConfigIdOffset = 2;
pub const CFE_ConfigIdOffset_MISSION_NAME: CFE_ConfigIdOffset = 0;
pub const CFE_ES_SystemState_CORE_STARTUP: CFE_ES_SystemState = 2;
pub const CFE_ES_COUNTID_BASE: C2RustUnnamed_56 = 1245184;
pub const OS_FILESYS_TYPE_FS_BASED: C2RustUnnamed_34 = 1;
pub const OS_FILESYS_TYPE_VOLATILE_DISK: C2RustUnnamed_34 = 3;
pub const VOLATILE_DISK_LOC_TMP: C2RustUnnamed_26 = 3;
pub const VOLATILE_DISK_LOC_VARTMP: C2RustUnnamed_26 = 2;
pub const VOLATILE_DISK_LOC_ENV: C2RustUnnamed_26 = 1;
pub const VOLATILE_DISK_LOC_DEV_SHM: C2RustUnnamed_26 = 0;
pub const VOLATILE_DISK_LOC_MAX: C2RustUnnamed_26 = 4;
pub const OS_FILESYS_TYPE_NORMAL_DISK: C2RustUnnamed_34 = 2;
pub const OS_FILESYS_TYPE_UNKNOWN: C2RustUnnamed_34 = 0;
pub type C2RustUnnamed_26 = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_statvfs_t {
    pub block_size: size_t,
    pub total_blocks: osal_blockcount_t,
    pub blocks_free: osal_blockcount_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct statvfs {
    pub f_bsize: libc::c_ulong,
    pub f_frsize: libc::c_ulong,
    pub f_blocks: __fsblkcnt_t,
    pub f_bfree: __fsblkcnt_t,
    pub f_bavail: __fsblkcnt_t,
    pub f_files: __fsfilcnt_t,
    pub f_ffree: __fsfilcnt_t,
    pub f_favail: __fsfilcnt_t,
    pub f_fsid: libc::c_ulong,
    pub f_flag: libc::c_ulong,
    pub f_namemax: libc::c_ulong,
    pub __f_spare: [libc::c_int; 6],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_27 {
    pub Word: uint16,
    pub Endian: uint8,
}
pub const CFE_ES_SystemState_EARLY_INIT: CFE_ES_SystemState = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_CommandData_t {
    pub ResetType: [libc::c_char; 10],
    pub GotResetType: uint32,
    pub SubType: uint32,
    pub GotSubType: uint32,
    pub CpuName: [libc::c_char; 32],
    pub GotCpuName: uint32,
    pub CpuId: uint32,
    pub GotCpuId: uint32,
    pub SpacecraftId: uint32,
    pub GotSpacecraftId: uint32,
}
pub type CFE_PSP_ModuleInitFunc_t = Option<unsafe extern "C" fn(uint32) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_ModuleApi_t {
    pub ModuleType: CFE_PSP_ModuleType_t,
    pub OperationFlags: uint32,
    pub Init: CFE_PSP_ModuleInitFunc_t,
    pub ExtendedApi: *const libc::c_void,
}
pub type CFE_PSP_ModuleType_t = libc::c_uint;
pub const CFE_PSP_MODULE_TYPE_DEVICEDRIVER: CFE_PSP_ModuleType_t = 2;
pub const CFE_PSP_MODULE_TYPE_SIMPLE: CFE_PSP_ModuleType_t = 1;
pub const CFE_PSP_MODULE_TYPE_INVALID: CFE_PSP_ModuleType_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_IODriver_API_t {
    pub DeviceCommand: CFE_PSP_IODriver_ApiFunc_t,
    pub DeviceMutex: CFE_PSP_IODriver_ApiFunc_t,
}
pub type CFE_PSP_IODriver_ApiFunc_t =
    Option<unsafe extern "C" fn(uint32, uint16, uint16, CFE_PSP_IODriver_Arg_t) -> int32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub union CFE_PSP_IODriver_Arg_t {
    pub Vptr: *mut libc::c_void,
    pub ConstVptr: *const libc::c_void,
    pub ConstStr: *const libc::c_char,
    pub U32: uint32,
}
pub type CFE_PSP_IODriver_AdcCode_t = int32;
pub type linux_sysmon_cpuload_core_t = linux_sysmon_cpuload_core;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct linux_sysmon_cpuload_core {
    pub avg_load: CFE_PSP_IODriver_AdcCode_t,
    pub last_run_time: libc::c_ulong,
}
pub type linux_sysmon_cpuload_state_t = linux_sysmon_cpuload_state;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct linux_sysmon_cpuload_state {
    pub is_running: bool,
    pub should_run: bool,
    pub num_cpus: uint8_t,
    pub task_id: pthread_t,
    pub dev_fd: libc::c_int,
    pub num_samples: uint32_t,
    pub last_sample_time: uint64_t,
    pub per_core: [linux_sysmon_cpuload_core_t; 128],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_IODriver_AnalogRdWr_t {
    pub NumChannels: uint16,
    pub Samples: *mut CFE_PSP_IODriver_AdcCode_t,
}
pub const CFE_PSP_IODriver_ANALOG_IO_READ_CHANNELS: C2RustUnnamed_58 = 65537;
pub const CFE_PSP_IODriver_ANALOG_IO_NOOP: C2RustUnnamed_58 = 65536;
pub const CFE_PSP_IODriver_NOOP: C2RustUnnamed_57 = 0;
pub type linux_sysmon_state_t = linux_sysmon_state;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct linux_sysmon_state {
    pub local_module_id: uint32_t,
    pub cpu_load: linux_sysmon_cpuload_state_t,
}
pub type CFE_PSP_IODriver_Direction_t = libc::c_uint;
pub const CFE_PSP_IODriver_Direction_INPUT_OUTPUT: CFE_PSP_IODriver_Direction_t = 3;
pub const CFE_PSP_IODriver_Direction_OUTPUT_ONLY: CFE_PSP_IODriver_Direction_t = 2;
pub const CFE_PSP_IODriver_Direction_INPUT_ONLY: CFE_PSP_IODriver_Direction_t = 1;
pub const CFE_PSP_IODriver_Direction_DISABLED: CFE_PSP_IODriver_Direction_t = 0;
pub const CFE_PSP_IODriver_QUERY_DIRECTION: C2RustUnnamed_57 = 8;
pub const CFE_PSP_IODriver_LOOKUP_SUBCHANNEL: C2RustUnnamed_57 = 6;
pub const CFE_PSP_IODriver_LOOKUP_SUBSYSTEM: C2RustUnnamed_57 = 5;
pub const CFE_PSP_IODriver_GET_CONFIGURATION: C2RustUnnamed_57 = 4;
pub const CFE_PSP_IODriver_SET_CONFIGURATION: C2RustUnnamed_57 = 3;
pub const CFE_PSP_IODriver_GET_RUNNING: C2RustUnnamed_57 = 2;
pub type nfds_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pollfd {
    pub fd: libc::c_int,
    pub events: libc::c_short,
    pub revents: libc::c_short,
}
pub const CFE_PSP_IODriver_SET_RUNNING: C2RustUnnamed_57 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_28 {
    pub sys_timebase_id: osal_id_t,
}
pub const SIGEV_SIGNAL: C2RustUnnamed_52 = 0;
pub const _SC_SIGQUEUE_MAX: C2RustUnnamed_50 = 34;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_LinuxReservedAreaFixedLayout_t {
    pub BootRecord: CFE_PSP_ReservedMemoryBootRecord_t,
    pub ExceptionStorage: CFE_PSP_ExceptionStorage_t,
}
pub const _SC_PAGESIZE: C2RustUnnamed_50 = 30;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_condvar_internal_record_t {
    pub obj_name: [libc::c_char; 20],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_dir_internal_record_t {
    pub dir_name: [libc::c_char; 64],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_count_sem_internal_record_t {
    pub obj_name: [libc::c_char; 20],
}
pub const _SC_CLK_TCK: C2RustUnnamed_50 = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_BSP_GlobalData_t {
    pub ArgC: uint32,
    pub ArgV: *mut *mut libc::c_char,
    pub AppStatus: int32,
    pub MaxQueueDepth: osal_blockcount_t,
    pub ResoureConfig: [uint32; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct option {
    pub name: *const libc::c_char,
    pub has_arg: libc::c_int,
    pub flag: *mut libc::c_int,
    pub val: libc::c_int,
}
pub type os_err_name_t = [libc::c_char; 35];
pub type os_status_string_t = [libc::c_char; 12];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_ErrorTable_Entry_t {
    pub Number: int32,
    pub Name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_bin_sem_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
    pub value: int32,
}
pub type C2RustUnnamed_29 = libc::c_uint;
pub const OS_MAX_TOTAL_RECORDS: C2RustUnnamed_29 = 296;
pub type C2RustUnnamed_30 = libc::c_uint;
pub const LOCAL_NUM_OBJECTS: C2RustUnnamed_30 = 20;
pub type C2RustUnnamed_31 = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_condvar_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_count_sem_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
    pub value: int32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct os_dirent_t {
    pub FileName: [libc::c_char; 20],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: libc::c_ushort,
    pub d_type: libc::c_uchar,
    pub d_name: [libc::c_char; 256],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_file_prop_t {
    pub Path: [libc::c_char; 64],
    pub User: osal_id_t,
    pub IsValid: uint8,
}
pub type C2RustUnnamed_32 = libc::c_uint;
pub type C2RustUnnamed_33 = libc::c_uint;
pub const OS_SocketDomain_INVALID: OS_SocketDomain_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct os_fsinfo_t {
    pub MaxFds: uint32,
    pub FreeFds: uint32,
    pub MaxVolumes: uint32,
    pub FreeVolumes: uint32,
}
pub type C2RustUnnamed_34 = libc::c_uint;
pub const OS_FILESYS_TYPE_MAX: C2RustUnnamed_34 = 5;
pub const OS_FILESYS_TYPE_MTD: C2RustUnnamed_34 = 4;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_mut_sem_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_queue_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
}
pub type OS_SocketDomain_t = libc::c_uint;
pub const OS_SocketDomain_MAX: OS_SocketDomain_t = 3;
pub const OS_SocketDomain_INET6: OS_SocketDomain_t = 2;
pub const OS_SocketDomain_INET: OS_SocketDomain_t = 1;
pub type OS_SocketType_t = libc::c_uint;
pub const OS_SocketType_MAX: OS_SocketType_t = 3;
pub const OS_SocketType_STREAM: OS_SocketType_t = 2;
pub const OS_SocketType_DATAGRAM: OS_SocketType_t = 1;
pub const OS_SocketType_INVALID: OS_SocketType_t = 0;
pub type OS_SocketShutdownMode_t = libc::c_uint;
pub const OS_SocketShutdownMode_SHUT_READWRITE: OS_SocketShutdownMode_t = 3;
pub const OS_SocketShutdownMode_SHUT_WRITE: OS_SocketShutdownMode_t = 2;
pub const OS_SocketShutdownMode_SHUT_READ: OS_SocketShutdownMode_t = 1;
pub const OS_SocketShutdownMode_NONE: OS_SocketShutdownMode_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union OS_SockAddrData_t {
    pub Buffer: [uint8; 28],
    pub AlignU32: uint32,
    pub AlignPtr: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_SockAddr_t {
    pub ActualLength: size_t,
    pub AddrData: OS_SockAddrData_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_socket_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
}
pub type sa_family_t = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union OS_SockAddr_Accessor_t {
    pub data: [libc::c_char; 28],
    pub sa: sockaddr,
    pub sa_in: sockaddr_in,
    pub sa_in6: sockaddr_in6,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in6_addr {
    pub __in6_u: C2RustUnnamed_35,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_35 {
    pub __u6_addr8: [uint8_t; 16],
    pub __u6_addr16: [uint16_t; 8],
    pub __u6_addr32: [uint32_t; 4],
}
pub type in_port_t = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_addr_t = uint32_t;
pub type socklen_t = __socklen_t;
pub const IPPROTO_TCP: C2RustUnnamed_55 = 6;
pub const SOCK_STREAM: __socket_type = 1;
pub const IPPROTO_UDP: C2RustUnnamed_55 = 17;
pub const SOCK_DGRAM: __socket_type = 2;
pub const osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE: C2RustUnnamed_45 = 6;
pub const OS_STREAM_STATE_LISTENING: C2RustUnnamed_44 = 16;
pub const OS_STREAM_STATE_CONNECTED: C2RustUnnamed_44 = 2;
pub const OS_STREAM_STATE_BOUND: C2RustUnnamed_44 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
}
pub const SHUT_RDWR: C2RustUnnamed_54 = 2;
pub const SHUT_WR: C2RustUnnamed_54 = 1;
pub const SHUT_RD: C2RustUnnamed_54 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
}
pub const MSG_DONTWAIT: C2RustUnnamed_53 = 64;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_task_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
    pub stack_size: size_t,
    pub priority: osal_priority_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_timebase_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
    pub nominal_interval_time: uint32,
    pub freerun_time: uint32,
    pub accuracy: uint32,
}
pub const osal_src_os_shared_src_osapi_timebase_c__LOCAL_OBJID_TYPE: C2RustUnnamed_47 = 8;
pub type OS_TimerCallback_t = Option<unsafe extern "C" fn(osal_id_t) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_timer_prop_t {
    pub name: [libc::c_char; 20],
    pub creator: osal_id_t,
    pub start_time: uint32,
    pub interval_time: uint32,
    pub accuracy: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union OS_Timer_ArgWrapper_t {
    pub timer_callback_func: OS_TimerCallback_t,
    pub opaque_arg: *mut libc::c_void,
}
pub type C2RustUnnamed_36 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_countsem_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_36 = 20;
pub type C2RustUnnamed_37 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_dir_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_37 = 4;
pub type C2RustUnnamed_38 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_file_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_38 = 50;
pub type C2RustUnnamed_39 = libc::c_uint;
pub const _ISalnum: C2RustUnnamed_39 = 8;
pub const _ISpunct: C2RustUnnamed_39 = 4;
pub const _IScntrl: C2RustUnnamed_39 = 2;
pub const _ISblank: C2RustUnnamed_39 = 1;
pub const _ISgraph: C2RustUnnamed_39 = 32768;
pub const _ISprint: C2RustUnnamed_39 = 16384;
pub const _ISxdigit: C2RustUnnamed_39 = 4096;
pub const _ISdigit: C2RustUnnamed_39 = 2048;
pub const _ISalpha: C2RustUnnamed_39 = 1024;
pub const _ISlower: C2RustUnnamed_39 = 512;
pub const _ISupper: C2RustUnnamed_39 = 256;
pub type C2RustUnnamed_40 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_filesys_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_40 = 14;
pub type C2RustUnnamed_41 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_module_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_41 = 20;
pub type C2RustUnnamed_42 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_mutex_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_42 = 20;
pub type C2RustUnnamed_43 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_queue_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_43 = 64;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OS_FdSet {
    pub object_ids: [uint8; 7],
}
pub type C2RustUnnamed_44 = libc::c_uint;
pub type C2RustUnnamed_45 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_sockets_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_45 = 50;
pub type C2RustUnnamed_46 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_task_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_46 = 64;
pub type C2RustUnnamed_47 = libc::c_uint;
pub const osal_src_os_shared_src_osapi_timebase_c__LOCAL_NUM_OBJECTS: C2RustUnnamed_47 = 5;
pub type UtAssert_CaseType_t = libc::c_uint;
pub const UTASSERT_CASETYPE_MAX: UtAssert_CaseType_t = 14;
pub const UTASSERT_CASETYPE_DEBUG: UtAssert_CaseType_t = 13;
pub const UTASSERT_CASETYPE_FLOW: UtAssert_CaseType_t = 12;
pub const UTASSERT_CASETYPE_PASS: UtAssert_CaseType_t = 11;
pub const UTASSERT_CASETYPE_INFO: UtAssert_CaseType_t = 10;
pub const UTASSERT_CASETYPE_END: UtAssert_CaseType_t = 9;
pub const UTASSERT_CASETYPE_BEGIN: UtAssert_CaseType_t = 8;
pub const UTASSERT_CASETYPE_NA: UtAssert_CaseType_t = 7;
pub const UTASSERT_CASETYPE_WARN: UtAssert_CaseType_t = 6;
pub const UTASSERT_CASETYPE_MIR: UtAssert_CaseType_t = 5;
pub const UTASSERT_CASETYPE_TTF: UtAssert_CaseType_t = 4;
pub const UTASSERT_CASETYPE_TSF: UtAssert_CaseType_t = 3;
pub const UTASSERT_CASETYPE_FAILURE: UtAssert_CaseType_t = 2;
pub const UTASSERT_CASETYPE_ABORT: UtAssert_CaseType_t = 1;
pub const UTASSERT_CASETYPE_NONE: UtAssert_CaseType_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_Assert_Global_t {
    pub LibState: CFE_Assert_State_Enum_t,
    pub CurrVerbosity: uint32,
    pub StatusCallback: CFE_Assert_StatusCallback_t,
    pub LogFileFinal: [libc::c_char; 64],
    pub LogFileTemp: [libc::c_char; 64],
    pub LogFileDesc: osal_id_t,
    pub AccessMutex: osal_id_t,
    pub OwnerAppId: CFE_ES_AppId_t,
    pub CurrentTestName: [libc::c_char; 20],
    pub StoredStatus: CFE_Status_t,
    pub StoredText: [libc::c_char; 512],
    pub StoredFile: [libc::c_char; 64],
    pub StoredLine: uint32,
}
pub type CFE_Assert_StatusCallback_t =
    Option<unsafe extern "C" fn(uint8, *const libc::c_char, *const libc::c_char) -> ()>;
pub type CFE_Assert_State_Enum_t = libc::c_uint;
pub const CFE_Assert_State_ACTIVE: CFE_Assert_State_Enum_t = 2;
pub const CFE_Assert_State_STARTUP: CFE_Assert_State_Enum_t = 1;
pub const CFE_Assert_State_INIT: CFE_Assert_State_Enum_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UtAssert_TestCounter_t {
    pub TestSegmentCount: uint32,
    pub TotalTestCases: uint32,
    pub CaseCount: [uint32; 14],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_Snprintf_Buffer_t {
    pub Text: [libc::c_char; 256],
}
pub type UT_IntCheck_t = ptrdiff_t;
pub type UtAssert_Compare_t = libc::c_uint;
pub const UtAssert_Compare_MAX: UtAssert_Compare_t = 9;
pub const UtAssert_Compare_BITMASK_UNSET: UtAssert_Compare_t = 8;
pub const UtAssert_Compare_BITMASK_SET: UtAssert_Compare_t = 7;
pub const UtAssert_Compare_GTEQ: UtAssert_Compare_t = 6;
pub const UtAssert_Compare_LTEQ: UtAssert_Compare_t = 5;
pub const UtAssert_Compare_GT: UtAssert_Compare_t = 4;
pub const UtAssert_Compare_LT: UtAssert_Compare_t = 3;
pub const UtAssert_Compare_NEQ: UtAssert_Compare_t = 2;
pub const UtAssert_Compare_EQ: UtAssert_Compare_t = 1;
pub const UtAssert_Compare_NONE: UtAssert_Compare_t = 0;
pub type UtAssert_Radix_t = libc::c_uint;
pub const UtAssert_Radix_HEX: UtAssert_Radix_t = 16;
pub const UtAssert_Radix_DECIMAL: UtAssert_Radix_t = 10;
pub const UtAssert_Radix_OCTAL: UtAssert_Radix_t = 8;
pub const UtAssert_Radix_BOOLEAN: UtAssert_Radix_t = 1;
pub const UtAssert_Radix_DEFAULT: UtAssert_Radix_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union UtAssert_IntBuf_t {
    pub s: libc::c_long,
    pub u: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UtListNodeTag {
    pub Next: *mut UtListNodeTag,
    pub Prev: *mut UtListNodeTag,
    pub Data: *mut libc::c_void,
    pub DataSize: uint32,
    pub Tag: uint32,
}
pub type UtListNode_t = UtListNodeTag;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UtListHead_t {
    pub Tags: *mut UtListNode_t,
    pub NumberOfTags: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ListAllocator {
    pub Head: UtListHead_t,
    pub Tags: [UtListNode_t; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union NodeAllocator {
    pub Node: UtListNode_t,
    pub AlignDbl: libc::c_double,
    pub AlignPtr: *mut libc::c_void,
    pub AlignLong: libc::c_long,
}
pub type UT_EntryKey_t = cpuaddr;
pub type UT_IntReturn_t = ptrdiff_t;
pub type UT_StubContext_Arg_Type_t = libc::c_uint;
pub const UT_STUBCONTEXT_ARG_TYPE_INDIRECT: UT_StubContext_Arg_Type_t = 2;
pub const UT_STUBCONTEXT_ARG_TYPE_DIRECT: UT_StubContext_Arg_Type_t = 1;
pub const UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED: UT_StubContext_Arg_Type_t = 0;
pub type UT_ValueGenre = libc::c_uint;
pub const UT_ValueGenre_POINTER: UT_ValueGenre = 3;
pub const UT_ValueGenre_FLOAT: UT_ValueGenre = 2;
pub const UT_ValueGenre_INTEGER: UT_ValueGenre = 1;
pub const UT_ValueGenre_OPAQUE: UT_ValueGenre = 0;
pub type UT_ValueGenre_t = UT_ValueGenre;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_StubArgMetaData_t {
    pub Type: UT_StubContext_Arg_Type_t,
    pub Name: *const libc::c_char,
    pub Size: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_StubContext_t {
    pub Int32StatusCode: int32,
    pub Int32StatusIsSet: bool,
    pub ArgCount: uint32,
    pub ArgPtr: [*const libc::c_void; 8],
    pub Meta: [UT_StubArgMetaData_t; 8],
}
pub type UT_HookFunc_t = Option<
    unsafe extern "C" fn(*mut libc::c_void, int32, uint32, *const UT_StubContext_t) -> int32,
>;
pub type UT_VaHookFunc_t = Option<
    unsafe extern "C" fn(
        *mut libc::c_void,
        int32,
        uint32,
        *const UT_StubContext_t,
        *mut __va_list_tag,
    ) -> int32,
>;
pub type UT_HandlerFunc_t =
    Option<unsafe extern "C" fn(*mut libc::c_void, UT_EntryKey_t, *const UT_StubContext_t) -> ()>;
pub type UT_VaHandlerFunc_t = Option<
    unsafe extern "C" fn(
        *mut libc::c_void,
        UT_EntryKey_t,
        *const UT_StubContext_t,
        *mut __va_list_tag,
    ) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_StubTableEntry_t {
    pub EntryType: UT_EntryType_t,
    pub ModeFlags: uint32,
    pub FuncKey: UT_EntryKey_t,
    pub Data: UT_EntryData_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union UT_EntryData_t {
    pub Rc: UT_RetcodeEntry_t,
    pub Rvc: UT_RetvalConfigEntry_t,
    pub Buff: UT_BufferEntry_t,
    pub Cb: UT_CallbackEntry_t,
    pub Context: UT_StubContext_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_CallbackEntry_t {
    pub Ptr: UT_HookFuncPtr_t,
    pub CallbackArg: *mut libc::c_void,
    pub IsVarg: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union UT_HookFuncPtr_t {
    pub Addr: *mut libc::c_void,
    pub SimpleHook: UT_HookFunc_t,
    pub VaHook: UT_VaHookFunc_t,
    pub SimpleHandler: UT_HandlerFunc_t,
    pub VaHandler: UT_VaHandlerFunc_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_BufferEntry_t {
    pub Position: size_t,
    pub TotalSize: size_t,
    pub BasePtr: *mut uint8,
    pub ContentTypeStr: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_RetvalConfigEntry_t {
    pub Genre: UT_ValueGenre_t,
    pub Counter: int32,
    pub Buf: UT_RetvalBuf_t,
    pub ActualSz: size_t,
    pub TypeName: *const libc::c_char,
}
pub type UT_RetvalBuf_t = UT_RetvalBuf;
#[derive(Copy, Clone)]
#[repr(C)]
pub union UT_RetvalBuf {
    pub Raw: [uint8; 8],
    pub IndirectPtr: *const libc::c_void,
    pub Ptr: *mut libc::c_void,
    pub Integer: UT_IntReturn_t,
    pub FloatingPt: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UT_RetcodeEntry_t {
    pub Count: uint32,
    pub Value: int32,
}
pub type UT_EntryType_t = libc::c_uint;
pub const UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT: UT_EntryType_t = 9;
pub const UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED: UT_EntryType_t = 8;
pub const UT_ENTRYTYPE_RETURN_BUFFER: UT_EntryType_t = 7;
pub const UT_ENTRYTYPE_FINAL_HANDLER: UT_EntryType_t = 6;
pub const UT_ENTRYTYPE_CALL_ONCE: UT_EntryType_t = 5;
pub const UT_ENTRYTYPE_CALLBACK_CONTEXT: UT_EntryType_t = 4;
pub const UT_ENTRYTYPE_CALLBACK_HOOK: UT_EntryType_t = 3;
pub const UT_ENTRYTYPE_DATA_BUFFER: UT_EntryType_t = 2;
pub const UT_ENTRYTYPE_COUNTER: UT_EntryType_t = 1;
pub const UT_ENTRYTYPE_UNUSED: UT_EntryType_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_48 {
    pub AsInt: libc::c_ulong,
    pub AsPtr: *mut libc::c_void,
    pub AsFloat: libc::c_double,
}
pub const UTASSERT_GROUP_TEST: C2RustUnnamed_49 = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UtTestDataBaseEntry_t {
    pub Test: Option<unsafe extern "C" fn() -> ()>,
    pub Setup: Option<unsafe extern "C" fn() -> ()>,
    pub Teardown: Option<unsafe extern "C" fn() -> ()>,
    pub TestName: [libc::c_char; 40],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct UtAssert_Global_t {
    pub DataBasePtr: *mut UtListHead_t,
    pub ExecutedCount: uint32,
}
pub const UTASSERT_GROUP_SETUP: C2RustUnnamed_49 = 1;
pub const UTASSERT_GROUP_TEARDOWN: C2RustUnnamed_49 = 3;
pub const UTASSERT_GROUP_MAX: C2RustUnnamed_49 = 4;
pub const UTASSERT_GROUP_DEFAULT: C2RustUnnamed_49 = 0;
pub type C2RustUnnamed_49 = libc::c_uint;
pub type C2RustUnnamed_50 = libc::c_uint;
pub const _SC_SIGSTKSZ: C2RustUnnamed_50 = 250;
pub const _SC_MINSIGSTKSZ: C2RustUnnamed_50 = 249;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: C2RustUnnamed_50 = 248;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: C2RustUnnamed_50 = 247;
pub const _SC_XOPEN_STREAMS: C2RustUnnamed_50 = 246;
pub const _SC_TRACE_USER_EVENT_MAX: C2RustUnnamed_50 = 245;
pub const _SC_TRACE_SYS_MAX: C2RustUnnamed_50 = 244;
pub const _SC_TRACE_NAME_MAX: C2RustUnnamed_50 = 243;
pub const _SC_TRACE_EVENT_NAME_MAX: C2RustUnnamed_50 = 242;
pub const _SC_SS_REPL_MAX: C2RustUnnamed_50 = 241;
pub const _SC_V7_LPBIG_OFFBIG: C2RustUnnamed_50 = 240;
pub const _SC_V7_LP64_OFF64: C2RustUnnamed_50 = 239;
pub const _SC_V7_ILP32_OFFBIG: C2RustUnnamed_50 = 238;
pub const _SC_V7_ILP32_OFF32: C2RustUnnamed_50 = 237;
pub const _SC_RAW_SOCKETS: C2RustUnnamed_50 = 236;
pub const _SC_IPV6: C2RustUnnamed_50 = 235;
pub const _SC_LEVEL4_CACHE_LINESIZE: C2RustUnnamed_50 = 199;
pub const _SC_LEVEL4_CACHE_ASSOC: C2RustUnnamed_50 = 198;
pub const _SC_LEVEL4_CACHE_SIZE: C2RustUnnamed_50 = 197;
pub const _SC_LEVEL3_CACHE_LINESIZE: C2RustUnnamed_50 = 196;
pub const _SC_LEVEL3_CACHE_ASSOC: C2RustUnnamed_50 = 195;
pub const _SC_LEVEL3_CACHE_SIZE: C2RustUnnamed_50 = 194;
pub const _SC_LEVEL2_CACHE_LINESIZE: C2RustUnnamed_50 = 193;
pub const _SC_LEVEL2_CACHE_ASSOC: C2RustUnnamed_50 = 192;
pub const _SC_LEVEL2_CACHE_SIZE: C2RustUnnamed_50 = 191;
pub const _SC_LEVEL1_DCACHE_LINESIZE: C2RustUnnamed_50 = 190;
pub const _SC_LEVEL1_DCACHE_ASSOC: C2RustUnnamed_50 = 189;
pub const _SC_LEVEL1_DCACHE_SIZE: C2RustUnnamed_50 = 188;
pub const _SC_LEVEL1_ICACHE_LINESIZE: C2RustUnnamed_50 = 187;
pub const _SC_LEVEL1_ICACHE_ASSOC: C2RustUnnamed_50 = 186;
pub const _SC_LEVEL1_ICACHE_SIZE: C2RustUnnamed_50 = 185;
pub const _SC_TRACE_LOG: C2RustUnnamed_50 = 184;
pub const _SC_TRACE_INHERIT: C2RustUnnamed_50 = 183;
pub const _SC_TRACE_EVENT_FILTER: C2RustUnnamed_50 = 182;
pub const _SC_TRACE: C2RustUnnamed_50 = 181;
pub const _SC_HOST_NAME_MAX: C2RustUnnamed_50 = 180;
pub const _SC_V6_LPBIG_OFFBIG: C2RustUnnamed_50 = 179;
pub const _SC_V6_LP64_OFF64: C2RustUnnamed_50 = 178;
pub const _SC_V6_ILP32_OFFBIG: C2RustUnnamed_50 = 177;
pub const _SC_V6_ILP32_OFF32: C2RustUnnamed_50 = 176;
pub const _SC_2_PBS_CHECKPOINT: C2RustUnnamed_50 = 175;
pub const _SC_STREAMS: C2RustUnnamed_50 = 174;
pub const _SC_SYMLOOP_MAX: C2RustUnnamed_50 = 173;
pub const _SC_2_PBS_TRACK: C2RustUnnamed_50 = 172;
pub const _SC_2_PBS_MESSAGE: C2RustUnnamed_50 = 171;
pub const _SC_2_PBS_LOCATE: C2RustUnnamed_50 = 170;
pub const _SC_2_PBS_ACCOUNTING: C2RustUnnamed_50 = 169;
pub const _SC_2_PBS: C2RustUnnamed_50 = 168;
pub const _SC_USER_GROUPS_R: C2RustUnnamed_50 = 167;
pub const _SC_USER_GROUPS: C2RustUnnamed_50 = 166;
pub const _SC_TYPED_MEMORY_OBJECTS: C2RustUnnamed_50 = 165;
pub const _SC_TIMEOUTS: C2RustUnnamed_50 = 164;
pub const _SC_SYSTEM_DATABASE_R: C2RustUnnamed_50 = 163;
pub const _SC_SYSTEM_DATABASE: C2RustUnnamed_50 = 162;
pub const _SC_THREAD_SPORADIC_SERVER: C2RustUnnamed_50 = 161;
pub const _SC_SPORADIC_SERVER: C2RustUnnamed_50 = 160;
pub const _SC_SPAWN: C2RustUnnamed_50 = 159;
pub const _SC_SIGNALS: C2RustUnnamed_50 = 158;
pub const _SC_SHELL: C2RustUnnamed_50 = 157;
pub const _SC_REGEX_VERSION: C2RustUnnamed_50 = 156;
pub const _SC_REGEXP: C2RustUnnamed_50 = 155;
pub const _SC_SPIN_LOCKS: C2RustUnnamed_50 = 154;
pub const _SC_READER_WRITER_LOCKS: C2RustUnnamed_50 = 153;
pub const _SC_NETWORKING: C2RustUnnamed_50 = 152;
pub const _SC_SINGLE_PROCESS: C2RustUnnamed_50 = 151;
pub const _SC_MULTI_PROCESS: C2RustUnnamed_50 = 150;
pub const _SC_MONOTONIC_CLOCK: C2RustUnnamed_50 = 149;
pub const _SC_FILE_SYSTEM: C2RustUnnamed_50 = 148;
pub const _SC_FILE_LOCKING: C2RustUnnamed_50 = 147;
pub const _SC_FILE_ATTRIBUTES: C2RustUnnamed_50 = 146;
pub const _SC_PIPE: C2RustUnnamed_50 = 145;
pub const _SC_FIFO: C2RustUnnamed_50 = 144;
pub const _SC_FD_MGMT: C2RustUnnamed_50 = 143;
pub const _SC_DEVICE_SPECIFIC_R: C2RustUnnamed_50 = 142;
pub const _SC_DEVICE_SPECIFIC: C2RustUnnamed_50 = 141;
pub const _SC_DEVICE_IO: C2RustUnnamed_50 = 140;
pub const _SC_THREAD_CPUTIME: C2RustUnnamed_50 = 139;
pub const _SC_CPUTIME: C2RustUnnamed_50 = 138;
pub const _SC_CLOCK_SELECTION: C2RustUnnamed_50 = 137;
pub const _SC_C_LANG_SUPPORT_R: C2RustUnnamed_50 = 136;
pub const _SC_C_LANG_SUPPORT: C2RustUnnamed_50 = 135;
pub const _SC_BASE: C2RustUnnamed_50 = 134;
pub const _SC_BARRIERS: C2RustUnnamed_50 = 133;
pub const _SC_ADVISORY_INFO: C2RustUnnamed_50 = 132;
pub const _SC_XOPEN_REALTIME_THREADS: C2RustUnnamed_50 = 131;
pub const _SC_XOPEN_REALTIME: C2RustUnnamed_50 = 130;
pub const _SC_XOPEN_LEGACY: C2RustUnnamed_50 = 129;
pub const _SC_XBS5_LPBIG_OFFBIG: C2RustUnnamed_50 = 128;
pub const _SC_XBS5_LP64_OFF64: C2RustUnnamed_50 = 127;
pub const _SC_XBS5_ILP32_OFFBIG: C2RustUnnamed_50 = 126;
pub const _SC_XBS5_ILP32_OFF32: C2RustUnnamed_50 = 125;
pub const _SC_NL_TEXTMAX: C2RustUnnamed_50 = 124;
pub const _SC_NL_SETMAX: C2RustUnnamed_50 = 123;
pub const _SC_NL_NMAX: C2RustUnnamed_50 = 122;
pub const _SC_NL_MSGMAX: C2RustUnnamed_50 = 121;
pub const _SC_NL_LANGMAX: C2RustUnnamed_50 = 120;
pub const _SC_NL_ARGMAX: C2RustUnnamed_50 = 119;
pub const _SC_USHRT_MAX: C2RustUnnamed_50 = 118;
pub const _SC_ULONG_MAX: C2RustUnnamed_50 = 117;
pub const _SC_UINT_MAX: C2RustUnnamed_50 = 116;
pub const _SC_UCHAR_MAX: C2RustUnnamed_50 = 115;
pub const _SC_SHRT_MIN: C2RustUnnamed_50 = 114;
pub const _SC_SHRT_MAX: C2RustUnnamed_50 = 113;
pub const _SC_SCHAR_MIN: C2RustUnnamed_50 = 112;
pub const _SC_SCHAR_MAX: C2RustUnnamed_50 = 111;
pub const _SC_SSIZE_MAX: C2RustUnnamed_50 = 110;
pub const _SC_NZERO: C2RustUnnamed_50 = 109;
pub const _SC_MB_LEN_MAX: C2RustUnnamed_50 = 108;
pub const _SC_WORD_BIT: C2RustUnnamed_50 = 107;
pub const _SC_LONG_BIT: C2RustUnnamed_50 = 106;
pub const _SC_INT_MIN: C2RustUnnamed_50 = 105;
pub const _SC_INT_MAX: C2RustUnnamed_50 = 104;
pub const _SC_CHAR_MIN: C2RustUnnamed_50 = 103;
pub const _SC_CHAR_MAX: C2RustUnnamed_50 = 102;
pub const _SC_CHAR_BIT: C2RustUnnamed_50 = 101;
pub const _SC_XOPEN_XPG4: C2RustUnnamed_50 = 100;
pub const _SC_XOPEN_XPG3: C2RustUnnamed_50 = 99;
pub const _SC_XOPEN_XPG2: C2RustUnnamed_50 = 98;
pub const _SC_2_UPE: C2RustUnnamed_50 = 97;
pub const _SC_2_C_VERSION: C2RustUnnamed_50 = 96;
pub const _SC_2_CHAR_TERM: C2RustUnnamed_50 = 95;
pub const _SC_XOPEN_SHM: C2RustUnnamed_50 = 94;
pub const _SC_XOPEN_ENH_I18N: C2RustUnnamed_50 = 93;
pub const _SC_XOPEN_CRYPT: C2RustUnnamed_50 = 92;
pub const _SC_XOPEN_UNIX: C2RustUnnamed_50 = 91;
pub const _SC_XOPEN_XCU_VERSION: C2RustUnnamed_50 = 90;
pub const _SC_XOPEN_VERSION: C2RustUnnamed_50 = 89;
pub const _SC_PASS_MAX: C2RustUnnamed_50 = 88;
pub const _SC_ATEXIT_MAX: C2RustUnnamed_50 = 87;
pub const _SC_AVPHYS_PAGES: C2RustUnnamed_50 = 86;
pub const _SC_PHYS_PAGES: C2RustUnnamed_50 = 85;
pub const _SC_NPROCESSORS_ONLN: C2RustUnnamed_50 = 84;
pub const _SC_NPROCESSORS_CONF: C2RustUnnamed_50 = 83;
pub const _SC_THREAD_PROCESS_SHARED: C2RustUnnamed_50 = 82;
pub const _SC_THREAD_PRIO_PROTECT: C2RustUnnamed_50 = 81;
pub const _SC_THREAD_PRIO_INHERIT: C2RustUnnamed_50 = 80;
pub const _SC_THREAD_PRIORITY_SCHEDULING: C2RustUnnamed_50 = 79;
pub const _SC_THREAD_ATTR_STACKSIZE: C2RustUnnamed_50 = 78;
pub const _SC_THREAD_ATTR_STACKADDR: C2RustUnnamed_50 = 77;
pub const _SC_THREAD_THREADS_MAX: C2RustUnnamed_50 = 76;
pub const _SC_THREAD_STACK_MIN: C2RustUnnamed_50 = 75;
pub const _SC_THREAD_KEYS_MAX: C2RustUnnamed_50 = 74;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: C2RustUnnamed_50 = 73;
pub const _SC_TTY_NAME_MAX: C2RustUnnamed_50 = 72;
pub const _SC_LOGIN_NAME_MAX: C2RustUnnamed_50 = 71;
pub const _SC_GETPW_R_SIZE_MAX: C2RustUnnamed_50 = 70;
pub const _SC_GETGR_R_SIZE_MAX: C2RustUnnamed_50 = 69;
pub const _SC_THREAD_SAFE_FUNCTIONS: C2RustUnnamed_50 = 68;
pub const _SC_THREADS: C2RustUnnamed_50 = 67;
pub const _SC_T_IOV_MAX: C2RustUnnamed_50 = 66;
pub const _SC_PII_OSI_M: C2RustUnnamed_50 = 65;
pub const _SC_PII_OSI_CLTS: C2RustUnnamed_50 = 64;
pub const _SC_PII_OSI_COTS: C2RustUnnamed_50 = 63;
pub const _SC_PII_INTERNET_DGRAM: C2RustUnnamed_50 = 62;
pub const _SC_PII_INTERNET_STREAM: C2RustUnnamed_50 = 61;
pub const _SC_IOV_MAX: C2RustUnnamed_50 = 60;
pub const _SC_UIO_MAXIOV: C2RustUnnamed_50 = 60;
pub const _SC_SELECT: C2RustUnnamed_50 = 59;
pub const _SC_POLL: C2RustUnnamed_50 = 58;
pub const _SC_PII_OSI: C2RustUnnamed_50 = 57;
pub const _SC_PII_INTERNET: C2RustUnnamed_50 = 56;
pub const _SC_PII_SOCKET: C2RustUnnamed_50 = 55;
pub const _SC_PII_XTI: C2RustUnnamed_50 = 54;
pub const _SC_PII: C2RustUnnamed_50 = 53;
pub const _SC_2_LOCALEDEF: C2RustUnnamed_50 = 52;
pub const _SC_2_SW_DEV: C2RustUnnamed_50 = 51;
pub const _SC_2_FORT_RUN: C2RustUnnamed_50 = 50;
pub const _SC_2_FORT_DEV: C2RustUnnamed_50 = 49;
pub const _SC_2_C_DEV: C2RustUnnamed_50 = 48;
pub const _SC_2_C_BIND: C2RustUnnamed_50 = 47;
pub const _SC_2_VERSION: C2RustUnnamed_50 = 46;
pub const _SC_CHARCLASS_NAME_MAX: C2RustUnnamed_50 = 45;
pub const _SC_RE_DUP_MAX: C2RustUnnamed_50 = 44;
pub const _SC_LINE_MAX: C2RustUnnamed_50 = 43;
pub const _SC_EXPR_NEST_MAX: C2RustUnnamed_50 = 42;
pub const _SC_EQUIV_CLASS_MAX: C2RustUnnamed_50 = 41;
pub const _SC_COLL_WEIGHTS_MAX: C2RustUnnamed_50 = 40;
pub const _SC_BC_STRING_MAX: C2RustUnnamed_50 = 39;
pub const _SC_BC_SCALE_MAX: C2RustUnnamed_50 = 38;
pub const _SC_BC_DIM_MAX: C2RustUnnamed_50 = 37;
pub const _SC_BC_BASE_MAX: C2RustUnnamed_50 = 36;
pub const _SC_TIMER_MAX: C2RustUnnamed_50 = 35;
pub const _SC_SEM_VALUE_MAX: C2RustUnnamed_50 = 33;
pub const _SC_SEM_NSEMS_MAX: C2RustUnnamed_50 = 32;
pub const _SC_RTSIG_MAX: C2RustUnnamed_50 = 31;
pub const _SC_VERSION: C2RustUnnamed_50 = 29;
pub const _SC_MQ_PRIO_MAX: C2RustUnnamed_50 = 28;
pub const _SC_MQ_OPEN_MAX: C2RustUnnamed_50 = 27;
pub const _SC_DELAYTIMER_MAX: C2RustUnnamed_50 = 26;
pub const _SC_AIO_PRIO_DELTA_MAX: C2RustUnnamed_50 = 25;
pub const _SC_AIO_MAX: C2RustUnnamed_50 = 24;
pub const _SC_AIO_LISTIO_MAX: C2RustUnnamed_50 = 23;
pub const _SC_SHARED_MEMORY_OBJECTS: C2RustUnnamed_50 = 22;
pub const _SC_SEMAPHORES: C2RustUnnamed_50 = 21;
pub const _SC_MESSAGE_PASSING: C2RustUnnamed_50 = 20;
pub const _SC_MEMORY_PROTECTION: C2RustUnnamed_50 = 19;
pub const _SC_MEMLOCK_RANGE: C2RustUnnamed_50 = 18;
pub const _SC_MEMLOCK: C2RustUnnamed_50 = 17;
pub const _SC_MAPPED_FILES: C2RustUnnamed_50 = 16;
pub const _SC_FSYNC: C2RustUnnamed_50 = 15;
pub const _SC_SYNCHRONIZED_IO: C2RustUnnamed_50 = 14;
pub const _SC_PRIORITIZED_IO: C2RustUnnamed_50 = 13;
pub const _SC_ASYNCHRONOUS_IO: C2RustUnnamed_50 = 12;
pub const _SC_TIMERS: C2RustUnnamed_50 = 11;
pub const _SC_PRIORITY_SCHEDULING: C2RustUnnamed_50 = 10;
pub const _SC_REALTIME_SIGNALS: C2RustUnnamed_50 = 9;
pub const _SC_SAVED_IDS: C2RustUnnamed_50 = 8;
pub const _SC_JOB_CONTROL: C2RustUnnamed_50 = 7;
pub const _SC_TZNAME_MAX: C2RustUnnamed_50 = 6;
pub const _SC_STREAM_MAX: C2RustUnnamed_50 = 5;
pub const _SC_OPEN_MAX: C2RustUnnamed_50 = 4;
pub const _SC_NGROUPS_MAX: C2RustUnnamed_50 = 3;
pub const _SC_CHILD_MAX: C2RustUnnamed_50 = 1;
pub const _SC_ARG_MAX: C2RustUnnamed_50 = 0;
pub type C2RustUnnamed_51 = libc::c_uint;
pub const FPE_CONDTRAP: C2RustUnnamed_51 = 15;
pub const FPE_FLTUNK: C2RustUnnamed_51 = 14;
pub type C2RustUnnamed_52 = libc::c_uint;
pub const SIGEV_THREAD_ID: C2RustUnnamed_52 = 4;
pub const SIGEV_THREAD: C2RustUnnamed_52 = 2;
pub const SIGEV_NONE: C2RustUnnamed_52 = 1;
pub type __socket_type = libc::c_uint;
pub const SOCK_NONBLOCK: __socket_type = 2048;
pub const SOCK_CLOEXEC: __socket_type = 524288;
pub const SOCK_PACKET: __socket_type = 10;
pub const SOCK_DCCP: __socket_type = 6;
pub const SOCK_SEQPACKET: __socket_type = 5;
pub const SOCK_RDM: __socket_type = 4;
pub const SOCK_RAW: __socket_type = 3;
pub type C2RustUnnamed_53 = libc::c_uint;
pub const MSG_CMSG_CLOEXEC: C2RustUnnamed_53 = 1073741824;
pub const MSG_FASTOPEN: C2RustUnnamed_53 = 536870912;
pub const MSG_ZEROCOPY: C2RustUnnamed_53 = 67108864;
pub const MSG_BATCH: C2RustUnnamed_53 = 262144;
pub const MSG_WAITFORONE: C2RustUnnamed_53 = 65536;
pub const MSG_MORE: C2RustUnnamed_53 = 32768;
pub const MSG_NOSIGNAL: C2RustUnnamed_53 = 16384;
pub const MSG_ERRQUEUE: C2RustUnnamed_53 = 8192;
pub const MSG_RST: C2RustUnnamed_53 = 4096;
pub const MSG_CONFIRM: C2RustUnnamed_53 = 2048;
pub const MSG_SYN: C2RustUnnamed_53 = 1024;
pub const MSG_FIN: C2RustUnnamed_53 = 512;
pub const MSG_WAITALL: C2RustUnnamed_53 = 256;
pub const MSG_EOR: C2RustUnnamed_53 = 128;
pub const MSG_TRUNC: C2RustUnnamed_53 = 32;
pub const MSG_PROXY: C2RustUnnamed_53 = 16;
pub const MSG_CTRUNC: C2RustUnnamed_53 = 8;
pub const MSG_TRYHARD: C2RustUnnamed_53 = 4;
pub const MSG_DONTROUTE: C2RustUnnamed_53 = 4;
pub const MSG_PEEK: C2RustUnnamed_53 = 2;
pub const MSG_OOB: C2RustUnnamed_53 = 1;
pub type C2RustUnnamed_54 = libc::c_uint;
pub type C2RustUnnamed_55 = libc::c_uint;
pub const IPPROTO_MAX: C2RustUnnamed_55 = 263;
pub const IPPROTO_MPTCP: C2RustUnnamed_55 = 262;
pub const IPPROTO_RAW: C2RustUnnamed_55 = 255;
pub const IPPROTO_ETHERNET: C2RustUnnamed_55 = 143;
pub const IPPROTO_MPLS: C2RustUnnamed_55 = 137;
pub const IPPROTO_UDPLITE: C2RustUnnamed_55 = 136;
pub const IPPROTO_SCTP: C2RustUnnamed_55 = 132;
pub const IPPROTO_COMP: C2RustUnnamed_55 = 108;
pub const IPPROTO_PIM: C2RustUnnamed_55 = 103;
pub const IPPROTO_ENCAP: C2RustUnnamed_55 = 98;
pub const IPPROTO_BEETPH: C2RustUnnamed_55 = 94;
pub const IPPROTO_MTP: C2RustUnnamed_55 = 92;
pub const IPPROTO_AH: C2RustUnnamed_55 = 51;
pub const IPPROTO_ESP: C2RustUnnamed_55 = 50;
pub const IPPROTO_GRE: C2RustUnnamed_55 = 47;
pub const IPPROTO_RSVP: C2RustUnnamed_55 = 46;
pub const IPPROTO_IPV6: C2RustUnnamed_55 = 41;
pub const IPPROTO_DCCP: C2RustUnnamed_55 = 33;
pub const IPPROTO_TP: C2RustUnnamed_55 = 29;
pub const IPPROTO_IDP: C2RustUnnamed_55 = 22;
pub const IPPROTO_PUP: C2RustUnnamed_55 = 12;
pub const IPPROTO_EGP: C2RustUnnamed_55 = 8;
pub const IPPROTO_IPIP: C2RustUnnamed_55 = 4;
pub const IPPROTO_IGMP: C2RustUnnamed_55 = 2;
pub const IPPROTO_ICMP: C2RustUnnamed_55 = 1;
pub const IPPROTO_IP: C2RustUnnamed_55 = 0;
pub type CFE_StatusString_t = [libc::c_char; 11];
pub type CFE_ES_LogMode = libc::c_uint;
pub type CFE_ES_ExceptionAction = libc::c_uint;
pub type CFE_ES_AppType = libc::c_uint;
pub type CFE_ES_RunStatus = libc::c_uint;
pub type CFE_ES_SystemState = libc::c_uint;
pub const CFE_ES_SystemState_MAX: CFE_ES_SystemState = 7;
pub const CFE_ES_SystemState_UNDEFINED: CFE_ES_SystemState = 0;
pub type CFE_ES_LogEntryType = libc::c_uint;
pub type CFE_ES_AppState = libc::c_uint;
pub const CFE_ES_AppState_MAX: CFE_ES_AppState = 6;
pub const CFE_ES_AppState_UNDEFINED: CFE_ES_AppState = 0;
pub type CFE_TIME_ClockState = libc::c_int;
pub type CFE_TIME_SourceSelect = libc::c_uint;
pub type CFE_TIME_ToneSignalSelect = libc::c_uint;
pub type CFE_TIME_AdjustDirection = libc::c_uint;
pub type CFE_TIME_FlywheelState = libc::c_uint;
pub type CFE_TIME_SetState = libc::c_uint;
pub type CFE_EVS_MsgFormat = libc::c_uint;
pub type CFE_EVS_LogMode = libc::c_uint;
pub type CFE_EVS_EventType = libc::c_uint;
pub type CFE_EVS_EventFilter = libc::c_uint;
pub type CFE_FS_SubType = libc::c_uint;
pub type CFE_TBL_BufferSelect = libc::c_uint;
pub type CFE_TBL_SrcEnum = libc::c_uint;
pub const CFE_TBL_SRC_ADDRESS: CFE_TBL_SrcEnum = 1;
pub const CFE_TBL_SRC_FILE: CFE_TBL_SrcEnum = 0;
pub type CFE_TBL_SrcEnum_t = CFE_TBL_SrcEnum;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_Info {
    pub Size: size_t,
    pub NumUsers: uint32,
    pub FileCreateTimeSecs: uint32,
    pub FileCreateTimeSubSecs: uint32,
    pub Crc: uint32,
    pub TimeOfLastUpdate: CFE_TIME_SysTime_t,
    pub TableLoadedOnce: bool,
    pub DumpOnly: bool,
    pub DoubleBuffered: bool,
    pub UserDefAddr: bool,
    pub Critical: bool,
    pub LastFileLoaded: [libc::c_char; 64],
}
pub type CFE_TBL_Info_t = CFE_TBL_Info;
pub type CFE_PSP_StatusString_t = [libc::c_char; 12];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_TBL_FileDef {
    pub ObjectName: [libc::c_char; 64],
    pub TableName: [libc::c_char; 40],
    pub Description: [libc::c_char; 32],
    pub TgtFilename: [libc::c_char; 20],
    pub ObjectSize: uint32,
}
pub type CFE_TBL_FileDef_t = CFE_TBL_FileDef;
pub type C2RustUnnamed_56 = libc::c_uint;
pub const CFE_ES_TASKID_BASE: C2RustUnnamed_56 = 65536;
pub type CFE_ES_PerfState = libc::c_uint;
pub const CFE_ES_PERF_MAX_STATES: CFE_ES_PerfState = 3;
pub type CFE_ES_PerfMode = libc::c_uint;
pub type CFE_ConfigIdOffset = libc::c_uint;
pub const CFE_ConfigIdOffset_MOD_SRCVER_CONFIG: CFE_ConfigIdOffset = 33;
pub const CFE_ConfigIdOffset_MOD_SRCVER_RESOURCEID: CFE_ConfigIdOffset = 32;
pub const CFE_ConfigIdOffset_MOD_SRCVER_SBR: CFE_ConfigIdOffset = 31;
pub const CFE_ConfigIdOffset_MOD_SRCVER_MSG: CFE_ConfigIdOffset = 30;
pub const CFE_ConfigIdOffset_MOD_SRCVER_PSP: CFE_ConfigIdOffset = 29;
pub const CFE_ConfigIdOffset_MOD_SRCVER_OSAL: CFE_ConfigIdOffset = 28;
pub const CFE_ConfigIdOffset_MOD_SRCVER_TIME: CFE_ConfigIdOffset = 27;
pub const CFE_ConfigIdOffset_MOD_SRCVER_TBL: CFE_ConfigIdOffset = 26;
pub const CFE_ConfigIdOffset_MOD_SRCVER_SB: CFE_ConfigIdOffset = 25;
pub const CFE_ConfigIdOffset_MOD_SRCVER_FS: CFE_ConfigIdOffset = 24;
pub const CFE_ConfigIdOffset_MOD_SRCVER_EVS: CFE_ConfigIdOffset = 23;
pub const CFE_ConfigIdOffset_MOD_SRCVER_ES: CFE_ConfigIdOffset = 22;
pub const CFE_ConfigIdOffset_MOD_SRCVER_SAMPLE_LIB: CFE_ConfigIdOffset = 21;
pub const CFE_ConfigIdOffset_MOD_SRCVER_SAMPLE_APP: CFE_ConfigIdOffset = 20;
pub const CFE_ConfigIdOffset_MOD_SRCVER_CFE_ASSERT: CFE_ConfigIdOffset = 19;
pub const CFE_ConfigIdOffset_MOD_SRCVER_SCH_LAB: CFE_ConfigIdOffset = 18;
pub const CFE_ConfigIdOffset_MOD_SRCVER_TO_LAB: CFE_ConfigIdOffset = 17;
pub const CFE_ConfigIdOffset_MOD_SRCVER_CI_LAB: CFE_ConfigIdOffset = 16;
pub const CFE_ConfigIdOffset_MOD_SRCVER_CORE_PRIVATE: CFE_ConfigIdOffset = 15;
pub const CFE_ConfigIdOffset_MOD_SRCVER_CORE_API: CFE_ConfigIdOffset = 14;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CFE_PSP_IODriver_Location_t {
    pub PspModuleId: uint32,
    pub SubsystemId: uint16,
    pub SubchannelId: uint16,
}
pub type C2RustUnnamed_57 = libc::c_uint;
pub const CFE_PSP_IODriver_EXTENDED_BASE: C2RustUnnamed_57 = 2147418112;
pub const CFE_PSP_IODriver_STREAM_IO_CLASS_BASE: C2RustUnnamed_57 = 327680;
pub const CFE_PSP_IODriver_MEMORY_IO_CLASS_BASE: C2RustUnnamed_57 = 262144;
pub const CFE_PSP_IODriver_PACKET_IO_CLASS_BASE: C2RustUnnamed_57 = 196608;
pub const CFE_PSP_IODriver_DISCRETE_IO_CLASS_BASE: C2RustUnnamed_57 = 131072;
pub const CFE_PSP_IODriver_ANALOG_IO_CLASS_BASE: C2RustUnnamed_57 = 65536;
pub const CFE_PSP_IODriver_SET_DIRECTION: C2RustUnnamed_57 = 7;
pub type C2RustUnnamed_58 = libc::c_uint;
pub const CFE_PSP_IODriver_ANALOG_IO_MAX: C2RustUnnamed_58 = 65539;
pub const CFE_PSP_IODriver_ANALOG_IO_WRITE_CHANNELS: C2RustUnnamed_58 = 65538;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CI_LAB_HkTlm_Payload_t {
    pub CommandErrorCounter: uint8,
    pub CommandCounter: uint8,
    pub EnableChecksums: uint8,
    pub SocketConnected: uint8,
    pub Spare1: [uint8; 8],
    pub IngestPackets: uint32,
    pub IngestErrors: uint32,
    pub Spare2: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CI_LAB_HkTlm_t {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: CI_LAB_HkTlm_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CI_LAB_GlobalData_t {
    pub SocketConnected: bool,
    pub Scheduled: bool,
    pub CommandPipe: CFE_SB_PipeId_t,
    pub SocketID: osal_id_t,
    pub SocketAddress: OS_SockAddr_t,
    pub HkTlm: CI_LAB_HkTlm_t,
    pub NetBufPtr: *mut libc::c_void,
    pub NetBufSize: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CI_LAB_ReadUplinkCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CI_LAB_SendHkCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CI_LAB_ResetCountersCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CI_LAB_NoopCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_Sub_t {
    pub Stream: CFE_SB_MsgId_t,
    pub Flags: CFE_SB_Qos_t,
    pub BufLimit: uint16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_Subs_t {
    pub Subs: [TO_LAB_Sub_t; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_HkTlm_Payload_t {
    pub CommandCounter: uint8,
    pub CommandErrorCounter: uint8,
    pub spareToAlign: [uint8; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_DataTypes_Payload_t {
    pub synch: uint16,
    pub bl1: uint8,
    pub bl2: uint8,
    pub b1: int8,
    pub b2: int8,
    pub b3: int8,
    pub b4: int8,
    pub w1: int16,
    pub w2: int16,
    pub dw1: int32,
    pub dw2: int32,
    pub f1: libc::c_float,
    pub f2: libc::c_float,
    pub df1: libc::c_double,
    pub df2: libc::c_double,
    pub str_0: [libc::c_char; 10],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_AddPacket_Payload_t {
    pub Stream: CFE_SB_MsgId_t,
    pub Flags: CFE_SB_Qos_t,
    pub BufLimit: uint8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_RemovePacket_Payload_t {
    pub Stream: CFE_SB_MsgId_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_EnableOutput_Payload_t {
    pub dest_IP: [libc::c_char; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_HkTlm_t {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: TO_LAB_HkTlm_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_DataTypesTlm_t {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: TO_LAB_DataTypes_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_SendHkCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_NoopCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_ResetCountersCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_RemoveAllCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_SendDataTypesCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_AddPacketCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: TO_LAB_AddPacket_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_RemovePacketCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: TO_LAB_RemovePacket_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_EnableOutputCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: TO_LAB_EnableOutput_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TO_LAB_GlobalData_t {
    pub Tlm_pipe: CFE_SB_PipeId_t,
    pub Cmd_pipe: CFE_SB_PipeId_t,
    pub TLMsockid: osal_id_t,
    pub downlink_on: bool,
    pub tlm_dest_IP: [libc::c_char; 17],
    pub suppress_sendto: bool,
    pub HkTlm: TO_LAB_HkTlm_t,
    pub DataTypesTlm: TO_LAB_DataTypesTlm_t,
    pub SubsTblPtr: *mut TO_LAB_Subs_t,
    pub SubsTblHandle: CFE_TBL_Handle_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SCH_LAB_ScheduleTableEntry_t {
    pub MessageID: CFE_SB_MsgId_t,
    pub PacketRate: uint32,
    pub FcnCode: CFE_MSG_FcnCode_t,
    pub PayloadLength: uint16,
    pub MessageBuffer: [uint16; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SCH_LAB_ScheduleTable_t {
    pub TickRate: uint32,
    pub Config: [SCH_LAB_ScheduleTableEntry_t; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SCH_LAB_StateEntry_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub MessageBuffer: [uint16; 32],
    pub PayloadLength: uint16,
    pub PacketRate: uint32,
    pub Counter: uint32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SCH_LAB_GlobalData_t {
    pub State: [SCH_LAB_StateEntry_t; 32],
    pub TimerId: osal_id_t,
    pub TimingSem: osal_id_t,
    pub TblHandle: CFE_TBL_Handle_t,
    pub CmdPipe: CFE_SB_PipeId_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_ExampleTable_t {
    pub Int1: uint16,
    pub Int2: uint16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_DisplayParam_Payload {
    pub ValU32: uint32,
    pub ValI16: int16,
    pub ValStr: [libc::c_char; 10],
}
pub type SAMPLE_APP_DisplayParam_Payload_t = SAMPLE_APP_DisplayParam_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_HkTlm_Payload {
    pub CommandErrorCounter: uint8,
    pub CommandCounter: uint8,
    pub spare: [uint8; 2],
}
pub type SAMPLE_APP_HkTlm_Payload_t = SAMPLE_APP_HkTlm_Payload;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_NoopCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_ResetCountersCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_ProcessCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_DisplayParamCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
    pub Payload: SAMPLE_APP_DisplayParam_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_SendHkCmd_t {
    pub CommandHeader: CFE_MSG_CommandHeader_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_HkTlm_t {
    pub TelemetryHeader: CFE_MSG_TelemetryHeader_t,
    pub Payload: SAMPLE_APP_HkTlm_Payload_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SAMPLE_APP_Data_t {
    pub CmdCounter: uint8,
    pub ErrCounter: uint8,
    pub HkTlm: SAMPLE_APP_HkTlm_t,
    pub RunStatus: uint32,
    pub CommandPipe: CFE_SB_PipeId_t,
    pub PipeName: [libc::c_char; 20],
    pub PipeDepth: uint16,
    pub TblHandles: [CFE_TBL_Handle_t; 1],
}
#[inline]
unsafe extern "C" fn OS_ObjectIdToInteger(mut object_id: osal_id_t) -> libc::c_ulong {
    return object_id as libc::c_ulong;
}
#[inline]
unsafe extern "C" fn OS_ObjectIdEqual(
    mut object_id1: osal_id_t,
    mut object_id2: osal_id_t,
) -> bool {
    return OS_ObjectIdToInteger(object_id1) == OS_ObjectIdToInteger(object_id2);
}
#[inline]
unsafe extern "C" fn OS_StatusToInteger(mut Status: osal_status_t) -> libc::c_long {
    return Status as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_SetExitCode(mut code: int32) {
    OS_BSP_Global.AppStatus = code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_GetArgC() -> uint32 {
    return OS_BSP_Global.ArgC;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_GetArgV() -> *const *mut libc::c_char {
    return OS_BSP_Global.ArgV;
}
#[no_mangle]
pub static mut OS_BSP_Global: OS_BSP_GlobalData_t = OS_BSP_GlobalData_t {
    ArgC: 0,
    ArgV: 0 as *const *mut libc::c_char as *mut *mut libc::c_char,
    AppStatus: 0,
    MaxQueueDepth: 0,
    ResoureConfig: [0; 16],
};
#[inline]
unsafe extern "C" fn OS_ObjectIdDefined(mut object_id: osal_id_t) -> bool {
    return OS_ObjectIdToInteger(object_id) != 0 as libc::c_int as libc::c_ulong;
}
#[inline]
unsafe extern "C" fn OS_ObjectIdFromInteger(mut value: libc::c_ulong) -> osal_id_t {
    let mut idv: osal_id_t = value as osal_id_t;
    return idv;
}
#[no_mangle]
pub static mut OS_STATIC_SYMBOL_TABLE: [OS_static_symbol_record_t; 3] = unsafe {
    [
        {
            let mut init = OS_static_symbol_record_t {
                Name: b"OS_Application_Startup\0" as *const u8 as *const libc::c_char,
                Address: Some(OS_Application_Startup as unsafe extern "C" fn() -> ()),
                Module: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = OS_static_symbol_record_t {
                Name: b"OS_Application_Run\0" as *const u8 as *const libc::c_char,
                Address: Some(OS_Application_Run as unsafe extern "C" fn() -> ()),
                Module: 0 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = OS_static_symbol_record_t {
                Name: 0 as *const libc::c_char,
                Address: None,
                Module: 0 as *const libc::c_char,
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_SetResourceTypeConfig(
    mut ResourceType: uint32,
    mut ConfigOptionValue: uint32,
) {
    if ResourceType < 0x10 as libc::c_int as libc::c_uint {
        OS_BSP_Global.ResoureConfig[ResourceType as usize] = ConfigOptionValue;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_GetResourceTypeConfig(mut ResourceType: uint32) -> uint32 {
    let mut ConfigOptionValue: uint32 = 0;
    if ResourceType < 0x10 as libc::c_int as libc::c_uint {
        ConfigOptionValue = OS_BSP_Global.ResoureConfig[ResourceType as usize];
    } else {
        ConfigOptionValue = 0 as libc::c_int as uint32;
    }
    return ConfigOptionValue;
}
#[inline]
unsafe extern "C" fn OS_ObjectIdToSerialNumber_Impl(mut id: osal_id_t) -> uint32 {
    return (OS_ObjectIdToInteger(id) & 0xffff as libc::c_int as libc::c_ulong) as uint32;
}
#[inline]
unsafe extern "C" fn OS_ObjectIdToType_Impl(mut id: osal_id_t) -> osal_objtype_t {
    return (OS_ObjectIdToInteger(id) >> 16 as libc::c_int) as osal_objtype_t;
}
#[inline]
unsafe extern "C" fn OS_ObjectIdCompose_Impl(
    mut idtype: osal_objtype_t,
    mut idserial: uint32,
    mut result: *mut osal_id_t,
) {
    *result = OS_ObjectIdFromInteger((idtype << 16 as libc::c_int | idserial) as libc::c_ulong);
}
#[inline]
unsafe extern "C" fn OS_ObjectIdIsValid(mut object_id: osal_id_t) -> bool {
    let mut objtype: osal_objtype_t = OS_ObjectIdToType_Impl(object_id);
    return objtype > 0 as libc::c_int as libc::c_uint
        && objtype < 0x10 as libc::c_int as libc::c_uint;
}
#[inline]
unsafe extern "C" fn OS_ObjectIndexFromToken(mut token: *const OS_object_token_t) -> osal_index_t {
    return (*token).obj_idx;
}
#[inline]
unsafe extern "C" fn OS_ObjectIdFromToken(mut token: *const OS_object_token_t) -> osal_id_t {
    return (*token).obj_id;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemDelete(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_BinSemDelete_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemAPI_Init() -> int32 {
    memset(
        OS_bin_sem_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_bin_sem_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemGetInfo(
    mut sem_id: osal_id_t,
    mut bin_prop: *mut OS_bin_sem_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if bin_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_BinSemGetInfo\0"))
                .as_ptr(),
            259 as libc::c_int,
            b"(bin_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        bin_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_bin_sem_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_bin_sem_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        strncpy(
            ((*bin_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*bin_prop).creator = (*record).creator;
        return_code = OS_BinSemGetInfo_Impl(&mut token, bin_prop);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemGetIdByName(
    mut sem_id: *mut osal_id_t,
    mut sem_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    if sem_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_BinSemGetIdByName\0"))
                .as_ptr(),
            238 as libc::c_int,
            b"(sem_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if sem_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_BinSemGetIdByName\0"))
                .as_ptr(),
            239 as libc::c_int,
            b"(sem_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_name,
        sem_id,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemTake(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_BinSemTake_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemCreate(
    mut sem_id: *mut osal_id_t,
    mut sem_name: *const libc::c_char,
    mut sem_initial_value: uint32,
    mut options: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut binsem: *mut OS_bin_sem_internal_record_t = 0 as *mut OS_bin_sem_internal_record_t;
    if sem_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_BinSemCreate\0"))
                .as_ptr(),
            98 as libc::c_int,
            b"(sem_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if sem_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_BinSemCreate\0"))
                .as_ptr(),
            99 as libc::c_int,
            b"(sem_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        sem_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_name,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        binsem = &mut *OS_bin_sem_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_bin_sem_internal_record_t;
        memset(
            binsem as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_bin_sem_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*binsem).obj_name).as_mut_ptr(),
            sem_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh0 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh0 = ((*binsem).obj_name).as_mut_ptr();
        return_code = OS_BinSemCreate_Impl(&mut token, sem_initial_value, options);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, sem_id);
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_bin_sem_table: [OS_bin_sem_internal_record_t; 20] =
    [OS_bin_sem_internal_record_t { obj_name: [0; 20] }; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemTimedWait(mut sem_id: osal_id_t, mut msecs: uint32) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_BinSemTimedWait_Impl(&mut token, msecs);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemFlush(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_BinSemFlush_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemGive(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_BinSemGive_Impl(&mut token);
    }
    return return_code;
}
#[inline]
unsafe extern "C" fn OS_TimeGetTotalSeconds(mut tm: OS_time_t) -> int64 {
    return tm.ticks / OS_TIME_TICKS_PER_SECOND as libc::c_int as libc::c_long;
}
#[inline]
unsafe extern "C" fn OS_TimeFromTotalSeconds(mut tm: int64) -> OS_time_t {
    let mut ostm: OS_time_t = {
        let mut init = OS_time_t {
            ticks: tm * OS_TIME_TICKS_PER_SECOND as libc::c_int as libc::c_long,
        };
        init
    };
    return ostm;
}
#[inline]
unsafe extern "C" fn OS_TimeGetTotalMilliseconds(mut tm: OS_time_t) -> int64 {
    return tm.ticks / OS_TIME_TICKS_PER_MSEC as libc::c_int as libc::c_long;
}
#[inline]
unsafe extern "C" fn OS_TimeFromTotalNanoseconds(mut tm: int64) -> OS_time_t {
    let mut ostm: OS_time_t = {
        let mut init = OS_time_t {
            ticks: tm / OS_TIME_TICK_RESOLUTION_NS as libc::c_int as libc::c_long,
        };
        init
    };
    return ostm;
}
#[inline]
unsafe extern "C" fn OS_TimeGetFractionalPart(mut tm: OS_time_t) -> int64 {
    return tm.ticks % OS_TIME_TICKS_PER_SECOND as libc::c_int as libc::c_long;
}
#[inline]
unsafe extern "C" fn OS_TimeGetSubsecondsPart(mut tm: OS_time_t) -> uint32 {
    let mut frac: int64 = (OS_TimeGetFractionalPart(tm) << 30 as libc::c_int)
        + (OS_TIME_TICKS_PER_SECOND as libc::c_int >> 2 as libc::c_int) as libc::c_long;
    return ((frac - 1 as libc::c_int as libc::c_long)
        / (OS_TIME_TICKS_PER_SECOND as libc::c_int >> 2 as libc::c_int) as libc::c_long)
        as uint32;
}
#[inline]
unsafe extern "C" fn OS_TimeGetNanosecondsPart(mut tm: OS_time_t) -> uint32 {
    return (OS_TimeGetFractionalPart(tm) as uint32)
        .wrapping_mul(OS_TIME_TICK_RESOLUTION_NS as libc::c_int as libc::c_uint);
}
#[inline]
unsafe extern "C" fn OS_TimeAssembleFromNanoseconds(
    mut seconds: int64,
    mut nanoseconds: uint32,
) -> OS_time_t {
    let mut result: OS_time_t = OS_time_t { ticks: 0 };
    result.ticks = seconds * OS_TIME_TICKS_PER_SECOND as libc::c_int as libc::c_long;
    result.ticks += nanoseconds
        .wrapping_div(OS_TIME_TICK_RESOLUTION_NS as libc::c_int as libc::c_uint)
        as libc::c_long;
    return result;
}
#[inline]
unsafe extern "C" fn OS_TimeAdd(mut time1: OS_time_t, mut time2: OS_time_t) -> OS_time_t {
    let mut ostm: OS_time_t = {
        let mut init = OS_time_t {
            ticks: time1.ticks + time2.ticks,
        };
        init
    };
    return ostm;
}
#[inline]
unsafe extern "C" fn OS_TimeGetMicrosecondsPart(mut tm: OS_time_t) -> uint32 {
    return (OS_TimeGetFractionalPart(tm) as uint32)
        .wrapping_div(OS_TIME_TICKS_PER_USEC as libc::c_int as libc::c_uint);
}
#[inline]
unsafe extern "C" fn OS_TimeAssembleFromSubseconds(
    mut seconds: int64,
    mut subseconds: uint32,
) -> OS_time_t {
    let mut result: OS_time_t = OS_time_t { ticks: 0 };
    result.ticks = seconds * OS_TIME_TICKS_PER_SECOND as libc::c_int as libc::c_long;
    result.ticks += subseconds as int64
        * (OS_TIME_TICKS_PER_SECOND as libc::c_int >> 2 as libc::c_int) as libc::c_long
        >> 30 as libc::c_int;
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetLocalTime(mut time_struct: *mut OS_time_t) -> int32 {
    if time_struct.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_GetLocalTime\0"))
                .as_ptr(),
            50 as libc::c_int,
            b"(time_struct) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return OS_GetLocalTime_Impl(time_struct);
}
#[no_mangle]
pub unsafe extern "C" fn OS_SetLocalTime(mut time_struct: *const OS_time_t) -> int32 {
    if time_struct.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SetLocalTime\0"))
                .as_ptr(),
            64 as libc::c_int,
            b"(time_struct) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return OS_SetLocalTime_Impl(time_struct);
}
#[inline]
unsafe extern "C" fn OS_TimeSubtract(mut time1: OS_time_t, mut time2: OS_time_t) -> OS_time_t {
    let mut ostm: OS_time_t = {
        let mut init = OS_time_t {
            ticks: time1.ticks - time2.ticks,
        };
        init
    };
    return ostm;
}
#[no_mangle]
pub static mut OS_SharedGlobalVars: OS_SharedGlobalVars_t = {
    let mut init = OS_shared_global_vars {
        GlobalState: 0 as libc::c_int as uint32,
        PrintfConsoleId: 0,
        PrintfEnabled: 0 as libc::c_int != 0,
        MicroSecPerTick: 0 as libc::c_int as uint32,
        TicksPerSecond: 0 as libc::c_int as uint32,
        EventHandler: None,
        DebugLevel: 1 as libc::c_int as uint8,
    };
    init
};
#[no_mangle]
pub unsafe extern "C" fn OS_ApplicationExit(mut Status: int32) {
    if Status == 0 as libc::c_int {
        exit(0 as libc::c_int);
    } else {
        exit(1 as libc::c_int);
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_IdleLoop() {
    while OS_SharedGlobalVars.GlobalState != 0xabadc0de as libc::c_uint {
        OS_IdleLoop_Impl();
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_ApplicationShutdown(mut flag: uint8) {
    if flag as libc::c_int == 1 as libc::c_int {
        ::core::ptr::write_volatile(
            &mut OS_SharedGlobalVars.GlobalState as *mut uint32,
            0xabadc0de as libc::c_uint,
        );
    }
    OS_ApplicationShutdown_Impl();
}
#[no_mangle]
pub unsafe extern "C" fn OS_API_Teardown() {
    OS_DeleteAllObjects();
    OS_ApplicationShutdown(1 as libc::c_int as uint8);
}
#[no_mangle]
pub unsafe extern "C" fn OS_NotifyEvent(
    mut event: OS_Event_t,
    mut object_id: osal_id_t,
    mut data: *mut libc::c_void,
) -> int32 {
    let mut status: int32 = 0;
    if (OS_SharedGlobalVars.EventHandler).is_some() {
        status = (OS_SharedGlobalVars.EventHandler).expect("non-null function pointer")(
            event, object_id, data,
        );
    } else {
        status = 0 as libc::c_int;
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DeleteAllObjects() {
    let mut ObjectCount: uint32 = 0;
    let mut TryCount: uint32 = 0;
    TryCount = 0 as libc::c_int as uint32;
    loop {
        ObjectCount = 0 as libc::c_int as uint32;
        TryCount = TryCount.wrapping_add(1);
        TryCount;
        OS_ForEachObjectOfType(
            0x9 as libc::c_int as osal_objtype_t,
            0 as libc::c_int as osal_id_t,
            Some(OS_CleanUpObject as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> ()),
            &mut ObjectCount as *mut uint32 as *mut libc::c_void,
        );
        OS_ForEachObjectOfType(
            0x8 as libc::c_int as osal_objtype_t,
            0 as libc::c_int as osal_id_t,
            Some(OS_CleanUpObject as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> ()),
            &mut ObjectCount as *mut uint32 as *mut libc::c_void,
        );
        OS_ForEachObjectOfType(
            0x1 as libc::c_int as osal_objtype_t,
            0 as libc::c_int as osal_id_t,
            Some(OS_CleanUpObject as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> ()),
            &mut ObjectCount as *mut uint32 as *mut libc::c_void,
        );
        OS_ForEachObject(
            0 as libc::c_int as osal_id_t,
            Some(OS_CleanUpObject as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> ()),
            &mut ObjectCount as *mut uint32 as *mut libc::c_void,
        );
        if ObjectCount == 0 as libc::c_int as libc::c_uint
            || TryCount > 4 as libc::c_int as libc::c_uint
        {
            break;
        }
        OS_TaskDelay(5 as libc::c_int as uint32);
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_CleanUpObject(mut object_id: osal_id_t, mut arg: *mut libc::c_void) {
    let mut ObjectCount: *mut uint32 = 0 as *mut uint32;
    ObjectCount = arg as *mut uint32;
    *ObjectCount = (*ObjectCount).wrapping_add(1);
    *ObjectCount;
    match OS_IdentifyObject(object_id) {
        1 => {
            OS_TaskDelete(object_id);
        }
        2 => {
            OS_QueueDelete(object_id);
        }
        4 => {
            OS_BinSemDelete(object_id);
        }
        3 => {
            OS_CountSemDelete(object_id);
        }
        5 => {
            OS_MutSemDelete(object_id);
        }
        10 => {
            OS_ModuleUnload(object_id);
        }
        8 => {
            OS_TimeBaseDelete(object_id);
        }
        9 => {
            OS_TimerDelete(object_id);
        }
        6 => {
            OS_close(object_id);
        }
        7 => {
            OS_DirectoryClose(object_id);
        }
        13 => {
            OS_CondVarDelete(object_id);
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_API_Init() -> int32 {
    let mut return_code: int32 = 0 as libc::c_int;
    let mut idtype: osal_objtype_t = 0;
    let mut microSecPerSec: uint32 = 0;
    if OS_SharedGlobalVars.GlobalState == 0xbe57c0de as libc::c_uint {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_API_Init\0")).as_ptr(),
            118 as libc::c_int as uint32,
            b"NOTE: ignored redundant OS_API_Init() call\n\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    memset(
        &mut OS_SharedGlobalVars as *mut OS_SharedGlobalVars_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_SharedGlobalVars_t>() as libc::c_ulong,
    );
    OS_SharedGlobalVars.DebugLevel = 1 as libc::c_int as uint8;
    ::core::ptr::write_volatile(
        &mut OS_SharedGlobalVars.GlobalState as *mut uint32,
        0xbe57c0de as libc::c_uint,
    );
    return_code = OS_ObjectIdInit();
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    idtype = 0 as libc::c_int as osal_objtype_t;
    while idtype < 0x10 as libc::c_int as libc::c_uint {
        return_code = OS_API_Impl_Init(idtype);
        if return_code != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_API_Init\0"))
                    .as_ptr(),
                146 as libc::c_int as uint32,
                b"OS_API_Impl_Init(0x%x) failed to initialize: %d\n\0" as *const u8
                    as *const libc::c_char,
                idtype,
                return_code,
            );
            break;
        } else {
            match idtype {
                1 => {
                    return_code = OS_TaskAPI_Init();
                }
                2 => {
                    return_code = OS_QueueAPI_Init();
                }
                4 => {
                    return_code = OS_BinSemAPI_Init();
                }
                3 => {
                    return_code = OS_CountSemAPI_Init();
                }
                5 => {
                    return_code = OS_MutexAPI_Init();
                }
                10 => {
                    return_code = OS_ModuleAPI_Init();
                }
                8 => {
                    return_code = OS_TimeBaseAPI_Init();
                }
                9 => {
                    return_code = OS_TimerCbAPI_Init();
                }
                6 => {
                    return_code = OS_FileAPI_Init();
                }
                7 => {
                    return_code = OS_DirAPI_Init();
                }
                11 => {
                    return_code = OS_FileSysAPI_Init();
                }
                12 => {
                    return_code = OS_ConsoleAPI_Init();
                }
                13 => {
                    return_code = OS_CondVarAPI_Init();
                }
                _ => {}
            }
            if return_code != 0 as libc::c_int {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_API_Init\0"))
                        .as_ptr(),
                    196 as libc::c_int as uint32,
                    b"ID type 0x%x shared layer failed to initialize: %d\n\0" as *const u8
                        as *const libc::c_char,
                    idtype,
                    return_code,
                );
                break;
            } else {
                idtype = idtype.wrapping_add(1);
                idtype;
            }
        }
    }
    if return_code == 0 as libc::c_int {
        return_code = OS_NetworkAPI_Init();
    }
    if return_code == 0 as libc::c_int {
        return_code = OS_SocketAPI_Init();
    }
    if return_code == 0 as libc::c_int
        && (OS_SharedGlobalVars.MicroSecPerTick == 0 as libc::c_int as libc::c_uint
            || OS_SharedGlobalVars.TicksPerSecond == 0 as libc::c_int as libc::c_uint)
    {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_API_Init\0")).as_ptr(),
            218 as libc::c_int as uint32,
            b"Implementation failed to initialize tick time globals\n\0" as *const u8
                as *const libc::c_char,
        );
        return_code = -(1 as libc::c_int);
    }
    microSecPerSec =
        (OS_SharedGlobalVars.MicroSecPerTick).wrapping_mul(OS_SharedGlobalVars.TicksPerSecond);
    if microSecPerSec != 1000000 as libc::c_int as libc::c_uint {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_API_Init\0"))
                .as_ptr(),
            229 as libc::c_int as uint32,
            b"Warning: Microsecs per sec value of %lu does not equal 1000000 (MicroSecPerTick: %ld   TicksPerSecond: %ld)\n\0"
                as *const u8 as *const libc::c_char,
            microSecPerSec as libc::c_ulong,
            OS_SharedGlobalVars.MicroSecPerTick as libc::c_long,
            OS_SharedGlobalVars.TicksPerSecond as libc::c_long,
        );
    }
    if return_code != 0 as libc::c_int {
        ::core::ptr::write_volatile(
            &mut OS_SharedGlobalVars.GlobalState as *mut uint32,
            0xabadc0de as libc::c_uint,
        );
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_RegisterEventHandler(mut handler: OS_EventHandler_t) -> int32 {
    if handler.is_none() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"OS_RegisterEventHandler\0",
            ))
            .as_ptr(),
            275 as libc::c_int,
            b"(handler) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    OS_SharedGlobalVars.EventHandler = handler;
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn OS_strnlen(mut s: *const libc::c_char, mut maxlen: size_t) -> size_t {
    let mut end: *const libc::c_char =
        memchr(s as *const libc::c_void, 0 as libc::c_int, maxlen) as *const libc::c_char;
    if !end.is_null() {
        maxlen = end.offset_from(s) as libc::c_long as size_t;
    }
    return maxlen;
}
#[no_mangle]
pub static mut OS_condvar_table: [OS_condvar_internal_record_t; 4] =
    [OS_condvar_internal_record_t { obj_name: [0; 20] }; 4];
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarAPI_Init() -> int32 {
    memset(
        OS_condvar_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_condvar_internal_record_t; 4]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarCreate(
    mut var_id: *mut osal_id_t,
    mut var_name: *const libc::c_char,
    mut options: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut condvar: *mut OS_condvar_internal_record_t = 0 as *mut OS_condvar_internal_record_t;
    if var_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_CondVarCreate\0"))
                .as_ptr(),
            86 as libc::c_int,
            b"(var_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if var_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_CondVarCreate\0"))
                .as_ptr(),
            87 as libc::c_int,
            b"(var_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        var_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    return_code =
        OS_ObjectIdAllocateNew(0xd as libc::c_int as osal_objtype_t, var_name, &mut token);
    if return_code == 0 as libc::c_int {
        condvar = &mut *OS_condvar_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_condvar_internal_record_t;
        memset(
            condvar as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_condvar_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*condvar).obj_name).as_mut_ptr(),
            var_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh1 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh1 = ((*condvar).obj_name).as_mut_ptr();
        return_code = OS_CondVarCreate_Impl(&mut token, options);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, var_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarDelete(mut var_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CondVarDelete_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarLock(mut var_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CondVarLock_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarUnlock(mut var_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CondVarUnlock_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarSignal(mut var_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CondVarSignal_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarBroadcast(mut var_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CondVarBroadcast_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarWait(mut var_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CondVarWait_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarTimedWait(
    mut var_id: osal_id_t,
    mut abs_wakeup_time: *const OS_time_t,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if abs_wakeup_time.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"OS_CondVarTimedWait\0"))
                .as_ptr(),
            248 as libc::c_int,
            b"(abs_wakeup_time) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CondVarTimedWait_Impl(&mut token, abs_wakeup_time);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarGetIdByName(
    mut var_id: *mut osal_id_t,
    mut var_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    if var_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_CondVarGetIdByName\0"))
                .as_ptr(),
            271 as libc::c_int,
            b"(var_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if var_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_CondVarGetIdByName\0"))
                .as_ptr(),
            272 as libc::c_int,
            b"(var_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(0xd as libc::c_int as osal_objtype_t, var_name, var_id);
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarGetInfo(
    mut var_id: osal_id_t,
    mut condvar_prop: *mut OS_condvar_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if condvar_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_CondVarGetInfo\0"))
                .as_ptr(),
            292 as libc::c_int,
            b"(condvar_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        condvar_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_condvar_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        0xd as libc::c_int as osal_objtype_t,
        var_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_condvar_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        strncpy(
            ((*condvar_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*condvar_prop).creator = (*record).creator;
        return_code = OS_CondVarGetInfo_Impl(&mut token, condvar_prop);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_count_sem_table: [OS_count_sem_internal_record_t; 20] =
    [OS_count_sem_internal_record_t { obj_name: [0; 20] }; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemAPI_Init() -> int32 {
    memset(
        OS_count_sem_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_count_sem_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemCreate(
    mut sem_id: *mut osal_id_t,
    mut sem_name: *const libc::c_char,
    mut sem_initial_value: uint32,
    mut options: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut countsem: *mut OS_count_sem_internal_record_t =
        0 as *mut OS_count_sem_internal_record_t;
    if sem_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_CountSemCreate\0"))
                .as_ptr(),
            90 as libc::c_int,
            b"(sem_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if sem_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_CountSemCreate\0"))
                .as_ptr(),
            91 as libc::c_int,
            b"(sem_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        sem_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_name,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        countsem = &mut *OS_count_sem_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_count_sem_internal_record_t;
        memset(
            countsem as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_count_sem_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*countsem).obj_name).as_mut_ptr(),
            sem_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh2 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh2 = ((*countsem).obj_name).as_mut_ptr();
        return_code = OS_CountSemCreate_Impl(&mut token, sem_initial_value, options);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, sem_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemDelete(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CountSemDelete_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemGive(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CountSemGive_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemTake(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CountSemTake_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemTimedWait(mut sem_id: osal_id_t, mut msecs: uint32) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_CountSemTimedWait_Impl(&mut token, msecs);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemGetIdByName(
    mut sem_id: *mut osal_id_t,
    mut sem_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    if sem_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"OS_CountSemGetIdByName\0",
            ))
            .as_ptr(),
            209 as libc::c_int,
            b"(sem_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if sem_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"OS_CountSemGetIdByName\0",
            ))
            .as_ptr(),
            210 as libc::c_int,
            b"(sem_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(
        osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_name,
        sem_id,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemGetInfo(
    mut sem_id: osal_id_t,
    mut count_prop: *mut OS_count_sem_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if count_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_CountSemGetInfo\0"))
                .as_ptr(),
            230 as libc::c_int,
            b"(count_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        count_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_count_sem_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_countsem_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_count_sem_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        strncpy(
            ((*count_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*count_prop).creator = (*record).creator;
        return_code = OS_CountSemGetInfo_Impl(&mut token, count_prop);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_dir_table: [OS_dir_internal_record_t; 4] =
    [OS_dir_internal_record_t { dir_name: [0; 64] }; 4];
#[no_mangle]
pub unsafe extern "C" fn OS_DirAPI_Init() -> int32 {
    memset(
        OS_dir_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_dir_internal_record_t; 4]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_mkdir(mut path: *const libc::c_char, mut access: uint32) -> int32 {
    let mut return_code: int32 = 0;
    let mut local_path: [libc::c_char; 128] = [0; 128];
    return_code = OS_TranslatePath(path, local_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_DirCreate_Impl(local_path.as_mut_ptr(), access);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirectoryOpen(
    mut dir_id: *mut osal_id_t,
    mut path: *const libc::c_char,
) -> int32 {
    let mut local_path: [libc::c_char; 128] = [0; 128];
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut dir: *mut OS_dir_internal_record_t = 0 as *mut OS_dir_internal_record_t;
    let mut return_code: int32 = 0;
    if dir_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_DirectoryOpen\0"))
                .as_ptr(),
            113 as libc::c_int,
            b"(dir_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_TranslatePath(path, local_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_ObjectIdAllocateNew(
            osal_src_os_shared_src_osapi_dir_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
            0 as *const libc::c_char,
            &mut token,
        );
        if return_code == 0 as libc::c_int {
            dir = &mut *OS_dir_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_dir_internal_record_t;
            memset(
                dir as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<OS_dir_internal_record_t>() as libc::c_ulong,
            );
            strncpy(
                ((*dir).dir_name).as_mut_ptr(),
                path,
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            let ref mut fresh3 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
            *fresh3 = ((*dir).dir_name).as_mut_ptr();
            return_code = OS_DirOpen_Impl(&mut token, local_path.as_mut_ptr());
            return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, dir_id);
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirectoryClose(mut dir_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_dir_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        dir_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_DirClose_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirectoryRead(
    mut dir_id: osal_id_t,
    mut dirent: *mut os_dirent_t,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if dirent.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_DirectoryRead\0"))
                .as_ptr(),
            174 as libc::c_int,
            b"(dirent) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_dir_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        dir_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_DirRead_Impl(&mut token, dirent);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirectoryRewind(mut dir_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_dir_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        dir_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_DirRewind_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_rmdir(mut path: *const libc::c_char) -> int32 {
    let mut return_code: int32 = 0;
    let mut local_path: [libc::c_char; 128] = [0; 128];
    return_code = OS_TranslatePath(path, local_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_DirRemove_Impl(local_path.as_mut_ptr());
    }
    return return_code;
}
static mut OS_GLOBAL_ERROR_NAME_TABLE: [OS_ErrorTable_Entry_t; 42] = [
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: 0 as libc::c_int,
            Name: b"OS_SUCCESS\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(1 as libc::c_int),
            Name: b"OS_ERROR\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(2 as libc::c_int),
            Name: b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(3 as libc::c_int),
            Name: b"OS_ERROR_ADDRESS_MISALIGNED\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(4 as libc::c_int),
            Name: b"OS_ERROR_TIMEOUT\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(5 as libc::c_int),
            Name: b"OS_INVALID_INT_NUM\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(6 as libc::c_int),
            Name: b"OS_SEM_FAILURE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(7 as libc::c_int),
            Name: b"OS_SEM_TIMEOUT\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(8 as libc::c_int),
            Name: b"OS_QUEUE_EMPTY\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(9 as libc::c_int),
            Name: b"OS_QUEUE_FULL\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(10 as libc::c_int),
            Name: b"OS_QUEUE_TIMEOUT\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(11 as libc::c_int),
            Name: b"OS_QUEUE_INVALID_SIZE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(12 as libc::c_int),
            Name: b"OS_QUEUE_ID_ERROR\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(13 as libc::c_int),
            Name: b"OS_ERR_NAME_TOO_LONG\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(14 as libc::c_int),
            Name: b"OS_ERR_NO_FREE_IDS\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(15 as libc::c_int),
            Name: b"OS_ERR_NAME_TAKEN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(16 as libc::c_int),
            Name: b"OS_ERR_INVALID_ID\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(17 as libc::c_int),
            Name: b"OS_ERR_NAME_NOT_FOUND\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(18 as libc::c_int),
            Name: b"OS_ERR_SEM_NOT_FULL\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(19 as libc::c_int),
            Name: b"OS_ERR_INVALID_PRIORITY\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(20 as libc::c_int),
            Name: b"OS_INVALID_SEM_VALUE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(27 as libc::c_int),
            Name: b"OS_ERR_FILE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(28 as libc::c_int),
            Name: b"OS_ERR_NOT_IMPLEMENTED\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(29 as libc::c_int),
            Name: b"OS_TIMER_ERR_INVALID_ARGS\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(30 as libc::c_int),
            Name: b"OS_TIMER_ERR_TIMER_ID\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(31 as libc::c_int),
            Name: b"OS_TIMER_ERR_UNAVAILABLE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(32 as libc::c_int),
            Name: b"OS_TIMER_ERR_INTERNAL\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(33 as libc::c_int),
            Name: b"OS_ERR_OBJECT_IN_USE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(34 as libc::c_int),
            Name: b"OS_ERR_BAD_ADDRESS\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(35 as libc::c_int),
            Name: b"OS_ERR_INCORRECT_OBJ_STATE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(36 as libc::c_int),
            Name: b"OS_ERR_INCORRECT_OBJ_TYPE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(37 as libc::c_int),
            Name: b"OS_ERR_STREAM_DISCONNECTED\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(38 as libc::c_int),
            Name: b"OS_ERR_OPERATION_NOT_SUPPORTED\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(40 as libc::c_int),
            Name: b"OS_ERR_INVALID_SIZE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(41 as libc::c_int),
            Name: b"OS_ERR_OUTPUT_TOO_LARGE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(42 as libc::c_int),
            Name: b"OS_ERR_INVALID_ARGUMENT\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(103 as libc::c_int),
            Name: b"OS_FS_ERR_PATH_TOO_LONG\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(104 as libc::c_int),
            Name: b"OS_FS_ERR_NAME_TOO_LONG\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(106 as libc::c_int),
            Name: b"OS_FS_ERR_DRIVE_NOT_CREATED\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(107 as libc::c_int),
            Name: b"OS_FS_ERR_DEVICE_NOT_FREE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: -(108 as libc::c_int),
            Name: b"OS_FS_ERR_PATH_INVALID\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = OS_ErrorTable_Entry_t {
            Number: 0 as libc::c_int,
            Name: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub unsafe extern "C" fn OS_StatusToString(
    mut status: osal_status_t,
    mut status_string: *mut os_status_string_t,
) -> *mut libc::c_char {
    let mut string: *mut libc::c_char = 0 as *mut libc::c_char;
    if !status_string.is_null() {
        snprintf(
            (*status_string).as_mut_ptr(),
            ::core::mem::size_of::<os_status_string_t>() as libc::c_ulong,
            b"%ld\0" as *const u8 as *const libc::c_char,
            OS_StatusToInteger(status),
        );
        string = (*status_string).as_mut_ptr();
    }
    return string;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetErrorName(
    mut error_num: int32,
    mut err_name: *mut os_err_name_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut Error: *const OS_ErrorTable_Entry_t = 0 as *const OS_ErrorTable_Entry_t;
    if err_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_GetErrorName\0"))
                .as_ptr(),
            131 as libc::c_int,
            b"(err_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    Error = OS_GLOBAL_ERROR_NAME_TABLE.as_ptr();
    while !((*Error).Name).is_null() && (*Error).Number != error_num {
        Error = Error.offset(1);
        Error;
    }
    if (*Error).Number != error_num {
        Error = OS_IMPL_ERROR_NAME_TABLE.as_ptr();
        while !((*Error).Name).is_null() && (*Error).Number != error_num {
            Error = Error.offset(1);
            Error;
        }
    }
    if (*Error).Number == error_num && !((*Error).Name).is_null() {
        strncpy(
            (*err_name).as_mut_ptr(),
            (*Error).Name,
            (::core::mem::size_of::<os_err_name_t>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*err_name)[(::core::mem::size_of::<os_err_name_t>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
            0 as libc::c_int as libc::c_char;
        return_code = 0 as libc::c_int;
    } else {
        snprintf(
            (*err_name).as_mut_ptr(),
            35 as libc::c_int as libc::c_ulong,
            b"OS_UNKNOWN(%d)\0" as *const u8 as *const libc::c_char,
            error_num,
        );
        return_code = -(1 as libc::c_int);
    }
    (*err_name)[(35 as libc::c_int - 1 as libc::c_int) as usize] = '\0' as i32 as libc::c_char;
    return return_code;
}
#[no_mangle]
pub static mut OS_stream_table: [OS_stream_internal_record_t; 50] = [OS_stream_internal_record_t {
    stream_name: [0; 64],
    socket_domain: 0,
    socket_type: 0,
    stream_state: 0,
}; 50];
#[no_mangle]
pub unsafe extern "C" fn OS_FileIteratorClose(
    mut filedes: osal_id_t,
    mut arg: *mut libc::c_void,
) -> int32 {
    return OS_close(filedes);
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileAPI_Init() -> int32 {
    memset(
        OS_stream_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_stream_internal_record_t; 50]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_OpenCreate(
    mut filedes: *mut osal_id_t,
    mut path: *const libc::c_char,
    mut flags: int32,
    mut access_mode: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut local_path: [libc::c_char; 128] = [0; 128];
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    if filedes.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_OpenCreate\0"))
                .as_ptr(),
            115 as libc::c_int,
            b"(filedes) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    *filedes = 0 as libc::c_int as osal_id_t;
    if access_mode != 1 as libc::c_int
        && access_mode != 0 as libc::c_int
        && access_mode != 2 as libc::c_int
    {
        return -(1 as libc::c_int);
    }
    return_code = OS_TranslatePath(path, local_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_ObjectIdAllocateNew(
            osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
            0 as *const libc::c_char,
            &mut token,
        );
        if return_code == 0 as libc::c_int {
            stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_stream_internal_record_t;
            memset(
                stream as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<OS_stream_internal_record_t>() as libc::c_ulong,
            );
            strncpy(
                ((*stream).stream_name).as_mut_ptr(),
                path,
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            let ref mut fresh4 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
            *fresh4 = ((*stream).stream_name).as_mut_ptr();
            return_code = OS_FileOpen_Impl(&mut token, local_path.as_mut_ptr(), flags, access_mode);
            return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, filedes);
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_close(mut filedes: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        filedes,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_GenericClose_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimedRead(
    mut filedes: osal_id_t,
    mut buffer: *mut libc::c_void,
    mut nbytes: size_t,
    mut timeout: int32,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if buffer.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 13], &[libc::c_char; 13]>(b"OS_TimedRead\0")).as_ptr(),
            191 as libc::c_int,
            b"(buffer) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(nbytes > 0 as libc::c_int as libc::c_ulong
        && nbytes
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        filedes,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_GenericRead_Impl(&mut token, buffer, nbytes, timeout);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimedWrite(
    mut filedes: osal_id_t,
    mut buffer: *const libc::c_void,
    mut nbytes: size_t,
    mut timeout: int32,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if buffer.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_TimedWrite\0"))
                .as_ptr(),
            217 as libc::c_int,
            b"(buffer) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(nbytes > 0 as libc::c_int as libc::c_ulong
        && nbytes
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        filedes,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_GenericWrite_Impl(&mut token, buffer, nbytes, timeout);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_read(
    mut filedes: osal_id_t,
    mut buffer: *mut libc::c_void,
    mut nbytes: size_t,
) -> int32 {
    return OS_TimedRead(filedes, buffer, nbytes, -(1 as libc::c_int));
}
#[no_mangle]
pub unsafe extern "C" fn OS_write(
    mut filedes: osal_id_t,
    mut buffer: *const libc::c_void,
    mut nbytes: size_t,
) -> int32 {
    return OS_TimedWrite(filedes, buffer, nbytes, -(1 as libc::c_int));
}
#[no_mangle]
pub unsafe extern "C" fn OS_chmod(mut path: *const libc::c_char, mut access_mode: uint32) -> int32 {
    let mut local_path: [libc::c_char; 128] = [0; 128];
    let mut return_code: int32 = 0;
    return_code = OS_TranslatePath(path, local_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_FileChmod_Impl(local_path.as_mut_ptr(), access_mode);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_stat(
    mut path: *const libc::c_char,
    mut filestats: *mut os_fstat_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut local_path: [libc::c_char; 128] = [0; 128];
    if filestats.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"OS_stat\0")).as_ptr(),
            284 as libc::c_int,
            b"(filestats) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        filestats as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<os_fstat_t>() as libc::c_ulong,
    );
    return_code = OS_TranslatePath(path, local_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_FileStat_Impl(local_path.as_mut_ptr(), filestats);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_lseek(
    mut filedes: osal_id_t,
    mut offset: int32,
    mut whence: uint32,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        filedes,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_GenericSeek_Impl(&mut token, offset, whence);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_remove(mut path: *const libc::c_char) -> int32 {
    let mut return_code: int32 = 0;
    let mut local_path: [libc::c_char; 128] = [0; 128];
    return_code = OS_TranslatePath(path, local_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_FileRemove_Impl(local_path.as_mut_ptr());
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_rename(
    mut old_filename: *const libc::c_char,
    mut new_filename: *const libc::c_char,
) -> int32 {
    let mut iter: OS_object_iter_t = OS_object_iter_t {
        base: 0 as *mut OS_common_record_t,
        match_0: None,
        arg: 0 as *mut libc::c_void,
        limit: 0,
        token: OS_object_token_t {
            lock_mode: OS_LOCK_MODE_NONE,
            lock_key: osal_key_t { key_value: 0 },
            obj_type: 0,
            obj_idx: 0,
            obj_id: 0,
        },
    };
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut return_code: int32 = 0;
    let mut old_path: [libc::c_char; 128] = [0; 128];
    let mut new_path: [libc::c_char; 128] = [0; 128];
    return_code = OS_TranslatePath(old_filename, old_path.as_mut_ptr());
    if return_code == 0 as libc::c_int {
        return_code = OS_TranslatePath(new_filename, new_path.as_mut_ptr());
    }
    if return_code == 0 as libc::c_int {
        return_code = OS_FileRename_Impl(old_path.as_mut_ptr(), new_path.as_mut_ptr());
    }
    if return_code == 0 as libc::c_int {
        OS_ObjectIdIterateActive(
            osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
            &mut iter,
        );
        while OS_ObjectIdIteratorGetNext(&mut iter) {
            stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut iter.token
            ) as isize) as *mut OS_stream_internal_record_t;
            if (*stream).socket_domain as libc::c_int == OS_SocketDomain_INVALID as libc::c_int
                && strcmp(((*stream).stream_name).as_mut_ptr(), old_filename) == 0 as libc::c_int
            {
                strncpy(
                    ((*stream).stream_name).as_mut_ptr(),
                    new_filename,
                    (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                );
                (*stream).stream_name[(::core::mem::size_of::<[libc::c_char; 64]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    as usize] = 0 as libc::c_int as libc::c_char;
            }
        }
        OS_ObjectIdIteratorDestroy(&mut iter);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_cp(
    mut src: *const libc::c_char,
    mut dest: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut rd_size: int32 = 0;
    let mut wr_size: int32 = 0;
    let mut wr_total: int32 = 0;
    let mut file1: osal_id_t = 0;
    let mut file2: osal_id_t = 0;
    let mut copyblock: [uint8; 512] = [0; 512];
    if src.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 6], &[libc::c_char; 6]>(b"OS_cp\0")).as_ptr(),
            402 as libc::c_int,
            b"(src) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if dest.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 6], &[libc::c_char; 6]>(b"OS_cp\0")).as_ptr(),
            403 as libc::c_int,
            b"(dest) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    file1 = 0 as libc::c_int as osal_id_t;
    file2 = 0 as libc::c_int as osal_id_t;
    return_code = OS_OpenCreate(
        &mut file1,
        src,
        OS_FILE_FLAG_NONE as libc::c_int,
        0 as libc::c_int,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_OpenCreate(
            &mut file2,
            dest,
            OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
            1 as libc::c_int,
        );
    }
    while return_code == 0 as libc::c_int {
        rd_size = OS_read(
            file1,
            copyblock.as_mut_ptr() as *mut libc::c_void,
            ::core::mem::size_of::<[uint8; 512]>() as libc::c_ulong,
        );
        if rd_size < 0 as libc::c_int {
            return_code = rd_size;
            break;
        } else {
            if rd_size == 0 as libc::c_int {
                break;
            }
            wr_total = 0 as libc::c_int;
            while wr_total < rd_size {
                wr_size = OS_write(
                    file2,
                    &mut *copyblock.as_mut_ptr().offset(wr_total as isize) as *mut uint8
                        as *const libc::c_void,
                    (rd_size - wr_total) as size_t,
                );
                if wr_size < 0 as libc::c_int {
                    return_code = wr_size;
                    break;
                } else {
                    wr_total += wr_size;
                }
            }
        }
    }
    if OS_ObjectIdDefined(file1) {
        OS_close(file1);
    }
    if OS_ObjectIdDefined(file2) {
        OS_close(file2);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_mv(
    mut src: *const libc::c_char,
    mut dest: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    return_code = OS_rename(src, dest);
    if return_code != 0 as libc::c_int {
        return_code = OS_cp(src, dest);
        if return_code == 0 as libc::c_int {
            OS_remove(src);
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FDGetInfo(
    mut filedes: osal_id_t,
    mut fd_prop: *mut OS_file_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if fd_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 13], &[libc::c_char; 13]>(b"OS_FDGetInfo\0")).as_ptr(),
            487 as libc::c_int,
            b"(fd_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        fd_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_file_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        filedes,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_stream_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        if !((*record).name_entry).is_null() {
            strncpy(
                ((*fd_prop).Path).as_mut_ptr(),
                (*record).name_entry,
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
        }
        (*fd_prop).User = (*record).creator;
        (*fd_prop).IsValid = 1 as libc::c_int as uint8;
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileOpenCheck(mut Filename: *const libc::c_char) -> int32 {
    let mut return_code: int32 = 0;
    let mut iter: OS_object_iter_t = OS_object_iter_t {
        base: 0 as *mut OS_common_record_t,
        match_0: None,
        arg: 0 as *mut libc::c_void,
        limit: 0,
        token: OS_object_token_t {
            lock_mode: OS_LOCK_MODE_NONE,
            lock_key: osal_key_t { key_value: 0 },
            obj_type: 0,
            obj_idx: 0,
            obj_id: 0,
        },
    };
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    if Filename.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_FileOpenCheck\0"))
                .as_ptr(),
            523 as libc::c_int,
            b"(Filename) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = -(1 as libc::c_int);
    OS_ObjectIdIterateActive(
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        &mut iter,
    );
    while OS_ObjectIdIteratorGetNext(&mut iter) {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut iter.token
        ) as isize) as *mut OS_stream_internal_record_t;
        if !((*stream).socket_domain as libc::c_int == OS_SocketDomain_INVALID as libc::c_int
            && strcmp(((*stream).stream_name).as_mut_ptr(), Filename) == 0 as libc::c_int)
        {
            continue;
        }
        return_code = 0 as libc::c_int;
        break;
    }
    OS_ObjectIdIteratorDestroy(&mut iter);
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CloseFileByName(mut Filename: *const libc::c_char) -> int32 {
    let mut return_code: int32 = 0;
    let mut close_code: int32 = 0;
    let mut iter: OS_object_iter_t = OS_object_iter_t {
        base: 0 as *mut OS_common_record_t,
        match_0: None,
        arg: 0 as *mut libc::c_void,
        limit: 0,
        token: OS_object_token_t {
            lock_mode: OS_LOCK_MODE_NONE,
            lock_key: osal_key_t { key_value: 0 },
            obj_type: 0,
            obj_idx: 0,
            obj_id: 0,
        },
    };
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    if Filename.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_CloseFileByName\0"))
                .as_ptr(),
            558 as libc::c_int,
            b"(Filename) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = -(108 as libc::c_int);
    OS_ObjectIdIterateActive(
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        &mut iter,
    );
    while OS_ObjectIdIteratorGetNext(&mut iter) {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut iter.token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*stream).socket_domain as libc::c_int == OS_SocketDomain_INVALID as libc::c_int
            && strcmp(((*stream).stream_name).as_mut_ptr(), Filename) == 0 as libc::c_int
        {
            close_code = OS_ObjectIdIteratorProcessEntry(
                &mut iter,
                Some(
                    OS_FileIteratorClose
                        as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> int32,
                ),
            );
            if return_code == -(108 as libc::c_int) || close_code != 0 as libc::c_int {
                return_code = close_code;
            }
        }
    }
    OS_ObjectIdIteratorDestroy(&mut iter);
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CloseAllFiles() -> int32 {
    let mut return_code: int32 = 0;
    let mut close_code: int32 = 0;
    let mut iter: OS_object_iter_t = OS_object_iter_t {
        base: 0 as *mut OS_common_record_t,
        match_0: None,
        arg: 0 as *mut libc::c_void,
        limit: 0,
        token: OS_object_token_t {
            lock_mode: OS_LOCK_MODE_NONE,
            lock_key: osal_key_t { key_value: 0 },
            obj_type: 0,
            obj_idx: 0,
            obj_id: 0,
        },
    };
    return_code = 0 as libc::c_int;
    OS_ObjectIdIterateActive(
        osal_src_os_shared_src_osapi_file_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        &mut iter,
    );
    while OS_ObjectIdIteratorGetNext(&mut iter) {
        close_code = OS_ObjectIdIteratorProcessEntry(
            &mut iter,
            Some(
                OS_FileIteratorClose as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> int32,
            ),
        );
        if close_code != 0 as libc::c_int {
            return_code = close_code;
        }
    }
    OS_ObjectIdIteratorDestroy(&mut iter);
    return return_code;
}
#[no_mangle]
pub static mut OS_filesys_table: [OS_filesys_internal_record_t; 14] =
    [OS_filesys_internal_record_t {
        device_name: [0; 32],
        volume_name: [0; 32],
        system_mountpt: [0; 128],
        virtual_mountpt: [0; 64],
        address: 0 as *const libc::c_char as *mut libc::c_char,
        blocksize: 0,
        numblocks: 0,
        flags: 0,
        fstype: 0,
    }; 14];
#[no_mangle]
pub static mut OS_FILESYS_RAMDISK_VOLNAME_PREFIX: [libc::c_char; 4] =
    unsafe { *::core::mem::transmute::<&[u8; 4], &[libc::c_char; 4]>(b"RAM\0") };
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysFilterFree(
    mut ref_0: *mut libc::c_void,
    mut token: *const OS_object_token_t,
    mut obj: *const OS_common_record_t,
) -> bool {
    return !OS_ObjectIdDefined((*obj).active_id);
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSys_FindVirtMountPoint(
    mut ref_0: *mut libc::c_void,
    mut token: *const OS_object_token_t,
    mut obj: *const OS_common_record_t,
) -> bool {
    let mut filesys: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    let mut target: *const libc::c_char = ref_0 as *const libc::c_char;
    let mut mplen: size_t = 0;
    filesys = &mut *OS_filesys_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_filesys_internal_record_t;
    if (*filesys).flags as libc::c_int & 0x20 as libc::c_int == 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    mplen = OS_strnlen(
        ((*filesys).virtual_mountpt).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
    );
    if mplen == 0 as libc::c_int as libc::c_ulong
        || mplen >= ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
        || strncmp(target, ((*filesys).virtual_mountpt).as_mut_ptr(), mplen) != 0 as libc::c_int
    {
        return 0 as libc::c_int != 0;
    }
    return *target.offset(mplen as isize) as libc::c_int == '/' as i32
        || *target.offset(mplen as isize) as libc::c_int == 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSys_Initialize(
    mut address: *mut libc::c_char,
    mut fsdevname: *const libc::c_char,
    mut fsvolname: *const libc::c_char,
    mut blocksize: size_t,
    mut numblocks: osal_blockcount_t,
    mut should_format: bool,
) -> int32 {
    let mut filesys: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if fsdevname.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_FileSys_Initialize\0"))
                .as_ptr(),
            144 as libc::c_int,
            b"(fsdevname) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        fsdevname as *const libc::c_void,
        '\0' as i32,
        ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    if fsvolname.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_FileSys_Initialize\0"))
                .as_ptr(),
            145 as libc::c_int,
            b"(fsvolname) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        fsvolname as *const libc::c_void,
        '\0' as i32,
        ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    if *fsdevname.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
        || *fsvolname.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
    {
        return -(108 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        fsdevname,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        filesys = &mut *OS_filesys_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_filesys_internal_record_t;
        memset(
            filesys as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_filesys_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*filesys).device_name).as_mut_ptr(),
            fsdevname,
            (::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh5 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh5 = ((*filesys).device_name).as_mut_ptr();
        (*filesys).blocksize = blocksize;
        (*filesys).numblocks = numblocks;
        (*filesys).address = address;
        strncpy(
            ((*filesys).volume_name).as_mut_ptr(),
            fsvolname,
            (::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        if !((*filesys).address).is_null()
            || strncmp(
                ((*filesys).volume_name).as_mut_ptr(),
                OS_FILESYS_RAMDISK_VOLNAME_PREFIX.as_ptr(),
                (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            ) == 0 as libc::c_int
        {
            (*filesys).fstype = OS_FILESYS_TYPE_VOLATILE_DISK as libc::c_int as uint8;
        }
        return_code = OS_FileSysStartVolume_Impl(&mut token);
        if return_code == 0 as libc::c_int {
            if should_format {
                return_code = OS_FileSysFormatVolume_Impl(&mut token);
            }
            if return_code == 0 as libc::c_int {
                (*filesys).flags = ((*filesys).flags as libc::c_int | 0x2 as libc::c_int) as uint8;
            } else {
                OS_FileSysStopVolume_Impl(&mut token);
            }
        }
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, 0 as *mut osal_id_t);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysAPI_Init() -> int32 {
    let mut return_code: int32 = 0 as libc::c_int;
    memset(
        OS_filesys_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_filesys_internal_record_t; 14]>() as libc::c_ulong,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysAddFixedMap(
    mut filesys_id: *mut osal_id_t,
    mut phys_path: *const libc::c_char,
    mut virt_path: *const libc::c_char,
) -> int32 {
    let mut filesys: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if filesys_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_FileSysAddFixedMap\0"))
                .as_ptr(),
            250 as libc::c_int,
            b"(filesys_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if phys_path.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_FileSysAddFixedMap\0"))
                .as_ptr(),
            251 as libc::c_int,
            b"(phys_path) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        phys_path as *const libc::c_void,
        '\0' as i32,
        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    if virt_path.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_FileSysAddFixedMap\0"))
                .as_ptr(),
            252 as libc::c_int,
            b"(virt_path) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        virt_path as *const libc::c_void,
        '\0' as i32,
        64 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        virt_path,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        filesys = &mut *OS_filesys_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_filesys_internal_record_t;
        memset(
            filesys as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_filesys_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*filesys).virtual_mountpt).as_mut_ptr(),
            virt_path,
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh6 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh6 = ((*filesys).virtual_mountpt).as_mut_ptr();
        strncpy(
            ((*filesys).system_mountpt).as_mut_ptr(),
            phys_path,
            (::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        strncpy(
            ((*filesys).virtual_mountpt).as_mut_ptr(),
            virt_path,
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*filesys).fstype = OS_FILESYS_TYPE_FS_BASED as libc::c_int as uint8;
        (*filesys).flags = 0x1 as libc::c_int as uint8;
        return_code = OS_FileSysStartVolume_Impl(&mut token);
        if return_code == 0 as libc::c_int {
            (*filesys).flags = ((*filesys).flags as libc::c_int | 0x2 as libc::c_int) as uint8;
            return_code = OS_FileSysMountVolume_Impl(&mut token);
        }
        if return_code == 0 as libc::c_int {
            (*filesys).flags = ((*filesys).flags as libc::c_int
                | (0x10 as libc::c_int | 0x20 as libc::c_int))
                as uint8;
        }
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, filesys_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_mkfs(
    mut address: *mut libc::c_char,
    mut devname: *const libc::c_char,
    mut volname: *const libc::c_char,
    mut blocksize: size_t,
    mut numblocks: osal_blockcount_t,
) -> int32 {
    let mut return_code: int32 = 0;
    return_code = OS_FileSys_Initialize(
        address,
        devname,
        volname,
        blocksize,
        numblocks,
        1 as libc::c_int != 0,
    );
    if return_code == -(35 as libc::c_int) || return_code == -(14 as libc::c_int) {
        return_code = -(107 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_rmfs(mut devname: *const libc::c_char) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if devname.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"OS_rmfs\0")).as_ptr(),
            337 as libc::c_int,
            b"(devname) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        devname as *const libc::c_void,
        '\0' as i32,
        64 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    return_code = OS_ObjectIdGetByName(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        devname,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_FileSysStopVolume_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    } else {
        return_code = -(17 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_initfs(
    mut address: *mut libc::c_char,
    mut devname: *const libc::c_char,
    mut volname: *const libc::c_char,
    mut blocksize: size_t,
    mut numblocks: osal_blockcount_t,
) -> int32 {
    let mut return_code: int32 = 0;
    return_code = OS_FileSys_Initialize(
        address,
        devname,
        volname,
        blocksize,
        numblocks,
        0 as libc::c_int != 0,
    );
    if return_code == -(35 as libc::c_int) || return_code == -(14 as libc::c_int) {
        return_code = -(107 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_chkfs(mut name: *const libc::c_char, mut repair: bool) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"OS_chkfs\0")).as_ptr(),
            553 as libc::c_int,
            b"(name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        name as *const libc::c_void,
        '\0' as i32,
        64 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    return_code = OS_ObjectIdGetBySearch(
        OS_LOCK_MODE_REFCOUNT,
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        Some(
            OS_FileSys_FindVirtMountPoint
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        name as *mut libc::c_void,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_FileSysCheckVolume_Impl(&mut token, repair);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FS_GetPhysDriveName(
    mut PhysDriveName: *mut libc::c_char,
    mut MountPoint: *const libc::c_char,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    let mut filesys: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    if MountPoint.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"OS_FS_GetPhysDriveName\0",
            ))
            .as_ptr(),
            582 as libc::c_int,
            b"(MountPoint) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        MountPoint as *const libc::c_void,
        '\0' as i32,
        64 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    if PhysDriveName.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"OS_FS_GetPhysDriveName\0",
            ))
            .as_ptr(),
            583 as libc::c_int,
            b"(PhysDriveName) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetBySearch(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        Some(
            OS_FileSys_FindVirtMountPoint
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        MountPoint as *mut libc::c_void,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        filesys = &mut *OS_filesys_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_filesys_internal_record_t;
        if (*filesys).flags as libc::c_int & 0x10 as libc::c_int != 0 as libc::c_int {
            strncpy(
                PhysDriveName,
                ((*filesys).system_mountpt).as_mut_ptr(),
                (64 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
            );
            *PhysDriveName.offset((64 as libc::c_int - 1 as libc::c_int) as isize) =
                0 as libc::c_int as libc::c_char;
        } else {
            return_code = -(35 as libc::c_int);
        }
        OS_ObjectIdRelease(&mut token);
    } else {
        return_code = -(17 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetFsInfo(mut filesys_info: *mut os_fsinfo_t) -> int32 {
    let mut iter: OS_object_iter_t = OS_object_iter_t {
        base: 0 as *mut OS_common_record_t,
        match_0: None,
        arg: 0 as *mut libc::c_void,
        limit: 0,
        token: OS_object_token_t {
            lock_mode: OS_LOCK_MODE_NONE,
            lock_key: osal_key_t { key_value: 0 },
            obj_type: 0,
            obj_idx: 0,
            obj_id: 0,
        },
    };
    if filesys_info.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 13], &[libc::c_char; 13]>(b"OS_GetFsInfo\0")).as_ptr(),
            624 as libc::c_int,
            b"(filesys_info) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        filesys_info as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<os_fsinfo_t>() as libc::c_ulong,
    );
    (*filesys_info).MaxFds = 50 as libc::c_int as uint32;
    (*filesys_info).MaxVolumes = 14 as libc::c_int as uint32;
    OS_ObjectIdIteratorInit(
        Some(
            OS_FileSysFilterFree
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        0 as *mut libc::c_void,
        0x6 as libc::c_int as osal_objtype_t,
        &mut iter,
    );
    while OS_ObjectIdIteratorGetNext(&mut iter) {
        (*filesys_info).FreeFds = ((*filesys_info).FreeFds).wrapping_add(1);
        (*filesys_info).FreeFds;
    }
    OS_ObjectIdIteratorDestroy(&mut iter);
    OS_ObjectIdIteratorInit(
        Some(
            OS_FileSysFilterFree
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        0 as *mut libc::c_void,
        0xb as libc::c_int as osal_objtype_t,
        &mut iter,
    );
    while OS_ObjectIdIteratorGetNext(&mut iter) {
        (*filesys_info).FreeVolumes = ((*filesys_info).FreeVolumes).wrapping_add(1);
        (*filesys_info).FreeVolumes;
    }
    OS_ObjectIdIteratorDestroy(&mut iter);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysStatVolume(
    mut name: *const libc::c_char,
    mut statbuf: *mut OS_statvfs_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_FileSysStatVolume\0"))
                .as_ptr(),
            525 as libc::c_int,
            b"(name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        name as *const libc::c_void,
        '\0' as i32,
        64 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    if statbuf.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_FileSysStatVolume\0"))
                .as_ptr(),
            526 as libc::c_int,
            b"(statbuf) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetBySearch(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        Some(
            OS_FileSys_FindVirtMountPoint
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        name as *mut libc::c_void,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_FileSysStatVolume_Impl(&mut token, statbuf);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_unmount(mut mountpoint: *const libc::c_char) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut filesys: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    if mountpoint.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"OS_unmount\0")).as_ptr(),
            468 as libc::c_int,
            b"(mountpoint) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        mountpoint as *const libc::c_void,
        '\0' as i32,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    return_code = OS_ObjectIdGetBySearch(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        Some(
            OS_FileSys_FindVirtMountPoint
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        mountpoint as *mut libc::c_void,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        filesys = &mut *OS_filesys_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_filesys_internal_record_t;
        if (*filesys).flags as libc::c_int & !(0x1 as libc::c_int)
            != 0x2 as libc::c_int | 0x10 as libc::c_int | 0x20 as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else {
            return_code = OS_FileSysUnmountVolume_Impl(&mut token);
        }
        if return_code == 0 as libc::c_int {
            (*filesys).flags = ((*filesys).flags as libc::c_int
                & !(0x10 as libc::c_int | 0x20 as libc::c_int))
                as uint8;
        }
        OS_ObjectIdRelease(&mut token);
    }
    if return_code != 0 as libc::c_int {
        return_code = -(17 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_mount(
    mut devname: *const libc::c_char,
    mut mountpoint: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut filesys: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    if devname.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"OS_mount\0")).as_ptr(),
            403 as libc::c_int,
            b"(devname) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        devname as *const libc::c_void,
        '\0' as i32,
        ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    if mountpoint.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"OS_mount\0")).as_ptr(),
            404 as libc::c_int,
            b"(mountpoint) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        mountpoint as *const libc::c_void,
        '\0' as i32,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return -(103 as libc::c_int);
    }
    return_code = OS_ObjectIdGetByName(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        devname,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        filesys = &mut *OS_filesys_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_filesys_internal_record_t;
        if (*filesys).flags as libc::c_int & !(0x1 as libc::c_int) != 0x2 as libc::c_int {
            return_code = -(35 as libc::c_int);
        } else if (*filesys).system_mountpt[0 as libc::c_int as usize] as libc::c_int
            == 0 as libc::c_int
        {
            return_code = -(108 as libc::c_int);
        } else {
            return_code = OS_FileSysMountVolume_Impl(&mut token);
        }
        if return_code == 0 as libc::c_int {
            (*filesys).flags = ((*filesys).flags as libc::c_int
                | (0x10 as libc::c_int | 0x20 as libc::c_int))
                as uint8;
            strncpy(
                ((*filesys).virtual_mountpt).as_mut_ptr(),
                mountpoint,
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*filesys).virtual_mountpt[(::core::mem::size_of::<[libc::c_char; 64]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
        }
        OS_ObjectIdRelease(&mut token);
    }
    if return_code != 0 as libc::c_int {
        return_code = -(17 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TranslatePath(
    mut VirtualPath: *const libc::c_char,
    mut LocalPath: *mut libc::c_char,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    let mut name_ptr: *const libc::c_char = 0 as *const libc::c_char;
    let mut filesys: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    let mut SysMountPointLen: size_t = 0;
    let mut VirtPathLen: size_t = 0;
    let mut VirtPathBegin: size_t = 0;
    if VirtualPath.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_TranslatePath\0"))
                .as_ptr(),
            668 as libc::c_int,
            b"(VirtualPath) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if LocalPath.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_TranslatePath\0"))
                .as_ptr(),
            669 as libc::c_int,
            b"(LocalPath) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    VirtPathLen = OS_strnlen(VirtualPath, 64 as libc::c_int as size_t);
    if VirtPathLen >= 64 as libc::c_int as libc::c_ulong {
        return -(103 as libc::c_int);
    }
    name_ptr = strrchr(VirtualPath, '/' as i32);
    if name_ptr.is_null() {
        return -(108 as libc::c_int);
    }
    name_ptr = name_ptr.offset(1 as libc::c_int as isize);
    if (memchr(
        name_ptr as *const libc::c_void,
        0 as libc::c_int,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(104 as libc::c_int);
    }
    SysMountPointLen = 0 as libc::c_int as size_t;
    VirtPathBegin = VirtPathLen;
    if *VirtualPath.offset(0 as libc::c_int as isize) as libc::c_int != '/' as i32 {
        return -(108 as libc::c_int);
    }
    return_code = OS_ObjectIdGetBySearch(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_filesys_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        Some(
            OS_FileSys_FindVirtMountPoint
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        VirtualPath as *mut libc::c_void,
        &mut token,
    );
    if return_code != 0 as libc::c_int {
        return_code = -(108 as libc::c_int);
    } else {
        filesys = &mut *OS_filesys_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_filesys_internal_record_t;
        if (*filesys).flags as libc::c_int & 0x10 as libc::c_int != 0 as libc::c_int {
            SysMountPointLen = OS_strnlen(
                ((*filesys).system_mountpt).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
            );
            VirtPathBegin = OS_strnlen(
                ((*filesys).virtual_mountpt).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            );
            if SysMountPointLen < (64 as libc::c_int + 64 as libc::c_int) as libc::c_ulong {
                memcpy(
                    LocalPath as *mut libc::c_void,
                    ((*filesys).system_mountpt).as_mut_ptr() as *const libc::c_void,
                    SysMountPointLen,
                );
            }
        } else {
            return_code = -(35 as libc::c_int);
        }
        OS_ObjectIdRelease(&mut token);
    }
    if return_code == 0 as libc::c_int {
        if VirtPathLen < VirtPathBegin {
            return_code = -(108 as libc::c_int);
        } else {
            VirtPathLen =
                (VirtPathLen as libc::c_ulong).wrapping_sub(VirtPathBegin) as size_t as size_t;
            if SysMountPointLen.wrapping_add(VirtPathLen)
                < (64 as libc::c_int + 64 as libc::c_int) as libc::c_ulong
            {
                memcpy(
                    &mut *LocalPath.offset(SysMountPointLen as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    &*VirtualPath.offset(VirtPathBegin as isize) as *const libc::c_char
                        as *const libc::c_void,
                    VirtPathLen,
                );
                *LocalPath.offset(SysMountPointLen.wrapping_add(VirtPathLen) as isize) =
                    0 as libc::c_int as libc::c_char;
            } else {
                return_code = -(103 as libc::c_int);
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_HeapGetInfo(mut heap_prop: *mut OS_heap_prop_t) -> int32 {
    if heap_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_HeapGetInfo\0"))
                .as_ptr(),
            50 as libc::c_int,
            b"(heap_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return OS_HeapGetInfo_Impl(heap_prop);
}
static mut OS_common_table: [OS_common_record_t; 296] = [OS_common_record_t {
    name_entry: 0 as *const libc::c_char,
    active_id: 0,
    creator: 0,
    refcount: 0,
}; 296];
#[no_mangle]
pub static mut OS_objtype_state: [OS_objtype_state_t; 16] = [OS_objtype_state_t {
    last_id_issued: 0,
    transaction_count: 0,
    owner_key: osal_key_t { key_value: 0 },
}; 16];
#[no_mangle]
pub static mut OS_global_task_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_queue_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_bin_sem_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_count_sem_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_mutex_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_stream_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_dir_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_timebase_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_timecb_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_module_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_filesys_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_console_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub static mut OS_global_condvar_table: *mut OS_common_record_t =
    0 as *const OS_common_record_t as *mut OS_common_record_t;
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdInit() -> int32 {
    memset(
        OS_common_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_common_record_t; 296]>() as libc::c_ulong,
    );
    memset(
        OS_objtype_state.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_objtype_state_t; 16]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetMaxForObjectType(mut idtype: osal_objtype_t) -> uint32 {
    match idtype {
        1 => return 64 as libc::c_int as uint32,
        2 => return 64 as libc::c_int as uint32,
        4 => return 20 as libc::c_int as uint32,
        3 => return 20 as libc::c_int as uint32,
        5 => return 20 as libc::c_int as uint32,
        6 => return 50 as libc::c_int as uint32,
        7 => return 4 as libc::c_int as uint32,
        8 => return 5 as libc::c_int as uint32,
        9 => return 10 as libc::c_int as uint32,
        10 => return 20 as libc::c_int as uint32,
        11 => return 14 as libc::c_int as uint32,
        12 => return 1 as libc::c_int as uint32,
        13 => return 4 as libc::c_int as uint32,
        _ => return 0 as libc::c_int as uint32,
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetBaseForObjectType(mut idtype: osal_objtype_t) -> uint32 {
    match idtype {
        1 => return OS_TASK_BASE as libc::c_int as uint32,
        2 => return OS_QUEUE_BASE as libc::c_int as uint32,
        4 => return OS_BINSEM_BASE as libc::c_int as uint32,
        3 => return OS_COUNTSEM_BASE as libc::c_int as uint32,
        5 => return OS_MUTEX_BASE as libc::c_int as uint32,
        6 => return OS_STREAM_BASE as libc::c_int as uint32,
        7 => return OS_DIR_BASE as libc::c_int as uint32,
        8 => return OS_TIMEBASE_BASE as libc::c_int as uint32,
        9 => return OS_TIMECB_BASE as libc::c_int as uint32,
        10 => return OS_MODULE_BASE as libc::c_int as uint32,
        11 => return OS_FILESYS_BASE as libc::c_int as uint32,
        12 => return OS_CONSOLE_BASE as libc::c_int as uint32,
        13 => return OS_CONDVAR_BASE as libc::c_int as uint32,
        _ => return 0 as libc::c_int as uint32,
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_ForEachFilterCreator(
    mut ref_0: *mut libc::c_void,
    mut token: *const OS_object_token_t,
    mut obj: *const OS_common_record_t,
) -> bool {
    let mut filter: *mut OS_creator_filter_t = ref_0 as *mut OS_creator_filter_t;
    return OS_ObjectIdIsValid((*obj).active_id) as libc::c_int != 0
        && (OS_ObjectIdEqual((*filter).creator_id, 0 as libc::c_int as osal_id_t) as libc::c_int
            != 0
            || OS_ObjectIdEqual((*obj).creator, (*filter).creator_id) as libc::c_int != 0);
}
#[no_mangle]
pub unsafe extern "C" fn OS_ForEachDoCallback(
    mut obj_id: osal_id_t,
    mut ref_0: *mut libc::c_void,
) -> int32 {
    let mut filter: *mut OS_creator_filter_t = ref_0 as *mut OS_creator_filter_t;
    ((*filter).user_callback).expect("non-null function pointer")(obj_id, (*filter).user_arg);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdGlobalFromToken(
    mut token: *const OS_object_token_t,
) -> *mut OS_common_record_t {
    let mut base_idx: uint32 = OS_GetBaseForObjectType((*token).obj_type);
    return &mut *OS_common_table
        .as_mut_ptr()
        .offset(base_idx.wrapping_add((*token).obj_idx) as isize)
        as *mut OS_common_record_t;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectNameMatch(
    mut ref_0: *mut libc::c_void,
    mut token: *const OS_object_token_t,
    mut obj: *const OS_common_record_t,
) -> bool {
    return !((*obj).name_entry).is_null()
        && strcmp(ref_0 as *const libc::c_char, (*obj).name_entry) == 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdTransactionInit(
    mut lock_mode: OS_lock_mode_t,
    mut idtype: osal_objtype_t,
    mut token: *mut OS_object_token_t,
) -> int32 {
    memset(
        token as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_object_token_t>() as libc::c_ulong,
    );
    if OS_SharedGlobalVars.GlobalState != 0xbe57c0de as libc::c_uint
        && OS_SharedGlobalVars.GlobalState != 0xabadc0de as libc::c_uint
    {
        return -(1 as libc::c_int);
    }
    if OS_SharedGlobalVars.GlobalState == 0xabadc0de as libc::c_uint
        && lock_mode as libc::c_uint != OS_LOCK_MODE_EXCLUSIVE as libc::c_int as libc::c_uint
    {
        return -(35 as libc::c_int);
    }
    if OS_GetMaxForObjectType(idtype) == 0 as libc::c_int as libc::c_uint {
        return -(16 as libc::c_int);
    }
    (*token).lock_mode = lock_mode;
    (*token).obj_type = idtype;
    (*token).obj_idx = -(1 as libc::c_int) as osal_index_t;
    if lock_mode as libc::c_uint != OS_LOCK_MODE_NONE as libc::c_int as libc::c_uint {
        OS_Lock_Global(token);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdTransactionCancel(mut token: *mut OS_object_token_t) {
    if (*token).lock_mode as libc::c_uint != OS_LOCK_MODE_NONE as libc::c_int as libc::c_uint {
        OS_Unlock_Global(token);
        (*token).lock_mode = OS_LOCK_MODE_NONE;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdConvertToken(mut token: *mut OS_object_token_t) -> int32 {
    let mut return_code: int32 = -(1 as libc::c_int);
    let mut attempts: uint32 = 0 as libc::c_int as uint32;
    let mut obj: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut expected_id: osal_id_t = 0;
    obj = OS_ObjectIdGlobalFromToken(token);
    expected_id = OS_ObjectIdFromToken(token);
    if !OS_ObjectIdIsValid(expected_id) {
        return -(35 as libc::c_int);
    }
    if (*token).lock_mode as libc::c_uint == OS_LOCK_MODE_RESERVED as libc::c_int as libc::c_uint {
        expected_id = 0xffffffff as libc::c_uint;
    }
    loop {
        if OS_ObjectIdEqual((*obj).active_id, expected_id) {
            if (*token).lock_mode as libc::c_uint
                == OS_LOCK_MODE_EXCLUSIVE as libc::c_int as libc::c_uint
            {
                if !OS_ObjectIdEqual(expected_id, 0xffffffff as libc::c_uint) {
                    expected_id = 0xffffffff as libc::c_uint;
                    (*obj).active_id = expected_id;
                }
                if (*obj).refcount as libc::c_int == 0 as libc::c_int {
                    return_code = 0 as libc::c_int;
                    break;
                }
            } else {
                return_code = 0 as libc::c_int;
                break;
            }
        } else if (*token).lock_mode as libc::c_uint
            == OS_LOCK_MODE_NONE as libc::c_int as libc::c_uint
            || !OS_ObjectIdEqual((*obj).active_id, 0xffffffff as libc::c_uint)
        {
            return_code = -(16 as libc::c_int);
            break;
        }
        attempts = attempts.wrapping_add(1);
        attempts;
        if attempts >= 5 as libc::c_int as libc::c_uint {
            return_code = -(33 as libc::c_int);
            break;
        } else {
            OS_WaitForStateChange(token, attempts);
        }
    }
    if (*token).lock_mode as libc::c_uint != OS_LOCK_MODE_NONE as libc::c_int as libc::c_uint {
        if return_code == 0 as libc::c_int {
            (*obj).refcount = ((*obj).refcount).wrapping_add(1);
            (*obj).refcount;
            if (*token).lock_mode as libc::c_uint
                == OS_LOCK_MODE_REFCOUNT as libc::c_int as libc::c_uint
                || (*token).lock_mode as libc::c_uint
                    == OS_LOCK_MODE_EXCLUSIVE as libc::c_int as libc::c_uint
            {
                OS_Unlock_Global(token);
            }
        } else if (*token).lock_mode as libc::c_uint
            == OS_LOCK_MODE_EXCLUSIVE as libc::c_int as libc::c_uint
            && OS_ObjectIdEqual(expected_id, 0xffffffff as libc::c_uint) as libc::c_int != 0
        {
            (*obj).active_id = OS_ObjectIdFromToken(token);
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdFindNextMatch(
    mut MatchFunc: OS_ObjectMatchFunc_t,
    mut arg: *mut libc::c_void,
    mut token: *mut OS_object_token_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut obj_count: uint32 = 0;
    let mut base: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    return_code = -(17 as libc::c_int);
    base = &mut *OS_common_table.as_mut_ptr().offset((OS_GetBaseForObjectType
        as unsafe extern "C" fn(osal_objtype_t) -> uint32)(
        (*token).obj_type
    ) as isize) as *mut OS_common_record_t;
    obj_count = OS_GetMaxForObjectType((*token).obj_type);
    (*token).obj_id = 0 as libc::c_int as osal_id_t;
    loop {
        (*token).obj_idx = ((*token).obj_idx).wrapping_add(1);
        (*token).obj_idx;
        if (*token).obj_idx >= obj_count {
            break;
        }
        record = &mut *base.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            token
        ) as isize) as *mut OS_common_record_t;
        if !(OS_ObjectIdDefined((*record).active_id) as libc::c_int != 0
            && MatchFunc.expect("non-null function pointer")(arg, token, record) as libc::c_int
                != 0)
        {
            continue;
        }
        return_code = 0 as libc::c_int;
        (*token).obj_id = (*record).active_id;
        break;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdFindNextFree(mut token: *mut OS_object_token_t) -> int32 {
    let mut max_id: uint32 = 0;
    let mut base_id: uint32 = 0;
    let mut local_id: uint32 = 0 as libc::c_int as uint32;
    let mut serial: uint32 = 0;
    let mut i: uint32 = 0;
    let mut return_code: int32 = 0;
    let mut obj: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut objtype_state: *mut OS_objtype_state_t = 0 as *mut OS_objtype_state_t;
    base_id = OS_GetBaseForObjectType((*token).obj_type);
    max_id = OS_GetMaxForObjectType((*token).obj_type);
    objtype_state = &mut *OS_objtype_state
        .as_mut_ptr()
        .offset((*token).obj_type as isize) as *mut OS_objtype_state_t;
    if max_id == 0 as libc::c_int as libc::c_uint {
        return_code = -(28 as libc::c_int);
        serial = 0 as libc::c_int as uint32;
    } else {
        return_code = -(14 as libc::c_int);
        serial = OS_ObjectIdToSerialNumber_Impl((*objtype_state).last_id_issued);
    }
    i = 0 as libc::c_int as uint32;
    while i < max_id {
        serial = serial.wrapping_add(1);
        local_id = serial.wrapping_rem(max_id);
        if serial >= 0xffff as libc::c_int as libc::c_uint {
            serial = local_id;
        }
        obj = &mut *OS_common_table
            .as_mut_ptr()
            .offset(local_id.wrapping_add(base_id) as isize)
            as *mut OS_common_record_t;
        if !OS_ObjectIdDefined((*obj).active_id) {
            return_code = 0 as libc::c_int;
            break;
        } else {
            i = i.wrapping_add(1);
            i;
        }
    }
    if return_code == 0 as libc::c_int {
        (*token).obj_idx = local_id;
        OS_ObjectIdCompose_Impl((*token).obj_type, serial, &mut (*token).obj_id);
        (*obj).active_id = (*token).obj_id;
        (*obj).name_entry = 0 as *const libc::c_char;
        (*obj).creator = OS_TaskGetId();
        (*obj).refcount = 0 as libc::c_int as uint16;
        (*objtype_state).last_id_issued = (*token).obj_id;
    }
    if return_code != 0 as libc::c_int {
        (*token).obj_idx = -(1 as libc::c_int) as osal_index_t;
        (*token).obj_id = 0 as libc::c_int as osal_id_t;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_Lock_Global(mut token: *mut OS_object_token_t) {
    let mut self_task_id: osal_id_t = 0;
    let mut objtype: *mut OS_objtype_state_t = 0 as *mut OS_objtype_state_t;
    if (*token).obj_type < 0x10 as libc::c_int as libc::c_uint
        && (*token).lock_mode as libc::c_uint != OS_LOCK_MODE_NONE as libc::c_int as libc::c_uint
    {
        objtype = &mut *OS_objtype_state
            .as_mut_ptr()
            .offset((*token).obj_type as isize) as *mut OS_objtype_state_t;
        self_task_id = OS_TaskGetId_Impl();
        OS_Lock_Global_Impl((*token).obj_type);
        if !OS_ObjectIdIsValid(self_task_id) {
            self_task_id = 0xffffffff as libc::c_uint;
        }
        (*token).lock_key.key_value = (0x4d000000 as libc::c_int as libc::c_ulong
            | (OS_ObjectIdToInteger(self_task_id) ^ (*objtype).transaction_count as libc::c_ulong)
                & 0xffffff as libc::c_int as libc::c_ulong)
            as uint32;
        (*objtype).transaction_count = ((*objtype).transaction_count).wrapping_add(1);
        (*objtype).transaction_count;
        if (*objtype).owner_key.key_value != 0 as libc::c_int as libc::c_uint {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_Lock_Global\0"))
                    .as_ptr(),
                716 as libc::c_int as uint32,
                b"ERROR: global %u acquired by task 0x%lx when already assigned key 0x%lx\n\0"
                    as *const u8 as *const libc::c_char,
                (*token).obj_type,
                OS_ObjectIdToInteger(self_task_id),
                (*objtype).owner_key.key_value as libc::c_ulong,
            );
        } else {
            (*objtype).owner_key = (*token).lock_key;
        }
    } else {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_Lock_Global\0"))
                .as_ptr(),
            726 as libc::c_int as uint32,
            b"ERROR: cannot lock global %u for mode %u\n\0" as *const u8 as *const libc::c_char,
            (*token).obj_type,
            (*token).lock_mode as libc::c_uint,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_Unlock_Global(mut token: *mut OS_object_token_t) {
    let mut objtype: *mut OS_objtype_state_t = 0 as *mut OS_objtype_state_t;
    if (*token).obj_type < 0x10 as libc::c_int as libc::c_uint
        && (*token).lock_mode as libc::c_uint != OS_LOCK_MODE_NONE as libc::c_int as libc::c_uint
    {
        objtype = &mut *OS_objtype_state
            .as_mut_ptr()
            .offset((*token).obj_type as isize) as *mut OS_objtype_state_t;
        if (*objtype).owner_key.key_value & 0xff000000 as libc::c_uint
            != 0x4d000000 as libc::c_int as libc::c_uint
            || (*objtype).owner_key.key_value != (*token).lock_key.key_value
        {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_Unlock_Global\0"))
                    .as_ptr(),
                756 as libc::c_int as uint32,
                b"ERROR: global %u released using mismatched key=0x%lx expected=0x%lx\n\0"
                    as *const u8 as *const libc::c_char,
                (*token).obj_type,
                (*token).lock_key.key_value as libc::c_ulong,
                (*objtype).owner_key.key_value as libc::c_ulong,
            );
        }
        (*objtype).owner_key = {
            let mut init = osal_key_t {
                key_value: 0 as libc::c_int as uint32,
            };
            init
        };
        (*token).lock_key = {
            let mut init = osal_key_t {
                key_value: 0 as libc::c_int as uint32,
            };
            init
        };
        OS_Unlock_Global_Impl((*token).obj_type);
    } else {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_Unlock_Global\0"))
                .as_ptr(),
            767 as libc::c_int as uint32,
            b"ERROR: cannot unlock global %u for mode %u\n\0" as *const u8 as *const libc::c_char,
            (*token).obj_type,
            (*token).lock_mode as libc::c_uint,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_WaitForStateChange(
    mut token: *mut OS_object_token_t,
    mut attempts: uint32,
) {
    let mut saved_unlock_key: osal_key_t = osal_key_t { key_value: 0 };
    let mut objtype: *mut OS_objtype_state_t = 0 as *mut OS_objtype_state_t;
    objtype = &mut *OS_objtype_state
        .as_mut_ptr()
        .offset((*token).obj_type as isize) as *mut OS_objtype_state_t;
    saved_unlock_key = (*objtype).owner_key;
    (*objtype).owner_key = {
        let mut init = osal_key_t {
            key_value: 0 as libc::c_int as uint32,
        };
        init
    };
    OS_WaitForStateChange_Impl((*token).obj_type, attempts);
    (*objtype).owner_key = saved_unlock_key;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdFinalizeNew(
    mut operation_status: int32,
    mut token: *mut OS_object_token_t,
    mut outid: *mut osal_id_t,
) -> int32 {
    let mut final_id: osal_id_t = 0;
    if operation_status == 0 as libc::c_int {
        final_id = (*token).obj_id;
    } else {
        final_id = 0 as libc::c_int as osal_id_t;
    }
    OS_ObjectIdTransactionFinish(token, &mut final_id);
    if operation_status == 0 as libc::c_int {
        OS_NotifyEvent(
            OS_EVENT_RESOURCE_CREATED,
            (*token).obj_id,
            0 as *mut libc::c_void,
        );
    }
    if !outid.is_null() {
        *outid = final_id;
    }
    return operation_status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdFinalizeDelete(
    mut operation_status: int32,
    mut token: *mut OS_object_token_t,
) -> int32 {
    let mut final_id: osal_id_t = 0;
    if operation_status == 0 as libc::c_int {
        final_id = 0 as libc::c_int as osal_id_t;
    } else {
        final_id = (*token).obj_id;
    }
    OS_ObjectIdTransactionFinish(token, &mut final_id);
    if operation_status == 0 as libc::c_int {
        OS_NotifyEvent(
            OS_EVENT_RESOURCE_DELETED,
            (*token).obj_id,
            0 as *mut libc::c_void,
        );
    }
    return operation_status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdGetBySearch(
    mut lock_mode: OS_lock_mode_t,
    mut idtype: osal_objtype_t,
    mut MatchFunc: OS_ObjectMatchFunc_t,
    mut arg: *mut libc::c_void,
    mut token: *mut OS_object_token_t,
) -> int32 {
    let mut return_code: int32 = 0;
    OS_ObjectIdTransactionInit(lock_mode, idtype, token);
    return_code = OS_ObjectIdFindNextMatch(MatchFunc, arg, token);
    if return_code == 0 as libc::c_int {
        return_code = OS_ObjectIdConvertToken(token);
    } else {
        OS_ObjectIdTransactionCancel(token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdGetByName(
    mut lock_mode: OS_lock_mode_t,
    mut idtype: osal_objtype_t,
    mut name: *const libc::c_char,
    mut token: *mut OS_object_token_t,
) -> int32 {
    return OS_ObjectIdGetBySearch(
        lock_mode,
        idtype,
        Some(
            OS_ObjectNameMatch
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        name as *mut libc::c_void,
        token,
    );
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdFindByName(
    mut idtype: osal_objtype_t,
    mut name: *const libc::c_char,
    mut object_id: *mut osal_id_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if name.is_null() {
        return -(17 as libc::c_int);
    }
    if (memchr(
        name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    return_code = OS_ObjectIdGetByName(OS_LOCK_MODE_GLOBAL, idtype, name, &mut token);
    if return_code == 0 as libc::c_int {
        *object_id = token.obj_id;
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdGetById(
    mut lock_mode: OS_lock_mode_t,
    mut idtype: osal_objtype_t,
    mut id: osal_id_t,
    mut token: *mut OS_object_token_t,
) -> int32 {
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdTransactionInit(lock_mode, idtype, token);
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    return_code = OS_ObjectIdToArrayIndex(idtype, id, &mut (*token).obj_idx);
    if return_code == 0 as libc::c_int {
        (*token).obj_id = id;
        return_code = OS_ObjectIdConvertToken(token);
    }
    if return_code != 0 as libc::c_int {
        OS_ObjectIdTransactionCancel(token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdTransactionFinish(
    mut token: *mut OS_object_token_t,
    mut final_id: *const osal_id_t,
) {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    if (*token).lock_mode as libc::c_uint == OS_LOCK_MODE_NONE as libc::c_int as libc::c_uint {
        return;
    }
    record = OS_ObjectIdGlobalFromToken(token);
    if (*token).lock_mode as libc::c_uint == OS_LOCK_MODE_EXCLUSIVE as libc::c_int as libc::c_uint
        || (*token).lock_mode as libc::c_uint
            == OS_LOCK_MODE_REFCOUNT as libc::c_int as libc::c_uint
    {
        OS_Lock_Global(token);
    }
    if (*record).refcount as libc::c_int > 0 as libc::c_int {
        (*record).refcount = ((*record).refcount).wrapping_sub(1);
        (*record).refcount;
    }
    if !final_id.is_null() {
        (*record).active_id = *final_id;
    } else if (*token).lock_mode as libc::c_uint
        == OS_LOCK_MODE_EXCLUSIVE as libc::c_int as libc::c_uint
    {
        (*record).active_id = (*token).obj_id;
    }
    OS_Unlock_Global(token);
    (*token).lock_mode = OS_LOCK_MODE_NONE;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdRelease(mut token: *mut OS_object_token_t) {
    OS_ObjectIdTransactionFinish(token, 0 as *const osal_id_t);
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdAllocateNew(
    mut idtype: osal_objtype_t,
    mut name: *const libc::c_char,
    mut token: *mut OS_object_token_t,
) -> int32 {
    let mut return_code: int32 = 0;
    if OS_SharedGlobalVars.GlobalState == 0xabadc0de as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdTransactionInit(OS_LOCK_MODE_EXCLUSIVE, idtype, token);
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    if !name.is_null() {
        return_code = OS_ObjectIdFindNextMatch(
            Some(
                OS_ObjectNameMatch
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const OS_object_token_t,
                        *const OS_common_record_t,
                    ) -> bool,
            ),
            name as *mut libc::c_void,
            token,
        );
    } else {
        return_code = -(17 as libc::c_int);
    }
    if return_code == 0 as libc::c_int {
        return_code = -(15 as libc::c_int);
    } else {
        return_code = OS_ObjectIdFindNextFree(token);
    }
    if return_code != 0 as libc::c_int {
        OS_ObjectIdTransactionCancel(token);
        return return_code;
    } else {
        return_code = OS_NotifyEvent(
            OS_EVENT_RESOURCE_ALLOCATED,
            (*token).obj_id,
            0 as *mut libc::c_void,
        );
    }
    if return_code == 0 as libc::c_int {
        return_code = OS_ObjectIdConvertToken(token);
    }
    if return_code != 0 as libc::c_int {
        return_code = OS_ObjectIdFinalizeNew(return_code, token, 0 as *mut osal_id_t);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdTransferToken(
    mut token_from: *mut OS_object_token_t,
    mut token_to: *mut OS_object_token_t,
) {
    *token_to = *token_from;
    (*token_from).lock_mode = OS_LOCK_MODE_NONE;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdIteratorInit(
    mut matchfunc: OS_ObjectMatchFunc_t,
    mut matcharg: *mut libc::c_void,
    mut objtype: osal_objtype_t,
    mut iter: *mut OS_object_iter_t,
) -> int32 {
    (*iter).match_0 = matchfunc;
    (*iter).arg = matcharg;
    (*iter).limit = OS_GetMaxForObjectType(objtype);
    (*iter).base = &mut *OS_common_table.as_mut_ptr().offset((OS_GetBaseForObjectType
        as unsafe extern "C" fn(osal_objtype_t) -> uint32)(
        objtype
    ) as isize) as *mut OS_common_record_t;
    return OS_ObjectIdTransactionInit(OS_LOCK_MODE_GLOBAL, objtype, &mut (*iter).token);
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectFilterActive(
    mut ref_0: *mut libc::c_void,
    mut token: *const OS_object_token_t,
    mut obj: *const OS_common_record_t,
) -> bool {
    return OS_ObjectIdDefined((*obj).active_id);
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdIterateActive(
    mut objtype: osal_objtype_t,
    mut iter: *mut OS_object_iter_t,
) -> int32 {
    return OS_ObjectIdIteratorInit(
        Some(
            OS_ObjectFilterActive
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        0 as *mut libc::c_void,
        objtype,
        iter,
    );
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdIteratorGetNext(mut iter: *mut OS_object_iter_t) -> bool {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut got_next: bool = false;
    got_next = 0 as libc::c_int != 0;
    (*iter).token.obj_id = 0 as libc::c_int as osal_id_t;
    loop {
        (*iter).token.obj_idx = ((*iter).token.obj_idx).wrapping_add(1);
        (*iter).token.obj_idx;
        if (*iter).token.obj_idx >= (*iter).limit {
            break;
        }
        record = &mut *((*iter).base).offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut (*iter).token
        ) as isize) as *mut OS_common_record_t;
        if ((*iter).match_0).is_none()
            || ((*iter).match_0).expect("non-null function pointer")(
                (*iter).arg,
                &mut (*iter).token,
                record,
            ) as libc::c_int
                != 0
        {
            (*iter).token.obj_id = (*record).active_id;
            got_next = 1 as libc::c_int != 0;
        }
        if got_next {
            break;
        }
    }
    return got_next;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdIteratorDestroy(mut iter: *mut OS_object_iter_t) {
    OS_ObjectIdTransactionCancel(&mut (*iter).token);
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdIteratorProcessEntry(
    mut iter: *mut OS_object_iter_t,
    mut func: Option<unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> int32>,
) -> int32 {
    let mut status: int32 = 0;
    OS_Unlock_Global(&mut (*iter).token);
    status = func.expect("non-null function pointer")(
        OS_ObjectIdFromToken(&mut (*iter).token),
        (*iter).arg,
    );
    OS_Lock_Global(&mut (*iter).token);
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ConvertToArrayIndex(
    mut object_id: osal_id_t,
    mut ArrayIndex: *mut osal_index_t,
) -> int32 {
    return OS_ObjectIdToArrayIndex(0 as libc::c_int as osal_objtype_t, object_id, ArrayIndex);
}
#[no_mangle]
pub unsafe extern "C" fn OS_ForEachObject(
    mut creator_id: osal_id_t,
    mut callback_ptr: OS_ArgCallback_t,
    mut callback_arg: *mut libc::c_void,
) {
    let mut idtype: osal_objtype_t = 0;
    idtype = 0 as libc::c_int as osal_objtype_t;
    while idtype < 0x10 as libc::c_int as libc::c_uint {
        OS_ForEachObjectOfType(idtype, creator_id, callback_ptr, callback_arg);
        idtype = idtype.wrapping_add(1);
        idtype;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_ForEachObjectOfType(
    mut objtype: osal_objtype_t,
    mut creator_id: osal_id_t,
    mut callback_ptr: OS_ArgCallback_t,
    mut callback_arg: *mut libc::c_void,
) {
    let mut iter: OS_object_iter_t = OS_object_iter_t {
        base: 0 as *mut OS_common_record_t,
        match_0: None,
        arg: 0 as *mut libc::c_void,
        limit: 0,
        token: OS_object_token_t {
            lock_mode: OS_LOCK_MODE_NONE,
            lock_key: osal_key_t { key_value: 0 },
            obj_type: 0,
            obj_idx: 0,
            obj_id: 0,
        },
    };
    let mut filter: OS_creator_filter_t = OS_creator_filter_t {
        creator_id: 0,
        user_callback: None,
        user_arg: 0 as *mut libc::c_void,
    };
    filter.creator_id = creator_id;
    filter.user_callback = callback_ptr;
    filter.user_arg = callback_arg;
    if OS_ObjectIdIteratorInit(
        Some(
            OS_ForEachFilterCreator
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        &mut filter as *mut OS_creator_filter_t as *mut libc::c_void,
        objtype,
        &mut iter,
    ) == 0 as libc::c_int
    {
        while OS_ObjectIdIteratorGetNext(&mut iter) {
            OS_ObjectIdIteratorProcessEntry(
                &mut iter,
                Some(
                    OS_ForEachDoCallback
                        as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> int32,
                ),
            );
        }
        OS_ObjectIdIteratorDestroy(&mut iter);
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_IdentifyObject(mut object_id: osal_id_t) -> osal_objtype_t {
    return OS_ObjectIdToType_Impl(object_id);
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetResourceName(
    mut object_id: osal_id_t,
    mut buffer: *mut libc::c_char,
    mut buffer_size: size_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut return_code: int32 = 0;
    let mut name_len: size_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if buffer.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_GetResourceName\0"))
                .as_ptr(),
            1407 as libc::c_int,
            b"(buffer) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(buffer_size > 0 as libc::c_int as libc::c_ulong
        && buffer_size
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    *buffer.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        OS_ObjectIdToType_Impl(object_id),
        object_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = OS_ObjectIdGlobalFromToken(&mut token);
        if !((*record).name_entry).is_null() {
            name_len = OS_strnlen((*record).name_entry, buffer_size);
            if buffer_size <= name_len {
                return_code = -(13 as libc::c_int);
                name_len = buffer_size.wrapping_sub(1 as libc::c_int as libc::c_ulong);
            }
            memcpy(
                buffer as *mut libc::c_void,
                (*record).name_entry as *const libc::c_void,
                name_len,
            );
            *buffer.offset(name_len as isize) = 0 as libc::c_int as libc::c_char;
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ObjectIdToArrayIndex(
    mut idtype: osal_objtype_t,
    mut object_id: osal_id_t,
    mut ArrayIndex: *mut osal_index_t,
) -> int32 {
    let mut max_id: uint32 = 0;
    let mut obj_index: uint32 = 0;
    let mut actual_type: osal_objtype_t = 0;
    let mut return_code: int32 = 0;
    if ArrayIndex.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"OS_ObjectIdToArrayIndex\0",
            ))
            .as_ptr(),
            1455 as libc::c_int,
            b"(ArrayIndex) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    obj_index = OS_ObjectIdToSerialNumber_Impl(object_id);
    actual_type = OS_ObjectIdToType_Impl(object_id);
    if idtype != 0 as libc::c_int as libc::c_uint && actual_type != idtype {
        return_code = -(16 as libc::c_int);
    } else {
        max_id = OS_GetMaxForObjectType(actual_type);
        if max_id == 0 as libc::c_int as libc::c_uint {
            return_code = -(16 as libc::c_int);
        } else {
            return_code = 0 as libc::c_int;
            *ArrayIndex = obj_index.wrapping_rem(max_id);
        }
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_module_table: [OS_module_internal_record_t; 20] = [OS_module_internal_record_t {
    module_name: [0; 20],
    file_name: [0; 64],
    module_type: OS_MODULE_TYPE_UNKNOWN,
    flags: 0,
    entry_point: 0,
}; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_SymbolLookup_Static(
    mut SymbolAddress: *mut cpuaddr,
    mut SymbolName: *const libc::c_char,
    mut ModuleName: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = -(28 as libc::c_int);
    let mut StaticSym: *const OS_static_symbol_record_t = OS_STATIC_SYMBOL_TABLE.as_ptr();
    while !StaticSym.is_null() {
        if ((*StaticSym).Name).is_null() {
            return_code = -(1 as libc::c_int);
            break;
        } else if strcmp((*StaticSym).Name, SymbolName) == 0 as libc::c_int
            && (ModuleName.is_null() || strcmp((*StaticSym).Module, ModuleName) == 0 as libc::c_int)
        {
            *SymbolAddress = ::core::mem::transmute::<Option<unsafe extern "C" fn() -> ()>, cpuaddr>(
                (*StaticSym).Address,
            );
            return_code = 0 as libc::c_int;
            break;
        } else {
            StaticSym = StaticSym.offset(1);
            StaticSym;
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleLoad_Static(mut ModuleName: *const libc::c_char) -> int32 {
    let mut return_code: int32 = -(17 as libc::c_int);
    let mut StaticSym: *const OS_static_symbol_record_t = OS_STATIC_SYMBOL_TABLE.as_ptr();
    while !StaticSym.is_null() {
        if ((*StaticSym).Name).is_null() {
            break;
        }
        if !((*StaticSym).Module).is_null()
            && strcmp((*StaticSym).Module, ModuleName) == 0 as libc::c_int
        {
            return_code = 0 as libc::c_int;
            break;
        } else {
            StaticSym = StaticSym.offset(1);
            StaticSym;
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleAPI_Init() -> int32 {
    memset(
        OS_module_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_module_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleLoad(
    mut module_id: *mut osal_id_t,
    mut module_name: *const libc::c_char,
    mut filename: *const libc::c_char,
    mut flags: uint32,
) -> int32 {
    let mut translated_path: [libc::c_char; 128] = [0; 128];
    let mut return_code: int32 = 0;
    let mut filename_status: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut module: *mut OS_module_internal_record_t = 0 as *mut OS_module_internal_record_t;
    if module_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_ModuleLoad\0"))
                .as_ptr(),
            188 as libc::c_int,
            b"(module_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if module_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_ModuleLoad\0"))
                .as_ptr(),
            189 as libc::c_int,
            b"(module_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        module_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    filename_status = OS_TranslatePath(filename, translated_path.as_mut_ptr());
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_module_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        module_name,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        module = &mut *OS_module_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_module_internal_record_t;
        memset(
            module as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_module_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*module).module_name).as_mut_ptr(),
            module_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh7 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh7 = ((*module).module_name).as_mut_ptr();
        (*module).flags = flags;
        return_code = OS_ModuleLoad_Static(module_name);
        if return_code == 0 as libc::c_int {
            (*module).module_type = OS_MODULE_TYPE_STATIC;
        } else if filename_status != 0 as libc::c_int {
            return_code = filename_status;
        } else {
            strncpy(
                ((*module).file_name).as_mut_ptr(),
                filename,
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*module).module_type = OS_MODULE_TYPE_DYNAMIC;
            return_code = OS_ModuleLoad_Impl(&mut token, translated_path.as_mut_ptr());
        }
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, module_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleUnload(mut module_id: osal_id_t) -> int32 {
    let mut module: *mut OS_module_internal_record_t = 0 as *mut OS_module_internal_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_module_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        module_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        module = &mut *OS_module_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_module_internal_record_t;
        if (*module).module_type as libc::c_uint
            == OS_MODULE_TYPE_DYNAMIC as libc::c_int as libc::c_uint
        {
            return_code = OS_ModuleUnload_Impl(&mut token);
        }
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleInfo(
    mut module_id: osal_id_t,
    mut module_info: *mut OS_module_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut module: *mut OS_module_internal_record_t = 0 as *mut OS_module_internal_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if module_info.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_ModuleInfo\0"))
                .as_ptr(),
            307 as libc::c_int,
            b"(module_info) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        module_info as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_module_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_module_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        module_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_module_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        module = &mut *OS_module_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_module_internal_record_t;
        strncpy(
            ((*module_info).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        strncpy(
            ((*module_info).filename).as_mut_ptr(),
            ((*module).file_name).as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        return_code = OS_ModuleGetInfo_Impl(&mut token, module_info);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SymbolLookup(
    mut symbol_address: *mut cpuaddr,
    mut SymbolName: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut staticsym_status: int32 = 0;
    if symbol_address.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SymbolLookup\0"))
                .as_ptr(),
            342 as libc::c_int,
            b"(symbol_address) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if SymbolName.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SymbolLookup\0"))
                .as_ptr(),
            343 as libc::c_int,
            b"(SymbolName) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_SymbolLookup_Impl(symbol_address, SymbolName);
    if return_code != 0 as libc::c_int {
        staticsym_status =
            OS_SymbolLookup_Static(symbol_address, SymbolName, 0 as *const libc::c_char);
        if staticsym_status == 0 as libc::c_int {
            return_code = staticsym_status;
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleSymbolLookup(
    mut module_id: osal_id_t,
    mut symbol_address: *mut cpuaddr,
    mut symbol_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut staticsym_status: int32 = 0;
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if symbol_address.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_ModuleSymbolLookup\0"))
                .as_ptr(),
            387 as libc::c_int,
            b"(symbol_address) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if symbol_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_ModuleSymbolLookup\0"))
                .as_ptr(),
            388 as libc::c_int,
            b"(symbol_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_module_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        module_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_module_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        return_code = OS_ModuleSymbolLookup_Impl(&mut token, symbol_address, symbol_name);
        if return_code != 0 as libc::c_int {
            staticsym_status =
                OS_SymbolLookup_Static(symbol_address, symbol_name, (*record).name_entry);
            if staticsym_status == 0 as libc::c_int {
                return_code = staticsym_status;
            }
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SymbolTableDump(
    mut filename: *const libc::c_char,
    mut size_limit: size_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut translated_path: [libc::c_char; 128] = [0; 128];
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if filename.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_SymbolTableDump\0"))
                .as_ptr(),
            430 as libc::c_int,
            b"(filename) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_TranslatePath(filename, translated_path.as_mut_ptr());
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    return_code = OS_ObjectIdTransactionInit(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_module_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        &mut token,
    );
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    return_code = OS_SymbolTableDump_Impl(translated_path.as_mut_ptr(), size_limit);
    OS_ObjectIdTransactionCancel(&mut token);
    return return_code;
}
#[no_mangle]
pub static mut OS_mutex_table: [OS_mutex_internal_record_t; 20] = [OS_mutex_internal_record_t {
    obj_name: [0; 20],
    last_owner: 0,
}; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_MutexAPI_Init() -> int32 {
    memset(
        OS_mutex_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_mutex_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemCreate(
    mut sem_id: *mut osal_id_t,
    mut sem_name: *const libc::c_char,
    mut options: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut mutex: *mut OS_mutex_internal_record_t = 0 as *mut OS_mutex_internal_record_t;
    if sem_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_MutSemCreate\0"))
                .as_ptr(),
            95 as libc::c_int,
            b"(sem_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if sem_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_MutSemCreate\0"))
                .as_ptr(),
            96 as libc::c_int,
            b"(sem_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        sem_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_mutex_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_name,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        mutex = &mut *OS_mutex_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_mutex_internal_record_t;
        memset(
            mutex as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_mutex_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*mutex).obj_name).as_mut_ptr(),
            sem_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh8 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh8 = ((*mutex).obj_name).as_mut_ptr();
        return_code = OS_MutSemCreate_Impl(&mut token, options);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, sem_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemDelete(mut sem_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_mutex_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_MutSemDelete_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemGive(mut sem_id: osal_id_t) -> int32 {
    let mut mutex: *mut OS_mutex_internal_record_t = 0 as *mut OS_mutex_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    let mut self_task: osal_id_t = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_mutex_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        mutex = &mut *OS_mutex_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_mutex_internal_record_t;
        self_task = OS_TaskGetId();
        if !OS_ObjectIdEqual((*mutex).last_owner, self_task) {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_MutSemGive\0"))
                    .as_ptr(),
                164 as libc::c_int as uint32,
                b"WARNING: Task %lu giving mutex %lu while owned by task %lu\n\0" as *const u8
                    as *const libc::c_char,
                OS_ObjectIdToInteger(self_task),
                OS_ObjectIdToInteger(sem_id),
                OS_ObjectIdToInteger((*mutex).last_owner),
            );
        }
        (*mutex).last_owner = 0 as libc::c_int as osal_id_t;
        return_code = OS_MutSemGive_Impl(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemTake(mut sem_id: osal_id_t) -> int32 {
    let mut mutex: *mut OS_mutex_internal_record_t = 0 as *mut OS_mutex_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_mutex_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        mutex = &mut *OS_mutex_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_mutex_internal_record_t;
        return_code = OS_MutSemTake_Impl(&mut token);
        if return_code == 0 as libc::c_int {
            (*mutex).last_owner = OS_TaskGetId();
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemGetIdByName(
    mut sem_id: *mut osal_id_t,
    mut sem_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    if sem_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_MutSemGetIdByName\0"))
                .as_ptr(),
            215 as libc::c_int,
            b"(sem_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if sem_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_MutSemGetIdByName\0"))
                .as_ptr(),
            216 as libc::c_int,
            b"(sem_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(
        osal_src_os_shared_src_osapi_mutex_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_name,
        sem_id,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemGetInfo(
    mut sem_id: osal_id_t,
    mut mut_prop: *mut OS_mut_sem_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if mut_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_MutSemGetInfo\0"))
                .as_ptr(),
            236 as libc::c_int,
            b"(mut_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        mut_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_mut_sem_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_mutex_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sem_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_mutex_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        strncpy(
            ((*mut_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*mut_prop).creator = (*record).creator;
        return_code = OS_MutSemGetInfo_Impl(&mut token, mut_prop);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_NetworkAPI_Init() -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_NetworkGetHostName(
    mut host_name: *mut libc::c_char,
    mut name_len: size_t,
) -> int32 {
    let mut return_code: int32 = 0;
    if host_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_NetworkGetHostName\0"))
                .as_ptr(),
            65 as libc::c_int,
            b"(host_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(name_len > 0 as libc::c_int as libc::c_ulong
        && name_len
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return_code = OS_NetworkGetHostName_Impl(host_name, name_len);
    if return_code != 0 as libc::c_int {
        *host_name.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_NetworkGetID() -> int32 {
    let mut IdBuf: int32 = 0;
    if OS_NetworkGetID_Impl(&mut IdBuf) != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return IdBuf;
}
static mut OS_printf_buffer_mem: [libc::c_char; 17300] = [0; 17300];
#[no_mangle]
pub static mut OS_console_table: [OS_console_internal_record_t; 1] =
    [OS_console_internal_record_t {
        device_name: [0; 20],
        BufBase: 0 as *const libc::c_char as *mut libc::c_char,
        BufSize: 0,
        ReadPos: 0,
        WritePos: 0,
        OverflowEvents: 0,
        IsAsync: false,
    }; 1];
#[no_mangle]
pub unsafe extern "C" fn OS_ConsoleAPI_Init() -> int32 {
    let mut console: *mut OS_console_internal_record_t = 0 as *mut OS_console_internal_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    memset(
        &mut OS_console_table as *mut [OS_console_internal_record_t; 1] as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_console_internal_record_t; 1]>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdAllocateNew(
        0xc as libc::c_int as osal_objtype_t,
        b"\0" as *const u8 as *const libc::c_char,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        console = &mut *OS_console_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_console_internal_record_t;
        memset(
            console as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_console_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*console).device_name).as_mut_ptr(),
            b"\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh9 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh9 = ((*console).device_name).as_mut_ptr();
        (*console).BufBase = OS_printf_buffer_mem.as_mut_ptr();
        (*console).BufSize = ::core::mem::size_of::<[libc::c_char; 17300]>() as libc::c_ulong;
        (*console).IsAsync = 1 as libc::c_int != 0;
        return_code = OS_ConsoleCreate_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeNew(
            return_code,
            &mut token,
            &mut OS_SharedGlobalVars.PrintfConsoleId,
        );
        ::core::ptr::write_volatile(
            &mut OS_SharedGlobalVars.PrintfEnabled as *mut bool,
            1 as libc::c_int != 0,
        );
    }
    return return_code;
}
unsafe extern "C" fn OS_Console_CopyOut(
    mut console: *mut OS_console_internal_record_t,
    mut Str: *const libc::c_char,
    mut NextWritePos: *mut size_t,
) -> int32 {
    let mut pmsg: *const libc::c_char = 0 as *const libc::c_char;
    let mut WriteOffset: size_t = 0;
    let mut return_code: int32 = 0;
    return_code = -(1 as libc::c_int);
    pmsg = Str;
    WriteOffset = *NextWritePos;
    loop {
        if *pmsg as libc::c_int == 0 as libc::c_int {
            *NextWritePos = WriteOffset;
            return_code = 0 as libc::c_int;
            break;
        } else {
            *((*console).BufBase).offset(WriteOffset as isize) = *pmsg;
            WriteOffset = WriteOffset.wrapping_add(1 as libc::c_int as libc::c_ulong);
            if WriteOffset >= (*console).BufSize {
                WriteOffset = 0 as libc::c_int as size_t;
            }
            if WriteOffset == (*console).ReadPos {
                return_code = -(9 as libc::c_int);
                break;
            } else {
                pmsg = pmsg.offset(1);
                pmsg;
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ConsoleWrite(
    mut console_id: osal_id_t,
    mut Str: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut console: *mut OS_console_internal_record_t = 0 as *mut OS_console_internal_record_t;
    let mut PendingWritePos: size_t = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        0xc as libc::c_int as osal_objtype_t,
        console_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        console = &mut *OS_console_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_console_internal_record_t;
        PendingWritePos = (*console).WritePos;
        if (*console).device_name[0 as libc::c_int as usize] as libc::c_int != 0 as libc::c_int {
            return_code = OS_Console_CopyOut(
                console,
                ((*console).device_name).as_mut_ptr(),
                &mut PendingWritePos,
            );
        }
        if return_code == 0 as libc::c_int {
            return_code = OS_Console_CopyOut(console, Str, &mut PendingWritePos);
        }
        if return_code == 0 as libc::c_int {
            ::core::ptr::write_volatile(&mut (*console).WritePos as *mut size_t, PendingWritePos);
        } else {
            (*console).OverflowEvents = ((*console).OverflowEvents).wrapping_add(1);
            (*console).OverflowEvents;
        }
        if (*console).IsAsync {
            OS_ConsoleWakeup_Impl(&mut token);
        } else {
            OS_ConsoleOutput_Impl(&mut token);
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_printf(mut String: *const libc::c_char, mut args: ...) {
    let mut va: ::core::ffi::VaListImpl;
    let mut msg_buffer: [libc::c_char; 172] = [0; 172];
    let mut actualsz: libc::c_int = 0;
    if String.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"OS_printf\0")).as_ptr(),
            269 as libc::c_int,
            b"String != ((void*)0)\0" as *const u8 as *const libc::c_char,
            b"\0" as *const u8 as *const libc::c_char,
        );
        return;
    }
    if OS_SharedGlobalVars.GlobalState != 0xbe57c0de as libc::c_uint {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"OS_printf\0")).as_ptr(),
            290 as libc::c_int as uint32,
            b"BUG: OS_printf() called when OSAL not initialized: %s\0" as *const u8
                as *const libc::c_char,
            String,
        );
    } else if OS_SharedGlobalVars.PrintfEnabled {
        va = args.clone();
        actualsz = vsnprintf(
            msg_buffer.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 172]>() as libc::c_ulong,
            String,
            va.as_va_list(),
        );
        if actualsz < 0 as libc::c_int {
            actualsz = 0 as libc::c_int;
        } else if actualsz >= 172 as libc::c_int {
            actualsz = 172 as libc::c_int - 1 as libc::c_int;
        }
        msg_buffer[actualsz as usize] = 0 as libc::c_int as libc::c_char;
        OS_ConsoleWrite(OS_SharedGlobalVars.PrintfConsoleId, msg_buffer.as_mut_ptr());
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_printf_disable() {
    ::core::ptr::write_volatile(
        &mut OS_SharedGlobalVars.PrintfEnabled as *mut bool,
        0 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn OS_printf_enable() {
    ::core::ptr::write_volatile(
        &mut OS_SharedGlobalVars.PrintfEnabled as *mut bool,
        1 as libc::c_int != 0,
    );
}
#[no_mangle]
pub static mut OS_queue_table: [OS_queue_internal_record_t; 64] = [OS_queue_internal_record_t {
    queue_name: [0; 20],
    max_size: 0,
    max_depth: 0,
}; 64];
#[no_mangle]
pub unsafe extern "C" fn OS_QueueAPI_Init() -> int32 {
    memset(
        OS_queue_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_queue_internal_record_t; 64]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueCreate(
    mut queue_id: *mut osal_id_t,
    mut queue_name: *const libc::c_char,
    mut queue_depth: osal_blockcount_t,
    mut data_size: size_t,
    mut flags: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut queue: *mut OS_queue_internal_record_t = 0 as *mut OS_queue_internal_record_t;
    if queue_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_QueueCreate\0"))
                .as_ptr(),
            92 as libc::c_int,
            b"(queue_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if queue_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_QueueCreate\0"))
                .as_ptr(),
            93 as libc::c_int,
            b"(queue_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        queue_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    if !(data_size > 0 as libc::c_int as libc::c_ulong
        && data_size
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    if !(queue_depth <= 50 as libc::c_int as libc::c_ulong) {
        return -(11 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_queue_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        queue_name,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        queue = &mut *OS_queue_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_queue_internal_record_t;
        memset(
            queue as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_queue_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*queue).queue_name).as_mut_ptr(),
            queue_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh10 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh10 = ((*queue).queue_name).as_mut_ptr();
        (*queue).max_depth = queue_depth;
        (*queue).max_size = data_size;
        return_code = OS_QueueCreate_Impl(&mut token, flags);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, queue_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueDelete(mut queue_id: osal_id_t) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_queue_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        queue_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_QueueDelete_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueGet(
    mut queue_id: osal_id_t,
    mut data: *mut libc::c_void,
    mut size: size_t,
    mut size_copied: *mut size_t,
    mut timeout: int32,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    let mut queue: *mut OS_queue_internal_record_t = 0 as *mut OS_queue_internal_record_t;
    if data.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_QueueGet\0")).as_ptr(),
            155 as libc::c_int,
            b"(data) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if size_copied.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_QueueGet\0")).as_ptr(),
            156 as libc::c_int,
            b"(size_copied) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(size > 0 as libc::c_int as libc::c_ulong
        && size
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_queue_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        queue_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        queue = &mut *OS_queue_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_queue_internal_record_t;
        if size < (*queue).max_size {
            *size_copied = 0 as libc::c_int as size_t;
            return_code = -(11 as libc::c_int);
        } else {
            return_code = OS_QueueGet_Impl(&mut token, data, size, size_copied, timeout);
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueuePut(
    mut queue_id: osal_id_t,
    mut data: *const libc::c_void,
    mut size: size_t,
    mut flags: uint32,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    let mut queue: *mut OS_queue_internal_record_t = 0 as *mut OS_queue_internal_record_t;
    if data.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"OS_QueuePut\0")).as_ptr(),
            194 as libc::c_int,
            b"(data) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(size > 0 as libc::c_int as libc::c_ulong
        && size
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_queue_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        queue_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        queue = &mut *OS_queue_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_queue_internal_record_t;
        if size > (*queue).max_size {
            return_code = -(11 as libc::c_int);
        } else {
            return_code = OS_QueuePut_Impl(&mut token, data, size, flags);
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueGetIdByName(
    mut queue_id: *mut osal_id_t,
    mut queue_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    if queue_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"OS_QueueGetIdByName\0"))
                .as_ptr(),
            229 as libc::c_int,
            b"(queue_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if queue_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"OS_QueueGetIdByName\0"))
                .as_ptr(),
            230 as libc::c_int,
            b"(queue_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(
        osal_src_os_shared_src_osapi_queue_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        queue_name,
        queue_id,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueGetInfo(
    mut queue_id: osal_id_t,
    mut queue_prop: *mut OS_queue_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if queue_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_QueueGetInfo\0"))
                .as_ptr(),
            250 as libc::c_int,
            b"(queue_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        queue_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_queue_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_queue_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        queue_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_queue_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        strncpy(
            ((*queue_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*queue_prop).creator = (*record).creator;
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectFdIsSet(mut Set: *const OS_FdSet, mut objid: osal_id_t) -> bool {
    let mut return_code: int32 = 0;
    let mut local_id: osal_index_t = 0;
    if Set.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_SelectFdIsSet\0"))
                .as_ptr(),
            185 as libc::c_int,
            b"Set != NULL\0" as *const u8 as *const libc::c_char,
            b"false\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int != 0;
    }
    return_code =
        OS_ObjectIdToArrayIndex(0x6 as libc::c_int as osal_objtype_t, objid, &mut local_id);
    if return_code != 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    return (*Set).object_ids[(local_id >> 3 as libc::c_int) as usize] as libc::c_int
        >> (local_id & 0x7 as libc::c_int as libc::c_uint)
        & 0x1 as libc::c_int
        != 0;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectSingle(
    mut objid: osal_id_t,
    mut StateFlags: *mut uint32,
    mut msecs: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if StateFlags.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SelectSingle\0"))
                .as_ptr(),
            63 as libc::c_int,
            b"(StateFlags) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        0x6 as libc::c_int as osal_objtype_t,
        objid,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_SelectSingle_Impl(&mut token, StateFlags, msecs);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectMultiple(
    mut ReadSet: *mut OS_FdSet,
    mut WriteSet: *mut OS_FdSet,
    mut msecs: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    return_code = OS_SelectMultiple_Impl(ReadSet, WriteSet, msecs);
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectFdZero(mut Set: *mut OS_FdSet) -> int32 {
    if Set.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SelectFdZero\0"))
                .as_ptr(),
            111 as libc::c_int,
            b"(Set) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        Set as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_FdSet>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectFdAdd(mut Set: *mut OS_FdSet, mut objid: osal_id_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut local_id: osal_index_t = 0;
    if Set.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_SelectFdAdd\0"))
                .as_ptr(),
            129 as libc::c_int,
            b"(Set) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code =
        OS_ObjectIdToArrayIndex(0x6 as libc::c_int as osal_objtype_t, objid, &mut local_id);
    if return_code == 0 as libc::c_int {
        (*Set).object_ids[(local_id >> 3 as libc::c_int) as usize] =
            ((*Set).object_ids[(local_id >> 3 as libc::c_int) as usize] as libc::c_int
                | (1 as libc::c_int) << (local_id & 0x7 as libc::c_int as libc::c_uint))
                as uint8;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectFdClear(mut Set: *mut OS_FdSet, mut objid: osal_id_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut local_id: osal_index_t = 0;
    if Set.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_SelectFdClear\0"))
                .as_ptr(),
            157 as libc::c_int,
            b"(Set) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code =
        OS_ObjectIdToArrayIndex(0x6 as libc::c_int as osal_objtype_t, objid, &mut local_id);
    if return_code == 0 as libc::c_int {
        (*Set).object_ids[(local_id >> 3 as libc::c_int) as usize] =
            ((*Set).object_ids[(local_id >> 3 as libc::c_int) as usize] as libc::c_int
                & !((1 as libc::c_int) << (local_id & 0x7 as libc::c_int as libc::c_uint)))
                as uint8;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ShellOutputToFile(
    mut Cmd: *const libc::c_char,
    mut filedes: osal_id_t,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if Cmd.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_ShellOutputToFile\0"))
                .as_ptr(),
            55 as libc::c_int,
            b"(Cmd) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        0x6 as libc::c_int as osal_objtype_t,
        filedes,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_ShellOutputToFile_Impl(&mut token, Cmd);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAPI_Init() -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CreateSocketName(
    mut token: *const OS_object_token_t,
    mut Addr: *const OS_SockAddr_t,
    mut parent_name: *const libc::c_char,
) {
    let mut len: size_t = 0;
    let mut port: uint16 = 0;
    let mut sock: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    sock = &mut *OS_stream_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_stream_internal_record_t;
    if OS_SocketAddrToString_Impl(
        ((*sock).stream_name).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        Addr,
    ) != 0 as libc::c_int
    {
        (*sock).stream_name[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    }
    if OS_SocketAddrGetPort_Impl(&mut port, Addr) == 0 as libc::c_int {
        len = OS_strnlen(
            ((*sock).stream_name).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        );
        snprintf(
            &mut *((*sock).stream_name).as_mut_ptr().offset(len as isize) as *mut libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong).wrapping_sub(len),
            b":%u\0" as *const u8 as *const libc::c_char,
            port as libc::c_uint,
        );
    }
    if !parent_name.is_null() {
        len = OS_strnlen(
            ((*sock).stream_name).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        );
        snprintf(
            &mut *((*sock).stream_name).as_mut_ptr().offset(len as isize) as *mut libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong).wrapping_sub(len),
            b"-%s\0" as *const u8 as *const libc::c_char,
            parent_name,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketOpen(
    mut sock_id: *mut osal_id_t,
    mut Domain: OS_SocketDomain_t,
    mut Type: OS_SocketType_t,
) -> int32 {
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut return_code: int32 = 0;
    if sock_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_SocketOpen\0"))
                .as_ptr(),
            126 as libc::c_int,
            b"(sock_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        0 as *const libc::c_char,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_stream_internal_record_t;
        memset(
            stream as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_stream_internal_record_t>() as libc::c_ulong,
        );
        (*stream).socket_domain = Domain as uint8;
        (*stream).socket_type = Type as uint8;
        return_code = OS_SocketOpen_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, sock_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketBind(
    mut sock_id: osal_id_t,
    mut Addr: *const OS_SockAddr_t,
) -> int32 {
    let mut return_code: int32 = 0;
    return_code = OS_SocketBindAddress(sock_id, Addr);
    if return_code == 0 as libc::c_int {
        return_code = OS_SocketListen(sock_id);
        if return_code == -(36 as libc::c_int) {
            return_code = 0 as libc::c_int;
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketListen(mut sock_id: osal_id_t) -> int32 {
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*stream).socket_domain as libc::c_int == OS_SocketDomain_INVALID as libc::c_int
            || (*stream).socket_type as libc::c_int != OS_SocketType_STREAM as libc::c_int
        {
            return_code = -(36 as libc::c_int);
        } else if (*stream).stream_state as libc::c_int & OS_STREAM_STATE_BOUND as libc::c_int
            == 0 as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else if (*stream).stream_state as libc::c_int
            & (OS_STREAM_STATE_LISTENING as libc::c_int | OS_STREAM_STATE_CONNECTED as libc::c_int)
            != 0 as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else {
            return_code = OS_SocketListen_Impl(&mut token);
            if return_code == 0 as libc::c_int {
                (*stream).stream_state = ((*stream).stream_state as libc::c_int
                    | OS_STREAM_STATE_LISTENING as libc::c_int)
                    as uint16;
            }
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketBindAddress(
    mut sock_id: osal_id_t,
    mut Addr: *const OS_SockAddr_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketBindAddress\0"))
                .as_ptr(),
            242 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_stream_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*stream).socket_domain as libc::c_int == OS_SocketDomain_INVALID as libc::c_int {
            return_code = -(36 as libc::c_int);
        } else if (*stream).stream_state as libc::c_int
            & (OS_STREAM_STATE_BOUND as libc::c_int | OS_STREAM_STATE_CONNECTED as libc::c_int)
            != 0 as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else {
            return_code = OS_SocketBindAddress_Impl(&mut token, Addr);
            if return_code == 0 as libc::c_int {
                OS_CreateSocketName(&mut token, Addr, 0 as *const libc::c_char);
                (*record).name_entry = ((*stream).stream_name).as_mut_ptr();
                (*stream).stream_state = ((*stream).stream_state as libc::c_int
                    | OS_STREAM_STATE_BOUND as libc::c_int)
                    as uint16;
            }
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAccept(
    mut sock_id: osal_id_t,
    mut connsock_id: *mut osal_id_t,
    mut Addr: *mut OS_SockAddr_t,
    mut timeout: int32,
) -> int32 {
    let mut sock_record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut conn_record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut sock: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut conn: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut sock_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut conn_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SocketAccept\0"))
                .as_ptr(),
            295 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if connsock_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SocketAccept\0"))
                .as_ptr(),
            296 as libc::c_int,
            b"(connsock_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    conn_record = 0 as *mut OS_common_record_t;
    sock_record = 0 as *mut OS_common_record_t;
    sock = 0 as *mut OS_stream_internal_record_t;
    conn = 0 as *mut OS_stream_internal_record_t;
    memset(
        &mut sock_token as *mut OS_object_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_object_token_t>() as libc::c_ulong,
    );
    memset(
        &mut conn_token as *mut OS_object_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_object_token_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut sock_token,
    );
    if return_code == 0 as libc::c_int {
        sock_record = &mut *OS_global_stream_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut sock_token
        ) as isize) as *mut OS_common_record_t;
        sock = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut sock_token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*sock).socket_type as libc::c_int != OS_SocketType_STREAM as libc::c_int {
            return_code = -(36 as libc::c_int);
        } else if (*sock).stream_state as libc::c_int
            & (OS_STREAM_STATE_BOUND as libc::c_int | OS_STREAM_STATE_CONNECTED as libc::c_int)
            != OS_STREAM_STATE_BOUND as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else {
            return_code = OS_ObjectIdAllocateNew(
                osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int
                    as osal_objtype_t,
                0 as *const libc::c_char,
                &mut conn_token,
            );
            if return_code == 0 as libc::c_int {
                conn_record = &mut *OS_global_stream_table.offset((OS_ObjectIndexFromToken
                    as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                    &mut conn_token,
                ) as isize) as *mut OS_common_record_t;
                conn = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                    as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                    &mut conn_token,
                ) as isize) as *mut OS_stream_internal_record_t;
                memset(
                    conn as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<OS_stream_internal_record_t>() as libc::c_ulong,
                );
                (*conn).socket_domain = (*sock).socket_domain;
                (*conn).socket_type = (*sock).socket_type;
                OS_SocketAddrInit_Impl(Addr, (*sock).socket_domain as OS_SocketDomain_t);
                return_code = OS_SocketAccept_Impl(&mut sock_token, &mut conn_token, Addr, timeout);
                if return_code == 0 as libc::c_int {
                    OS_CreateSocketName(&mut conn_token, Addr, (*sock_record).name_entry);
                    (*conn_record).name_entry = ((*conn).stream_name).as_mut_ptr();
                    (*conn).stream_state = ((*conn).stream_state as libc::c_int
                        | OS_STREAM_STATE_CONNECTED as libc::c_int)
                        as uint16;
                }
                return_code = OS_ObjectIdFinalizeNew(return_code, &mut conn_token, connsock_id);
            }
        }
        OS_ObjectIdRelease(&mut sock_token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketConnect(
    mut sock_id: osal_id_t,
    mut Addr: *const OS_SockAddr_t,
    mut Timeout: int32,
) -> int32 {
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_SocketConnect\0"))
                .as_ptr(),
            378 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*stream).socket_domain as libc::c_int == OS_SocketDomain_INVALID as libc::c_int {
            return_code = -(36 as libc::c_int);
        } else if (*stream).socket_type as libc::c_int == OS_SocketType_STREAM as libc::c_int
            && (*stream).stream_state as libc::c_int & OS_STREAM_STATE_CONNECTED as libc::c_int
                != 0 as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else {
            return_code = OS_SocketConnect_Impl(&mut token, Addr, Timeout);
            if return_code == 0 as libc::c_int {
                (*stream).stream_state = ((*stream).stream_state as libc::c_int
                    | (OS_STREAM_STATE_CONNECTED as libc::c_int
                        | OS_STREAM_STATE_READABLE as libc::c_int
                        | OS_STREAM_STATE_WRITABLE as libc::c_int))
                    as uint16;
            }
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketShutdown(
    mut sock_id: osal_id_t,
    mut Mode: OS_SocketShutdownMode_t,
) -> int32 {
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if !(Mode as libc::c_uint == OS_SocketShutdownMode_SHUT_READ as libc::c_int as libc::c_uint
        || Mode as libc::c_uint == OS_SocketShutdownMode_SHUT_WRITE as libc::c_int as libc::c_uint
        || Mode as libc::c_uint
            == OS_SocketShutdownMode_SHUT_READWRITE as libc::c_int as libc::c_uint)
    {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"OS_SocketShutdown\0"))
                .as_ptr(),
            425 as libc::c_int,
            b"Mode == OS_SocketShutdownMode_SHUT_READ || Mode == OS_SocketShutdownMode_SHUT_WRITE || Mode == OS_SocketShutdownMode_SHUT_READWRITE\0"
                as *const u8 as *const libc::c_char,
            b"OS_ERR_INVALID_ARGUMENT\0" as *const u8 as *const libc::c_char,
        );
        return -(42 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*stream).socket_domain as libc::c_int == OS_SocketDomain_INVALID as libc::c_int {
            return_code = -(36 as libc::c_int);
        } else if (*stream).socket_type as libc::c_int == OS_SocketType_STREAM as libc::c_int
            && (*stream).stream_state as libc::c_int & OS_STREAM_STATE_CONNECTED as libc::c_int
                == 0 as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else {
            return_code = OS_SocketShutdown_Impl(&mut token, Mode);
            if return_code == 0 as libc::c_int {
                if Mode as libc::c_uint
                    & OS_SocketShutdownMode_SHUT_READ as libc::c_int as libc::c_uint
                    != 0
                {
                    (*stream).stream_state = ((*stream).stream_state as libc::c_int
                        & !(OS_STREAM_STATE_READABLE as libc::c_int))
                        as uint16;
                }
                if Mode as libc::c_uint
                    & OS_SocketShutdownMode_SHUT_WRITE as libc::c_int as libc::c_uint
                    != 0
                {
                    (*stream).stream_state = ((*stream).stream_state as libc::c_int
                        & !(OS_STREAM_STATE_WRITABLE as libc::c_int))
                        as uint16;
                }
            }
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketRecvFrom(
    mut sock_id: osal_id_t,
    mut buffer: *mut libc::c_void,
    mut buflen: size_t,
    mut RemoteAddr: *mut OS_SockAddr_t,
    mut timeout: int32,
) -> int32 {
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if buffer.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_SocketRecvFrom\0"))
                .as_ptr(),
            481 as libc::c_int,
            b"(buffer) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(buflen > 0 as libc::c_int as libc::c_ulong
        && buflen
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*stream).socket_type as libc::c_int != OS_SocketType_DATAGRAM as libc::c_int {
            return_code = -(36 as libc::c_int);
        } else if (*stream).stream_state as libc::c_int & OS_STREAM_STATE_BOUND as libc::c_int
            == 0 as libc::c_int
        {
            return_code = -(35 as libc::c_int);
        } else {
            return_code = OS_SocketRecvFrom_Impl(&mut token, buffer, buflen, RemoteAddr, timeout);
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketSendTo(
    mut sock_id: osal_id_t,
    mut buffer: *const libc::c_void,
    mut buflen: size_t,
    mut RemoteAddr: *const OS_SockAddr_t,
) -> int32 {
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if buffer.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SocketSendTo\0"))
                .as_ptr(),
            522 as libc::c_int,
            b"(buffer) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(buflen > 0 as libc::c_int as libc::c_ulong
        && buflen
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    if RemoteAddr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_SocketSendTo\0"))
                .as_ptr(),
            524 as libc::c_int,
            b"(RemoteAddr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        stream = &mut *OS_stream_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_stream_internal_record_t;
        if (*stream).socket_type as libc::c_int != OS_SocketType_DATAGRAM as libc::c_int {
            return_code = -(36 as libc::c_int);
        } else {
            return_code = OS_SocketSendTo_Impl(&mut token, buffer, buflen, RemoteAddr);
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketGetIdByName(
    mut sock_id: *mut osal_id_t,
    mut sock_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    if sock_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketGetIdByName\0"))
                .as_ptr(),
            557 as libc::c_int,
            b"(sock_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if sock_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketGetIdByName\0"))
                .as_ptr(),
            558 as libc::c_int,
            b"(sock_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_name,
        sock_id,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketGetInfo(
    mut sock_id: osal_id_t,
    mut sock_prop: *mut OS_socket_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut return_code: int32 = 0;
    if sock_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_SocketGetInfo\0"))
                .as_ptr(),
            578 as libc::c_int,
            b"(sock_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        sock_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_socket_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_sockets_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        sock_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_stream_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        strncpy(
            ((*sock_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*sock_prop).creator = (*record).creator;
        return_code = OS_SocketGetInfo_Impl(&mut token, sock_prop);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrInit(
    mut Addr: *mut OS_SockAddr_t,
    mut Domain: OS_SocketDomain_t,
) -> int32 {
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_SocketAddrInit\0"))
                .as_ptr(),
            607 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return OS_SocketAddrInit_Impl(Addr, Domain);
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrToString(
    mut buffer: *mut libc::c_char,
    mut buflen: size_t,
    mut Addr: *const OS_SockAddr_t,
) -> int32 {
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_SocketAddrToString\0"))
                .as_ptr(),
            621 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if buffer.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_SocketAddrToString\0"))
                .as_ptr(),
            622 as libc::c_int,
            b"(buffer) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if !(buflen > 0 as libc::c_int as libc::c_ulong
        && buflen
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return OS_SocketAddrToString_Impl(buffer, buflen, Addr);
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrFromString(
    mut Addr: *mut OS_SockAddr_t,
    mut string: *const libc::c_char,
) -> int32 {
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"OS_SocketAddrFromString\0",
            ))
            .as_ptr(),
            637 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if string.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"OS_SocketAddrFromString\0",
            ))
            .as_ptr(),
            638 as libc::c_int,
            b"(string) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return OS_SocketAddrFromString_Impl(Addr, string);
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrGetPort(
    mut PortNum: *mut uint16,
    mut Addr: *const OS_SockAddr_t,
) -> int32 {
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketAddrGetPort\0"))
                .as_ptr(),
            652 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if PortNum.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketAddrGetPort\0"))
                .as_ptr(),
            653 as libc::c_int,
            b"(PortNum) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return OS_SocketAddrGetPort_Impl(PortNum, Addr);
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrSetPort(
    mut Addr: *mut OS_SockAddr_t,
    mut PortNum: uint16,
) -> int32 {
    if Addr.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketAddrSetPort\0"))
                .as_ptr(),
            667 as libc::c_int,
            b"(Addr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return OS_SocketAddrSetPort_Impl(Addr, PortNum);
}
#[no_mangle]
pub static mut OS_task_table: [OS_task_internal_record_t; 64] = [OS_task_internal_record_t {
    task_name: [0; 20],
    stack_size: 0,
    priority: 0,
    entry_function_pointer: None,
    delete_hook_pointer: None,
    entry_arg: 0 as *const libc::c_void as *mut libc::c_void,
    stack_pointer: 0 as *const libc::c_void as *mut libc::c_void,
}; 64];
unsafe extern "C" fn OS_TaskPrepare(
    mut task_id: osal_id_t,
    mut entrypt: *mut osal_task_entry,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut task: *mut OS_task_internal_record_t = 0 as *mut OS_task_internal_record_t;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        0x1 as libc::c_int as osal_objtype_t,
        task_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        task = &mut *OS_task_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_task_internal_record_t;
        return_code = OS_TaskMatch_Impl(&mut token);
        *entrypt = (*task).entry_function_pointer;
        OS_ObjectIdRelease(&mut token);
    }
    if return_code == 0 as libc::c_int {
        return_code = OS_TaskRegister_Impl(task_id);
    }
    if return_code == 0 as libc::c_int {
        return_code = OS_NotifyEvent(OS_EVENT_TASK_STARTUP, task_id, 0 as *mut libc::c_void);
    }
    if return_code != 0 as libc::c_int {
        *entrypt = None;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskEntryPoint(mut task_id: osal_id_t) {
    let mut task_entry: osal_task_entry = None;
    if OS_TaskPrepare(task_id, &mut task_entry) == 0 as libc::c_int {
        if task_entry.is_some() {
            (Some(task_entry.expect("non-null function pointer")))
                .expect("non-null function pointer")();
        }
    }
    OS_TaskExit();
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskAPI_Init() -> int32 {
    memset(
        OS_task_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_task_internal_record_t; 64]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskCreate(
    mut task_id: *mut osal_id_t,
    mut task_name: *const libc::c_char,
    mut function_pointer: osal_task_entry,
    mut stack_pointer: osal_stackptr_t,
    mut stack_size: size_t,
    mut priority: osal_priority_t,
    mut flags: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut task: *mut OS_task_internal_record_t = 0 as *mut OS_task_internal_record_t;
    if task_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_TaskCreate\0"))
                .as_ptr(),
            176 as libc::c_int,
            b"(task_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if function_pointer.is_none() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_TaskCreate\0"))
                .as_ptr(),
            177 as libc::c_int,
            b"(function_pointer) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if task_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_TaskCreate\0"))
                .as_ptr(),
            178 as libc::c_int,
            b"(task_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        task_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    if !(stack_size > 0 as libc::c_int as libc::c_ulong
        && stack_size
            < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)
                as libc::c_ulong)
    {
        return -(40 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        task_name,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        task = &mut *OS_task_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_task_internal_record_t;
        memset(
            task as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_task_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*task).task_name).as_mut_ptr(),
            task_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh11 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh11 = ((*task).task_name).as_mut_ptr();
        (*task).stack_size = stack_size;
        (*task).priority = priority;
        (*task).entry_function_pointer = function_pointer;
        (*task).stack_pointer = stack_pointer;
        flags |= 0 as libc::c_int as libc::c_uint;
        return_code = OS_TaskCreate_Impl(&mut token, flags);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, task_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskDelete(mut task_id: osal_id_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut task: *mut OS_task_internal_record_t = 0 as *mut OS_task_internal_record_t;
    let mut delete_hook: osal_task_entry = None;
    delete_hook = None;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        task_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        task = &mut *OS_task_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_task_internal_record_t;
        delete_hook = (*task).delete_hook_pointer;
        return_code = OS_TaskDelete_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    if return_code == 0 as libc::c_int && delete_hook.is_some() {
        delete_hook.expect("non-null function pointer")();
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskExit() {
    let mut task_id: osal_id_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    task_id = OS_TaskGetId_Impl();
    if OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        task_id,
        &mut token,
    ) == 0 as libc::c_int
    {
        OS_TaskDetach_Impl(&mut token);
        OS_ObjectIdFinalizeDelete(0 as libc::c_int, &mut token);
    }
    OS_TaskExit_Impl();
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskDelay(mut millisecond: uint32) -> int32 {
    return OS_TaskDelay_Impl(millisecond);
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskSetPriority(
    mut task_id: osal_id_t,
    mut new_priority: osal_priority_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut task: *mut OS_task_internal_record_t = 0 as *mut OS_task_internal_record_t;
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        task_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        task = &mut *OS_task_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_task_internal_record_t;
        return_code = OS_TaskSetPriority_Impl(&mut token, new_priority);
        if return_code == 0 as libc::c_int {
            (*task).priority = new_priority;
        }
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskGetId() -> osal_id_t {
    let mut task_id: osal_id_t = 0;
    task_id = OS_TaskGetId_Impl();
    return task_id;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskGetIdByName(
    mut task_id: *mut osal_id_t,
    mut task_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    if task_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_TaskGetIdByName\0"))
                .as_ptr(),
            343 as libc::c_int,
            b"(task_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if task_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_TaskGetIdByName\0"))
                .as_ptr(),
            344 as libc::c_int,
            b"(task_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        task_name,
        task_id,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskGetInfo(
    mut task_id: osal_id_t,
    mut task_prop: *mut OS_task_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut task: *mut OS_task_internal_record_t = 0 as *mut OS_task_internal_record_t;
    if task_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_TaskGetInfo\0"))
                .as_ptr(),
            365 as libc::c_int,
            b"(task_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    memset(
        task_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_task_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        task_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_task_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        task = &mut *OS_task_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_task_internal_record_t;
        if !((*record).name_entry).is_null() {
            strncpy(
                ((*task_prop).name).as_mut_ptr(),
                (*record).name_entry,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*task_prop).name[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
        }
        (*task_prop).creator = (*record).creator;
        (*task_prop).stack_size = (*task).stack_size;
        (*task_prop).priority = (*task).priority;
        return_code = OS_TaskGetInfo_Impl(&mut token, task_prop);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskInstallDeleteHandler(
    mut function_pointer: osal_task_entry,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut task: *mut OS_task_internal_record_t = 0 as *mut OS_task_internal_record_t;
    let mut task_id: osal_id_t = 0;
    task_id = OS_TaskGetId_Impl();
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        task_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        task = &mut *OS_task_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_task_internal_record_t;
        (*task).delete_hook_pointer = function_pointer;
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskFindIdBySystemData(
    mut task_id: *mut osal_id_t,
    mut sysdata: *const libc::c_void,
    mut sysdata_size: size_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    if task_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
                b"OS_TaskFindIdBySystemData\0",
            ))
            .as_ptr(),
            434 as libc::c_int,
            b"(task_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_TaskValidateSystemData_Impl(sysdata, sysdata_size);
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    return_code = OS_ObjectIdGetBySearch(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_task_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        Some(
            OS_TaskIdMatchSystemData_Impl
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const OS_object_token_t,
                    *const OS_common_record_t,
                ) -> bool,
        ),
        sysdata as *mut libc::c_void,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        *task_id = OS_ObjectIdFromToken(&mut token);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_timebase_table: [OS_timebase_internal_record_t; 5] =
    [OS_timebase_internal_record_t {
        timebase_name: [0; 20],
        external_sync: None,
        accuracy_usec: 0,
        first_cb: 0,
        freerun_time: 0,
        nominal_start_time: 0,
        nominal_interval_time: 0,
    }; 5];
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseAPI_Init() -> int32 {
    memset(
        OS_timebase_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_timebase_internal_record_t; 5]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseCreate(
    mut timebase_id: *mut osal_id_t,
    mut timebase_name: *const libc::c_char,
    mut external_sync: OS_TimerSync_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    if timebase_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_TimeBaseCreate\0"))
                .as_ptr(),
            108 as libc::c_int,
            b"(timebase_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if timebase_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_TimeBaseCreate\0"))
                .as_ptr(),
            109 as libc::c_int,
            b"(timebase_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        timebase_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdAllocateNew(
        0x8 as libc::c_int as osal_objtype_t,
        timebase_name,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_timebase_internal_record_t;
        memset(
            timebase as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_timebase_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*timebase).timebase_name).as_mut_ptr(),
            timebase_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh12 = (*OS_ObjectIdGlobalFromToken(&mut token)).name_entry;
        *fresh12 = ((*timebase).timebase_name).as_mut_ptr();
        (*timebase).external_sync = external_sync;
        if external_sync.is_none() {
            (*timebase).accuracy_usec = OS_SharedGlobalVars.MicroSecPerTick;
        } else {
            (*timebase).accuracy_usec = 0 as libc::c_int as uint32;
        }
        return_code = OS_TimeBaseCreate_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut token, timebase_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseSet(
    mut timebase_id: osal_id_t,
    mut start_time: uint32,
    mut interval_time: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    if !(start_time < 1000000000 as libc::c_int as libc::c_uint) {
        return -(29 as libc::c_int);
    }
    if !(interval_time < 1000000000 as libc::c_int as libc::c_uint) {
        return -(29 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        0x8 as libc::c_int as osal_objtype_t,
        timebase_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_timebase_internal_record_t;
        OS_TimeBaseLock_Impl(&mut token);
        return_code = OS_TimeBaseSet_Impl(&mut token, start_time, interval_time);
        if return_code == 0 as libc::c_int {
            (*timebase).nominal_start_time = start_time;
            (*timebase).nominal_interval_time = interval_time;
        }
        OS_TimeBaseUnlock_Impl(&mut token);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseDelete(mut timebase_id: osal_id_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        0x8 as libc::c_int as osal_objtype_t,
        timebase_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        return_code = OS_TimeBaseDelete_Impl(&mut token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseGetIdByName(
    mut timebase_id: *mut osal_id_t,
    mut timebase_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    if timebase_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"OS_TimeBaseGetIdByName\0",
            ))
            .as_ptr(),
            255 as libc::c_int,
            b"(timebase_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if timebase_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"OS_TimeBaseGetIdByName\0",
            ))
            .as_ptr(),
            256 as libc::c_int,
            b"(timebase_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        timebase_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(
        0x8 as libc::c_int as osal_objtype_t,
        timebase_name,
        timebase_id,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseGetInfo(
    mut timebase_id: osal_id_t,
    mut timebase_prop: *mut OS_timebase_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    if timebase_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_TimeBaseGetInfo\0"))
                .as_ptr(),
            288 as libc::c_int,
            b"(timebase_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    memset(
        timebase_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_timebase_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        osal_src_os_shared_src_osapi_timebase_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        timebase_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_timebase_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_timebase_internal_record_t;
        strncpy(
            ((*timebase_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*timebase_prop).creator = (*record).creator;
        (*timebase_prop).nominal_interval_time = (*timebase).nominal_interval_time;
        (*timebase_prop).freerun_time = (*timebase).freerun_time;
        (*timebase_prop).accuracy = (*timebase).accuracy_usec;
        return_code = OS_TimeBaseGetInfo_Impl(&mut token, timebase_prop);
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseGetFreeRun(
    mut timebase_id: osal_id_t,
    mut freerun_val: *mut uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    if freerun_val.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_TimeBaseGetFreeRun\0"))
                .as_ptr(),
            335 as libc::c_int,
            b"(freerun_val) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        osal_src_os_shared_src_osapi_timebase_c__LOCAL_OBJID_TYPE as libc::c_int as osal_objtype_t,
        timebase_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_timebase_internal_record_t;
        *freerun_val = (*timebase).freerun_time;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBase_CallbackThread(mut timebase_id: osal_id_t) {
    let mut syncfunc: OS_TimerSync_t = None;
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    let mut timecb: *mut OS_timecb_internal_record_t = 0 as *mut OS_timecb_internal_record_t;
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut cb_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut tick_time: uint32 = 0;
    let mut spin_cycles: uint32 = 0;
    let mut saved_wait_time: int32 = 0;
    OS_TaskRegister_Impl(timebase_id);
    if OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        0x8 as libc::c_int as osal_objtype_t,
        timebase_id,
        &mut token,
    ) != 0 as libc::c_int
    {
        return;
    }
    record = &mut *OS_global_timebase_table.offset((OS_ObjectIndexFromToken
        as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
        &mut token
    ) as isize) as *mut OS_common_record_t;
    timebase = &mut *OS_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_timebase_internal_record_t;
    syncfunc = (*timebase).external_sync;
    spin_cycles = 0 as libc::c_int as uint32;
    OS_ObjectIdRelease(&mut token);
    loop {
        tick_time = (Some(syncfunc.expect("non-null function pointer")))
            .expect("non-null function pointer")(timebase_id);
        if tick_time != 0 as libc::c_int as libc::c_uint {
            spin_cycles = 0 as libc::c_int as uint32;
        } else if spin_cycles < 4 as libc::c_int as libc::c_uint {
            spin_cycles = spin_cycles.wrapping_add(1);
            spin_cycles;
        } else {
            OS_TaskDelay_Impl(10 as libc::c_int as uint32);
            if spin_cycles == 4 as libc::c_int as libc::c_uint {
                spin_cycles = spin_cycles.wrapping_add(1);
                spin_cycles;
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                        b"OS_TimeBase_CallbackThread\0",
                    ))
                    .as_ptr(),
                    444 as libc::c_int as uint32,
                    b"WARNING: Timebase Sync Spin Loop detected\n\0" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        OS_TimeBaseLock_Impl(&mut token);
        if !OS_ObjectIdEqual(timebase_id, (*record).active_id) {
            OS_TimeBaseUnlock_Impl(&mut token);
            break;
        } else {
            (*timebase).freerun_time = ((*timebase).freerun_time as libc::c_uint)
                .wrapping_add(tick_time) as uint32 as uint32;
            if OS_ObjectIdGetById(
                OS_LOCK_MODE_NONE,
                0x9 as libc::c_int as osal_objtype_t,
                (*timebase).first_cb,
                &mut cb_token,
            ) == 0 as libc::c_int
            {
                loop {
                    timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                        as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                        &mut cb_token,
                    )
                        as isize) as *mut OS_timecb_internal_record_t;
                    saved_wait_time = (*timecb).wait_time;
                    (*timecb).wait_time = ((*timecb).wait_time as libc::c_uint)
                        .wrapping_sub(tick_time) as int32
                        as int32;
                    while (*timecb).wait_time <= 0 as libc::c_int {
                        (*timecb).wait_time += (*timecb).interval_time;
                        if (*timecb).wait_time < -(*timecb).interval_time {
                            (*timecb).backlog_resets = ((*timecb).backlog_resets).wrapping_add(1);
                            (*timecb).backlog_resets;
                            (*timecb).wait_time = -(*timecb).interval_time;
                        }
                        if saved_wait_time > 0 as libc::c_int && ((*timecb).callback_ptr).is_some()
                        {
                            (Some(((*timecb).callback_ptr).expect("non-null function pointer")))
                                .expect("non-null function pointer")(
                                OS_ObjectIdFromToken(&mut cb_token),
                                (*timecb).callback_arg,
                            );
                        }
                        if (*timecb).interval_time <= 0 as libc::c_int {
                            break;
                        }
                    }
                    if !(OS_ObjectIdGetById(
                        OS_LOCK_MODE_NONE,
                        0x9 as libc::c_int as osal_objtype_t,
                        (*timecb).next_cb,
                        &mut cb_token,
                    ) == 0 as libc::c_int
                        && !OS_ObjectIdEqual(
                            OS_ObjectIdFromToken(&mut cb_token),
                            (*timebase).first_cb,
                        ))
                    {
                        break;
                    }
                }
            }
            OS_TimeBaseUnlock_Impl(&mut token);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_Milli2Ticks(
    mut milli_seconds: uint32,
    mut ticks: *mut libc::c_int,
) -> int32 {
    let mut num_of_ticks: uint64 = 0;
    let mut return_code: int32 = 0 as libc::c_int;
    num_of_ticks = (milli_seconds as uint64)
        .wrapping_mul(OS_SharedGlobalVars.TicksPerSecond as libc::c_ulong)
        .wrapping_add(999 as libc::c_int as libc::c_ulong)
        .wrapping_div(1000 as libc::c_int as libc::c_ulong);
    if num_of_ticks <= 2147483647 as libc::c_int as libc::c_ulong {
        *ticks = num_of_ticks as libc::c_int;
    } else {
        return_code = -(1 as libc::c_int);
        *ticks = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_timecb_table: [OS_timecb_internal_record_t; 10] = [OS_timecb_internal_record_t {
    timer_name: [0; 20],
    flags: 0,
    timebase_token: OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    },
    prev_cb: 0,
    next_cb: 0,
    backlog_resets: 0,
    wait_time: 0,
    interval_time: 0,
    callback_ptr: None,
    callback_arg: 0 as *const libc::c_void as *mut libc::c_void,
}; 10];
#[no_mangle]
pub unsafe extern "C" fn OS_TimerCbAPI_Init() -> int32 {
    memset(
        OS_timecb_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_timecb_internal_record_t; 10]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn OS_DoTimerAdd(
    mut timer_id: *mut osal_id_t,
    mut timer_name: *const libc::c_char,
    mut timebase_ref_id: osal_id_t,
    mut callback_ptr: OS_ArgCallback_t,
    mut callback_arg: *mut libc::c_void,
    mut flags: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut timebase_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timecb_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut listcb_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timecb: *mut OS_timecb_internal_record_t = 0 as *mut OS_timecb_internal_record_t;
    let mut list_timecb: *mut OS_timecb_internal_record_t = 0 as *mut OS_timecb_internal_record_t;
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    if timer_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_DoTimerAdd\0"))
                .as_ptr(),
            107 as libc::c_int,
            b"(timer_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if timer_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_DoTimerAdd\0"))
                .as_ptr(),
            108 as libc::c_int,
            b"(timer_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        timer_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    if callback_ptr.is_none() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"OS_DoTimerAdd\0"))
                .as_ptr(),
            109 as libc::c_int,
            b"(callback_ptr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        0x8 as libc::c_int as osal_objtype_t,
        timebase_ref_id,
        &mut timebase_token,
    );
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    return_code = OS_ObjectIdAllocateNew(
        0x9 as libc::c_int as osal_objtype_t,
        timer_name,
        &mut timecb_token,
    );
    if return_code == 0 as libc::c_int {
        timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut timecb_token
        ) as isize) as *mut OS_timecb_internal_record_t;
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut timebase_token,
            ) as isize) as *mut OS_timebase_internal_record_t;
        memset(
            timecb as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<OS_timecb_internal_record_t>() as libc::c_ulong,
        );
        strncpy(
            ((*timecb).timer_name).as_mut_ptr(),
            timer_name,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        let ref mut fresh13 = (*OS_ObjectIdGlobalFromToken(&mut timecb_token)).name_entry;
        *fresh13 = ((*timecb).timer_name).as_mut_ptr();
        OS_ObjectIdTransferToken(&mut timebase_token, &mut (*timecb).timebase_token);
        (*timecb).callback_ptr = callback_ptr;
        (*timecb).callback_arg = callback_arg;
        (*timecb).flags = flags;
        (*timecb).prev_cb = OS_ObjectIdFromToken(&mut timecb_token);
        (*timecb).next_cb = OS_ObjectIdFromToken(&mut timecb_token);
        OS_TimeBaseLock_Impl(&mut timebase_token);
        if OS_ObjectIdGetById(
            OS_LOCK_MODE_NONE,
            0x9 as libc::c_int as osal_objtype_t,
            (*timebase).first_cb,
            &mut listcb_token,
        ) == 0 as libc::c_int
        {
            list_timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut listcb_token,
            ) as isize) as *mut OS_timecb_internal_record_t;
            (*timecb).next_cb = OS_ObjectIdFromToken(&mut listcb_token);
            (*timecb).prev_cb = (*list_timecb).prev_cb;
            if OS_ObjectIdGetById(
                OS_LOCK_MODE_NONE,
                0x9 as libc::c_int as osal_objtype_t,
                (*timecb).prev_cb,
                &mut listcb_token,
            ) == 0 as libc::c_int
            {
                (*list_timecb).prev_cb = OS_ObjectIdFromToken(&mut timecb_token);
                list_timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                    as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                    &mut listcb_token,
                ) as isize) as *mut OS_timecb_internal_record_t;
                (*list_timecb).next_cb = OS_ObjectIdFromToken(&mut timecb_token);
            }
        }
        (*timebase).first_cb = OS_ObjectIdFromToken(&mut timecb_token);
        OS_TimeBaseUnlock_Impl(&mut timebase_token);
        return_code = OS_ObjectIdFinalizeNew(return_code, &mut timecb_token, timer_id);
    } else {
        OS_ObjectIdRelease(&mut timebase_token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimerAdd(
    mut timer_id: *mut osal_id_t,
    mut timer_name: *const libc::c_char,
    mut timebase_id: osal_id_t,
    mut callback_ptr: OS_ArgCallback_t,
    mut callback_arg: *mut libc::c_void,
) -> int32 {
    return OS_DoTimerAdd(
        timer_id,
        timer_name,
        timebase_id,
        callback_ptr,
        callback_arg,
        0 as libc::c_int as uint32,
    );
}
unsafe extern "C" fn OS_Timer_NoArgCallback(mut objid: osal_id_t, mut arg: *mut libc::c_void) {
    let mut Conv: OS_Timer_ArgWrapper_t = OS_Timer_ArgWrapper_t {
        timer_callback_func: None,
    };
    Conv.opaque_arg = arg;
    (Some((Conv.timer_callback_func).expect("non-null function pointer")))
        .expect("non-null function pointer")(objid);
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimerCreate(
    mut timer_id: *mut osal_id_t,
    mut timer_name: *const libc::c_char,
    mut clock_accuracy: *mut uint32,
    mut callback_ptr: OS_TimerCallback_t,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut timebase_ref_id: osal_id_t = 0;
    let mut Conv: OS_Timer_ArgWrapper_t = OS_Timer_ArgWrapper_t {
        timer_callback_func: None,
    };
    if timer_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_TimerCreate\0"))
                .as_ptr(),
            241 as libc::c_int,
            b"(timer_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if timer_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_TimerCreate\0"))
                .as_ptr(),
            242 as libc::c_int,
            b"(timer_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if (memchr(
        timer_name as *const libc::c_void,
        '\0' as i32,
        20 as libc::c_int as libc::c_ulong,
    ))
    .is_null()
    {
        return -(13 as libc::c_int);
    }
    if clock_accuracy.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_TimerCreate\0"))
                .as_ptr(),
            243 as libc::c_int,
            b"(clock_accuracy) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if callback_ptr.is_none() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"OS_TimerCreate\0"))
                .as_ptr(),
            244 as libc::c_int,
            b"(callback_ptr) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    return_code = OS_TimeBaseCreate(&mut timebase_ref_id, timer_name, None);
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    Conv.opaque_arg = 0 as *mut libc::c_void;
    Conv.timer_callback_func = callback_ptr;
    return_code = OS_DoTimerAdd(
        timer_id,
        timer_name,
        timebase_ref_id,
        Some(OS_Timer_NoArgCallback as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> ()),
        Conv.opaque_arg,
        0x1 as libc::c_int as uint32,
    );
    if return_code != 0 as libc::c_int {
        OS_TimeBaseDelete(timebase_ref_id);
    } else {
        *clock_accuracy = OS_SharedGlobalVars.MicroSecPerTick;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimerSet(
    mut timer_id: osal_id_t,
    mut start_time: uint32,
    mut interval_time: uint32,
) -> int32 {
    let mut timecb: *mut OS_timecb_internal_record_t = 0 as *mut OS_timecb_internal_record_t;
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut dedicated_timebase_id: osal_id_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    dedicated_timebase_id = 0 as libc::c_int as osal_id_t;
    if !(start_time < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint)) {
        return -(29 as libc::c_int);
    }
    if !(interval_time
        < (4294967295 as libc::c_uint).wrapping_div(2 as libc::c_int as libc::c_uint))
    {
        return -(29 as libc::c_int);
    }
    if !(start_time != 0 as libc::c_int as libc::c_uint
        || interval_time != 0 as libc::c_int as libc::c_uint)
    {
        return -(29 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        0x9 as libc::c_int as osal_objtype_t,
        timer_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_timecb_internal_record_t;
        OS_TimeBaseLock_Impl(&mut (*timecb).timebase_token);
        if (*timecb).flags & 0x1 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint
        {
            dedicated_timebase_id = OS_ObjectIdFromToken(&mut (*timecb).timebase_token);
        }
        (*timecb).wait_time = start_time as int32;
        (*timecb).interval_time = interval_time as int32;
        OS_TimeBaseUnlock_Impl(&mut (*timecb).timebase_token);
        OS_ObjectIdRelease(&mut token);
    }
    if return_code == 0 as libc::c_int
        && OS_ObjectIdDefined(dedicated_timebase_id) as libc::c_int != 0
    {
        return_code = OS_TimeBaseSet(dedicated_timebase_id, start_time, interval_time);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimerDelete(mut timer_id: osal_id_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut dedicated_timebase_id: osal_id_t = 0;
    let mut timecb_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timebase_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut listcb_token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    let mut timecb: *mut OS_timecb_internal_record_t = 0 as *mut OS_timecb_internal_record_t;
    let mut list_timecb: *mut OS_timecb_internal_record_t = 0 as *mut OS_timecb_internal_record_t;
    dedicated_timebase_id = 0 as libc::c_int as osal_id_t;
    memset(
        &mut timebase_token as *mut OS_object_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_object_token_t>() as libc::c_ulong,
    );
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_EXCLUSIVE,
        0x9 as libc::c_int as osal_objtype_t,
        timer_id,
        &mut timecb_token,
    );
    if return_code == 0 as libc::c_int {
        timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut timecb_token
        ) as isize) as *mut OS_timecb_internal_record_t;
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut (*timecb).timebase_token,
            ) as isize) as *mut OS_timebase_internal_record_t;
        OS_ObjectIdTransferToken(&mut (*timecb).timebase_token, &mut timebase_token);
        OS_TimeBaseLock_Impl(&mut (*timecb).timebase_token);
        if (*timecb).flags & 0x1 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint
        {
            dedicated_timebase_id = OS_ObjectIdFromToken(&mut (*timecb).timebase_token);
        }
        if OS_ObjectIdEqual(
            (*timebase).first_cb,
            OS_ObjectIdFromToken(&mut timecb_token),
        ) {
            if OS_ObjectIdEqual(OS_ObjectIdFromToken(&mut timecb_token), (*timecb).next_cb) {
                (*timebase).first_cb = 0 as libc::c_int as osal_id_t;
            } else {
                (*timebase).first_cb = (*timecb).next_cb;
            }
        }
        if OS_ObjectIdGetById(
            OS_LOCK_MODE_NONE,
            0x9 as libc::c_int as osal_objtype_t,
            (*timecb).prev_cb,
            &mut listcb_token,
        ) == 0 as libc::c_int
        {
            list_timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut listcb_token,
            ) as isize) as *mut OS_timecb_internal_record_t;
            (*list_timecb).next_cb = (*timecb).next_cb;
        }
        if OS_ObjectIdGetById(
            OS_LOCK_MODE_NONE,
            0x9 as libc::c_int as osal_objtype_t,
            (*timecb).next_cb,
            &mut listcb_token,
        ) == 0 as libc::c_int
        {
            list_timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut listcb_token,
            ) as isize) as *mut OS_timecb_internal_record_t;
            (*list_timecb).prev_cb = (*timecb).prev_cb;
        }
        (*timecb).next_cb = OS_ObjectIdFromToken(&mut timecb_token);
        (*timecb).prev_cb = OS_ObjectIdFromToken(&mut timecb_token);
        OS_TimeBaseUnlock_Impl(&mut (*timecb).timebase_token);
        return_code = OS_ObjectIdFinalizeDelete(return_code, &mut timecb_token);
    }
    OS_ObjectIdRelease(&mut timebase_token);
    if return_code == 0 as libc::c_int
        && OS_ObjectIdDefined(dedicated_timebase_id) as libc::c_int != 0
    {
        OS_TimeBaseDelete(dedicated_timebase_id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimerGetIdByName(
    mut timer_id: *mut osal_id_t,
    mut timer_name: *const libc::c_char,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    if timer_id.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"OS_TimerGetIdByName\0"))
                .as_ptr(),
            471 as libc::c_int,
            b"(timer_id) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    if timer_name.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"OS_TimerGetIdByName\0"))
                .as_ptr(),
            472 as libc::c_int,
            b"(timer_name) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    return_code = OS_ObjectIdFindByName(0x9 as libc::c_int as osal_objtype_t, timer_name, timer_id);
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimerGetInfo(
    mut timer_id: osal_id_t,
    mut timer_prop: *mut OS_timer_prop_t,
) -> int32 {
    let mut record: *mut OS_common_record_t = 0 as *mut OS_common_record_t;
    let mut return_code: int32 = 0;
    let mut objtype: osal_objtype_t = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut timecb: *mut OS_timecb_internal_record_t = 0 as *mut OS_timecb_internal_record_t;
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    if timer_prop.is_null() {
        OS_printf(
            b"\n**BUG** %s():%d:check '%s' FAILED --> %s\n\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"OS_TimerGetInfo\0"))
                .as_ptr(),
            505 as libc::c_int,
            b"(timer_prop) != NULL\0" as *const u8 as *const libc::c_char,
            b"OS_INVALID_POINTER\0" as *const u8 as *const libc::c_char,
        );
        return -(2 as libc::c_int);
    }
    objtype = OS_ObjectIdToType_Impl(OS_TaskGetId_Impl());
    if objtype == 0x8 as libc::c_int as libc::c_uint {
        return -(35 as libc::c_int);
    }
    memset(
        timer_prop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_timer_prop_t>() as libc::c_ulong,
    );
    return_code = OS_ObjectIdGetById(
        OS_LOCK_MODE_GLOBAL,
        0x9 as libc::c_int as osal_objtype_t,
        timer_id,
        &mut token,
    );
    if return_code == 0 as libc::c_int {
        record = &mut *OS_global_timecb_table.offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_common_record_t;
        timecb = &mut *OS_timecb_table.as_mut_ptr().offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            &mut token
        ) as isize) as *mut OS_timecb_internal_record_t;
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut (*timecb).timebase_token,
            ) as isize) as *mut OS_timebase_internal_record_t;
        strncpy(
            ((*timer_prop).name).as_mut_ptr(),
            (*record).name_entry,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*timer_prop).creator = (*record).creator;
        (*timer_prop).interval_time = (*timecb).interval_time as uint32;
        (*timer_prop).accuracy = (*timebase).accuracy_usec;
        OS_ObjectIdRelease(&mut token);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetVersionString() -> *const libc::c_char {
    return b"equuleus-rc1+dev53\0" as *const u8 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetVersionNumber(mut VersionNumbers: *mut uint8) {
    *VersionNumbers.offset(0 as libc::c_int as isize) = 5 as libc::c_int as uint8;
    *VersionNumbers.offset(1 as libc::c_int as isize) = 0 as libc::c_int as uint8;
    *VersionNumbers.offset(2 as libc::c_int as isize) = 0 as libc::c_int as uint8;
    *VersionNumbers.offset(3 as libc::c_int as isize) = 0xff as libc::c_int as uint8;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetVersionCodeName() -> *const libc::c_char {
    return b"Equuleus\0" as *const u8 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetBuildNumber() -> uint32 {
    return 53 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DebugPrintf(
    mut Level: uint32,
    mut Func: *const libc::c_char,
    mut Line: uint32,
    mut Format: *const libc::c_char,
    mut args: ...
) {
    let mut buffer: [libc::c_char; 132] = [0; 132];
    let mut va: ::core::ffi::VaListImpl;
    if OS_SharedGlobalVars.DebugLevel as libc::c_uint >= Level {
        OS_BSP_Lock_Impl();
        snprintf(
            buffer.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 132]>() as libc::c_ulong,
            b"%s():%lu:\0" as *const u8 as *const libc::c_char,
            Func,
            Line as libc::c_ulong,
        );
        OS_BSP_ConsoleOutput_Impl(buffer.as_mut_ptr(), strlen(buffer.as_mut_ptr()));
        va = args.clone();
        vsnprintf(
            buffer.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 132]>() as libc::c_ulong,
            Format,
            va.as_va_list(),
        );
        OS_BSP_ConsoleOutput_Impl(buffer.as_mut_ptr(), strlen(buffer.as_mut_ptr()));
        OS_BSP_Unlock_Impl();
    }
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GetContext() -> UtAssert_CaseType_t {
    return DefaultContext;
}
#[no_mangle]
pub static mut DefaultContext: UtAssert_CaseType_t = UTASSERT_CASETYPE_FAILURE;
#[no_mangle]
pub unsafe extern "C" fn UtAssertEx(
    mut Expression: bool,
    mut CaseType: UtAssert_CaseType_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut MessageFormat: *const libc::c_char,
    mut args: ...
) -> bool {
    let mut va: ::core::ffi::VaListImpl;
    let mut FinalMessage: [libc::c_char; 256] = [0; 256];
    let mut TestSegmentCount: uint32 = 0;
    let mut TotalTestCases: uint32 = 0;
    UT_BSP_Lock();
    UT_SegmentCounters.TotalTestCases = (UT_SegmentCounters.TotalTestCases).wrapping_add(1);
    UT_SegmentCounters.TotalTestCases;
    if Expression {
        CaseType = UTASSERT_CASETYPE_PASS;
    }
    if (CaseType as uint32) < UTASSERT_CASETYPE_MAX as libc::c_int as libc::c_uint {
        UT_SegmentCounters.CaseCount[CaseType as uint32 as usize] =
            (UT_SegmentCounters.CaseCount[CaseType as uint32 as usize]).wrapping_add(1);
        UT_SegmentCounters.CaseCount[CaseType as uint32 as usize];
    }
    TestSegmentCount =
        (1 as libc::c_int as libc::c_uint).wrapping_add(UT_TotalCounters.TestSegmentCount);
    TotalTestCases = UT_SegmentCounters.TotalTestCases;
    UT_BSP_Unlock();
    va = args.clone();
    vsnprintf(
        FinalMessage.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        MessageFormat,
        va.as_va_list(),
    );
    UtAssert_DoReport(
        File,
        Line,
        TestSegmentCount,
        TotalTestCases,
        CaseType as uint8,
        CurrentSegment.as_mut_ptr(),
        FinalMessage.as_mut_ptr(),
    );
    return Expression;
}
static mut CurrentSegment: [libc::c_char; 64] = [0; 64];
#[no_mangle]
pub unsafe extern "C" fn UtAssert_DoReport(
    mut File: *const libc::c_char,
    mut LineNum: uint32,
    mut SegmentNum: uint32,
    mut TestSeq: uint32,
    mut MessageType: uint8,
    mut SubsysName: *const libc::c_char,
    mut ShortDesc: *const libc::c_char,
) {
    let mut FileLen: uint32 = 0;
    let mut BasePtr: *const libc::c_char = 0 as *const libc::c_char;
    let mut ReportBuffer: [libc::c_char; 320] = [0; 320];
    FileLen = strlen(File) as uint32;
    BasePtr = File.offset(FileLen as isize);
    while FileLen > 0 as libc::c_int as libc::c_uint {
        BasePtr = BasePtr.offset(-1);
        BasePtr;
        FileLen = FileLen.wrapping_sub(1);
        FileLen;
        if !(*BasePtr as libc::c_int == '/' as i32 || *BasePtr as libc::c_int == '\\' as i32) {
            continue;
        }
        BasePtr = BasePtr.offset(1);
        BasePtr;
        break;
    }
    snprintf(
        ReportBuffer.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 320]>() as libc::c_ulong,
        b"%02u.%03u %s:%u - %s\0" as *const u8 as *const libc::c_char,
        SegmentNum,
        TestSeq,
        BasePtr,
        LineNum,
        ShortDesc,
    );
    UT_BSP_DoText(MessageType, ReportBuffer.as_mut_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GetCaseTypeAbbrev(
    mut CaseType: UtAssert_CaseType_t,
) -> *const libc::c_char {
    let mut AbbrevStr: *const libc::c_char = 0 as *const libc::c_char;
    match CaseType as libc::c_uint {
        1 => {
            AbbrevStr = b"ABORT\0" as *const u8 as *const libc::c_char;
        }
        2 => {
            AbbrevStr = b"FAIL\0" as *const u8 as *const libc::c_char;
        }
        5 => {
            AbbrevStr = b"MIR\0" as *const u8 as *const libc::c_char;
        }
        3 => {
            AbbrevStr = b"TSF\0" as *const u8 as *const libc::c_char;
        }
        4 => {
            AbbrevStr = b"TTF\0" as *const u8 as *const libc::c_char;
        }
        6 => {
            AbbrevStr = b"WARN\0" as *const u8 as *const libc::c_char;
        }
        7 => {
            AbbrevStr = b"N/A\0" as *const u8 as *const libc::c_char;
        }
        8 => {
            AbbrevStr = b"BEGIN\0" as *const u8 as *const libc::c_char;
        }
        9 => {
            AbbrevStr = b"END\0" as *const u8 as *const libc::c_char;
        }
        11 => {
            AbbrevStr = b"PASS\0" as *const u8 as *const libc::c_char;
        }
        10 => {
            AbbrevStr = b"INFO\0" as *const u8 as *const libc::c_char;
        }
        12 => {
            AbbrevStr = b"FLOW\0" as *const u8 as *const libc::c_char;
        }
        13 => {
            AbbrevStr = b"DEBUG\0" as *const u8 as *const libc::c_char;
        }
        _ => {
            AbbrevStr = b"OTHER\0" as *const u8 as *const libc::c_char;
        }
    }
    return AbbrevStr;
}
#[no_mangle]
pub static mut UT_SegmentCounters: UtAssert_TestCounter_t = {
    let mut init = UtAssert_TestCounter_t {
        TestSegmentCount: 0 as libc::c_int as uint32,
        TotalTestCases: 0,
        CaseCount: [0; 14],
    };
    init
};
#[no_mangle]
pub static mut UT_TotalCounters: UtAssert_TestCounter_t = {
    let mut init = UtAssert_TestCounter_t {
        TestSegmentCount: 0 as libc::c_int as uint32,
        TotalTestCases: 0,
        CaseCount: [0; 14],
    };
    init
};
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GetPassCount() -> uint32 {
    return UT_TotalCounters.CaseCount[UTASSERT_CASETYPE_PASS as libc::c_int as usize];
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GetFailCount() -> uint32 {
    return UT_TotalCounters.CaseCount[UTASSERT_CASETYPE_FAILURE as libc::c_int as usize];
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GetCounters() -> *const UtAssert_TestCounter_t {
    return &mut UT_TotalCounters;
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_BeginTest(mut SegmentName: *const libc::c_char) {
    let mut TestSegmentCount: uint32 = 0;
    UT_BSP_Lock();
    memset(
        &mut UT_SegmentCounters as *mut UtAssert_TestCounter_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<UtAssert_TestCounter_t>() as libc::c_ulong,
    );
    strncpy(
        CurrentSegment.as_mut_ptr(),
        SegmentName,
        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    CurrentSegment[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
        0 as libc::c_int as libc::c_char;
    TestSegmentCount =
        (1 as libc::c_int as libc::c_uint).wrapping_add(UT_TotalCounters.TestSegmentCount);
    UT_BSP_Unlock();
    UT_BSP_StartTestSegment(TestSegmentCount, SegmentName);
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_EndTest() {
    let mut Ct: uint32 = 0;
    let mut SegmentValid: bool = false;
    let mut Local_SegmentCounters: UtAssert_TestCounter_t = UtAssert_TestCounter_t {
        TestSegmentCount: 0,
        TotalTestCases: 0,
        CaseCount: [0; 14],
    };
    let mut Local_SegmentName: [libc::c_char; 64] = [0; 64];
    UT_BSP_Lock();
    SegmentValid = UT_SegmentCounters.TotalTestCases > 0 as libc::c_int as libc::c_uint;
    if SegmentValid {
        UT_TotalCounters.TestSegmentCount = (UT_TotalCounters.TestSegmentCount).wrapping_add(1);
        UT_TotalCounters.TestSegmentCount;
        UT_SegmentCounters.TestSegmentCount = UT_TotalCounters.TestSegmentCount;
        UT_TotalCounters.TotalTestCases = (UT_TotalCounters.TotalTestCases as libc::c_uint)
            .wrapping_add(UT_SegmentCounters.TotalTestCases)
            as uint32 as uint32;
        Ct = 0 as libc::c_int as uint32;
        while Ct < UTASSERT_CASETYPE_MAX as libc::c_int as libc::c_uint {
            UT_TotalCounters.CaseCount[Ct as usize] = (UT_TotalCounters.CaseCount[Ct as usize]
                as libc::c_uint)
                .wrapping_add(UT_SegmentCounters.CaseCount[Ct as usize])
                as uint32 as uint32;
            Ct = Ct.wrapping_add(1);
            Ct;
        }
        memcpy(
            &mut Local_SegmentCounters as *mut UtAssert_TestCounter_t as *mut libc::c_void,
            &mut UT_SegmentCounters as *mut UtAssert_TestCounter_t as *const libc::c_void,
            ::core::mem::size_of::<UtAssert_TestCounter_t>() as libc::c_ulong,
        );
        strcpy(Local_SegmentName.as_mut_ptr(), CurrentSegment.as_mut_ptr());
    }
    memset(
        &mut UT_SegmentCounters as *mut UtAssert_TestCounter_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<UtAssert_TestCounter_t>() as libc::c_ulong,
    );
    UT_BSP_Unlock();
    if SegmentValid {
        UtAssert_DoTestSegmentReport(Local_SegmentName.as_mut_ptr(), &mut Local_SegmentCounters);
    } else {
        UT_BSP_DoText(
            UTASSERT_CASETYPE_END as libc::c_int as uint8,
            b"No test cases\n\0" as *const u8 as *const libc::c_char,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_DoTestSegmentReport(
    mut SegmentName: *const libc::c_char,
    mut TestCounters: *const UtAssert_TestCounter_t,
) {
    let mut ReportBuffer: [libc::c_char; 144] = [0; 144];
    snprintf(
        ReportBuffer.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 144]>() as libc::c_ulong,
        b"%-22s ABORT::%-4u  WARN::%-4u  FLOW::%-4u  DEBUG::%-4u  N/A::%-4u\0" as *const u8
            as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_ABORT as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_WARN as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_FLOW as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_DEBUG as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_NA as libc::c_int as usize],
    );
    UT_BSP_DoText(
        UTASSERT_CASETYPE_INFO as libc::c_int as uint8,
        ReportBuffer.as_mut_ptr(),
    );
    snprintf(
        ReportBuffer.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 144]>() as libc::c_ulong,
        b"%02u %-20s TOTAL::%-4u  PASS::%-4u  FAIL::%-4u  MIR::%-4u  TSF::%-4u  TTF::%-4u\0"
            as *const u8 as *const libc::c_char,
        (*TestCounters).TestSegmentCount,
        SegmentName,
        (*TestCounters).TotalTestCases,
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_PASS as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_FAILURE as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_MIR as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_TSF as libc::c_int as usize],
        (*TestCounters).CaseCount[UTASSERT_CASETYPE_TTF as libc::c_int as usize],
    );
    UT_BSP_DoText(
        UTASSERT_CASETYPE_END as libc::c_int as uint8,
        ReportBuffer.as_mut_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_SetContext(mut Context: UtAssert_CaseType_t) {
    DefaultContext = Context;
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GetSegmentName() -> *const libc::c_char {
    return CurrentSegment.as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert(
    mut Expression: bool,
    mut Description: *const libc::c_char,
    mut File: *const libc::c_char,
    mut Line: uint32,
) -> bool {
    return UtAssertEx(
        Expression,
        UtAssert_GetContext(),
        File,
        Line,
        b"%s\0" as *const u8 as *const libc::c_char,
        Description,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_Abort(mut Message: *const libc::c_char) {
    UT_BSP_DoText(UTASSERT_CASETYPE_ABORT as libc::c_int as uint8, Message);
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_Message(
    mut MessageType: uint8,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut Spec: *const libc::c_char,
    mut args: ...
) {
    let mut va: ::core::ffi::VaListImpl;
    let mut FinalMessage: [libc::c_char; 256] = [0; 256];
    let mut BaseName: *const libc::c_char = 0 as *const libc::c_char;
    let mut MsgLen: size_t = 0;
    if !File.is_null() {
        BaseName = strrchr(File, '/' as i32);
        if BaseName.is_null() {
            BaseName = File;
        } else {
            BaseName = BaseName.offset(1);
            BaseName;
        }
        snprintf(
            FinalMessage.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b"%s:%u:\0" as *const u8 as *const libc::c_char,
            BaseName,
            Line,
        );
        MsgLen = strlen(FinalMessage.as_mut_ptr());
    } else {
        MsgLen = 0 as libc::c_int as size_t;
    }
    va = args.clone();
    vsnprintf(
        &mut *FinalMessage.as_mut_ptr().offset(MsgLen as isize),
        (::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong).wrapping_sub(MsgLen),
        Spec,
        va.as_va_list(),
    );
    UT_BSP_DoText(MessageType, FinalMessage.as_mut_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_StringBufCompare(
    mut String1: *const libc::c_char,
    mut String1Max: size_t,
    mut String2: *const libc::c_char,
    mut String2Max: size_t,
    mut CompareType: UtAssert_Compare_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
) -> bool {
    let mut ScrubbedString1: [libc::c_char; 256] = [0; 256];
    let mut ScrubbedString2: [libc::c_char; 256] = [0; 256];
    let mut EndPtr1: *const libc::c_char = 0 as *const libc::c_char;
    let mut EndPtr2: *const libc::c_char = 0 as *const libc::c_char;
    let mut FormatLen1: size_t = 0;
    let mut FormatLen2: size_t = 0;
    let mut Result: bool = false;
    let mut Compare: libc::c_int = 0;
    if String1.is_null() {
        EndPtr1 = 0 as *const libc::c_char;
    } else if String1Max == 18446744073709551615 as libc::c_ulong {
        EndPtr1 = String1.offset(strlen(String1) as isize);
    } else {
        EndPtr1 = memchr(String1 as *const libc::c_void, 0 as libc::c_int, String1Max)
            as *const libc::c_char;
    }
    if !EndPtr1.is_null() {
        FormatLen1 = EndPtr1.offset_from(String1) as libc::c_long as size_t;
    } else {
        FormatLen1 = String1Max;
    }
    if String2.is_null() {
        EndPtr2 = 0 as *const libc::c_char;
    } else if String2Max == 18446744073709551615 as libc::c_ulong {
        EndPtr2 = String2.offset(strlen(String2) as isize);
    } else {
        EndPtr2 = memchr(String2 as *const libc::c_void, 0 as libc::c_int, String2Max)
            as *const libc::c_char;
    }
    if !EndPtr2.is_null() {
        FormatLen2 = EndPtr2.offset_from(String2) as libc::c_long as size_t;
    } else {
        FormatLen2 = String2Max;
    }
    if FormatLen1 == 0 as libc::c_int as libc::c_ulong
        && FormatLen2 == 0 as libc::c_int as libc::c_ulong
    {
        Compare = 0 as libc::c_int;
    } else {
        if FormatLen1 < FormatLen2 {
            Compare = memcmp(
                String1 as *const libc::c_void,
                String2 as *const libc::c_void,
                FormatLen1,
            );
        } else {
            Compare = memcmp(
                String1 as *const libc::c_void,
                String2 as *const libc::c_void,
                FormatLen2,
            );
        }
        if Compare == 0 as libc::c_int {
            Compare = FormatLen1.wrapping_sub(FormatLen2) as libc::c_int;
        }
    }
    match CompareType as libc::c_uint {
        1 => {
            Result = Compare == 0 as libc::c_int;
        }
        2 => {
            Result = Compare != 0 as libc::c_int;
        }
        3 => {
            Result = Compare < 0 as libc::c_int;
        }
        4 => {
            Result = Compare > 0 as libc::c_int;
        }
        5 => {
            Result = Compare <= 0 as libc::c_int;
        }
        6 => {
            Result = Compare >= 0 as libc::c_int;
        }
        _ => {
            Result = 0 as libc::c_int != 0;
        }
    }
    if FormatLen1 > 0 as libc::c_int as libc::c_ulong {
        EndPtr1 =
            memchr(String1 as *const libc::c_void, '\n' as i32, FormatLen1) as *const libc::c_char;
        if !EndPtr1.is_null() {
            FormatLen1 = EndPtr1.offset_from(String1) as libc::c_long as size_t;
        }
        memcpy(
            ScrubbedString1.as_mut_ptr() as *mut libc::c_void,
            String1 as *const libc::c_void,
            FormatLen1,
        );
    }
    ScrubbedString1[FormatLen1 as usize] = 0 as libc::c_int as libc::c_char;
    if FormatLen2 > 0 as libc::c_int as libc::c_ulong {
        EndPtr2 =
            memchr(String2 as *const libc::c_void, '\n' as i32, FormatLen2) as *const libc::c_char;
        if !EndPtr2.is_null() {
            FormatLen2 = EndPtr2.offset_from(String2) as libc::c_long as size_t;
        }
        memcpy(
            ScrubbedString2.as_mut_ptr() as *mut libc::c_void,
            String2 as *const libc::c_void,
            FormatLen2,
        );
    }
    ScrubbedString2[FormatLen2 as usize] = 0 as libc::c_int as libc::c_char;
    return UtAssertEx(
        Result,
        UTASSERT_CASETYPE_FAILURE,
        File,
        Line,
        b"String: '%s' == '%s'\0" as *const u8 as *const libc::c_char,
        ScrubbedString1.as_mut_ptr(),
        ScrubbedString2.as_mut_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GenericIntegerCompare(
    mut IsUnsigned: bool,
    mut ActualValue: UT_IntCheck_t,
    mut CompareType: UtAssert_Compare_t,
    mut RefValue: UT_IntCheck_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut RadixType: UtAssert_Radix_t,
    mut Typename: *const libc::c_char,
    mut ActualText: *const libc::c_char,
    mut RefText: *const libc::c_char,
) -> bool {
    static mut UTASSERT_PREFIX: [libc::c_char; 10] =
        unsafe { *::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"UTASSERT_\0") };
    let mut ActualStr: [libc::c_char; 32] = [0; 32];
    let mut RefStr: [libc::c_char; 32] = [0; 32];
    let mut TagStr: [libc::c_char; 32] = [0; 32];
    let mut TagLen: libc::c_int = 0;
    if !Typename.is_null() && *Typename as libc::c_int != 0 as libc::c_int {
        TagLen = snprintf(
            TagStr.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            b"%s\0" as *const u8 as *const libc::c_char,
            Typename,
        );
        if TagLen < 0 as libc::c_int {
            TagLen = 0 as libc::c_int;
        } else if TagLen as libc::c_ulong
            > (::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
                .wrapping_sub(3 as libc::c_int as libc::c_ulong)
        {
            TagLen = (::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
                .wrapping_sub(3 as libc::c_int as libc::c_ulong)
                as libc::c_int;
        }
        while TagLen > 0 as libc::c_int
            && (*(*__ctype_b_loc()).offset(
                TagStr[(TagLen - 1 as libc::c_int) as usize] as libc::c_uchar as libc::c_int
                    as isize,
            ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                != 0
                || TagStr[(TagLen - 1 as libc::c_int) as usize] as libc::c_int == ':' as i32)
        {
            TagLen -= 1;
            TagLen;
        }
        if TagLen > 0 as libc::c_int {
            TagStr[TagLen as usize] = ':' as i32 as libc::c_char;
            TagLen += 1;
            TagLen;
            TagStr[TagLen as usize] = ' ' as i32 as libc::c_char;
            TagLen += 1;
            TagLen;
        }
        TagStr[TagLen as usize] = 0 as libc::c_int as libc::c_char;
        if RadixType as libc::c_uint == UtAssert_Radix_DEFAULT as libc::c_int as libc::c_uint
            && !(strchr(Typename, '*' as i32)).is_null()
        {
            RadixType = UtAssert_Radix_HEX;
        }
    } else {
        TagStr[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    }
    if strncmp(
        ActualText,
        UTASSERT_PREFIX.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    ) == 0 as libc::c_int
    {
        ActualText = ActualText.offset(
            (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
        );
    }
    if strncmp(
        RefText,
        UTASSERT_PREFIX.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    ) == 0 as libc::c_int
    {
        RefText = RefText.offset(
            (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
        );
    }
    return UtAssertEx(
        UtAssert_DoCompare(ActualValue, CompareType, RefValue, IsUnsigned),
        UTASSERT_CASETYPE_FAILURE,
        File,
        Line,
        b"%s%s (%s) %s %s (%s)\0" as *const u8 as *const libc::c_char,
        TagStr.as_mut_ptr(),
        ActualText,
        UtAssert_GetValueText(
            ActualStr.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            ActualValue,
            IsUnsigned,
            RadixType,
        ),
        UtAssert_GetOpText(CompareType),
        RefText,
        UtAssert_GetValueText(
            RefStr.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            RefValue,
            IsUnsigned,
            RadixType,
        ),
    );
}
unsafe extern "C" fn UtAssert_GetValueText(
    mut TempBuf: *mut libc::c_char,
    mut TempSz: size_t,
    mut InValue: UT_IntCheck_t,
    mut IsUnsigned: bool,
    mut RadixType: UtAssert_Radix_t,
) -> *const libc::c_char {
    if RadixType as libc::c_uint == UtAssert_Radix_BOOLEAN as libc::c_int as libc::c_uint {
        if InValue != 0 as libc::c_int as libc::c_long {
            snprintf(
                TempBuf,
                TempSz,
                b"true\0" as *const u8 as *const libc::c_char,
            );
        } else {
            snprintf(
                TempBuf,
                TempSz,
                b"false\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if RadixType as libc::c_uint == UtAssert_Radix_OCTAL as libc::c_int as libc::c_uint {
        snprintf(
            TempBuf,
            TempSz,
            b"0%lo\0" as *const u8 as *const libc::c_char,
            InValue as libc::c_ulong,
        );
    } else if RadixType as libc::c_uint == UtAssert_Radix_HEX as libc::c_int as libc::c_uint {
        snprintf(
            TempBuf,
            TempSz,
            b"0x%lx\0" as *const u8 as *const libc::c_char,
            InValue as libc::c_ulong,
        );
    } else if IsUnsigned {
        snprintf(
            TempBuf,
            TempSz,
            b"%lu\0" as *const u8 as *const libc::c_char,
            InValue as libc::c_ulong,
        );
    } else {
        snprintf(
            TempBuf,
            TempSz,
            b"%ld\0" as *const u8 as *const libc::c_char,
            InValue,
        );
    }
    return TempBuf;
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GetOpText(
    mut CompareType: UtAssert_Compare_t,
) -> *const libc::c_char {
    let mut OpText: *const libc::c_char = 0 as *const libc::c_char;
    match CompareType as libc::c_uint {
        1 => {
            OpText = b"==\0" as *const u8 as *const libc::c_char;
        }
        2 => {
            OpText = b"!=\0" as *const u8 as *const libc::c_char;
        }
        3 => {
            OpText = b"<\0" as *const u8 as *const libc::c_char;
        }
        4 => {
            OpText = b">\0" as *const u8 as *const libc::c_char;
        }
        5 => {
            OpText = b"<=\0" as *const u8 as *const libc::c_char;
        }
        6 => {
            OpText = b">=\0" as *const u8 as *const libc::c_char;
        }
        7 => {
            OpText = b"&\0" as *const u8 as *const libc::c_char;
        }
        8 => {
            OpText = b"&~\0" as *const u8 as *const libc::c_char;
        }
        _ => {
            OpText = b"??\0" as *const u8 as *const libc::c_char;
        }
    }
    return OpText;
}
unsafe extern "C" fn UtAssert_DoCompare(
    mut ActualValueIn: libc::c_long,
    mut CompareType: UtAssert_Compare_t,
    mut ReferenceValueIn: UT_IntCheck_t,
    mut IsUnsigned: bool,
) -> bool {
    let mut Result: bool = false;
    let mut ActualValue: UtAssert_IntBuf_t = UtAssert_IntBuf_t { s: 0 };
    let mut ReferenceValue: UtAssert_IntBuf_t = UtAssert_IntBuf_t { s: 0 };
    if IsUnsigned {
        ActualValue.u = ActualValueIn as libc::c_ulong;
        ReferenceValue.u = ReferenceValueIn as libc::c_ulong;
    } else {
        ActualValue.s = ActualValueIn;
        ReferenceValue.s = ReferenceValueIn;
    }
    match (CompareType as libc::c_uint) << 1 as libc::c_int | IsUnsigned as libc::c_uint {
        3 => {
            Result = ActualValue.u == ReferenceValue.u;
        }
        2 => {
            Result = ActualValue.s == ReferenceValue.s;
        }
        5 => {
            Result = ActualValue.u != ReferenceValue.u;
        }
        4 => {
            Result = ActualValue.s != ReferenceValue.s;
        }
        7 => {
            Result = ActualValue.u < ReferenceValue.u;
        }
        6 => {
            Result = ActualValue.s < ReferenceValue.s;
        }
        9 => {
            Result = ActualValue.u > ReferenceValue.u;
        }
        8 => {
            Result = ActualValue.s > ReferenceValue.s;
        }
        11 => {
            Result = ActualValue.u <= ReferenceValue.u;
        }
        10 => {
            Result = ActualValue.s <= ReferenceValue.s;
        }
        13 => {
            Result = ActualValue.u >= ReferenceValue.u;
        }
        12 => {
            Result = ActualValue.s >= ReferenceValue.s;
        }
        15 => {
            Result = ActualValue.u & ReferenceValue.u == ReferenceValue.u;
        }
        14 => {
            Result = ActualValue.s & ReferenceValue.s == ReferenceValue.s;
        }
        17 => {
            Result = ActualValue.u & ReferenceValue.u == 0 as libc::c_int as libc::c_ulong;
        }
        16 => {
            Result = ActualValue.s & ReferenceValue.s == 0 as libc::c_int as libc::c_long;
        }
        _ => {
            Result = 0 as libc::c_int != 0;
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GenericUnsignedCompare(
    mut ActualValue: libc::c_ulong,
    mut CompareType: UtAssert_Compare_t,
    mut ReferenceValue: libc::c_ulong,
    mut RadixType: UtAssert_Radix_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut Desc: *const libc::c_char,
    mut ActualText: *const libc::c_char,
    mut ReferenceText: *const libc::c_char,
) -> bool {
    return UtAssert_GenericIntegerCompare(
        1 as libc::c_int != 0,
        ActualValue as UT_IntCheck_t,
        CompareType,
        ReferenceValue as UT_IntCheck_t,
        File,
        Line,
        RadixType,
        Desc,
        ActualText,
        ReferenceText,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtAssert_GenericSignedCompare(
    mut ActualValue: libc::c_long,
    mut CompareType: UtAssert_Compare_t,
    mut ReferenceValue: libc::c_long,
    mut RadixType: UtAssert_Radix_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut Desc: *const libc::c_char,
    mut ActualText: *const libc::c_char,
    mut ReferenceText: *const libc::c_char,
) -> bool {
    return UtAssert_GenericIntegerCompare(
        0 as libc::c_int != 0,
        ActualValue,
        CompareType,
        ReferenceValue,
        File,
        Line,
        RadixType,
        Desc,
        ActualText,
        ReferenceText,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Create(mut NumTags: uint32) -> *mut UtListHead_t {
    let mut NewList: *mut ListAllocator = 0 as *mut ListAllocator;
    let mut TagHead: *mut UtListNode_t = 0 as *mut UtListNode_t;
    let mut ActualSize: size_t = 0;
    let mut i: uint32 = 0;
    ActualSize = (::core::mem::size_of::<ListAllocator>() as libc::c_ulong).wrapping_add(
        (::core::mem::size_of::<UtListNode_t>() as libc::c_ulong)
            .wrapping_mul(NumTags as libc::c_ulong),
    );
    NewList = malloc(ActualSize) as *mut ListAllocator;
    memset(NewList as *mut libc::c_void, 0 as libc::c_int, ActualSize);
    (*NewList).Head.Tags = ((*NewList).Tags).as_mut_ptr();
    (*NewList).Head.NumberOfTags = NumTags;
    i = 0 as libc::c_int as uint32;
    while i < NumTags {
        TagHead = &mut *((*NewList).Head.Tags).offset(i as isize) as *mut UtListNode_t;
        (*TagHead).Tag = i;
        (*TagHead).Next = TagHead;
        (*TagHead).Prev = TagHead;
        i = i.wrapping_add(1);
        i;
    }
    return &mut (*NewList).Head;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Destroy(mut ListHead: *mut UtListHead_t) {
    let mut i: uint32 = 0;
    i = 0 as libc::c_int as uint32;
    while i < (*ListHead).NumberOfTags {
        UtList_Reset(&mut *((*ListHead).Tags).offset(i as isize));
        i = i.wrapping_add(1);
        i;
    }
    free(ListHead as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Reset(mut TagHead: *mut UtListNode_t) {
    while !UtList_IsEmpty(TagHead) {
        UtList_DeleteNode((*TagHead).Next);
    }
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Merge(
    mut TagHead1: *mut UtListNode_t,
    mut TagHead2: *mut UtListNode_t,
) {
    let mut Tail1: *mut UtListNode_t = (*TagHead1).Prev;
    let mut Tail2: *mut UtListNode_t = (*TagHead2).Prev;
    (*Tail1).Next = TagHead2;
    (*Tail2).Next = TagHead1;
    (*TagHead1).Prev = Tail2;
    (*TagHead2).Prev = Tail1;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Insert_After(
    mut ExistingNode: *mut UtListNode_t,
    mut NewNode: *mut UtListNode_t,
) {
    (*NewNode).Next = (*ExistingNode).Next;
    (*NewNode).Prev = ExistingNode;
    (*(*NewNode).Prev).Next = NewNode;
    (*(*NewNode).Next).Prev = NewNode;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Insert_Before(
    mut ExistingNode: *mut UtListNode_t,
    mut NewNode: *mut UtListNode_t,
) {
    (*NewNode).Next = ExistingNode;
    (*NewNode).Prev = (*ExistingNode).Prev;
    (*(*NewNode).Prev).Next = NewNode;
    (*(*NewNode).Next).Prev = NewNode;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Extract(mut ExistingNode: *mut UtListNode_t) {
    (*(*ExistingNode).Next).Prev = (*ExistingNode).Prev;
    (*(*ExistingNode).Prev).Next = (*ExistingNode).Next;
    (*ExistingNode).Next = ExistingNode;
    (*ExistingNode).Prev = ExistingNode;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_IsEnd(
    mut TagHead: *mut UtListNode_t,
    mut ListNode: *mut UtListNode_t,
) -> bool {
    return TagHead == ListNode;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_GetObject(mut ListNode: *mut UtListNode_t) -> *mut libc::c_void {
    return (*ListNode).Data;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_GetNext(mut ListNode: *mut UtListNode_t) -> *mut UtListNode_t {
    return (*ListNode).Next;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_GetHead(
    mut ListHead: *mut UtListHead_t,
    mut Tag: uint32,
) -> *mut UtListNode_t {
    if Tag >= (*ListHead).NumberOfTags {
        return 0 as *mut UtListNode_t;
    }
    return &mut *((*ListHead).Tags).offset(Tag as isize) as *mut UtListNode_t;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_NewNode(
    mut Data: *mut libc::c_void,
    mut DataSize: uint32,
) -> *mut UtListNode_t {
    let mut AllocNode: *mut NodeAllocator = 0 as *mut NodeAllocator;
    AllocNode = malloc(
        (::core::mem::size_of::<NodeAllocator>() as libc::c_ulong)
            .wrapping_add(DataSize as libc::c_ulong),
    ) as *mut NodeAllocator;
    memset(
        AllocNode as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<NodeAllocator>() as libc::c_ulong,
    );
    (*AllocNode).Node.Data = &mut *AllocNode.offset(1 as libc::c_int as isize) as *mut NodeAllocator
        as *mut libc::c_void;
    (*AllocNode).Node.DataSize = DataSize;
    memcpy((*AllocNode).Node.Data, Data, DataSize as libc::c_ulong);
    (*AllocNode).Node.Next = &mut (*AllocNode).Node;
    (*AllocNode).Node.Prev = &mut (*AllocNode).Node;
    return &mut (*AllocNode).Node;
}
#[no_mangle]
pub unsafe extern "C" fn UtList_Add(
    mut ListHead: *mut UtListHead_t,
    mut Data: *mut libc::c_void,
    mut DataSize: uint32,
    mut Tag: uint32,
) {
    let mut TagHead: *mut UtListNode_t = 0 as *mut UtListNode_t;
    let mut NewNode: *mut UtListNode_t = 0 as *mut UtListNode_t;
    TagHead = UtList_GetHead(ListHead, Tag);
    if !TagHead.is_null() {
        NewNode = UtList_NewNode(Data, DataSize);
        (*NewNode).Tag = Tag;
        UtList_Insert_Before(TagHead, NewNode);
    }
}
#[no_mangle]
pub unsafe extern "C" fn UtList_DeleteNode(mut DeleteNode: *mut UtListNode_t) {
    UtList_Extract(DeleteNode);
    if !((*DeleteNode).Data).is_null() {
        free(DeleteNode as *mut libc::c_void);
    }
}
#[no_mangle]
pub unsafe extern "C" fn UtList_IsEmpty(mut TagHead: *mut UtListNode_t) -> bool {
    return (*TagHead).Next == TagHead;
}
static mut UT_StubTable: [UT_StubTableEntry_t; 200] = [
    {
        let mut init = UT_StubTableEntry_t {
            EntryType: UT_ENTRYTYPE_UNUSED,
            ModeFlags: 0,
            FuncKey: 0,
            Data: UT_EntryData_t {
                Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
            },
        };
        init
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
    UT_StubTableEntry_t {
        EntryType: UT_ENTRYTYPE_UNUSED,
        ModeFlags: 0,
        FuncKey: 0,
        Data: UT_EntryData_t {
            Rc: UT_RetcodeEntry_t { Count: 0, Value: 0 },
        },
    },
];
static mut UT_MaxStubSearchLen: uint32 = 0 as libc::c_int as uint32;
unsafe extern "C" fn UT_ClearStubEntry(mut StubPtr: *mut UT_StubTableEntry_t) {
    if ((*StubPtr).EntryType as libc::c_uint
        == UT_ENTRYTYPE_DATA_BUFFER as libc::c_int as libc::c_uint
        || (*StubPtr).EntryType as libc::c_uint
            == UT_ENTRYTYPE_RETURN_BUFFER as libc::c_int as libc::c_uint)
        && !((*StubPtr).Data.Buff.BasePtr).is_null()
        && (*StubPtr).ModeFlags & 0x1 as libc::c_uint != 0 as libc::c_int as libc::c_uint
    {
        free((*StubPtr).Data.Buff.BasePtr as *mut libc::c_void);
    }
    memset(
        StubPtr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<UT_StubTableEntry_t>() as libc::c_ulong,
    );
}
unsafe extern "C" fn UT_GetStubEntry(
    mut FuncKey: UT_EntryKey_t,
    mut TestMode: UT_EntryType_t,
) -> *mut UT_StubTableEntry_t {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut Idx: uint32 =
        FuncKey.wrapping_rem((200 as libc::c_int - 1 as libc::c_int) as libc::c_ulong) as uint32;
    let mut SearchLen: uint32 = 0 as libc::c_int as uint32;
    let mut SearchLimit: uint32 = 0;
    let mut SearchKey: UT_EntryKey_t = 0;
    if TestMode as libc::c_uint == UT_ENTRYTYPE_UNUSED as libc::c_int as libc::c_uint {
        SearchLimit = 200 as libc::c_int as uint32;
        SearchKey = 0 as libc::c_int as UT_EntryKey_t;
    } else {
        SearchLimit = UT_MaxStubSearchLen;
        SearchKey = FuncKey;
    }
    loop {
        if SearchLen >= SearchLimit {
            StubPtr = 0 as *mut UT_StubTableEntry_t;
            break;
        } else {
            SearchLen = SearchLen.wrapping_add(1);
            SearchLen;
            StubPtr =
                &mut *UT_StubTable.as_mut_ptr().offset(Idx as isize) as *mut UT_StubTableEntry_t;
            if (*StubPtr).EntryType as libc::c_uint == TestMode as libc::c_uint
                && (*StubPtr).FuncKey == SearchKey
            {
                break;
            }
            Idx = Idx.wrapping_add(1);
            Idx;
            if Idx >= 200 as libc::c_int as libc::c_uint {
                Idx = 0 as libc::c_int as uint32;
            }
        }
    }
    if SearchLen > UT_MaxStubSearchLen {
        UT_MaxStubSearchLen = SearchLen;
    }
    return StubPtr;
}
#[no_mangle]
pub unsafe extern "C" fn UT_ResetState(mut FuncKey: UT_EntryKey_t) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut i: int32 = 0;
    StubPtr = UT_StubTable.as_mut_ptr();
    i = 0 as libc::c_int;
    while i < 200 as libc::c_int {
        if FuncKey == 0 as libc::c_int as libc::c_ulong || (*StubPtr).FuncKey == FuncKey {
            UT_ClearStubEntry(StubPtr);
        }
        StubPtr = StubPtr.offset(1);
        StubPtr;
        i += 1;
        i;
    }
    if FuncKey == 0 as libc::c_int as libc::c_ulong {
        UT_MaxStubSearchLen = 0 as libc::c_int as uint32;
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_CallOnce(mut Func: Option<unsafe extern "C" fn() -> ()>) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut OnceEnt: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut FuncKey: UT_EntryKey_t = 0;
    let mut i: int32 = 0;
    if Func.is_none() {
        return;
    }
    FuncKey = ::core::mem::transmute::<Option<unsafe extern "C" fn() -> ()>, UT_EntryKey_t>(Func);
    OnceEnt = 0 as *mut UT_StubTableEntry_t;
    StubPtr = UT_StubTable.as_mut_ptr();
    i = 0 as libc::c_int;
    while i < 200 as libc::c_int {
        if (*StubPtr).EntryType as libc::c_uint
            == UT_ENTRYTYPE_UNUSED as libc::c_int as libc::c_uint
            && OnceEnt.is_null()
        {
            OnceEnt = StubPtr;
        } else if (*StubPtr).EntryType as libc::c_uint
            == UT_ENTRYTYPE_CALL_ONCE as libc::c_int as libc::c_uint
            && (*StubPtr).FuncKey == FuncKey
        {
            OnceEnt = StubPtr;
            break;
        }
        StubPtr = StubPtr.offset(1);
        StubPtr;
        i += 1;
        i;
    }
    if OnceEnt.is_null() {
        UtAssert_Abort(
            b"Cannot do CallOnce - UT_MAX_FUNC_STUBS too low?\0" as *const u8
                as *const libc::c_char,
        );
    } else if (*OnceEnt).EntryType as libc::c_uint
        == UT_ENTRYTYPE_UNUSED as libc::c_int as libc::c_uint
    {
        (*OnceEnt).EntryType = UT_ENTRYTYPE_CALL_ONCE;
        (*OnceEnt).FuncKey = FuncKey;
        Func.expect("non-null function pointer")();
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_StoreRetval(
    mut Buf: *mut UT_RetvalBuf_t,
    mut ValuePtr: *const libc::c_void,
    mut ValueSize: size_t,
    mut ValueGenre: UT_ValueGenre_t,
) -> bool {
    match (ValueGenre as size_t) << 8 as libc::c_int | ValueSize {
        257 => {
            (*Buf).Integer = *(ValuePtr as *const int8) as UT_IntReturn_t;
        }
        258 => {
            (*Buf).Integer = *(ValuePtr as *const int16) as UT_IntReturn_t;
        }
        260 => {
            (*Buf).Integer = *(ValuePtr as *const int32) as UT_IntReturn_t;
        }
        264 => {
            (*Buf).Integer = *(ValuePtr as *const int64);
        }
        516 => {
            (*Buf).FloatingPt = *(ValuePtr as *const libc::c_float) as libc::c_double;
        }
        520 => {
            (*Buf).FloatingPt = *(ValuePtr as *const libc::c_double);
        }
        776 => {
            (*Buf).Ptr = *(ValuePtr as *const *mut libc::c_void);
        }
        _ => {
            return UtAssertEx(
                0 as libc::c_int != 0,
                UtAssert_GetContext(),
                b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/utstubs.c\0" as *const u8
                    as *const libc::c_char,
                313 as libc::c_int as uint32,
                b"Cannot store return value - ValueSize not valid\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn UT_LoadRetval(
    mut ValuePtr: *mut libc::c_void,
    mut ValueSize: size_t,
    mut Buf: *const UT_RetvalBuf_t,
    mut ValueGenre: UT_ValueGenre_t,
) -> bool {
    match (ValueGenre as size_t) << 8 as libc::c_int | ValueSize {
        257 => {
            *(ValuePtr as *mut int8) = (*Buf).Integer as int8;
        }
        258 => {
            *(ValuePtr as *mut int16) = (*Buf).Integer as int16;
        }
        260 => {
            *(ValuePtr as *mut int32) = (*Buf).Integer as int32;
        }
        264 => {
            *(ValuePtr as *mut int64) = (*Buf).Integer;
        }
        516 => {
            *(ValuePtr as *mut libc::c_float) = (*Buf).FloatingPt as libc::c_float;
        }
        520 => {
            *(ValuePtr as *mut libc::c_double) = (*Buf).FloatingPt;
        }
        776 => {
            let ref mut fresh14 = *(ValuePtr as *mut *mut libc::c_void);
            *fresh14 = (*Buf).Ptr;
        }
        _ => {
            return UtAssertEx(
                0 as libc::c_int != 0,
                UtAssert_GetContext(),
                b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/utstubs.c\0" as *const u8
                    as *const libc::c_char,
                348 as libc::c_int as uint32,
                b"Cannot load return value - ValueSize not valid\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn UT_ConfigureGenericStubReturnValue(
    mut FuncKey: UT_EntryKey_t,
    mut ValuePtr: *const libc::c_void,
    mut ValueSize: size_t,
    mut ValueGenre: UT_ValueGenre_t,
    mut Counter: int32,
    mut TypeName: *const libc::c_char,
) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut ReqEntryType: UT_EntryType_t = UT_ENTRYTYPE_UNUSED;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);
    if Counter > 0 as libc::c_int {
        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED;
        StubPtr = 0 as *mut UT_StubTableEntry_t;
    } else {
        ReqEntryType = UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT;
        StubPtr = UT_GetStubEntry(FuncKey, ReqEntryType);
    }
    if StubPtr.is_null() {
        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);
    }
    if StubPtr.is_null() {
        UtAssert_Abort(
            b"Cannot configure return value - UT_MAX_FUNC_STUBS too low?\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        (*StubPtr).FuncKey = FuncKey;
        (*StubPtr).EntryType = ReqEntryType;
        (*StubPtr).Data.Rvc.Genre = ValueGenre;
        (*StubPtr).Data.Rvc.Counter = Counter;
        (*StubPtr).Data.Rvc.ActualSz = ValueSize;
        (*StubPtr).Data.Rvc.TypeName = TypeName;
        if ValueGenre as libc::c_uint == UT_ValueGenre_OPAQUE as libc::c_int as libc::c_uint {
            (*StubPtr).Data.Rvc.Buf.IndirectPtr = ValuePtr;
        } else {
            UT_StoreRetval(
                &mut (*StubPtr).Data.Rvc.Buf,
                ValuePtr,
                ValueSize,
                ValueGenre,
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn UT_SetDeferredRetcode(
    mut FuncKey: UT_EntryKey_t,
    mut Count: int32,
    mut Retcode: UT_IntReturn_t,
) {
    if Count <= 0 as libc::c_int {
        UtAssertEx(
            0 as libc::c_int != 0,
            UtAssert_GetContext(),
            b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/utstubs.c\0" as *const u8
                as *const libc::c_char,
            416 as libc::c_int as uint32,
            b"BUG: Invalid Count (%ld) passed to UT_SetDeferredRetcode()\0" as *const u8
                as *const libc::c_char,
            Count as libc::c_long,
        );
    } else {
        UT_ConfigureGenericStubReturnValue(
            FuncKey,
            &mut Retcode as *mut UT_IntReturn_t as *const libc::c_void,
            ::core::mem::size_of::<UT_IntReturn_t>() as libc::c_ulong,
            UT_ValueGenre_INTEGER,
            Count,
            0 as *const libc::c_char,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn UT_ClearDeferredRetcode(mut FuncKey: UT_EntryKey_t) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    loop {
        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED);
        if StubPtr.is_null() {
            break;
        }
        UT_ClearStubEntry(StubPtr);
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_SetDefaultReturnValue(
    mut FuncKey: UT_EntryKey_t,
    mut Value: UT_IntReturn_t,
) {
    UT_ConfigureGenericStubReturnValue(
        FuncKey,
        &mut Value as *mut UT_IntReturn_t as *const libc::c_void,
        ::core::mem::size_of::<UT_IntReturn_t>() as libc::c_ulong,
        UT_ValueGenre_INTEGER,
        0 as libc::c_int,
        0 as *const libc::c_char,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UT_ClearDefaultReturnValue(mut FuncKey: UT_EntryKey_t) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT);
    if !StubPtr.is_null() {
        UT_ClearStubEntry(StubPtr);
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_GetStubRetcodeAndCount(
    mut FuncKey: UT_EntryKey_t,
    mut Retcode: *mut int32,
    mut Count: *mut int32,
) -> bool {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut Result: bool = false;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);
    if !StubPtr.is_null() {
        *Count = (*StubPtr).Data.Rc.Count as int32;
        *Retcode = (*StubPtr).Data.Rc.Value;
        Result = 1 as libc::c_int != 0;
    } else {
        Result = 0 as libc::c_int != 0;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn UT_GetStubCount(mut FuncKey: UT_EntryKey_t) -> uint32 {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut Count: uint32 = 0;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);
    if !StubPtr.is_null() {
        Count = (*StubPtr).Data.Rc.Count;
    } else {
        Count = 0 as libc::c_int as uint32;
    }
    return Count;
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_IsValueCompatible(
    mut Rvc: *const UT_RetvalConfigEntry_t,
    mut WantTypeName: *const libc::c_char,
    mut WantGenre: UT_ValueGenre_t,
) -> bool {
    let mut IsCompatible: bool = false;
    if !((*Rvc).TypeName).is_null() && !WantTypeName.is_null() {
        IsCompatible = strcmp((*Rvc).TypeName, WantTypeName) == 0 as libc::c_int;
    } else {
        IsCompatible = 0 as libc::c_int != 0;
    }
    if !IsCompatible
        && (*Rvc).Genre as libc::c_uint != UT_ValueGenre_OPAQUE as libc::c_int as libc::c_uint
        && (*Rvc).Genre as libc::c_uint == WantGenre as libc::c_uint
    {
        IsCompatible = 1 as libc::c_int != 0;
    }
    return IsCompatible;
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_RegisterReturnType(
    mut FuncKey: UT_EntryKey_t,
    mut ReturnSize: size_t,
    mut TypeName: *const libc::c_char,
) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    if ReturnSize > 0 as libc::c_int as libc::c_ulong {
        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);
        if !StubPtr.is_null() && (*StubPtr).Data.Buff.TotalSize != ReturnSize {
            UT_ClearStubEntry(StubPtr);
            StubPtr = 0 as *mut UT_StubTableEntry_t;
        }
        if StubPtr.is_null() {
            StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);
            if StubPtr.is_null() {
                UtAssert_Abort(
                    b"Cannot set return buffer - UT_MAX_FUNC_STUBS too low?\0" as *const u8
                        as *const libc::c_char,
                );
            } else {
                (*StubPtr).FuncKey = FuncKey;
                (*StubPtr).EntryType = UT_ENTRYTYPE_RETURN_BUFFER;
                (*StubPtr).Data.Buff.BasePtr = malloc(ReturnSize) as *mut uint8;
                if ((*StubPtr).Data.Buff.BasePtr).is_null() {
                    UtAssert_Abort(
                        b"Cannot allocate data buffer - malloc() failed!\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    memset(
                        (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void,
                        0 as libc::c_int,
                        ReturnSize,
                    );
                    (*StubPtr).ModeFlags |= 0x1 as libc::c_uint;
                }
                (*StubPtr).Data.Buff.TotalSize = ReturnSize;
            }
        }
        if !StubPtr.is_null() {
            (*StubPtr).Data.Buff.Position = 0 as libc::c_int as size_t;
            (*StubPtr).Data.Buff.ContentTypeStr = TypeName;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_GetReturnValuePtr(
    mut FuncKey: UT_EntryKey_t,
    mut ReturnSize: size_t,
    mut TypeName: *const libc::c_char,
) -> *mut libc::c_void {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut ReturnPtr: *mut libc::c_void = 0 as *mut libc::c_void;
    ReturnPtr = 0 as *mut libc::c_void;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);
    if StubPtr.is_null() {
        UtAssert_Abort(b"Return buffer invalid\0" as *const u8 as *const libc::c_char);
    } else {
        ReturnPtr = (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void;
        if (*StubPtr).Data.Buff.Position != ReturnSize
            || strcmp(TypeName, (*StubPtr).Data.Buff.ContentTypeStr) != 0 as libc::c_int
        {
            UtAssertEx(
                0 as libc::c_int != 0,
                UtAssert_GetContext(),
                b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/utstubs.c\0" as *const u8
                    as *const libc::c_char,
                602 as libc::c_int as uint32,
                b"Return value mismatch, expected %s(%lu) got %s(%lu)\0" as *const u8
                    as *const libc::c_char,
                TypeName,
                ReturnSize,
                (*StubPtr).Data.Buff.ContentTypeStr,
                (*StubPtr).Data.Buff.Position,
            );
        }
    }
    return ReturnPtr;
}
#[no_mangle]
pub unsafe extern "C" fn UT_SetDataBuffer(
    mut FuncKey: UT_EntryKey_t,
    mut DataBuffer: *mut libc::c_void,
    mut BufferSize: size_t,
    mut AllocateCopy: bool,
) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    if !DataBuffer.is_null() && BufferSize > 0 as libc::c_int as libc::c_ulong {
        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);
        if StubPtr.is_null() {
            UtAssert_Abort(
                b"Cannot set data buffer - UT_MAX_FUNC_STUBS too low?\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            (*StubPtr).FuncKey = FuncKey;
            (*StubPtr).EntryType = UT_ENTRYTYPE_DATA_BUFFER;
            if AllocateCopy {
                (*StubPtr).Data.Buff.BasePtr = malloc(BufferSize) as *mut uint8;
                if ((*StubPtr).Data.Buff.BasePtr).is_null() {
                    UtAssert_Abort(
                        b"Cannot allocate data buffer - malloc() failed!\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    memcpy(
                        (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void,
                        DataBuffer,
                        BufferSize,
                    );
                    (*StubPtr).ModeFlags |= 0x1 as libc::c_uint;
                }
            } else {
                (*StubPtr).Data.Buff.BasePtr = DataBuffer as *mut uint8;
            }
            (*StubPtr).Data.Buff.TotalSize = BufferSize;
            (*StubPtr).Data.Buff.Position = 0 as libc::c_int as size_t;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_GetDataBuffer(
    mut FuncKey: UT_EntryKey_t,
    mut DataBuffer: *mut *mut libc::c_void,
    mut MaxSize: *mut size_t,
    mut Position: *mut size_t,
) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut ResultDataBuffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ResultMaxSize: size_t = 0;
    let mut ResultPosition: size_t = 0;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);
    if StubPtr.is_null() {
        ResultDataBuffer = 0 as *mut libc::c_void;
        ResultMaxSize = 0 as libc::c_int as size_t;
        ResultPosition = 0 as libc::c_int as size_t;
    } else {
        ResultDataBuffer = (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void;
        ResultMaxSize = (*StubPtr).Data.Buff.TotalSize;
        ResultPosition = (*StubPtr).Data.Buff.Position;
    }
    if !DataBuffer.is_null() {
        *DataBuffer = ResultDataBuffer;
    }
    if !MaxSize.is_null() {
        *MaxSize = ResultMaxSize;
    }
    if !Position.is_null() {
        *Position = ResultPosition;
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_CopyToLocal(
    mut FuncKey: UT_EntryKey_t,
    mut LocalBuffer: *mut libc::c_void,
    mut MaxSize: size_t,
) -> size_t {
    let mut ActualCopy: size_t = 0;
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    ActualCopy = 0 as libc::c_int as size_t;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);
    if !StubPtr.is_null() {
        ActualCopy = ((*StubPtr).Data.Buff.TotalSize).wrapping_sub((*StubPtr).Data.Buff.Position);
        if MaxSize < ActualCopy {
            ActualCopy = MaxSize;
        }
        memcpy(
            LocalBuffer,
            &mut *((*StubPtr).Data.Buff.BasePtr).offset((*StubPtr).Data.Buff.Position as isize)
                as *mut uint8 as *const libc::c_void,
            ActualCopy,
        );
        (*StubPtr).Data.Buff.Position = ((*StubPtr).Data.Buff.Position as libc::c_ulong)
            .wrapping_add(ActualCopy) as size_t as size_t;
        if (*StubPtr).Data.Buff.Position >= (*StubPtr).Data.Buff.TotalSize {
            UT_ClearStubEntry(StubPtr);
        }
    }
    return ActualCopy;
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_CopyFromLocal(
    mut FuncKey: UT_EntryKey_t,
    mut LocalBuffer: *const libc::c_void,
    mut MaxSize: size_t,
) -> size_t {
    let mut ActualCopy: size_t = 0;
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    ActualCopy = 0 as libc::c_int as size_t;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_DATA_BUFFER);
    if !StubPtr.is_null() {
        ActualCopy = ((*StubPtr).Data.Buff.TotalSize).wrapping_sub((*StubPtr).Data.Buff.Position);
        if MaxSize < ActualCopy {
            ActualCopy = MaxSize;
        }
        memcpy(
            &mut *((*StubPtr).Data.Buff.BasePtr).offset((*StubPtr).Data.Buff.Position as isize)
                as *mut uint8 as *mut libc::c_void,
            LocalBuffer,
            ActualCopy,
        );
        (*StubPtr).Data.Buff.Position = ((*StubPtr).Data.Buff.Position as libc::c_ulong)
            .wrapping_add(ActualCopy) as size_t as size_t;
        if (*StubPtr).Data.Buff.Position >= (*StubPtr).Data.Buff.TotalSize {
            UT_ClearStubEntry(StubPtr);
        }
    }
    return ActualCopy;
}
unsafe extern "C" fn UT_DoSetHookFunction(
    mut FuncKey: UT_EntryKey_t,
    mut EntryType: UT_EntryType_t,
    mut Value: UT_HookFuncPtr_t,
    mut UserObj: *mut libc::c_void,
    mut IsVarg: bool,
) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    StubPtr = UT_GetStubEntry(FuncKey, EntryType);
    if StubPtr.is_null() && !(Value.Addr).is_null() {
        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);
        if StubPtr.is_null() {
            UtAssert_Abort(
                b"Cannot set hook function - UT_MAX_FUNC_STUBS too low?\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if (Value.Addr).is_null() && !StubPtr.is_null() {
        UT_ClearStubEntry(StubPtr);
    } else if !StubPtr.is_null() && !(Value.Addr).is_null() {
        (*StubPtr).FuncKey = FuncKey;
        (*StubPtr).EntryType = EntryType;
        (*StubPtr).Data.Cb.CallbackArg = UserObj;
        (*StubPtr).Data.Cb.Ptr = Value;
        (*StubPtr).Data.Cb.IsVarg = IsVarg;
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_SetHookFunction(
    mut FuncKey: UT_EntryKey_t,
    mut HookFunc: UT_HookFunc_t,
    mut UserObj: *mut libc::c_void,
) {
    let mut Value: UT_HookFuncPtr_t = UT_HookFuncPtr_t {
        Addr: 0 as *mut libc::c_void,
    };
    Value.SimpleHook = HookFunc;
    UT_DoSetHookFunction(
        FuncKey,
        UT_ENTRYTYPE_CALLBACK_HOOK,
        Value,
        UserObj,
        0 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UT_SetVaHookFunction(
    mut FuncKey: UT_EntryKey_t,
    mut HookFunc: UT_VaHookFunc_t,
    mut UserObj: *mut libc::c_void,
) {
    let mut Value: UT_HookFuncPtr_t = UT_HookFuncPtr_t {
        Addr: 0 as *mut libc::c_void,
    };
    Value.VaHook = HookFunc;
    UT_DoSetHookFunction(
        FuncKey,
        UT_ENTRYTYPE_CALLBACK_HOOK,
        Value,
        UserObj,
        1 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UT_SetHandlerFunction(
    mut FuncKey: UT_EntryKey_t,
    mut HandlerFunc: UT_HandlerFunc_t,
    mut UserObj: *mut libc::c_void,
) {
    let mut Value: UT_HookFuncPtr_t = UT_HookFuncPtr_t {
        Addr: 0 as *mut libc::c_void,
    };
    Value.SimpleHandler = HandlerFunc;
    UT_DoSetHookFunction(
        FuncKey,
        UT_ENTRYTYPE_FINAL_HANDLER,
        Value,
        UserObj,
        0 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UT_SetVaHandlerFunction(
    mut FuncKey: UT_EntryKey_t,
    mut HandlerFunc: UT_VaHandlerFunc_t,
    mut UserObj: *mut libc::c_void,
) {
    let mut Value: UT_HookFuncPtr_t = UT_HookFuncPtr_t {
        Addr: 0 as *mut libc::c_void,
    };
    Value.VaHandler = HandlerFunc;
    UT_DoSetHookFunction(
        FuncKey,
        UT_ENTRYTYPE_FINAL_HANDLER,
        Value,
        UserObj,
        1 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UT_Hook_GetArgPtr(
    mut ContextPtr: *const UT_StubContext_t,
    mut Name: *const libc::c_char,
    mut ExpectedTypeSize: size_t,
) -> *const libc::c_void {
    let mut i: uint32 = 0;
    let mut Result: *const libc::c_void = 0 as *const libc::c_void;
    let mut MetaPtr: *const UT_StubArgMetaData_t = 0 as *const UT_StubArgMetaData_t;
    static mut ARG_DEFAULT_ZERO_VALUE: C2RustUnnamed_48 = C2RustUnnamed_48 {
        AsInt: 0 as libc::c_int as libc::c_ulong,
    };
    Result = 0 as *const libc::c_void;
    i = 0 as libc::c_int as uint32;
    while i < (*ContextPtr).ArgCount {
        MetaPtr = &*((*ContextPtr).Meta).as_ptr().offset(i as isize) as *const UT_StubArgMetaData_t;
        if !((*MetaPtr).Name).is_null() {
            if strcmp((*MetaPtr).Name, Name) == 0 as libc::c_int
                && ((*MetaPtr).Size == 0 as libc::c_int as libc::c_ulong
                    || (*MetaPtr).Size == ExpectedTypeSize)
            {
                if (*MetaPtr).Type as libc::c_uint
                    == UT_STUBCONTEXT_ARG_TYPE_DIRECT as libc::c_int as libc::c_uint
                {
                    Result = &*((*ContextPtr).ArgPtr).as_ptr().offset(i as isize)
                        as *const *const libc::c_void
                        as *const libc::c_void;
                } else if (*MetaPtr).Type as libc::c_uint
                    == UT_STUBCONTEXT_ARG_TYPE_INDIRECT as libc::c_int as libc::c_uint
                {
                    Result = (*ContextPtr).ArgPtr[i as usize];
                }
                break;
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    if Result.is_null() {
        UtAssertEx(
            0 as libc::c_int != 0,
            UtAssert_GetContext(),
            b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/utstubs.c\0" as *const u8
                as *const libc::c_char,
            868 as libc::c_int as uint32,
            b"Requested parameter %s of size %lu which was not provided by the stub\0" as *const u8
                as *const libc::c_char,
            Name,
            ExpectedTypeSize,
        );
        if ExpectedTypeSize <= ::core::mem::size_of::<C2RustUnnamed_48>() as libc::c_ulong {
            Result = &ARG_DEFAULT_ZERO_VALUE as *const C2RustUnnamed_48 as *const libc::c_void;
        } else {
            UtAssert_Abort(b"No value for parameter\0" as *const u8 as *const libc::c_char);
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_RegisterContextWithMetaData(
    mut FuncKey: UT_EntryKey_t,
    mut Name: *const libc::c_char,
    mut ParamType: UT_StubContext_Arg_Type_t,
    mut ParamPtr: *const libc::c_void,
    mut ParamSize: size_t,
) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut MetaPtr: *mut UT_StubArgMetaData_t = 0 as *mut UT_StubArgMetaData_t;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);
    if StubPtr.is_null() {
        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);
    }
    if StubPtr.is_null() {
        UtAssert_Abort(
            b"Cannot set context - UT_MAX_FUNC_STUBS too low?\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        (*StubPtr).FuncKey = FuncKey;
        (*StubPtr).EntryType = UT_ENTRYTYPE_CALLBACK_CONTEXT;
        if (*StubPtr).Data.Context.ArgCount < 8 as libc::c_int as libc::c_uint {
            (*StubPtr).Data.Context.ArgPtr[(*StubPtr).Data.Context.ArgCount as usize] = ParamPtr;
            MetaPtr = &mut *((*StubPtr).Data.Context.Meta)
                .as_mut_ptr()
                .offset((*StubPtr).Data.Context.ArgCount as isize)
                as *mut UT_StubArgMetaData_t;
            (*MetaPtr).Size = ParamSize;
            (*MetaPtr).Type = ParamType;
            if !Name.is_null() {
                (*MetaPtr).Name = Name;
                while *(*MetaPtr).Name as libc::c_int != 0 as libc::c_int {
                    if *(*MetaPtr).Name as libc::c_int == '&' as i32 {
                        if (*MetaPtr).Type as libc::c_uint
                            == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED as libc::c_int as libc::c_uint
                        {
                            (*MetaPtr).Type = UT_STUBCONTEXT_ARG_TYPE_INDIRECT;
                        }
                    } else if *(*MetaPtr).Name as libc::c_int != ' ' as i32 {
                        break;
                    }
                    (*MetaPtr).Name = ((*MetaPtr).Name).offset(1);
                    (*MetaPtr).Name;
                }
                if (*MetaPtr).Type as libc::c_uint
                    == UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED as libc::c_int as libc::c_uint
                {
                    (*MetaPtr).Type = UT_STUBCONTEXT_ARG_TYPE_DIRECT;
                }
            }
            (*StubPtr).Data.Context.ArgCount = ((*StubPtr).Data.Context.ArgCount).wrapping_add(1);
            (*StubPtr).Data.Context.ArgCount;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_GetInt32StatusCode(
    mut Context: *const UT_StubContext_t,
    mut StatusCodeBuffer: *mut int32,
) -> bool {
    if !StatusCodeBuffer.is_null() {
        *StatusCodeBuffer = (*Context).Int32StatusCode;
    }
    return (*Context).Int32StatusIsSet;
}
#[no_mangle]
pub unsafe extern "C" fn UT_DefaultStubImplWithArgs(
    mut FunctionName: *const libc::c_char,
    mut FuncKey: UT_EntryKey_t,
    mut DefaultRc: int32,
    mut ArgList: ::core::ffi::VaList,
) -> int32 {
    let mut RetcodeString: *const libc::c_char = 0 as *const libc::c_char;
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut ContextTblPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut RvcPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    let mut LocalContext: UT_StubContext_t = UT_StubContext_t {
        Int32StatusCode: 0,
        Int32StatusIsSet: false,
        ArgCount: 0,
        ArgPtr: [0 as *const libc::c_void; 8],
        Meta: [UT_StubArgMetaData_t {
            Type: UT_STUBCONTEXT_ARG_TYPE_UNSPECIFIED,
            Name: 0 as *const libc::c_char,
            Size: 0,
        }; 8],
    };
    let mut Counter: uint32 = 0;
    let mut ArgListCopy: ::core::ffi::VaListImpl;
    let mut GotInt32StatusFromHook: bool = false;
    ContextTblPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_CONTEXT);
    if !ContextTblPtr.is_null() {
        LocalContext = (*ContextTblPtr).Data.Context;
        UT_ClearStubEntry(ContextTblPtr);
    } else {
        memset(
            &mut LocalContext as *mut UT_StubContext_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<UT_StubContext_t>() as libc::c_ulong,
        );
    }
    RvcPtr = UT_Stub_FindRetvalConfig(FuncKey);
    if !RvcPtr.is_null()
        && UT_Stub_IsValueCompatible(
            &mut (*RvcPtr).Data.Rvc,
            b"int32\0" as *const u8 as *const libc::c_char,
            UT_ValueGenre_INTEGER,
        ) as libc::c_int
            != 0
    {
        LocalContext.Int32StatusIsSet = UT_LoadRetval(
            &mut LocalContext.Int32StatusCode as *mut int32 as *mut libc::c_void,
            ::core::mem::size_of::<int32>() as libc::c_ulong,
            &mut (*RvcPtr).Data.Rvc.Buf,
            UT_ValueGenre_INTEGER,
        );
    }
    if !LocalContext.Int32StatusIsSet {
        LocalContext.Int32StatusCode = DefaultRc;
    }
    if !FunctionName.is_null() {
        if !LocalContext.Int32StatusIsSet {
            RetcodeString = b"DEFAULT\0" as *const u8 as *const libc::c_char;
        } else {
            RetcodeString = b"*SPECIAL*\0" as *const u8 as *const libc::c_char;
        }
        UtAssert_Message(
            UTASSERT_CASETYPE_DEBUG as libc::c_int as uint8,
            b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/utstubs.c\0" as *const u8
                as *const libc::c_char,
            1096 as libc::c_int as uint32,
            b"%s called (%s,%ld)\0" as *const u8 as *const libc::c_char,
            FunctionName,
            RetcodeString,
            LocalContext.Int32StatusCode as libc::c_long,
        );
    }
    Counter = 0 as libc::c_int as uint32;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_COUNTER);
    if StubPtr.is_null() {
        StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_UNUSED);
    }
    if StubPtr.is_null() {
        UtAssert_Abort(
            b"Cannot set counter - UT_MAX_FUNC_STUBS too low?\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        (*StubPtr).EntryType = UT_ENTRYTYPE_COUNTER;
        (*StubPtr).FuncKey = FuncKey;
        Counter = (*StubPtr).Data.Rc.Count;
        (*StubPtr).Data.Rc.Count = ((*StubPtr).Data.Rc.Count).wrapping_add(1);
        (*StubPtr).Data.Rc.Count;
        (*StubPtr).Data.Rc.Value = LocalContext.Int32StatusCode;
    }
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_CALLBACK_HOOK);
    if !StubPtr.is_null() {
        if (*StubPtr).Data.Cb.IsVarg {
            ArgListCopy = ArgList.clone();
            LocalContext.Int32StatusCode = ((*StubPtr).Data.Cb.Ptr.VaHook)
                .expect("non-null function pointer")(
                (*StubPtr).Data.Cb.CallbackArg,
                LocalContext.Int32StatusCode,
                Counter,
                &mut LocalContext,
                core::mem::transmute(ArgListCopy.as_va_list()),
            );
        } else {
            LocalContext.Int32StatusCode = ((*StubPtr).Data.Cb.Ptr.SimpleHook)
                .expect("non-null function pointer")(
                (*StubPtr).Data.Cb.CallbackArg,
                LocalContext.Int32StatusCode,
                Counter,
                &mut LocalContext,
            );
        }
        GotInt32StatusFromHook = 1 as libc::c_int != 0;
        LocalContext.Int32StatusIsSet = 1 as libc::c_int != 0;
    } else {
        GotInt32StatusFromHook = 0 as libc::c_int != 0;
    }
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER);
    if !StubPtr.is_null() {
        if (*StubPtr).Data.Cb.IsVarg {
            ((*StubPtr).Data.Cb.Ptr.VaHandler).expect("non-null function pointer")(
                (*StubPtr).Data.Cb.CallbackArg,
                FuncKey,
                &mut LocalContext,
                core::mem::transmute(ArgList.as_va_list()),
            );
        } else {
            ((*StubPtr).Data.Cb.Ptr.SimpleHandler).expect("non-null function pointer")(
                (*StubPtr).Data.Cb.CallbackArg,
                FuncKey,
                &mut LocalContext,
            );
        }
    }
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);
    if !StubPtr.is_null() && (*StubPtr).Data.Buff.Position == 0 as libc::c_int as libc::c_ulong {
        if GotInt32StatusFromHook as libc::c_int != 0
            && (*StubPtr).Data.Buff.TotalSize == ::core::mem::size_of::<int32>() as libc::c_ulong
        {
            memcpy(
                (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void,
                &mut LocalContext.Int32StatusCode as *mut int32 as *const libc::c_void,
                (*StubPtr).Data.Buff.TotalSize,
            );
            (*StubPtr).Data.Buff.Position = (*StubPtr).Data.Buff.TotalSize;
        } else if !RvcPtr.is_null() {
            if (*RvcPtr).Data.Rvc.Genre as libc::c_uint
                == UT_ValueGenre_OPAQUE as libc::c_int as libc::c_uint
            {
                if (*StubPtr).Data.Rvc.ActualSz != (*StubPtr).Data.Buff.TotalSize {
                    UtAssertEx(
                        0 as libc::c_int != 0,
                        UtAssert_GetContext(),
                        b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/utstubs.c\0" as *const u8
                            as *const libc::c_char,
                        1197 as libc::c_int as uint32,
                        b"Stub %s opaque return size mismatch, expected %lu, got %lu, type=%s\0"
                            as *const u8 as *const libc::c_char,
                        FunctionName,
                        (*StubPtr).Data.Buff.TotalSize,
                        (*StubPtr).Data.Rvc.ActualSz,
                        (*StubPtr).Data.Buff.ContentTypeStr,
                    );
                } else {
                    memcpy(
                        (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void,
                        (*StubPtr).Data.Rvc.Buf.IndirectPtr,
                        (*StubPtr).Data.Buff.TotalSize,
                    );
                    (*StubPtr).Data.Buff.Position = (*StubPtr).Data.Buff.TotalSize;
                }
            } else if UT_LoadRetval(
                (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void,
                (*StubPtr).Data.Buff.TotalSize,
                &mut (*RvcPtr).Data.Rvc.Buf,
                (*RvcPtr).Data.Rvc.Genre,
            ) {
                (*StubPtr).Data.Buff.Position = (*StubPtr).Data.Buff.TotalSize;
            }
        }
        if (*StubPtr).Data.Buff.Position == 0 as libc::c_int as libc::c_ulong {
            memset(
                (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void,
                0 as libc::c_int,
                (*StubPtr).Data.Buff.TotalSize,
            );
            (*StubPtr).Data.Buff.Position = (*StubPtr).Data.Buff.TotalSize;
        }
    }
    if !RvcPtr.is_null()
        && (*RvcPtr).EntryType as libc::c_uint
            == UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED as libc::c_int as libc::c_uint
    {
        UT_ClearStubEntry(RvcPtr);
    }
    return LocalContext.Int32StatusCode;
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_CopyToReturnValue(
    mut FuncKey: UT_EntryKey_t,
    mut BufferPtr: *const libc::c_void,
    mut BufferSize: size_t,
) {
    let mut StubPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    StubPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETURN_BUFFER);
    if !StubPtr.is_null() {
        if (*StubPtr).Data.Buff.TotalSize != BufferSize {
            UtAssert_Abort(
                b"Size mismatch in setting return value\0" as *const u8 as *const libc::c_char,
            );
        } else {
            memcpy(
                (*StubPtr).Data.Buff.BasePtr as *mut libc::c_void,
                BufferPtr,
                BufferSize,
            );
            (*StubPtr).Data.Buff.Position = BufferSize;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_Stub_FindRetvalConfig(
    mut FuncKey: UT_EntryKey_t,
) -> *mut UT_StubTableEntry_t {
    let mut StubEntryPtr: *mut UT_StubTableEntry_t = 0 as *mut UT_StubTableEntry_t;
    StubEntryPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_DEFERRED);
    if !StubEntryPtr.is_null() {
        (*StubEntryPtr).Data.Rvc.Counter -= 1;
        (*StubEntryPtr).Data.Rvc.Counter;
        if (*StubEntryPtr).Data.Rvc.Counter > 0 as libc::c_int {
            StubEntryPtr = 0 as *mut UT_StubTableEntry_t;
        }
    }
    if StubEntryPtr.is_null() {
        StubEntryPtr = UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_RETVAL_CONFIG_CONSTANT);
        if !StubEntryPtr.is_null() {
            (*StubEntryPtr).Data.Rvc.Counter += 1;
            (*StubEntryPtr).Data.Rvc.Counter;
        }
    }
    return StubEntryPtr;
}
#[no_mangle]
pub unsafe extern "C" fn UT_ExecuteVaHandler(
    mut FuncKey: UT_EntryKey_t,
    mut FunctionName: *const libc::c_char,
    mut DefaultHandler: UT_VaHandlerFunc_t,
    mut VaList: ::core::ffi::VaList,
) {
    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER)).is_null() && DefaultHandler.is_some()
    {
        UT_SetVaHandlerFunction(FuncKey, DefaultHandler, 0 as *mut libc::c_void);
    }
    UT_DefaultStubImplWithArgs(FunctionName, FuncKey, 0 as libc::c_int, VaList.as_va_list());
}
#[no_mangle]
pub unsafe extern "C" fn UT_DefaultStubImpl(
    mut FunctionName: *const libc::c_char,
    mut FuncKey: UT_EntryKey_t,
    mut DefaultRc: int32,
    mut args: ...
) -> int32 {
    let mut Retcode: int32 = 0;
    let mut va: ::core::ffi::VaListImpl;
    va = args.clone();
    Retcode = UT_DefaultStubImplWithArgs(FunctionName, FuncKey, DefaultRc, va.as_va_list());
    return Retcode;
}
#[no_mangle]
pub unsafe extern "C" fn UT_ExecuteBasicHandler(
    mut FuncKey: UT_EntryKey_t,
    mut FunctionName: *const libc::c_char,
    mut DefaultHandler: UT_HandlerFunc_t,
) {
    if (UT_GetStubEntry(FuncKey, UT_ENTRYTYPE_FINAL_HANDLER)).is_null() && DefaultHandler.is_some()
    {
        UT_SetHandlerFunction(FuncKey, DefaultHandler, 0 as *mut libc::c_void);
    }
    UT_DefaultStubImpl(
        FunctionName,
        FuncKey,
        0 as libc::c_int,
        0 as *mut libc::c_void,
    );
}
#[no_mangle]
pub static mut UtAssert_Global: UtAssert_Global_t = UtAssert_Global_t {
    DataBasePtr: 0 as *const UtListHead_t as *mut UtListHead_t,
    ExecutedCount: 0,
};
#[no_mangle]
pub unsafe extern "C" fn UtTest_AddCommon(
    mut Test: Option<unsafe extern "C" fn() -> ()>,
    mut Setup: Option<unsafe extern "C" fn() -> ()>,
    mut Teardown: Option<unsafe extern "C" fn() -> ()>,
    mut TestName: *const libc::c_char,
    mut EntryType: uint32,
) {
    let mut UtTestDataBaseEntry: UtTestDataBaseEntry_t = UtTestDataBaseEntry_t {
        Test: None,
        Setup: None,
        Teardown: None,
        TestName: [0; 40],
    };
    memset(
        &mut UtTestDataBaseEntry as *mut UtTestDataBaseEntry_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<UtTestDataBaseEntry_t>() as libc::c_ulong,
    );
    UtTestDataBaseEntry.Test = Test;
    UtTestDataBaseEntry.Setup = Setup;
    UtTestDataBaseEntry.Teardown = Teardown;
    if !TestName.is_null() {
        strncpy(
            (UtTestDataBaseEntry.TestName).as_mut_ptr(),
            TestName,
            (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
    }
    UT_BSP_Lock();
    UtList_Add(
        UtAssert_Global.DataBasePtr,
        &mut UtTestDataBaseEntry as *mut UtTestDataBaseEntry_t as *mut libc::c_void,
        ::core::mem::size_of::<UtTestDataBaseEntry_t>() as libc::c_ulong as uint32,
        EntryType,
    );
    UT_BSP_Unlock();
}
#[no_mangle]
pub unsafe extern "C" fn UtTest_Add(
    mut Test: Option<unsafe extern "C" fn() -> ()>,
    mut Setup: Option<unsafe extern "C" fn() -> ()>,
    mut Teardown: Option<unsafe extern "C" fn() -> ()>,
    mut SequenceName: *const libc::c_char,
) {
    UtTest_AddCommon(
        Test,
        Setup,
        Teardown,
        SequenceName,
        UTASSERT_GROUP_TEST as libc::c_int as uint32,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtTest_AddSetup(
    mut Setup: Option<unsafe extern "C" fn() -> ()>,
    mut SequenceName: *const libc::c_char,
) {
    UtTest_AddCommon(
        None,
        Setup,
        None,
        SequenceName,
        UTASSERT_GROUP_SETUP as libc::c_int as uint32,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtTest_AddTeardown(
    mut Teardown: Option<unsafe extern "C" fn() -> ()>,
    mut SequenceName: *const libc::c_char,
) {
    UtTest_AddCommon(
        None,
        None,
        Teardown,
        SequenceName,
        UTASSERT_GROUP_TEARDOWN as libc::c_int as uint32,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtTest_AddSubTest(
    mut Test: Option<unsafe extern "C" fn() -> ()>,
    mut Setup: Option<unsafe extern "C" fn() -> ()>,
    mut Teardown: Option<unsafe extern "C" fn() -> ()>,
    mut GroupName: *const libc::c_char,
    mut TestName: *const libc::c_char,
) {
    let mut CompleteTestName: [libc::c_char; 128] = [0; 128];
    let mut GroupPtr: *const libc::c_char = 0 as *const libc::c_char;
    let mut TestPtr: *const libc::c_char = 0 as *const libc::c_char;
    GroupPtr = GroupName;
    TestPtr = TestName;
    while *GroupPtr as libc::c_int != 0 as libc::c_int
        && *GroupPtr as libc::c_int == *TestPtr as libc::c_int
    {
        GroupPtr = GroupPtr.offset(1);
        GroupPtr;
        TestPtr = TestPtr.offset(1);
        TestPtr;
    }
    while TestPtr > TestName && *TestPtr as libc::c_int != '_' as i32 {
        TestPtr = TestPtr.offset(-1);
        TestPtr;
    }
    if *TestPtr as libc::c_int == '_' as i32 {
        TestPtr = TestPtr.offset(1);
        TestPtr;
    }
    GroupPtr = GroupName;
    if strncmp(
        GroupPtr,
        b"Test_\0" as *const u8 as *const libc::c_char,
        5 as libc::c_int as libc::c_ulong,
    ) == 0 as libc::c_int
    {
        GroupPtr = GroupPtr.offset(5 as libc::c_int as isize);
    }
    snprintf(
        CompleteTestName.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
        b"%s.%s\0" as *const u8 as *const libc::c_char,
        GroupPtr,
        TestPtr,
    );
    UtTest_AddCommon(
        Test,
        Setup,
        Teardown,
        CompleteTestName.as_mut_ptr(),
        UTASSERT_GROUP_TEST as libc::c_int as uint32,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UtTest_Run() {
    let mut UtListMain: *mut UtListNode_t = 0 as *mut UtListNode_t;
    let mut UtListNode: *mut UtListNode_t = 0 as *mut UtListNode_t;
    let mut UtTestDataBaseEntry: *mut UtTestDataBaseEntry_t = 0 as *mut UtTestDataBaseEntry_t;
    UT_BSP_Lock();
    UtListMain = UtList_GetHead(
        UtAssert_Global.DataBasePtr,
        UTASSERT_GROUP_DEFAULT as libc::c_int as uint32,
    );
    UtList_Merge(
        UtListMain,
        UtList_GetHead(
            UtAssert_Global.DataBasePtr,
            UTASSERT_GROUP_SETUP as libc::c_int as uint32,
        ),
    );
    UtList_Merge(
        UtListMain,
        UtList_GetHead(
            UtAssert_Global.DataBasePtr,
            UTASSERT_GROUP_TEST as libc::c_int as uint32,
        ),
    );
    UtList_Merge(
        UtListMain,
        UtList_GetHead(
            UtAssert_Global.DataBasePtr,
            UTASSERT_GROUP_TEARDOWN as libc::c_int as uint32,
        ),
    );
    UT_BSP_Unlock();
    UtListNode = UtList_GetNext(UtListMain);
    while !UtList_IsEnd(UtListMain, UtListNode) {
        UtTestDataBaseEntry = UtList_GetObject(UtListNode) as *mut UtTestDataBaseEntry_t;
        if !UtTestDataBaseEntry.is_null() {
            UtAssert_BeginTest(((*UtTestDataBaseEntry).TestName).as_mut_ptr());
            UtAssert_SetContext(UTASSERT_CASETYPE_TSF);
            if ((*UtTestDataBaseEntry).Setup).is_some() {
                ((*UtTestDataBaseEntry).Setup).expect("non-null function pointer")();
            }
            UtAssert_SetContext(UTASSERT_CASETYPE_FAILURE);
            if ((*UtTestDataBaseEntry).Test).is_some() {
                ((*UtTestDataBaseEntry).Test).expect("non-null function pointer")();
                UtAssert_Global.ExecutedCount = (UtAssert_Global.ExecutedCount).wrapping_add(1);
                UtAssert_Global.ExecutedCount;
            }
            UtAssert_SetContext(UTASSERT_CASETYPE_TTF);
            if ((*UtTestDataBaseEntry).Teardown).is_some() {
                ((*UtTestDataBaseEntry).Teardown).expect("non-null function pointer")();
            }
            UtAssert_EndTest();
        }
        UtListNode = UtList_GetNext(UtListNode);
    }
    UT_BSP_Lock();
    UtList_Destroy(UtAssert_Global.DataBasePtr);
    UT_BSP_Unlock();
    UT_BSP_EndTest(UtAssert_GetCounters());
}
#[no_mangle]
pub unsafe extern "C" fn UtTest_EarlyInit() {
    memset(
        &mut UtAssert_Global as *mut UtAssert_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<UtAssert_Global_t>() as libc::c_ulong,
    );
    UtAssert_Global.DataBasePtr = UtList_Create(UTASSERT_GROUP_MAX as libc::c_int as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn UtMessage(
    mut MessageType: uint8,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut Spec: *const libc::c_char,
    mut args: ...
) {
    let mut Buf: UT_Snprintf_Buffer_t = UT_Snprintf_Buffer_t { Text: [0; 256] };
    let mut va: ::core::ffi::VaListImpl;
    va = args.clone();
    vsnprintf(
        (Buf.Text).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        Spec,
        va.as_va_list(),
    );
    UT_BSP_DoText(MessageType, (Buf.Text).as_mut_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn UtBinFile2Mem(
    mut Memory: *mut libc::c_void,
    mut Filename: *const libc::c_char,
    mut Length: uint32,
) -> bool {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut Success: bool = false;
    Success = 0 as libc::c_int != 0;
    fp = fopen(Filename, b"r\0" as *const u8 as *const libc::c_char);
    if !fp.is_null() {
        if fread(
            Memory,
            Length as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            fp,
        ) == 1 as libc::c_int as libc::c_ulong
        {
            Success = 1 as libc::c_int != 0;
        }
        fclose(fp);
    } else {
        UtAssertEx(
            0 as libc::c_int != 0,
            UtAssert_GetContext(),
            b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/uttools.c\0" as *const u8
                as *const libc::c_char,
            88 as libc::c_int as uint32,
            b"UtBinFile2Mem: Error Opening %s: %s\0" as *const u8 as *const libc::c_char,
            Filename,
            strerror(*__errno_location()),
        );
    }
    return Success;
}
#[no_mangle]
pub unsafe extern "C" fn UtMem2BinFile(
    mut Memory: *const libc::c_void,
    mut Filename: *const libc::c_char,
    mut Length: uint32,
) -> bool {
    let mut fp: *mut FILE = 0 as *mut FILE;
    fp = fopen(Filename, b"w\0" as *const u8 as *const libc::c_char);
    if !fp.is_null() {
        fwrite(
            Memory,
            Length as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            fp,
        );
        fclose(fp);
        return 1 as libc::c_int != 0;
    } else {
        printf(
            b"UtMem2BinFile: Error Opening File: %s, %s\n\0" as *const u8 as *const libc::c_char,
            Filename,
            strerror(*__errno_location()),
        );
        UtAssertEx(
            0 as libc::c_int != 0,
            UtAssert_GetContext(),
            b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/uttools.c\0" as *const u8
                as *const libc::c_char,
            67 as libc::c_int as uint32,
            b"UtMem2BinFile: Error Opening File\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int != 0;
    };
}
#[no_mangle]
pub unsafe extern "C" fn UtMem2HexFile(
    mut Memory: *const libc::c_void,
    mut Filename: *const libc::c_char,
    mut Length: uint32,
) -> bool {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut i: uint32 = 0;
    let mut j: uint32 = 0;
    fp = fopen(Filename, b"w\0" as *const u8 as *const libc::c_char);
    if !fp.is_null() {
        i = 0 as libc::c_int as uint32;
        while i < Length {
            fprintf(
                fp,
                b"   %06lX: \0" as *const u8 as *const libc::c_char,
                i as libc::c_ulong,
            );
            j = 0 as libc::c_int as uint32;
            while j < 16 as libc::c_int as libc::c_uint {
                if i.wrapping_add(j) < Length {
                    fprintf(
                        fp,
                        b"%02X \0" as *const u8 as *const libc::c_char,
                        *(Memory as *mut uint8).offset(i.wrapping_add(j) as isize) as libc::c_int,
                    );
                } else {
                    fprintf(fp, b"   \0" as *const u8 as *const libc::c_char);
                }
                j = j.wrapping_add(1);
                j;
            }
            fprintf(fp, b" \0" as *const u8 as *const libc::c_char);
            j = 0 as libc::c_int as uint32;
            while j < 16 as libc::c_int as libc::c_uint {
                if i.wrapping_add(j) < Length {
                    fprintf(
                        fp,
                        b"%c\0" as *const u8 as *const libc::c_char,
                        if *(*__ctype_b_loc())
                            .offset(*(Memory as *mut uint8).offset(i.wrapping_add(j) as isize)
                                as libc::c_int as isize) as libc::c_int
                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                        {
                            *(Memory as *mut uint8).offset(i.wrapping_add(j) as isize)
                                as libc::c_int
                        } else {
                            '.' as i32
                        },
                    );
                }
                j = j.wrapping_add(1);
                j;
            }
            fprintf(fp, b"\n\0" as *const u8 as *const libc::c_char);
            i = (i as libc::c_uint).wrapping_add(16 as libc::c_int as libc::c_uint) as uint32
                as uint32;
        }
        fclose(fp);
        return 1 as libc::c_int != 0;
    } else {
        printf(
            b"UtMem2HexFile: Error Opening File: %s, %s\n\0" as *const u8 as *const libc::c_char,
            Filename,
            strerror(*__errno_location()),
        );
        UtAssertEx(
            0 as libc::c_int != 0,
            UtAssert_GetContext(),
            b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/uttools.c\0" as *const u8
                as *const libc::c_char,
            126 as libc::c_int as uint32,
            b"UtMem2HexFile: Error Opening File\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int != 0;
    };
}
#[no_mangle]
pub unsafe extern "C" fn UtMemFill(mut Memory: *mut libc::c_void, mut Length: uint32) {
    let mut i: uint32 = 0;
    let mut Byte_ptr: *mut uint8 = Memory as *mut uint8;
    i = 0 as libc::c_int as uint32;
    while i < Length {
        *Byte_ptr.offset(i as isize) = i as uint8;
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn UtSprintf(
    mut Spec: *const libc::c_char,
    mut args: ...
) -> *mut libc::c_char {
    let mut Args: ::core::ffi::VaListImpl;
    static mut Buf: [UT_Snprintf_Buffer_t; 10] = [UT_Snprintf_Buffer_t { Text: [0; 256] }; 10];
    static mut TextIndex: uint32 = 0 as libc::c_int as uint32;
    TextIndex = TextIndex.wrapping_add(1);
    TextIndex;
    if TextIndex >= 10 as libc::c_int as libc::c_uint {
        TextIndex = 0 as libc::c_int as uint32;
    }
    Args = args.clone();
    vsnprintf(
        (Buf[TextIndex as usize].Text).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        Spec,
        Args.as_va_list(),
    );
    return (Buf[TextIndex as usize].Text).as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn UtMem2BinFileCmp(
    mut Memory: *const libc::c_void,
    mut Filename: *const libc::c_char,
) -> bool {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut MemByte: *const uint8 = Memory as *const uint8;
    let mut FileByte: libc::c_int = 0;
    let mut Success: bool = false;
    let mut i: uint32 = 0;
    Success = 1 as libc::c_int != 0;
    fp = fopen(Filename, b"r\0" as *const u8 as *const libc::c_char);
    if !fp.is_null() {
        i = 0 as libc::c_int as uint32;
        loop {
            FileByte = fgetc(fp);
            if !(FileByte != -(1 as libc::c_int)) {
                break;
            }
            if *MemByte.offset(i as isize) as libc::c_int != FileByte {
                Success = 0 as libc::c_int != 0;
                printf(
                    b"UtMem2BinFileCmp: Miscompare in file: %s, byte offset: %lu, expected: %u, found: %u\n\0"
                        as *const u8 as *const libc::c_char,
                    Filename,
                    i as libc::c_ulong,
                    *MemByte.offset(i as isize) as libc::c_uint,
                    FileByte as libc::c_uint,
                );
                break;
            } else {
                i = i.wrapping_add(1);
                i;
            }
        }
        fclose(fp);
    } else {
        Success = 0 as libc::c_int != 0;
        printf(
            b"UtMem2BinFileCmp: Error Opening File: %s, %s\n\0" as *const u8 as *const libc::c_char,
            Filename,
            strerror(*__errno_location()),
        );
        UtAssertEx(
            0 as libc::c_int != 0,
            UtAssert_GetContext(),
            b"/home/kkysen/work/rust/cFS/osal/ut_assert/src/uttools.c\0" as *const u8
                as *const libc::c_char,
            252 as libc::c_int as uint32,
            b"UtMem2BinFileCmp: Error Opening File\0" as *const u8 as *const libc::c_char,
        );
    }
    return Success;
}
#[no_mangle]
pub unsafe extern "C" fn UtMemCmpCount(
    mut Memory: *const libc::c_void,
    mut Length: uint32,
) -> bool {
    let mut i: uint32 = 0;
    let mut Byte_ptr: *const uint8 = Memory as *const uint8;
    i = 0 as libc::c_int as uint32;
    while i < Length {
        if *Byte_ptr.offset(i as isize) as libc::c_uint != i & 0xff as libc::c_int as libc::c_uint {
            return 0 as libc::c_int != 0;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn UtMemCmpValue(
    mut Memory: *const libc::c_void,
    mut Value: uint8,
    mut Length: uint32,
) -> bool {
    let mut i: uint32 = 0;
    let mut Byte_ptr: *const uint8 = Memory as *const uint8;
    i = 0 as libc::c_int as uint32;
    while i < Length {
        if *Byte_ptr.offset(i as isize) as libc::c_int != Value as libc::c_int {
            return 0 as libc::c_int != 0;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn UtPrintx(mut Memory: *const libc::c_void, mut Length: uint32) {
    let mut i: uint32 = 0;
    let mut j: uint32 = 0;
    let mut Byte_ptr: *const uint8 = Memory as *const uint8;
    let mut OutputLine: [libc::c_char; 80] = [0; 80];
    let mut OutPtr: *mut libc::c_char = 0 as *mut libc::c_char;
    i = 0 as libc::c_int as uint32;
    while i < Length {
        snprintf(
            OutputLine.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
            b"%16lx: \0" as *const u8 as *const libc::c_char,
            &*Byte_ptr.offset(i as isize) as *const uint8 as libc::c_ulong,
        );
        OutPtr = OutputLine.as_mut_ptr();
        OutPtr = OutPtr.offset(strlen(OutputLine.as_mut_ptr()) as isize);
        j = 0 as libc::c_int as uint32;
        while j < 16 as libc::c_int as libc::c_uint && i < Length {
            sprintf(
                OutPtr,
                b"%02X  \0" as *const u8 as *const libc::c_char,
                *Byte_ptr.offset(i as isize) as libc::c_int,
            );
            OutPtr = OutPtr.offset(3 as libc::c_int as isize);
            j = j.wrapping_add(1);
            j;
            i = i.wrapping_add(1);
            i;
        }
        UT_BSP_DoText(
            UTASSERT_CASETYPE_INFO as libc::c_int as uint8,
            OutputLine.as_mut_ptr(),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_Shutdown_Impl() {
    abort();
}
#[no_mangle]
pub static mut OS_BSP_GenericLinuxGlobal: OS_BSP_GenericLinuxGlobalData_t =
    OS_BSP_GenericLinuxGlobalData_t {
        EnableTermControl: false,
        AccessMutex: pthread_mutex_t {
            __data: __pthread_mutex_s {
                __lock: 0,
                __count: 0,
                __owner: 0,
                __nusers: 0,
                __kind: 0,
                __spins: 0,
                __elision: 0,
                __list: __pthread_list_t {
                    __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                },
            },
        },
        AccessCancelState: 0,
    };
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_Unlock_Impl() {
    let mut status: libc::c_int = 0;
    status = pthread_mutex_unlock(&mut OS_BSP_GenericLinuxGlobal.AccessMutex);
    if status < 0 as libc::c_int {
        printf(
            b"%s():\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_BSP_Unlock_Impl\0"))
                .as_ptr(),
        );
        printf(
            b"pthread_mutex_unlock: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(status),
        );
    } else {
        pthread_setcancelstate(
            OS_BSP_GenericLinuxGlobal.AccessCancelState,
            0 as *mut libc::c_int,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_Lock_Impl() {
    let mut status: libc::c_int = 0;
    status = pthread_mutex_lock(&mut OS_BSP_GenericLinuxGlobal.AccessMutex);
    if status < 0 as libc::c_int {
        printf(
            b"%s():\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_BSP_Lock_Impl\0"))
                .as_ptr(),
        );
        printf(
            b"pthread_mutex_lock: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(status),
        );
    } else {
        pthread_setcancelstate(
            PTHREAD_CANCEL_DISABLE as libc::c_int,
            &mut OS_BSP_GenericLinuxGlobal.AccessCancelState,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_Initialize() {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut buffer: [libc::c_char; 32] = [0; 32];
    let mut mutex_attr: pthread_mutexattr_t = pthread_mutexattr_t { __size: [0; 4] };
    let mut status: libc::c_int = 0;
    if geteuid() != 0 as libc::c_int as libc::c_uint {
        fp = fopen(
            b"/proc/sys/fs/mqueue/msg_max\0" as *const u8 as *const libc::c_char,
            b"r\0" as *const u8 as *const libc::c_char,
        );
        if !fp.is_null() {
            if !(fgets(
                buffer.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong as libc::c_int,
                fp,
            ))
            .is_null()
            {
                OS_BSP_Global.MaxQueueDepth = strtoul(
                    buffer.as_mut_ptr(),
                    0 as *mut *mut libc::c_char,
                    10 as libc::c_int,
                );
                printf(
                    b"%s():\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(
                        b"OS_BSP_Initialize\0",
                    ))
                    .as_ptr(),
                );
                printf(
                    b"Maximum user msg queue depth = %u\n\0" as *const u8 as *const libc::c_char,
                    OS_BSP_Global.MaxQueueDepth as libc::c_uint,
                );
            }
            fclose(fp);
        }
    }
    status = pthread_mutexattr_init(&mut mutex_attr);
    if status < 0 as libc::c_int {
        printf(
            b"%s():\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_BSP_Initialize\0"))
                .as_ptr(),
        );
        printf(
            b"pthread_mutexattr_init: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(status),
        );
    }
    status = pthread_mutexattr_setprotocol(&mut mutex_attr, PTHREAD_PRIO_INHERIT as libc::c_int);
    if status < 0 as libc::c_int {
        printf(
            b"%s():\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_BSP_Initialize\0"))
                .as_ptr(),
        );
        printf(
            b"pthread_mutexattr_setprotocol: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(status),
        );
    }
    status = pthread_mutex_init(&mut OS_BSP_GenericLinuxGlobal.AccessMutex, &mut mutex_attr);
    if status < 0 as libc::c_int {
        printf(
            b"%s():\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_BSP_Initialize\0"))
                .as_ptr(),
        );
        printf(
            b"pthread_mutex_init: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(status),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_GetReturnStatus() -> libc::c_int {
    let mut retcode: libc::c_int = 0;
    match OS_BSP_Global.AppStatus {
        0 => {
            retcode = 0 as libc::c_int;
        }
        -1 => {
            retcode = 1 as libc::c_int;
        }
        _ => {
            retcode = OS_BSP_Global.AppStatus & 0x7f as libc::c_int;
        }
    }
    return retcode;
}
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char) -> libc::c_int {
    memset(
        &mut OS_BSP_Global as *mut OS_BSP_GlobalData_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_BSP_GlobalData_t>() as libc::c_ulong,
    );
    memset(
        &mut OS_BSP_GenericLinuxGlobal as *mut OS_BSP_GenericLinuxGlobalData_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_BSP_GenericLinuxGlobalData_t>() as libc::c_ulong,
    );
    OS_BSP_Global.ArgC = argc as uint32;
    OS_BSP_Global.ArgV = argv;
    if !(getenv(b"TERM\0" as *const u8 as *const libc::c_char)).is_null() {
        OS_BSP_GenericLinuxGlobal.EnableTermControl = isatty(1 as libc::c_int) != 0;
    }
    OS_BSP_Initialize();
    OS_Application_Startup();
    OS_Application_Run();
    return OS_BSP_GetReturnStatus();
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_ConsoleOutput_Impl(
    mut Str: *const libc::c_char,
    mut DataLen: size_t,
) {
    let mut WriteLen: ssize_t = 0;
    while DataLen > 0 as libc::c_int as libc::c_ulong {
        WriteLen = write(1 as libc::c_int, Str as *const libc::c_void, DataLen);
        if WriteLen <= 0 as libc::c_int as libc::c_long {
            break;
        }
        Str = Str.offset(WriteLen as isize);
        DataLen =
            (DataLen as libc::c_ulong).wrapping_sub(WriteLen as libc::c_ulong) as size_t as size_t;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_BSP_ConsoleSetMode_Impl(mut ModeBits: uint32) {
    let mut param: [libc::c_char; 32] = [0; 32];
    if OS_BSP_GenericLinuxGlobal.EnableTermControl {
        if ModeBits == 0 as libc::c_int as libc::c_uint {
            OS_BSP_ExecTput(
                b"sgr0\0" as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
        } else {
            if ModeBits & 0x8 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint {
                OS_BSP_ExecTput(
                    b"rmso\0" as *const u8 as *const libc::c_char,
                    0 as *const libc::c_char,
                );
            } else {
                OS_BSP_ExecTput(
                    b"smso\0" as *const u8 as *const libc::c_char,
                    0 as *const libc::c_char,
                );
            }
            snprintf(
                param.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                ModeBits & 0x7 as libc::c_int as libc::c_uint,
            );
            OS_BSP_ExecTput(
                b"setaf\0" as *const u8 as *const libc::c_char,
                param.as_mut_ptr(),
            );
        }
    }
}
unsafe extern "C" fn OS_BSP_ExecTput(mut cap: *const libc::c_char, mut param: *const libc::c_char) {
    let mut cpid: pid_t = 0;
    let mut status: libc::c_int = 0;
    cpid = fork();
    if cpid < 0 as libc::c_int {
        return;
    }
    if cpid == 0 as libc::c_int {
        execlp(
            b"tput\0" as *const u8 as *const libc::c_char,
            b"tput\0" as *const u8 as *const libc::c_char,
            cap,
            param,
            0 as *mut libc::c_void,
        );
        exit(1 as libc::c_int);
    }
    waitpid(cpid, &mut status, 0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemCreate_Impl(
    mut token: *const OS_object_token_t,
    mut initial_value: uint32,
    mut options: uint32,
) -> int32 {
    let mut ret: libc::c_int = 0;
    let mut attr_created: libc::c_int = 0;
    let mut mutex_created: libc::c_int = 0;
    let mut cond_created: libc::c_int = 0;
    let mut return_code: int32 = 0;
    let mut mutex_attr: pthread_mutexattr_t = pthread_mutexattr_t { __size: [0; 4] };
    let mut sem: *mut OS_impl_binsem_internal_record_t = 0 as *mut OS_impl_binsem_internal_record_t;
    if initial_value > 1 as libc::c_int as libc::c_uint {
        initial_value = 1 as libc::c_int as uint32;
    }
    attr_created = 0 as libc::c_int;
    mutex_created = 0 as libc::c_int;
    cond_created = 0 as libc::c_int;
    sem = &mut *OS_impl_bin_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_binsem_internal_record_t;
    memset(
        sem as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_impl_binsem_internal_record_t>() as libc::c_ulong,
    );
    ret = pthread_mutexattr_init(&mut mutex_attr);
    if ret != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_BinSemCreate_Impl\0"))
                .as_ptr(),
            152 as libc::c_int as uint32,
            b"Error: pthread_mutexattr_init failed: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(ret),
        );
        return_code = -(6 as libc::c_int);
    } else {
        attr_created = 1 as libc::c_int;
        ret = pthread_mutexattr_setprotocol(&mut mutex_attr, PTHREAD_PRIO_INHERIT as libc::c_int);
        if ret != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                    b"OS_BinSemCreate_Impl\0",
                ))
                .as_ptr(),
                166 as libc::c_int as uint32,
                b"Error: pthread_mutexattr_setprotocol failed: %s\n\0" as *const u8
                    as *const libc::c_char,
                strerror(ret),
            );
            return_code = -(6 as libc::c_int);
        } else {
            ret = pthread_mutex_init(&mut (*sem).id, &mut mutex_attr);
            if ret != 0 as libc::c_int {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                        b"OS_BinSemCreate_Impl\0",
                    ))
                    .as_ptr(),
                    177 as libc::c_int as uint32,
                    b"Error: pthread_mutex_init failed: %s\n\0" as *const u8 as *const libc::c_char,
                    strerror(ret),
                );
                return_code = -(6 as libc::c_int);
            } else {
                mutex_created = 1 as libc::c_int;
                ret = pthread_cond_init(&mut (*sem).cv, 0 as *const pthread_condattr_t);
                if ret != 0 as libc::c_int {
                    OS_DebugPrintf(
                        1 as libc::c_int as uint32,
                        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                            b"OS_BinSemCreate_Impl\0",
                        ))
                        .as_ptr(),
                        190 as libc::c_int as uint32,
                        b"Error: pthread_cond_init failed: %s\n\0" as *const u8
                            as *const libc::c_char,
                        strerror(ret),
                    );
                    return_code = -(6 as libc::c_int);
                } else {
                    cond_created = 1 as libc::c_int;
                    ret = pthread_cond_signal(&mut (*sem).cv);
                    if ret != 0 as libc::c_int {
                        OS_DebugPrintf(
                            1 as libc::c_int as uint32,
                            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                                b"OS_BinSemCreate_Impl\0",
                            ))
                            .as_ptr(),
                            203 as libc::c_int as uint32,
                            b"Error: initial pthread_cond_signal failed: %s\n\0" as *const u8
                                as *const libc::c_char,
                            strerror(ret),
                        );
                        return_code = -(6 as libc::c_int);
                    } else {
                        ::core::ptr::write_volatile(
                            &mut (*sem).current_value as *mut sig_atomic_t,
                            initial_value as sig_atomic_t,
                        );
                        return_code = 0 as libc::c_int;
                    }
                }
            }
        }
    }
    if return_code != 0 as libc::c_int {
        if mutex_created != 0 {
            pthread_mutex_destroy(&mut (*sem).id);
        }
        if cond_created != 0 {
            pthread_cond_destroy(&mut (*sem).cv);
        }
    }
    if attr_created != 0 {
        pthread_mutexattr_destroy(&mut mutex_attr);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_BinSemAcquireMutex(mut mut_0: *mut pthread_mutex_t) -> int32 {
    let mut timeout: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    if clock_gettime(0 as libc::c_int, &mut timeout) != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    timeout.tv_sec += 2 as libc::c_int as libc::c_long;
    if pthread_mutex_timedlock(mut_0, &mut timeout) != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut OS_impl_bin_sem_table: [OS_impl_binsem_internal_record_t; 20] =
    [OS_impl_binsem_internal_record_t {
        id: pthread_mutex_t {
            __data: __pthread_mutex_s {
                __lock: 0,
                __count: 0,
                __owner: 0,
                __nusers: 0,
                __kind: 0,
                __spins: 0,
                __elision: 0,
                __list: __pthread_list_t {
                    __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                },
            },
        },
        cv: pthread_cond_t {
            __data: __pthread_cond_s {
                __wseq: __atomic_wide_counter { __value64: 0 },
                __g1_start: __atomic_wide_counter { __value64: 0 },
                __g_refs: [0; 2],
                __g_size: [0; 2],
                __g1_orig_size: 0,
                __wrefs: 0,
                __g_signals: [0; 2],
            },
        },
        flush_request: 0,
        current_value: 0,
    }; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_BinSemReleaseMutex(mut mut_0: *mut libc::c_void) {
    pthread_mutex_unlock(mut_0 as *mut pthread_mutex_t);
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_BinSemAPI_Impl_Init() -> int32 {
    memset(
        OS_impl_bin_sem_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_binsem_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemDelete_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut sem: *mut OS_impl_binsem_internal_record_t = 0 as *mut OS_impl_binsem_internal_record_t;
    let mut return_code: int32 = 0;
    sem = &mut *OS_impl_bin_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_binsem_internal_record_t;
    if pthread_cond_destroy(&mut (*sem).cv) != 0 as libc::c_int {
        return_code = -(6 as libc::c_int);
    } else {
        return_code = 0 as libc::c_int;
        pthread_mutex_destroy(&mut (*sem).id);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemGive_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut sem: *mut OS_impl_binsem_internal_record_t = 0 as *mut OS_impl_binsem_internal_record_t;
    sem = &mut *OS_impl_bin_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_binsem_internal_record_t;
    if OS_Posix_BinSemAcquireMutex(&mut (*sem).id) != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    ::core::ptr::write_volatile(
        &mut (*sem).current_value as *mut sig_atomic_t,
        1 as libc::c_int,
    );
    pthread_cond_signal(&mut (*sem).cv);
    pthread_mutex_unlock(&mut (*sem).id);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemFlush_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut sem: *mut OS_impl_binsem_internal_record_t = 0 as *mut OS_impl_binsem_internal_record_t;
    sem = &mut *OS_impl_bin_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_binsem_internal_record_t;
    if OS_Posix_BinSemAcquireMutex(&mut (*sem).id) != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    ::core::ptr::write_volatile(
        &mut (*sem).flush_request as *mut sig_atomic_t,
        ::core::ptr::read_volatile::<sig_atomic_t>(&(*sem).flush_request as *const sig_atomic_t)
            + 1,
    );
    ::core::ptr::read_volatile::<sig_atomic_t>(&(*sem).flush_request as *const sig_atomic_t);
    pthread_cond_broadcast(&mut (*sem).cv);
    pthread_mutex_unlock(&mut (*sem).id);
    return 0 as libc::c_int;
}
unsafe extern "C" fn OS_GenericBinSemTake_Impl(
    mut token: *const OS_object_token_t,
    mut timeout: *const timespec,
) -> int32 {
    let mut flush_count: sig_atomic_t = 0;
    let mut return_code: int32 = 0;
    let mut sem: *mut OS_impl_binsem_internal_record_t = 0 as *mut OS_impl_binsem_internal_record_t;
    sem = &mut *OS_impl_bin_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_binsem_internal_record_t;
    if OS_Posix_BinSemAcquireMutex(&mut (*sem).id) != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    let mut __cancel_buf: __pthread_unwind_buf_t = __pthread_unwind_buf_t {
        __cancel_jmp_buf: [__cancel_jmp_buf_tag {
            __cancel_jmp_buf: [0; 8],
            __mask_was_saved: 0,
        }; 1],
        __pad: [0 as *mut libc::c_void; 4],
    };
    let mut __cancel_routine: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()> =
        Some(OS_Posix_BinSemReleaseMutex as unsafe extern "C" fn(*mut libc::c_void) -> ());
    let mut __cancel_arg: *mut libc::c_void =
        &mut (*sem).id as *mut pthread_mutex_t as *mut libc::c_void;
    let mut __not_first_call: libc::c_int = __sigsetjmp(
        (__cancel_buf.__cancel_jmp_buf).as_mut_ptr() as *mut libc::c_void as *mut __jmp_buf_tag,
        0 as libc::c_int,
    );
    if __not_first_call as libc::c_long != 0 {
        __cancel_routine.expect("non-null function pointer")(__cancel_arg);
        __pthread_unwind_next(&mut __cancel_buf);
    }
    __pthread_register_cancel(&mut __cancel_buf);
    return_code = 0 as libc::c_int;
    flush_count = (*sem).flush_request;
    while (*sem).current_value == 0 as libc::c_int && (*sem).flush_request == flush_count {
        if timeout.is_null() {
            pthread_cond_wait(&mut (*sem).cv, &mut (*sem).id);
        } else {
            if !(pthread_cond_timedwait(&mut (*sem).cv, &mut (*sem).id, timeout)
                == 110 as libc::c_int)
            {
                continue;
            }
            return_code = -(7 as libc::c_int);
            break;
        }
    }
    if return_code == 0 as libc::c_int && (*sem).flush_request == flush_count {
        ::core::ptr::write_volatile(
            &mut (*sem).current_value as *mut sig_atomic_t,
            0 as libc::c_int,
        );
    }
    __pthread_unregister_cancel(&mut __cancel_buf);
    __cancel_routine.expect("non-null function pointer")(__cancel_arg);
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemTake_Impl(mut token: *const OS_object_token_t) -> int32 {
    return OS_GenericBinSemTake_Impl(token, 0 as *const timespec);
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemTimedWait_Impl(
    mut token: *const OS_object_token_t,
    mut msecs: uint32,
) -> int32 {
    let mut ts: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    OS_Posix_CompAbsDelayTime(msecs, &mut ts);
    return OS_GenericBinSemTake_Impl(token, &mut ts);
}
#[no_mangle]
pub unsafe extern "C" fn OS_BinSemGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut sem_prop: *mut OS_bin_sem_prop_t,
) -> int32 {
    let mut sem: *mut OS_impl_binsem_internal_record_t = 0 as *mut OS_impl_binsem_internal_record_t;
    sem = &mut *OS_impl_bin_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_binsem_internal_record_t;
    (*sem_prop).value = (*sem).current_value;
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut POSIX_GlobalVars: POSIX_GlobalVars_t = {
    let mut init = POSIX_GlobalVars_t {
        EnableTaskPriorities: 0 as libc::c_int != 0,
        TruncateQueueDepth: 0,
        ClockAccuracyNsec: 0,
        ThreadKey: 0,
        MaximumSigMask: sigset_t { __val: [0; 16] },
        NormalSigMask: sigset_t { __val: [0; 16] },
        PageSize: 0,
        PriLimits: POSIX_PriorityLimits_t {
            PriorityMax: 0,
            PriorityMin: 0,
        },
        SelectedRtScheduler: 0,
    };
    init
};
#[no_mangle]
pub unsafe extern "C" fn OS_IdleLoop_Impl() {
    sigsuspend(&mut POSIX_GlobalVars.NormalSigMask);
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_CompAbsDelayTime(mut msecs: uint32, mut tm: *mut timespec) {
    clock_gettime(0 as libc::c_int, tm);
    (*tm).tv_sec += msecs.wrapping_div(1000 as libc::c_int as libc::c_uint) as time_t;
    (*tm).tv_nsec += msecs.wrapping_rem(1000 as libc::c_int as libc::c_uint) as libc::c_long
        * 1000000 as libc::c_long;
    if (*tm).tv_nsec >= 1000000000 as libc::c_long {
        (*tm).tv_nsec -= 1000000000 as libc::c_long;
        (*tm).tv_sec += 1;
        (*tm).tv_sec;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_API_Impl_Init(mut idtype: osal_objtype_t) -> int32 {
    let mut return_code: int32 = 0;
    return_code = OS_Posix_TableMutex_Init(idtype);
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    match idtype {
        1 => {
            return_code = OS_Posix_TaskAPI_Impl_Init();
        }
        2 => {
            return_code = OS_Posix_QueueAPI_Impl_Init();
        }
        4 => {
            return_code = OS_Posix_BinSemAPI_Impl_Init();
        }
        3 => {
            return_code = OS_Posix_CountSemAPI_Impl_Init();
        }
        5 => {
            return_code = OS_Posix_MutexAPI_Impl_Init();
        }
        10 => {
            return_code = OS_Posix_ModuleAPI_Impl_Init();
        }
        8 => {
            return_code = OS_Posix_TimeBaseAPI_Impl_Init();
        }
        6 => {
            return_code = OS_Posix_StreamAPI_Impl_Init();
        }
        7 => {
            return_code = OS_Posix_DirAPI_Impl_Init();
        }
        11 => {
            return_code = OS_Posix_FileSysAPI_Impl_Init();
        }
        13 => {
            return_code = OS_Posix_CondVarAPI_Impl_Init();
        }
        _ => {}
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ApplicationShutdown_Impl() {
    kill(getpid(), 1 as libc::c_int);
}
unsafe extern "C" fn OS_ConsoleTask_Entry(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut local_arg: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    let mut local: *mut OS_impl_console_internal_record_t =
        0 as *mut OS_impl_console_internal_record_t;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    local_arg.opaque_arg = arg;
    if OS_ObjectIdGetById(
        OS_LOCK_MODE_REFCOUNT,
        0xc as libc::c_int as osal_objtype_t,
        local_arg.id,
        &mut token,
    ) == 0 as libc::c_int
    {
        local = &mut *OS_impl_console_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_impl_console_internal_record_t;
        while OS_SharedGlobalVars.GlobalState != 0xabadc0de as libc::c_uint {
            OS_ConsoleOutput_Impl(&mut token);
            sem_wait(&mut (*local).data_sem);
        }
        OS_ObjectIdRelease(&mut token);
    }
    return 0 as *mut libc::c_void;
}
#[no_mangle]
pub static mut OS_impl_console_table: [OS_impl_console_internal_record_t; 1] =
    [OS_impl_console_internal_record_t {
        data_sem: sem_t { __size: [0; 32] },
    }; 1];
#[no_mangle]
pub unsafe extern "C" fn OS_ConsoleWakeup_Impl(mut token: *const OS_object_token_t) {
    let mut local: *mut OS_impl_console_internal_record_t =
        0 as *mut OS_impl_console_internal_record_t;
    local = &mut *OS_impl_console_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_console_internal_record_t;
    sem_post(&mut (*local).data_sem);
}
#[no_mangle]
pub unsafe extern "C" fn OS_ConsoleCreate_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut local: *mut OS_impl_console_internal_record_t =
        0 as *mut OS_impl_console_internal_record_t;
    let mut console: *mut OS_console_internal_record_t = 0 as *mut OS_console_internal_record_t;
    let mut consoletask: pthread_t = 0;
    let mut return_code: int32 = 0;
    let mut local_arg: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    console = &mut *OS_console_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_console_internal_record_t;
    local = &mut *OS_impl_console_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_console_internal_record_t;
    if (*token).obj_idx == 0 as libc::c_int as libc::c_uint {
        return_code = 0 as libc::c_int;
        if (*console).IsAsync {
            if sem_init(
                &mut (*local).data_sem,
                0 as libc::c_int,
                0 as libc::c_int as libc::c_uint,
            ) < 0 as libc::c_int
            {
                return_code = -(6 as libc::c_int);
            } else {
                local_arg.id = OS_ObjectIdFromToken(token);
                return_code = OS_Posix_InternalTaskCreate_Impl(
                    &mut consoletask,
                    10 as libc::c_int as osal_priority_t,
                    0 as libc::c_int as size_t,
                    Some(
                        OS_ConsoleTask_Entry
                            as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
                    ),
                    local_arg.opaque_arg,
                );
                if return_code != 0 as libc::c_int {
                    sem_destroy(&mut (*local).data_sem);
                }
            }
        }
    } else {
        return_code = -(28 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_impl_condvar_table: [OS_impl_condvar_internal_record_t; 4] =
    [OS_impl_condvar_internal_record_t {
        mut_0: pthread_mutex_t {
            __data: __pthread_mutex_s {
                __lock: 0,
                __count: 0,
                __owner: 0,
                __nusers: 0,
                __kind: 0,
                __spins: 0,
                __elision: 0,
                __list: __pthread_list_t {
                    __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                },
            },
        },
        cv: pthread_cond_t {
            __data: __pthread_cond_s {
                __wseq: __atomic_wide_counter { __value64: 0 },
                __g1_start: __atomic_wide_counter { __value64: 0 },
                __g_refs: [0; 2],
                __g_size: [0; 2],
                __g1_orig_size: 0,
                __wrefs: 0,
                __g_signals: [0; 2],
            },
        },
    }; 4];
unsafe extern "C" fn OS_Posix_CondVarReleaseMutex(mut mut_0: *mut libc::c_void) {
    pthread_mutex_unlock(mut_0 as *mut pthread_mutex_t);
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_CondVarAPI_Impl_Init() -> int32 {
    memset(
        OS_impl_condvar_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_condvar_internal_record_t; 4]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarCreate_Impl(
    mut token: *const OS_object_token_t,
    mut options: uint32,
) -> int32 {
    let mut final_status: int32 = 0;
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    final_status = 0 as libc::c_int;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    status = pthread_mutex_init(&mut (*impl_0).mut_0, 0 as *const pthread_mutexattr_t);
    if status != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"OS_CondVarCreate_Impl\0"))
                .as_ptr(),
            84 as libc::c_int as uint32,
            b"Error: CondVar mutex could not be created. ID = %lu: %s\n\0" as *const u8
                as *const libc::c_char,
            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
            strerror(status),
        );
        final_status = -(1 as libc::c_int);
    } else {
        status = pthread_cond_init(&mut (*impl_0).cv, 0 as *const pthread_condattr_t);
        if status != 0 as libc::c_int {
            pthread_mutex_destroy(&mut (*impl_0).mut_0);
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(
                    b"OS_CondVarCreate_Impl\0",
                ))
                .as_ptr(),
                98 as libc::c_int as uint32,
                b"Error: CondVar could not be created. ID = %lu: %s\n\0" as *const u8
                    as *const libc::c_char,
                OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
                strerror(status),
            );
            final_status = -(1 as libc::c_int);
        }
    }
    return final_status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarDelete_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut final_status: int32 = 0;
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    final_status = 0 as libc::c_int;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    status = pthread_cond_destroy(&mut (*impl_0).cv);
    if status != 0 as libc::c_int {
        final_status = -(1 as libc::c_int);
    }
    status = pthread_mutex_destroy(&mut (*impl_0).mut_0);
    if status != 0 as libc::c_int {
        final_status = -(1 as libc::c_int);
    }
    return final_status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarUnlock_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    status = pthread_mutex_unlock(&mut (*impl_0).mut_0);
    if status != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarLock_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    status = pthread_mutex_lock(&mut (*impl_0).mut_0);
    if status != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarSignal_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    status = pthread_cond_signal(&mut (*impl_0).cv);
    if status != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarBroadcast_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    status = pthread_cond_broadcast(&mut (*impl_0).cv);
    if status != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarWait_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    let mut __cancel_buf: __pthread_unwind_buf_t = __pthread_unwind_buf_t {
        __cancel_jmp_buf: [__cancel_jmp_buf_tag {
            __cancel_jmp_buf: [0; 8],
            __mask_was_saved: 0,
        }; 1],
        __pad: [0 as *mut libc::c_void; 4],
    };
    let mut __cancel_routine: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()> =
        Some(OS_Posix_CondVarReleaseMutex as unsafe extern "C" fn(*mut libc::c_void) -> ());
    let mut __cancel_arg: *mut libc::c_void =
        &mut (*impl_0).mut_0 as *mut pthread_mutex_t as *mut libc::c_void;
    let mut __not_first_call: libc::c_int = __sigsetjmp(
        (__cancel_buf.__cancel_jmp_buf).as_mut_ptr() as *mut libc::c_void as *mut __jmp_buf_tag,
        0 as libc::c_int,
    );
    if __not_first_call as libc::c_long != 0 {
        __cancel_routine.expect("non-null function pointer")(__cancel_arg);
        __pthread_unwind_next(&mut __cancel_buf);
    }
    __pthread_register_cancel(&mut __cancel_buf);
    status = pthread_cond_wait(&mut (*impl_0).cv, &mut (*impl_0).mut_0);
    __pthread_unregister_cancel(&mut __cancel_buf);
    if status != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarTimedWait_Impl(
    mut token: *const OS_object_token_t,
    mut abs_wakeup_time: *const OS_time_t,
) -> int32 {
    let mut limit: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_condvar_internal_record_t =
        0 as *mut OS_impl_condvar_internal_record_t;
    impl_0 = &mut *OS_impl_condvar_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_condvar_internal_record_t;
    limit.tv_sec = OS_TimeGetTotalSeconds(*abs_wakeup_time);
    limit.tv_nsec = OS_TimeGetNanosecondsPart(*abs_wakeup_time) as __syscall_slong_t;
    let mut __cancel_buf: __pthread_unwind_buf_t = __pthread_unwind_buf_t {
        __cancel_jmp_buf: [__cancel_jmp_buf_tag {
            __cancel_jmp_buf: [0; 8],
            __mask_was_saved: 0,
        }; 1],
        __pad: [0 as *mut libc::c_void; 4],
    };
    let mut __cancel_routine: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()> =
        Some(OS_Posix_CondVarReleaseMutex as unsafe extern "C" fn(*mut libc::c_void) -> ());
    let mut __cancel_arg: *mut libc::c_void =
        &mut (*impl_0).mut_0 as *mut pthread_mutex_t as *mut libc::c_void;
    let mut __not_first_call: libc::c_int = __sigsetjmp(
        (__cancel_buf.__cancel_jmp_buf).as_mut_ptr() as *mut libc::c_void as *mut __jmp_buf_tag,
        0 as libc::c_int,
    );
    if __not_first_call as libc::c_long != 0 {
        __cancel_routine.expect("non-null function pointer")(__cancel_arg);
        __pthread_unwind_next(&mut __cancel_buf);
    }
    __pthread_register_cancel(&mut __cancel_buf);
    status = pthread_cond_timedwait(&mut (*impl_0).cv, &mut (*impl_0).mut_0, &mut limit);
    __pthread_unregister_cancel(&mut __cancel_buf);
    if status == 110 as libc::c_int {
        return -(4 as libc::c_int);
    }
    if status != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CondVarGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut condvar_prop: *mut OS_condvar_prop_t,
) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut OS_impl_count_sem_table: [OS_impl_countsem_internal_record_t; 20] =
    [OS_impl_countsem_internal_record_t {
        id: sem_t { __size: [0; 32] },
    }; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_CountSemAPI_Impl_Init() -> int32 {
    memset(
        OS_impl_count_sem_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_countsem_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemCreate_Impl(
    mut token: *const OS_object_token_t,
    mut sem_initial_value: uint32,
    mut options: uint32,
) -> int32 {
    let mut impl_0: *mut OS_impl_countsem_internal_record_t =
        0 as *mut OS_impl_countsem_internal_record_t;
    impl_0 = &mut *OS_impl_count_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_countsem_internal_record_t;
    if sem_initial_value > 2147483647 as libc::c_int as libc::c_uint {
        return -(20 as libc::c_int);
    }
    if sem_init(&mut (*impl_0).id, 0 as libc::c_int, sem_initial_value) < 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemDelete_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_countsem_internal_record_t =
        0 as *mut OS_impl_countsem_internal_record_t;
    impl_0 = &mut *OS_impl_count_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_countsem_internal_record_t;
    if sem_destroy(&mut (*impl_0).id) < 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemGive_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_countsem_internal_record_t =
        0 as *mut OS_impl_countsem_internal_record_t;
    impl_0 = &mut *OS_impl_count_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_countsem_internal_record_t;
    if sem_post(&mut (*impl_0).id) < 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemTake_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_countsem_internal_record_t =
        0 as *mut OS_impl_countsem_internal_record_t;
    impl_0 = &mut *OS_impl_count_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_countsem_internal_record_t;
    if sem_wait(&mut (*impl_0).id) < 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemTimedWait_Impl(
    mut token: *const OS_object_token_t,
    mut msecs: uint32,
) -> int32 {
    let mut ts: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut result: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_countsem_internal_record_t =
        0 as *mut OS_impl_countsem_internal_record_t;
    impl_0 = &mut *OS_impl_count_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_countsem_internal_record_t;
    OS_Posix_CompAbsDelayTime(msecs, &mut ts);
    if sem_timedwait(&mut (*impl_0).id, &mut ts) == 0 as libc::c_int {
        result = 0 as libc::c_int;
    } else if *__errno_location() == 110 as libc::c_int {
        result = -(7 as libc::c_int);
    } else {
        result = -(6 as libc::c_int);
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn OS_CountSemGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut count_prop: *mut OS_count_sem_prop_t,
) -> int32 {
    let mut sval: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_countsem_internal_record_t =
        0 as *mut OS_impl_countsem_internal_record_t;
    impl_0 = &mut *OS_impl_count_sem_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_countsem_internal_record_t;
    if sem_getvalue(&mut (*impl_0).id, &mut sval) < 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    (*count_prop).value = sval;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_DirAPI_Impl_Init() -> int32 {
    memset(
        OS_impl_dir_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_dir_internal_record_t; 4]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut OS_impl_dir_table: [OS_impl_dir_internal_record_t; 4] =
    [OS_impl_dir_internal_record_t {
        dp: 0 as *const DIR as *mut DIR,
    }; 4];
#[no_mangle]
pub static mut OS_IMPL_ERROR_NAME_TABLE: [OS_ErrorTable_Entry_t; 1] = [{
    let mut init = OS_ErrorTable_Entry_t {
        Number: 0 as libc::c_int,
        Name: 0 as *const libc::c_char,
    };
    init
}];
#[no_mangle]
pub static mut OS_impl_filehandle_table: [OS_impl_file_internal_record_t; 50] =
    [OS_impl_file_internal_record_t {
        fd: 0,
        selectable: false,
    }; 50];
#[no_mangle]
pub static mut OS_IMPL_SELF_EUID: uid_t = 0 as libc::c_int as uid_t;
#[no_mangle]
pub static mut OS_IMPL_SELF_EGID: gid_t = 0 as libc::c_int as gid_t;
#[no_mangle]
pub static mut OS_IMPL_REGULAR_FILE_FLAGS: libc::c_int = 0o4000 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_StreamAPI_Impl_Init() -> int32 {
    let mut local_id: osal_index_t = 0;
    local_id = 0 as libc::c_int as osal_index_t;
    while local_id < 50 as libc::c_int as libc::c_uint {
        OS_impl_filehandle_table[local_id as usize].fd = -(1 as libc::c_int);
        local_id = local_id.wrapping_add(1);
        local_id;
    }
    OS_IMPL_SELF_EUID = geteuid();
    OS_IMPL_SELF_EGID = getegid();
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut OS_POSIX_DEVICEFILE_PREFIX: [libc::c_char; 6] =
    unsafe { *::core::mem::transmute::<&[u8; 6], &[libc::c_char; 6]>(b"/dev/\0") };
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_FileSysAPI_Impl_Init() -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysStartVolume_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut local: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    let mut stat_buf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    let mut tmpdir: *const libc::c_char = 0 as *const libc::c_char;
    let mut mplen: size_t = 0;
    let mut vollen: size_t = 0;
    let mut i: uint32 = 0;
    local = &mut *OS_filesys_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_filesys_internal_record_t;
    if (*local).fstype as libc::c_int == OS_FILESYS_TYPE_UNKNOWN as libc::c_int
        && strncmp(
            ((*local).device_name).as_mut_ptr(),
            OS_POSIX_DEVICEFILE_PREFIX.as_ptr(),
            (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        ) == 0 as libc::c_int
    {
        (*local).fstype = OS_FILESYS_TYPE_NORMAL_DISK as libc::c_int as uint8;
    }
    tmpdir = 0 as *const libc::c_char;
    if (*local).fstype as libc::c_int == OS_FILESYS_TYPE_VOLATILE_DISK as libc::c_int {
        i = 0 as libc::c_int as uint32;
        while i <= VOLATILE_DISK_LOC_MAX as libc::c_int as libc::c_uint {
            match i {
                0 => {
                    tmpdir = b"/dev/shm\0" as *const u8 as *const libc::c_char;
                }
                1 => {
                    tmpdir = getenv(b"TMPDIR\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    tmpdir = b"/var/tmp\0" as *const u8 as *const libc::c_char;
                }
                3 => {
                    tmpdir = b"/tmp\0" as *const u8 as *const libc::c_char;
                }
                _ => {
                    tmpdir = 0 as *const libc::c_char;
                }
            }
            if !tmpdir.is_null() && stat(tmpdir, &mut stat_buf) == 0 as libc::c_int {
                if stat_buf.st_mode
                    & (0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int) as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                    || stat_buf.st_mode & (0o200 as libc::c_int >> 3 as libc::c_int) as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                        && stat_buf.st_gid == getegid()
                    || stat_buf.st_mode & 0o200 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                        && stat_buf.st_uid == geteuid()
                {
                    break;
                }
            }
            i = i.wrapping_add(1);
            i;
        }
        if tmpdir.is_null() {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                    b"OS_FileSysStartVolume_Impl\0",
                ))
                .as_ptr(),
                170 as libc::c_int as uint32,
                b"No storage location for volatile volumes\0" as *const u8 as *const libc::c_char,
            );
            return -(106 as libc::c_int);
        }
        mplen = snprintf(
            ((*local).system_mountpt).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
            b"%s/osal:\0" as *const u8 as *const libc::c_char,
            tmpdir,
        ) as size_t;
        if mplen < ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong {
            vollen = OS_strnlen(
                ((*local).volume_name).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            );
            if vollen.wrapping_add(mplen)
                >= ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong
            {
                vollen = (::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong)
                    .wrapping_sub(mplen)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong);
            }
            memcpy(
                &mut *((*local).system_mountpt)
                    .as_mut_ptr()
                    .offset(mplen as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                ((*local).volume_name).as_mut_ptr() as *const libc::c_void,
                vollen,
            );
            (*local).system_mountpt[mplen.wrapping_add(vollen) as usize] =
                0 as libc::c_int as libc::c_char;
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysStopVolume_Impl(mut token: *const OS_object_token_t) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysFormatVolume_Impl(mut token: *const OS_object_token_t) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysMountVolume_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut local: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    let mut stat_buf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    local = &mut *OS_filesys_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_filesys_internal_record_t;
    if stat(((*local).system_mountpt).as_mut_ptr(), &mut stat_buf) != 0 as libc::c_int {
        if mkdir(
            ((*local).system_mountpt).as_mut_ptr(),
            0o700 as libc::c_int as __mode_t,
        ) < 0 as libc::c_int
        {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                    b"OS_FileSysMountVolume_Impl\0",
                ))
                .as_ptr(),
                258 as libc::c_int as uint32,
                b"ERROR: Cannot create mount point %s: %s\0" as *const u8 as *const libc::c_char,
                ((*local).system_mountpt).as_mut_ptr(),
                strerror(*__errno_location()),
            );
            return -(106 as libc::c_int);
        }
    } else if !(stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint)
    {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                b"OS_FileSysMountVolume_Impl\0",
            ))
            .as_ptr(),
            264 as libc::c_int as uint32,
            b"ERROR: Volume %s exists and is not a directory\0" as *const u8 as *const libc::c_char,
            ((*local).system_mountpt).as_mut_ptr(),
        );
        return -(106 as libc::c_int);
    }
    if (*local).fstype as libc::c_int != OS_FILESYS_TYPE_VOLATILE_DISK as libc::c_int
        && (*local).fstype as libc::c_int != OS_FILESYS_TYPE_FS_BASED as libc::c_int
    {
        return -(28 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysUnmountVolume_Impl(
    mut token: *const OS_object_token_t,
) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysStatVolume_Impl(
    mut token: *const OS_object_token_t,
    mut result: *mut OS_statvfs_t,
) -> int32 {
    let mut local: *mut OS_filesys_internal_record_t = 0 as *mut OS_filesys_internal_record_t;
    let mut stat_buf: statvfs = statvfs {
        f_bsize: 0,
        f_frsize: 0,
        f_blocks: 0,
        f_bfree: 0,
        f_bavail: 0,
        f_files: 0,
        f_ffree: 0,
        f_favail: 0,
        f_fsid: 0,
        f_flag: 0,
        f_namemax: 0,
        __f_spare: [0; 6],
    };
    local = &mut *OS_filesys_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_filesys_internal_record_t;
    if statvfs(((*local).system_mountpt).as_mut_ptr(), &mut stat_buf) != 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    (*result).block_size = stat_buf.f_bsize;
    (*result).blocks_free = stat_buf.f_bfree;
    (*result).total_blocks = stat_buf.f_blocks;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileSysCheckVolume_Impl(
    mut token: *const OS_object_token_t,
    mut repair: bool,
) -> int32 {
    return -(28 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn OS_HeapGetInfo_Impl(mut heap_prop: *mut OS_heap_prop_t) -> int32 {
    return -(28 as libc::c_int);
}
static mut OS_global_task_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_queue_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_bin_sem_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_mutex_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_count_sem_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_stream_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_dir_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_timebase_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_timecb_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_module_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_filesys_table_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_console_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
static mut OS_condvar_lock: OS_impl_objtype_lock_t = OS_impl_objtype_lock_t {
    mutex: pthread_mutex_t {
        __data: __pthread_mutex_s {
            __lock: 0,
            __count: 0,
            __owner: 0,
            __nusers: 0,
            __kind: 0,
            __spins: 0,
            __elision: 0,
            __list: __pthread_list_t {
                __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
            },
        },
    },
    cond: pthread_cond_t {
        __data: __pthread_cond_s {
            __wseq: __atomic_wide_counter { __value64: 0 },
            __g1_start: __atomic_wide_counter { __value64: 0 },
            __g_refs: [0; 2],
            __g_size: [0; 2],
            __g1_orig_size: 0,
            __wrefs: 0,
            __g_signals: [0; 2],
        },
    },
};
#[no_mangle]
pub static mut OS_impl_objtype_lock_table: [*mut OS_impl_objtype_lock_t; 16] = unsafe {
    [
        0 as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_global_task_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_queue_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_count_sem_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_bin_sem_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_mutex_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_stream_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_dir_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_timebase_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_timecb_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_module_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_filesys_table_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_console_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        &OS_condvar_lock as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        0 as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
        0 as *const OS_impl_objtype_lock_t as *mut OS_impl_objtype_lock_t,
    ]
};
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_ReleaseTableMutex(mut mut_0: *mut libc::c_void) {
    pthread_mutex_unlock(mut_0 as *mut pthread_mutex_t);
}
#[no_mangle]
pub unsafe extern "C" fn OS_Lock_Global_Impl(mut idtype: osal_objtype_t) {
    let mut impl_0: *mut OS_impl_objtype_lock_t = 0 as *mut OS_impl_objtype_lock_t;
    let mut ret: libc::c_int = 0;
    impl_0 = OS_impl_objtype_lock_table[idtype as usize];
    if !impl_0.is_null() {
        ret = pthread_mutex_lock(&mut (*impl_0).mutex);
        if ret != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_Lock_Global_Impl\0",
                ))
                .as_ptr(),
                95 as libc::c_int as uint32,
                b"pthread_mutex_lock(&impl->mutex): %s\0" as *const u8 as *const libc::c_char,
                strerror(ret),
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_Unlock_Global_Impl(mut idtype: osal_objtype_t) {
    let mut impl_0: *mut OS_impl_objtype_lock_t = 0 as *mut OS_impl_objtype_lock_t;
    let mut ret: libc::c_int = 0;
    impl_0 = OS_impl_objtype_lock_table[idtype as usize];
    if !impl_0.is_null() {
        ret = pthread_cond_broadcast(&mut (*impl_0).cond);
        if ret != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(
                    b"OS_Unlock_Global_Impl\0",
                ))
                .as_ptr(),
                119 as libc::c_int as uint32,
                b"pthread_cond_broadcast(&impl->cond): %s\0" as *const u8 as *const libc::c_char,
                strerror(ret),
            );
        }
        ret = pthread_mutex_unlock(&mut (*impl_0).mutex);
        if ret != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(
                    b"OS_Unlock_Global_Impl\0",
                ))
                .as_ptr(),
                126 as libc::c_int as uint32,
                b"pthread_mutex_unlock(&impl->mutex): %s\0" as *const u8 as *const libc::c_char,
                strerror(ret),
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_WaitForStateChange_Impl(
    mut objtype: osal_objtype_t,
    mut attempts: uint32,
) {
    let mut impl_0: *mut OS_impl_objtype_lock_t = 0 as *mut OS_impl_objtype_lock_t;
    let mut ts: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    impl_0 = OS_impl_objtype_lock_table[objtype as usize];
    let mut __cancel_buf: __pthread_unwind_buf_t = __pthread_unwind_buf_t {
        __cancel_jmp_buf: [__cancel_jmp_buf_tag {
            __cancel_jmp_buf: [0; 8],
            __mask_was_saved: 0,
        }; 1],
        __pad: [0 as *mut libc::c_void; 4],
    };
    let mut __cancel_routine: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()> =
        Some(OS_Posix_ReleaseTableMutex as unsafe extern "C" fn(*mut libc::c_void) -> ());
    let mut __cancel_arg: *mut libc::c_void =
        &mut (*impl_0).mutex as *mut pthread_mutex_t as *mut libc::c_void;
    let mut __not_first_call: libc::c_int = __sigsetjmp(
        (__cancel_buf.__cancel_jmp_buf).as_mut_ptr() as *mut libc::c_void as *mut __jmp_buf_tag,
        0 as libc::c_int,
    );
    if __not_first_call as libc::c_long != 0 {
        __cancel_routine.expect("non-null function pointer")(__cancel_arg);
        __pthread_unwind_next(&mut __cancel_buf);
    }
    __pthread_register_cancel(&mut __cancel_buf);
    clock_gettime(0 as libc::c_int, &mut ts);
    if attempts <= 10 as libc::c_int as libc::c_uint {
        ts.tv_nsec += attempts
            .wrapping_mul(attempts)
            .wrapping_mul(10000000 as libc::c_int as libc::c_uint)
            as libc::c_long;
        if ts.tv_nsec >= 1000000000 as libc::c_int as libc::c_long {
            ts.tv_nsec -= 1000000000 as libc::c_int as libc::c_long;
            ts.tv_sec += 1;
            ts.tv_sec;
        }
    } else {
        ts.tv_sec += 1;
        ts.tv_sec;
    }
    pthread_cond_timedwait(&mut (*impl_0).cond, &mut (*impl_0).mutex, &mut ts);
    __pthread_unregister_cancel(&mut __cancel_buf);
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_TableMutex_Init(mut idtype: osal_objtype_t) -> int32 {
    let mut ret: libc::c_int = 0;
    let mut return_code: int32 = 0 as libc::c_int;
    let mut mutex_attr: pthread_mutexattr_t = pthread_mutexattr_t { __size: [0; 4] };
    let mut impl_0: *mut OS_impl_objtype_lock_t = 0 as *mut OS_impl_objtype_lock_t;
    impl_0 = OS_impl_objtype_lock_table[idtype as usize];
    if impl_0.is_null() {
        return 0 as libc::c_int;
    }
    ret = pthread_mutexattr_init(&mut mutex_attr);
    if ret != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"OS_Posix_TableMutex_Init\0",
            ))
            .as_ptr(),
            202 as libc::c_int as uint32,
            b"Error: pthread_mutexattr_init failed: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(ret),
        );
        return_code = -(1 as libc::c_int);
    } else {
        ret = pthread_mutexattr_setprotocol(&mut mutex_attr, PTHREAD_PRIO_INHERIT as libc::c_int);
        if ret != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                    b"OS_Posix_TableMutex_Init\0",
                ))
                .as_ptr(),
                213 as libc::c_int as uint32,
                b"Error: pthread_mutexattr_setprotocol failed: %s\n\0" as *const u8
                    as *const libc::c_char,
                strerror(ret),
            );
            return_code = -(1 as libc::c_int);
        } else {
            ret = pthread_mutexattr_settype(&mut mutex_attr, PTHREAD_MUTEX_NORMAL as libc::c_int);
            if ret != 0 as libc::c_int {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                        b"OS_Posix_TableMutex_Init\0",
                    ))
                    .as_ptr(),
                    225 as libc::c_int as uint32,
                    b"Error: pthread_mutexattr_settype failed: %s\n\0" as *const u8
                        as *const libc::c_char,
                    strerror(ret),
                );
                return_code = -(1 as libc::c_int);
            } else {
                ret = pthread_mutex_init(&mut (*impl_0).mutex, &mut mutex_attr);
                if ret != 0 as libc::c_int {
                    OS_DebugPrintf(
                        1 as libc::c_int as uint32,
                        (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                            b"OS_Posix_TableMutex_Init\0",
                        ))
                        .as_ptr(),
                        233 as libc::c_int as uint32,
                        b"Error: pthread_mutex_init failed: %s\n\0" as *const u8
                            as *const libc::c_char,
                        strerror(ret),
                    );
                    return_code = -(1 as libc::c_int);
                } else {
                    ret = pthread_cond_init(&mut (*impl_0).cond, 0 as *const pthread_condattr_t);
                    if ret != 0 as libc::c_int {
                        OS_DebugPrintf(
                            1 as libc::c_int as uint32,
                            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                                b"OS_Posix_TableMutex_Init\0",
                            ))
                            .as_ptr(),
                            243 as libc::c_int as uint32,
                            b"Error: pthread_cond_init failed: %s\n\0" as *const u8
                                as *const libc::c_char,
                            strerror(ret),
                        );
                        return_code = -(1 as libc::c_int);
                    }
                }
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_impl_mutex_table: [OS_impl_mutex_internal_record_t; 20] =
    [OS_impl_mutex_internal_record_t {
        id: pthread_mutex_t {
            __data: __pthread_mutex_s {
                __lock: 0,
                __count: 0,
                __owner: 0,
                __nusers: 0,
                __kind: 0,
                __spins: 0,
                __elision: 0,
                __list: __pthread_list_t {
                    __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                },
            },
        },
    }; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_MutexAPI_Impl_Init() -> int32 {
    memset(
        OS_impl_mutex_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_mutex_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemCreate_Impl(
    mut token: *const OS_object_token_t,
    mut options: uint32,
) -> int32 {
    let mut return_code: libc::c_int = 0;
    let mut mutex_attr: pthread_mutexattr_t = pthread_mutexattr_t { __size: [0; 4] };
    let mut impl_0: *mut OS_impl_mutex_internal_record_t =
        0 as *mut OS_impl_mutex_internal_record_t;
    impl_0 = &mut *OS_impl_mutex_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_mutex_internal_record_t;
    return_code = pthread_mutexattr_init(&mut mutex_attr);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_MutSemCreate_Impl\0"))
                .as_ptr(),
            74 as libc::c_int as uint32,
            b"Error: Mutex could not be created. pthread_mutexattr_init failed ID = %lu: %s\n\0"
                as *const u8 as *const libc::c_char,
            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
            strerror(return_code),
        );
        return -(6 as libc::c_int);
    }
    return_code =
        pthread_mutexattr_setprotocol(&mut mutex_attr, PTHREAD_PRIO_INHERIT as libc::c_int);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"OS_MutSemCreate_Impl\0"))
                .as_ptr(),
            85 as libc::c_int as uint32,
            b"Error: Mutex could not be created. pthread_mutexattr_setprotocol failed ID = %lu: %s\n\0"
                as *const u8 as *const libc::c_char,
            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
            strerror(return_code),
        );
        return -(6 as libc::c_int);
    }
    return_code =
        pthread_mutexattr_settype(&mut mutex_attr, PTHREAD_MUTEX_RECURSIVE as libc::c_int);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_MutSemCreate_Impl\0"))
                .as_ptr(),
            96 as libc::c_int as uint32,
            b"Error: Mutex could not be created. pthread_mutexattr_settype failed ID = %lu: %s\n\0"
                as *const u8 as *const libc::c_char,
            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
            strerror(return_code),
        );
        return -(6 as libc::c_int);
    }
    return_code = pthread_mutex_init(&mut (*impl_0).id, &mut mutex_attr);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_MutSemCreate_Impl\0"))
                .as_ptr(),
            108 as libc::c_int as uint32,
            b"Error: Mutex could not be created. ID = %lu: %s\n\0" as *const u8
                as *const libc::c_char,
            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
            strerror(return_code),
        );
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemDelete_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_mutex_internal_record_t =
        0 as *mut OS_impl_mutex_internal_record_t;
    impl_0 = &mut *OS_impl_mutex_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_mutex_internal_record_t;
    status = pthread_mutex_destroy(&mut (*impl_0).id);
    if status != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemGive_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_mutex_internal_record_t =
        0 as *mut OS_impl_mutex_internal_record_t;
    impl_0 = &mut *OS_impl_mutex_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_mutex_internal_record_t;
    status = pthread_mutex_unlock(&mut (*impl_0).id);
    if status != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemTake_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_mutex_internal_record_t =
        0 as *mut OS_impl_mutex_internal_record_t;
    impl_0 = &mut *OS_impl_mutex_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_mutex_internal_record_t;
    status = pthread_mutex_lock(&mut (*impl_0).id);
    if status != 0 as libc::c_int {
        return -(6 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_MutSemGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut mut_prop: *mut OS_mut_sem_prop_t,
) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut OS_impl_queue_table: [OS_impl_queue_internal_record_t; 64] =
    [OS_impl_queue_internal_record_t { id: 0 }; 64];
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_QueueAPI_Impl_Init() -> int32 {
    memset(
        OS_impl_queue_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_queue_internal_record_t; 64]>() as libc::c_ulong,
    );
    POSIX_GlobalVars.TruncateQueueDepth = OS_BSP_Global.MaxQueueDepth;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueCreate_Impl(
    mut token: *const OS_object_token_t,
    mut flags: uint32,
) -> int32 {
    let mut return_code: libc::c_int = 0;
    let mut queueDesc: mqd_t = 0;
    let mut queueAttr: mq_attr = mq_attr {
        mq_flags: 0,
        mq_maxmsg: 0,
        mq_msgsize: 0,
        mq_curmsgs: 0,
        __pad: [0; 4],
    };
    let mut name: [libc::c_char; 40] = [0; 40];
    let mut impl_0: *mut OS_impl_queue_internal_record_t =
        0 as *mut OS_impl_queue_internal_record_t;
    let mut queue: *mut OS_queue_internal_record_t = 0 as *mut OS_queue_internal_record_t;
    impl_0 = &mut *OS_impl_queue_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_queue_internal_record_t;
    queue = &mut *OS_queue_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_queue_internal_record_t;
    memset(
        &mut queueAttr as *mut mq_attr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mq_attr>() as libc::c_ulong,
    );
    queueAttr.mq_maxmsg = (*queue).max_depth as __syscall_slong_t;
    queueAttr.mq_msgsize = (*queue).max_size as __syscall_slong_t;
    if POSIX_GlobalVars.TruncateQueueDepth > 0 as libc::c_int as libc::c_ulong
        && POSIX_GlobalVars.TruncateQueueDepth < queueAttr.mq_maxmsg as libc::c_ulong
    {
        queueAttr.mq_maxmsg = POSIX_GlobalVars.TruncateQueueDepth as __syscall_slong_t;
    }
    snprintf(
        name.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        b"/%d.%s\0" as *const u8 as *const libc::c_char,
        getpid(),
        ((*queue).queue_name).as_mut_ptr(),
    );
    queueDesc = mq_open(
        name.as_mut_ptr(),
        0o100 as libc::c_int | 0o2 as libc::c_int,
        0o666 as libc::c_int,
        &mut queueAttr as *mut mq_attr,
    );
    if queueDesc == -(1 as libc::c_int) {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"OS_QueueCreate_Impl\0"))
                .as_ptr(),
            119 as libc::c_int as uint32,
            b"OS_QueueCreate Error. errno = %d (%s)\n\0" as *const u8 as *const libc::c_char,
            *__errno_location(),
            strerror(*__errno_location()),
        );
        if *__errno_location() == 22 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_QueueCreate_Impl\0",
                ))
                .as_ptr(),
                122 as libc::c_int as uint32,
                b"Your queue depth may be too large for the\n\0" as *const u8
                    as *const libc::c_char,
            );
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_QueueCreate_Impl\0",
                ))
                .as_ptr(),
                123 as libc::c_int as uint32,
                b"OS to handle. Please check the msg_max\n\0" as *const u8 as *const libc::c_char,
            );
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_QueueCreate_Impl\0",
                ))
                .as_ptr(),
                124 as libc::c_int as uint32,
                b"parameter located in /proc/sys/fs/mqueue/msg_max\n\0" as *const u8
                    as *const libc::c_char,
            );
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_QueueCreate_Impl\0",
                ))
                .as_ptr(),
                125 as libc::c_int as uint32,
                b"on your Linux file system and raise it if you\n\0" as *const u8
                    as *const libc::c_char,
            );
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_QueueCreate_Impl\0",
                ))
                .as_ptr(),
                126 as libc::c_int as uint32,
                b" need to or run as root\n\0" as *const u8 as *const libc::c_char,
            );
        }
        return_code = -(1 as libc::c_int);
    } else {
        (*impl_0).id = queueDesc;
        return_code = 0 as libc::c_int;
        if mq_unlink(name.as_mut_ptr()) != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_QueueCreate_Impl\0",
                ))
                .as_ptr(),
                144 as libc::c_int as uint32,
                b"OS_QueueDelete Error during mq_unlink(). errno = %d (%s)\n\0" as *const u8
                    as *const libc::c_char,
                *__errno_location(),
                strerror(*__errno_location()),
            );
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueDelete_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut impl_0: *mut OS_impl_queue_internal_record_t =
        0 as *mut OS_impl_queue_internal_record_t;
    impl_0 = &mut *OS_impl_queue_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_queue_internal_record_t;
    if mq_close((*impl_0).id) != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"OS_QueueDelete_Impl\0"))
                .as_ptr(),
            171 as libc::c_int as uint32,
            b"OS_QueueDelete Error during mq_close(). errno = %d (%s)\n\0" as *const u8
                as *const libc::c_char,
            *__errno_location(),
            strerror(*__errno_location()),
        );
        return_code = -(1 as libc::c_int);
    } else {
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueueGet_Impl(
    mut token: *const OS_object_token_t,
    mut data: *mut libc::c_void,
    mut size: size_t,
    mut size_copied: *mut size_t,
    mut timeout: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut sizeCopied: ssize_t = 0;
    let mut ts: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut impl_0: *mut OS_impl_queue_internal_record_t =
        0 as *mut OS_impl_queue_internal_record_t;
    impl_0 = &mut *OS_impl_queue_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_queue_internal_record_t;
    sizeCopied = -(1 as libc::c_int) as ssize_t;
    if timeout == -(1 as libc::c_int) {
        loop {
            sizeCopied = mq_receive(
                (*impl_0).id,
                data as *mut libc::c_char,
                size,
                0 as *mut libc::c_uint,
            );
            if !(sizeCopied < 0 as libc::c_int as libc::c_long
                && *__errno_location() == 4 as libc::c_int)
            {
                break;
            }
        }
    } else {
        if timeout == 0 as libc::c_int {
            memset(
                &mut ts as *mut timespec as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<timespec>() as libc::c_ulong,
            );
        } else {
            OS_Posix_CompAbsDelayTime(timeout as uint32, &mut ts);
        }
        loop {
            sizeCopied = mq_timedreceive(
                (*impl_0).id,
                data as *mut libc::c_char,
                size,
                0 as *mut libc::c_uint,
                &mut ts,
            );
            if !(timeout != 0 as libc::c_int
                && sizeCopied < 0 as libc::c_int as libc::c_long
                && *__errno_location() == 4 as libc::c_int)
            {
                break;
            }
        }
    }
    if sizeCopied == -(1 as libc::c_int) as libc::c_long {
        *size_copied = 0 as libc::c_int as size_t;
        if *__errno_location() == 90 as libc::c_int {
            return_code = -(11 as libc::c_int);
        } else if timeout == -(1 as libc::c_int) || *__errno_location() != 110 as libc::c_int {
            return_code = -(1 as libc::c_int);
        } else if timeout == 0 as libc::c_int {
            return_code = -(8 as libc::c_int);
        } else {
            return_code = -(10 as libc::c_int);
        }
    } else {
        *size_copied = sizeCopied as size_t;
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_QueuePut_Impl(
    mut token: *const OS_object_token_t,
    mut data: *const libc::c_void,
    mut size: size_t,
    mut flags: uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut result: libc::c_int = 0;
    let mut ts: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut impl_0: *mut OS_impl_queue_internal_record_t =
        0 as *mut OS_impl_queue_internal_record_t;
    impl_0 = &mut *OS_impl_queue_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_queue_internal_record_t;
    memset(
        &mut ts as *mut timespec as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<timespec>() as libc::c_ulong,
    );
    loop {
        result = mq_timedsend(
            (*impl_0).id,
            data as *const libc::c_char,
            size,
            1 as libc::c_int as libc::c_uint,
            &mut ts,
        );
        if !(result == -(1 as libc::c_int) && *__errno_location() == 4 as libc::c_int) {
            break;
        }
    }
    if result == 0 as libc::c_int {
        return_code = 0 as libc::c_int;
    } else if *__errno_location() == 110 as libc::c_int {
        return_code = -(9 as libc::c_int);
    } else {
        return_code = -(1 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub static mut OS_impl_task_table: [OS_impl_task_internal_record_t; 64] =
    [OS_impl_task_internal_record_t { id: 0 }; 64];
unsafe extern "C" fn OS_PriorityRemap(mut InputPri: osal_priority_t) -> libc::c_int {
    let mut OutputPri: libc::c_int = 0;
    if InputPri as libc::c_int == 0 as libc::c_int {
        OutputPri = POSIX_GlobalVars.PriLimits.PriorityMax;
    } else if InputPri as libc::c_int >= 255 as libc::c_int {
        OutputPri = POSIX_GlobalVars.PriLimits.PriorityMin;
    } else {
        OutputPri = 255 as libc::c_int - 1 as libc::c_int - InputPri as libc::c_int;
        OutputPri *= POSIX_GlobalVars.PriLimits.PriorityMax
            - POSIX_GlobalVars.PriLimits.PriorityMin
            - 2 as libc::c_int;
        OutputPri += 255 as libc::c_int / 2 as libc::c_int;
        OutputPri /= 255 as libc::c_int - 2 as libc::c_int;
        OutputPri += POSIX_GlobalVars.PriLimits.PriorityMin + 1 as libc::c_int;
    }
    return OutputPri;
}
unsafe extern "C" fn OS_NoopSigHandler(mut signal_0: libc::c_int) {}
unsafe extern "C" fn OS_PthreadTaskEntry(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut local_arg: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    local_arg.opaque_arg = arg;
    OS_TaskEntryPoint(local_arg.id);
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn OS_Posix_GetSchedulerParams(
    mut sched_policy: libc::c_int,
    mut PriLim: *mut POSIX_PriorityLimits_t,
) -> bool {
    let mut ret: libc::c_int = 0;
    ret = sched_get_priority_max(sched_policy);
    if ret < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                b"OS_Posix_GetSchedulerParams\0",
            ))
            .as_ptr(),
            168 as libc::c_int as uint32,
            b"Policy %d: Unable to obtain maximum scheduling priority: %s\n\0" as *const u8
                as *const libc::c_char,
            sched_policy,
            strerror(*__errno_location()),
        );
        return 0 as libc::c_int != 0;
    }
    (*PriLim).PriorityMax = ret;
    ret = sched_get_priority_min(sched_policy);
    if ret < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                b"OS_Posix_GetSchedulerParams\0",
            ))
            .as_ptr(),
            177 as libc::c_int as uint32,
            b"Policy %d: Unable to obtain minimum scheduling priority: %s\n\0" as *const u8
                as *const libc::c_char,
            sched_policy,
            strerror(*__errno_location()),
        );
        return 0 as libc::c_int != 0;
    }
    (*PriLim).PriorityMin = ret;
    if (*PriLim).PriorityMax - (*PriLim).PriorityMin < 4 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                b"OS_Posix_GetSchedulerParams\0",
            ))
            .as_ptr(),
            197 as libc::c_int as uint32,
            b"Policy %d: Insufficient spread between priority min-max: %d-%d\n\0" as *const u8
                as *const libc::c_char,
            sched_policy,
            (*PriLim).PriorityMin,
            (*PriLim).PriorityMax,
        );
        return 0 as libc::c_int != 0;
    }
    OS_DebugPrintf(
        1 as libc::c_int as uint32,
        (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"OS_Posix_GetSchedulerParams\0",
        ))
        .as_ptr(),
        203 as libc::c_int as uint32,
        b"Policy %d: available, min-max: %d-%d\n\0" as *const u8 as *const libc::c_char,
        sched_policy,
        (*PriLim).PriorityMin,
        (*PriLim).PriorityMax,
    );
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_TaskAPI_Impl_Init() -> int32 {
    let mut ret: libc::c_int = 0;
    let mut ret_long: libc::c_long = 0;
    let mut sig: libc::c_int = 0;
    let mut sched_param: sched_param = sched_param { sched_priority: 0 };
    let mut sched_policy: libc::c_int = 0;
    let mut sched_fifo_limits: POSIX_PriorityLimits_t = POSIX_PriorityLimits_t {
        PriorityMax: 0,
        PriorityMin: 0,
    };
    let mut sched_fifo_valid: bool = false;
    let mut sched_rr_limits: POSIX_PriorityLimits_t = POSIX_PriorityLimits_t {
        PriorityMax: 0,
        PriorityMin: 0,
    };
    let mut sched_rr_valid: bool = false;
    memset(
        OS_impl_task_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_task_internal_record_t; 64]>() as libc::c_ulong,
    );
    memset(
        &mut sched_fifo_limits as *mut POSIX_PriorityLimits_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<POSIX_PriorityLimits_t>() as libc::c_ulong,
    );
    memset(
        &mut sched_rr_limits as *mut POSIX_PriorityLimits_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<POSIX_PriorityLimits_t>() as libc::c_ulong,
    );
    ret = pthread_key_create(&mut POSIX_GlobalVars.ThreadKey, None);
    if ret != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                b"OS_Posix_TaskAPI_Impl_Init\0",
            ))
            .as_ptr(),
            246 as libc::c_int as uint32,
            b"Error creating thread key: %s (%d)\n\0" as *const u8 as *const libc::c_char,
            strerror(ret),
            ret,
        );
        return -(1 as libc::c_int);
    }
    sigfillset(&mut POSIX_GlobalVars.MaximumSigMask);
    sigdelset(&mut POSIX_GlobalVars.MaximumSigMask, 2 as libc::c_int);
    sigdelset(&mut POSIX_GlobalVars.MaximumSigMask, 6 as libc::c_int);
    sigdelset(&mut POSIX_GlobalVars.MaximumSigMask, 11 as libc::c_int);
    sigdelset(&mut POSIX_GlobalVars.MaximumSigMask, 4 as libc::c_int);
    sigdelset(&mut POSIX_GlobalVars.MaximumSigMask, 7 as libc::c_int);
    sigdelset(&mut POSIX_GlobalVars.MaximumSigMask, 8 as libc::c_int);
    sigprocmask(
        2 as libc::c_int,
        &mut POSIX_GlobalVars.MaximumSigMask,
        &mut POSIX_GlobalVars.NormalSigMask,
    );
    sig = __libc_current_sigrtmin();
    while sig <= __libc_current_sigrtmax() {
        sigaddset(&mut POSIX_GlobalVars.NormalSigMask, sig);
        sig += 1;
        sig;
    }
    sigdelset(&mut POSIX_GlobalVars.NormalSigMask, 1 as libc::c_int);
    signal(
        1 as libc::c_int,
        Some(OS_NoopSigHandler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    ret = pthread_getschedparam(pthread_self(), &mut sched_policy, &mut sched_param);
    if ret == 0 as libc::c_int {
        POSIX_GlobalVars.SelectedRtScheduler = sched_policy;
        let mut current_block_52: u64;
        sched_fifo_valid = OS_Posix_GetSchedulerParams(1 as libc::c_int, &mut sched_fifo_limits);
        sched_rr_valid = OS_Posix_GetSchedulerParams(2 as libc::c_int, &mut sched_rr_limits);
        if sched_fifo_valid as libc::c_int != 0 && sched_rr_valid as libc::c_int != 0 {
            if sched_fifo_limits.PriorityMax - sched_fifo_limits.PriorityMin > 255 as libc::c_int {
                sched_policy = 1 as libc::c_int;
                POSIX_GlobalVars.PriLimits = sched_fifo_limits;
            } else {
                sched_policy = 2 as libc::c_int;
                POSIX_GlobalVars.PriLimits = sched_rr_limits;
            }
            current_block_52 = 10692455896603418738;
        } else if sched_fifo_valid {
            sched_policy = 1 as libc::c_int;
            POSIX_GlobalVars.PriLimits = sched_fifo_limits;
            current_block_52 = 10692455896603418738;
        } else if sched_rr_valid {
            sched_policy = 2 as libc::c_int;
            POSIX_GlobalVars.PriLimits = sched_rr_limits;
            current_block_52 = 10692455896603418738;
        } else {
            current_block_52 = 12381812505308290051;
        }
        match current_block_52 {
            10692455896603418738 => {
                sched_param.sched_priority = POSIX_GlobalVars.PriLimits.PriorityMax;
                POSIX_GlobalVars.PriLimits.PriorityMax -= 1;
                POSIX_GlobalVars.PriLimits.PriorityMax;
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                        b"OS_Posix_TaskAPI_Impl_Init\0",
                    ))
                    .as_ptr(),
                    389 as libc::c_int as uint32,
                    b"Selected policy %d for RT tasks, root task = %d\n\0" as *const u8
                        as *const libc::c_char,
                    sched_policy,
                    sched_param.sched_priority,
                );
                if POSIX_GlobalVars.PriLimits.PriorityMax - POSIX_GlobalVars.PriLimits.PriorityMin
                    > 255 as libc::c_int
                {
                    POSIX_GlobalVars.PriLimits.PriorityMax =
                        POSIX_GlobalVars.PriLimits.PriorityMin + 255 as libc::c_int;
                }
                ret = pthread_setschedparam(pthread_self(), sched_policy, &mut sched_param);
                if ret != 0 as libc::c_int {
                    OS_DebugPrintf(
                        1 as libc::c_int as uint32,
                        (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                            b"OS_Posix_TaskAPI_Impl_Init\0",
                        ))
                        .as_ptr(),
                        405 as libc::c_int as uint32,
                        b"Could not setschedparam in main thread: %s (%d)\n\0" as *const u8
                            as *const libc::c_char,
                        strerror(ret),
                        ret,
                    );
                } else {
                    POSIX_GlobalVars.SelectedRtScheduler = sched_policy;
                    POSIX_GlobalVars.EnableTaskPriorities = 1 as libc::c_int != 0;
                }
            }
            _ => {}
        }
    } else {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                b"OS_Posix_TaskAPI_Impl_Init\0",
            ))
            .as_ptr(),
            419 as libc::c_int as uint32,
            b"Could not getschedparam in main thread: %s (%d)\n\0" as *const u8
                as *const libc::c_char,
            strerror(ret),
            ret,
        );
    }
    ret_long = sysconf(_SC_PAGESIZE as libc::c_int);
    if ret_long < 0 as libc::c_int as libc::c_long {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                b"OS_Posix_TaskAPI_Impl_Init\0",
            ))
            .as_ptr(),
            437 as libc::c_int as uint32,
            b"Could not get page size via sysconf: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
        return -(1 as libc::c_int);
    }
    POSIX_GlobalVars.PageSize = ret_long as size_t;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_InternalTaskCreate_Impl(
    mut pthr: *mut pthread_t,
    mut priority: osal_priority_t,
    mut stacksz: size_t,
    mut entry: PthreadFuncPtr_t,
    mut entry_arg: *mut libc::c_void,
) -> int32 {
    let mut return_code: libc::c_int = 0 as libc::c_int;
    let mut custom_attr: pthread_attr_t = pthread_attr_t { __size: [0; 56] };
    let mut priority_holder: sched_param = sched_param { sched_priority: 0 };
    memset(
        &mut custom_attr as *mut pthread_attr_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<pthread_attr_t>() as libc::c_ulong,
    );
    return_code = pthread_attr_init(&mut custom_attr);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                b"OS_Posix_InternalTaskCreate_Impl\0",
            ))
            .as_ptr(),
            465 as libc::c_int as uint32,
            b"pthread_attr_init error in OS_TaskCreate: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(return_code),
        );
        return -(1 as libc::c_int);
    }
    stacksz = (stacksz as libc::c_ulong).wrapping_add(__sysconf(75 as libc::c_int) as libc::c_ulong)
        as size_t as size_t;
    stacksz = (stacksz as libc::c_ulong)
        .wrapping_add((POSIX_GlobalVars.PageSize).wrapping_sub(1 as libc::c_int as libc::c_ulong))
        as size_t as size_t;
    stacksz = (stacksz as libc::c_ulong)
        .wrapping_sub(stacksz.wrapping_rem(POSIX_GlobalVars.PageSize)) as size_t
        as size_t;
    return_code = pthread_attr_setstacksize(&mut custom_attr, stacksz);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                b"OS_Posix_InternalTaskCreate_Impl\0",
            ))
            .as_ptr(),
            483 as libc::c_int as uint32,
            b"pthread_attr_setstacksize error in OS_TaskCreate: %s\n\0" as *const u8
                as *const libc::c_char,
            strerror(return_code),
        );
        return -(1 as libc::c_int);
    }
    return_code =
        pthread_attr_setdetachstate(&mut custom_attr, PTHREAD_CREATE_JOINABLE as libc::c_int);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                b"OS_Posix_InternalTaskCreate_Impl\0",
            ))
            .as_ptr(),
            493 as libc::c_int as uint32,
            b"pthread_attr_setdetachstate error in OS_TaskCreate: %s\n\0" as *const u8
                as *const libc::c_char,
            strerror(return_code),
        );
        return -(1 as libc::c_int);
    }
    if POSIX_GlobalVars.EnableTaskPriorities {
        return_code =
            pthread_attr_setinheritsched(&mut custom_attr, PTHREAD_EXPLICIT_SCHED as libc::c_int);
        if return_code != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                    b"OS_Posix_InternalTaskCreate_Impl\0",
                ))
                .as_ptr(),
                510 as libc::c_int as uint32,
                b"pthread_attr_setinheritsched error in OS_TaskCreate, errno = %s\n\0" as *const u8
                    as *const libc::c_char,
                strerror(return_code),
            );
            return -(1 as libc::c_int);
        }
        return_code =
            pthread_attr_setschedpolicy(&mut custom_attr, POSIX_GlobalVars.SelectedRtScheduler);
        if return_code != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                    b"OS_Posix_InternalTaskCreate_Impl\0",
                ))
                .as_ptr(),
                521 as libc::c_int as uint32,
                b"pthread_attr_setschedpolity error in OS_TaskCreate: %s\n\0" as *const u8
                    as *const libc::c_char,
                strerror(return_code),
            );
            return -(1 as libc::c_int);
        }
        return_code = pthread_attr_getschedparam(&mut custom_attr, &mut priority_holder);
        if return_code != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                    b"OS_Posix_InternalTaskCreate_Impl\0",
                ))
                .as_ptr(),
                531 as libc::c_int as uint32,
                b"pthread_attr_getschedparam error in OS_TaskCreate: %s\n\0" as *const u8
                    as *const libc::c_char,
                strerror(return_code),
            );
            return -(1 as libc::c_int);
        }
        priority_holder.sched_priority = OS_PriorityRemap(priority);
        return_code = pthread_attr_setschedparam(&mut custom_attr, &mut priority_holder);
        if return_code != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                    b"OS_Posix_InternalTaskCreate_Impl\0",
                ))
                .as_ptr(),
                539 as libc::c_int as uint32,
                b"pthread_attr_setschedparam error in OS_TaskCreate: %s\n\0" as *const u8
                    as *const libc::c_char,
                strerror(return_code),
            );
            return -(1 as libc::c_int);
        }
    }
    return_code = pthread_create(pthr, &mut custom_attr, entry, entry_arg);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                b"OS_Posix_InternalTaskCreate_Impl\0",
            ))
            .as_ptr(),
            551 as libc::c_int as uint32,
            b"pthread_create error in OS_TaskCreate: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(return_code),
        );
        return -(1 as libc::c_int);
    }
    return_code = pthread_attr_destroy(&mut custom_attr);
    if return_code != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
                b"OS_Posix_InternalTaskCreate_Impl\0",
            ))
            .as_ptr(),
            564 as libc::c_int as uint32,
            b"pthread_attr_destroy error in OS_TaskCreate: %s\n\0" as *const u8
                as *const libc::c_char,
            strerror(return_code),
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskCreate_Impl(
    mut token: *const OS_object_token_t,
    mut flags: uint32,
) -> int32 {
    let mut arg: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    let mut return_code: int32 = 0;
    let mut impl_0: *mut OS_impl_task_internal_record_t = 0 as *mut OS_impl_task_internal_record_t;
    let mut task: *mut OS_task_internal_record_t = 0 as *mut OS_task_internal_record_t;
    memset(
        &mut arg as *mut OS_VoidPtrValueWrapper_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_VoidPtrValueWrapper_t>() as libc::c_ulong,
    );
    arg.id = OS_ObjectIdFromToken(token);
    task = &mut *OS_task_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_task_internal_record_t;
    impl_0 = &mut *OS_impl_task_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_task_internal_record_t;
    return_code = OS_Posix_InternalTaskCreate_Impl(
        &mut (*impl_0).id,
        (*task).priority,
        (*task).stack_size,
        Some(OS_PthreadTaskEntry as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void),
        arg.opaque_arg,
    );
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskDetach_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_task_internal_record_t = 0 as *mut OS_impl_task_internal_record_t;
    let mut ret: libc::c_int = 0;
    impl_0 = &mut *OS_impl_task_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_task_internal_record_t;
    ret = pthread_detach((*impl_0).id);
    if ret != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_TaskDetach_Impl\0"))
                .as_ptr(),
            615 as libc::c_int as uint32,
            b"pthread_detach: Failed on Task ID = %lu, err = %s\n\0" as *const u8
                as *const libc::c_char,
            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
            strerror(ret),
        );
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskMatch_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_task_internal_record_t = 0 as *mut OS_impl_task_internal_record_t;
    impl_0 = &mut *OS_impl_task_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_task_internal_record_t;
    if pthread_equal(pthread_self(), (*impl_0).id) == 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskDelete_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_task_internal_record_t = 0 as *mut OS_impl_task_internal_record_t;
    let mut retval: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ret: libc::c_int = 0;
    impl_0 = &mut *OS_impl_task_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_task_internal_record_t;
    ret = pthread_cancel((*impl_0).id);
    if ret != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_TaskDelete_Impl\0"))
                .as_ptr(),
            666 as libc::c_int as uint32,
            b"pthread_cancel: Failed on Task ID = %lu, err = %s\n\0" as *const u8
                as *const libc::c_char,
            OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
            strerror(ret),
        );
    } else {
        ret = pthread_join((*impl_0).id, &mut retval);
        if ret != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(
                    b"OS_TaskDelete_Impl\0",
                ))
                .as_ptr(),
                688 as libc::c_int as uint32,
                b"pthread_join: Failed on Task ID = %lu, err = %s\n\0" as *const u8
                    as *const libc::c_char,
                OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
                strerror(ret),
            );
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskExit_Impl() {
    pthread_exit(0 as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskDelay_Impl(mut millisecond: uint32) -> int32 {
    let mut sleep_end: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut status: libc::c_int = 0;
    clock_gettime(1 as libc::c_int, &mut sleep_end);
    sleep_end.tv_sec +=
        millisecond.wrapping_div(1000 as libc::c_int as libc::c_uint) as libc::c_long;
    sleep_end.tv_nsec += (1000000 as libc::c_int as libc::c_uint)
        .wrapping_mul(millisecond.wrapping_rem(1000 as libc::c_int as libc::c_uint))
        as libc::c_long;
    if sleep_end.tv_nsec >= 1000000000 as libc::c_int as libc::c_long {
        sleep_end.tv_nsec -= 1000000000 as libc::c_int as libc::c_long;
        sleep_end.tv_sec += 1;
        sleep_end.tv_sec;
    }
    loop {
        status = clock_nanosleep(
            1 as libc::c_int,
            1 as libc::c_int,
            &mut sleep_end,
            0 as *mut timespec,
        );
        if !(status == 4 as libc::c_int) {
            break;
        }
    }
    if status != 0 as libc::c_int {
        return -(1 as libc::c_int);
    } else {
        return 0 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskSetPriority_Impl(
    mut token: *const OS_object_token_t,
    mut new_priority: osal_priority_t,
) -> int32 {
    let mut os_priority: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_task_internal_record_t = 0 as *mut OS_impl_task_internal_record_t;
    impl_0 = &mut *OS_impl_task_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_task_internal_record_t;
    if POSIX_GlobalVars.EnableTaskPriorities {
        os_priority = OS_PriorityRemap(new_priority);
        ret = pthread_setschedprio((*impl_0).id, os_priority);
        if ret != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                    b"OS_TaskSetPriority_Impl\0",
                ))
                .as_ptr(),
                768 as libc::c_int as uint32,
                b"pthread_setschedprio: Task ID = %lu, prio = %d, err = %s\n\0" as *const u8
                    as *const libc::c_char,
                OS_ObjectIdToInteger(OS_ObjectIdFromToken(token)),
                os_priority,
                strerror(ret),
            );
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskRegister_Impl(mut global_task_id: osal_id_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut arg: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    let mut old_state: libc::c_int = 0;
    let mut old_type: libc::c_int = 0;
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE as libc::c_int, &mut old_state);
    pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED as libc::c_int, &mut old_type);
    memset(
        &mut arg as *mut OS_VoidPtrValueWrapper_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_VoidPtrValueWrapper_t>() as libc::c_ulong,
    );
    arg.id = global_task_id;
    return_code = pthread_setspecific(POSIX_GlobalVars.ThreadKey, arg.opaque_arg);
    if return_code == 0 as libc::c_int {
        return_code = 0 as libc::c_int;
    } else {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_TaskRegister_Impl\0"))
                .as_ptr(),
            810 as libc::c_int as uint32,
            b"OS_TaskRegister_Impl failed during pthread_setspecific() error=%s\n\0" as *const u8
                as *const libc::c_char,
            strerror(return_code),
        );
        return_code = -(1 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskGetId_Impl() -> osal_id_t {
    let mut self_record: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    self_record.opaque_arg = pthread_getspecific(POSIX_GlobalVars.ThreadKey);
    return self_record.id;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut task_prop: *mut OS_task_prop_t,
) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskIdMatchSystemData_Impl(
    mut ref_0: *mut libc::c_void,
    mut token: *const OS_object_token_t,
    mut obj: *const OS_common_record_t,
) -> bool {
    let mut target: *const pthread_t = ref_0 as *const pthread_t;
    let mut impl_0: *mut OS_impl_task_internal_record_t = 0 as *mut OS_impl_task_internal_record_t;
    impl_0 = &mut *OS_impl_task_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_task_internal_record_t;
    return pthread_equal(*target, (*impl_0).id) != 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TaskValidateSystemData_Impl(
    mut sysdata: *const libc::c_void,
    mut sysdata_size: size_t,
) -> int32 {
    if sysdata.is_null() || sysdata_size != ::core::mem::size_of::<pthread_t>() as libc::c_ulong {
        return -(2 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut OS_impl_timebase_table: [OS_impl_timebase_internal_record_t; 5] =
    [OS_impl_timebase_internal_record_t {
        handler_thread: 0,
        handler_mutex: pthread_mutex_t {
            __data: __pthread_mutex_s {
                __lock: 0,
                __count: 0,
                __owner: 0,
                __nusers: 0,
                __kind: 0,
                __spins: 0,
                __elision: 0,
                __list: __pthread_list_t {
                    __prev: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list as *mut __pthread_internal_list,
                },
            },
        },
        host_timerid: 0 as *const libc::c_void as *mut libc::c_void,
        assigned_signal: 0,
        sigset: sigset_t { __val: [0; 16] },
        reset_flag: 0,
    }; 5];
unsafe extern "C" fn OS_UsecToTimespec(mut usecs: uint32, mut time_spec: *mut timespec) {
    if usecs < 1000000 as libc::c_int as libc::c_uint {
        (*time_spec).tv_nsec =
            usecs.wrapping_mul(1000 as libc::c_int as libc::c_uint) as __syscall_slong_t;
        (*time_spec).tv_sec = 0 as libc::c_int as __time_t;
    } else {
        (*time_spec).tv_sec =
            usecs.wrapping_div(1000000 as libc::c_int as libc::c_uint) as __time_t;
        (*time_spec).tv_nsec = usecs
            .wrapping_rem(1000000 as libc::c_int as libc::c_uint)
            .wrapping_mul(1000 as libc::c_int as libc::c_uint)
            as __syscall_slong_t;
    };
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseLock_Impl(mut token: *const OS_object_token_t) {
    let mut impl_0: *mut OS_impl_timebase_internal_record_t =
        0 as *mut OS_impl_timebase_internal_record_t;
    impl_0 = &mut *OS_impl_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_timebase_internal_record_t;
    pthread_mutex_lock(&mut (*impl_0).handler_mutex);
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseUnlock_Impl(mut token: *const OS_object_token_t) {
    let mut impl_0: *mut OS_impl_timebase_internal_record_t =
        0 as *mut OS_impl_timebase_internal_record_t;
    impl_0 = &mut *OS_impl_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_timebase_internal_record_t;
    pthread_mutex_unlock(&mut (*impl_0).handler_mutex);
}
unsafe extern "C" fn OS_TimeBase_SigWaitImpl(mut obj_id: osal_id_t) -> uint32 {
    let mut ret: libc::c_int = 0;
    let mut token: OS_object_token_t = OS_object_token_t {
        lock_mode: OS_LOCK_MODE_NONE,
        lock_key: osal_key_t { key_value: 0 },
        obj_type: 0,
        obj_idx: 0,
        obj_id: 0,
    };
    let mut impl_0: *mut OS_impl_timebase_internal_record_t =
        0 as *mut OS_impl_timebase_internal_record_t;
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    let mut interval_time: uint32 = 0;
    let mut sig: libc::c_int = 0;
    interval_time = 0 as libc::c_int as uint32;
    if OS_ObjectIdGetById(
        OS_LOCK_MODE_NONE,
        0x8 as libc::c_int as osal_objtype_t,
        obj_id,
        &mut token,
    ) == 0 as libc::c_int
    {
        impl_0 = &mut *OS_impl_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_impl_timebase_internal_record_t;
        timebase = &mut *OS_timebase_table
            .as_mut_ptr()
            .offset((OS_ObjectIndexFromToken
                as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
                &mut token
            ) as isize) as *mut OS_timebase_internal_record_t;
        ret = sigwait(&mut (*impl_0).sigset, &mut sig);
        if !(ret != 0 as libc::c_int) {
            if (*impl_0).reset_flag == 0 as libc::c_int {
                interval_time = (*timebase).nominal_interval_time;
            } else {
                interval_time = (*timebase).nominal_start_time;
                (*impl_0).reset_flag = 0 as libc::c_int;
            }
        }
    }
    return interval_time;
}
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_TimeBaseAPI_Impl_Init() -> int32 {
    let mut status: libc::c_int = 0;
    let mut idx: osal_index_t = 0;
    let mut mutex_attr: pthread_mutexattr_t = pthread_mutexattr_t { __size: [0; 4] };
    let mut clock_resolution: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut return_code: int32 = 0;
    return_code = 0 as libc::c_int;
    memset(
        OS_impl_timebase_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_timebase_internal_record_t; 5]>() as libc::c_ulong,
    );
    status = clock_getres(1 as libc::c_int, &mut clock_resolution);
    if status != 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
                b"OS_Posix_TimeBaseAPI_Impl_Init\0",
            ))
            .as_ptr(),
            217 as libc::c_int as uint32,
            b"failed in clock_getres: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
        return_code = -(1 as libc::c_int);
    } else if clock_resolution.tv_sec > 0 as libc::c_int as libc::c_long {
        return_code = -(32 as libc::c_int);
    } else {
        POSIX_GlobalVars.ClockAccuracyNsec = clock_resolution.tv_nsec as uint32;
        status = pthread_mutexattr_init(&mut mutex_attr);
        if status != 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
                    b"OS_Posix_TimeBaseAPI_Impl_Init\0",
                ))
                .as_ptr(),
                244 as libc::c_int as uint32,
                b"Error: pthread_mutexattr_init failed: %s\n\0" as *const u8 as *const libc::c_char,
                strerror(status),
            );
            return_code = -(1 as libc::c_int);
        } else {
            status =
                pthread_mutexattr_setprotocol(&mut mutex_attr, PTHREAD_PRIO_INHERIT as libc::c_int);
            if status != 0 as libc::c_int {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
                        b"OS_Posix_TimeBaseAPI_Impl_Init\0",
                    ))
                    .as_ptr(),
                    255 as libc::c_int as uint32,
                    b"Error: pthread_mutexattr_setprotocol failed: %s\n\0" as *const u8
                        as *const libc::c_char,
                    strerror(status),
                );
                return_code = -(1 as libc::c_int);
            } else {
                idx = 0 as libc::c_int as osal_index_t;
                while idx < 5 as libc::c_int as libc::c_uint {
                    status = pthread_mutex_init(
                        &mut (*OS_impl_timebase_table.as_mut_ptr().offset(idx as isize))
                            .handler_mutex,
                        &mut mutex_attr,
                    );
                    if status != 0 as libc::c_int {
                        OS_DebugPrintf(
                            1 as libc::c_int as uint32,
                            (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
                                b"OS_Posix_TimeBaseAPI_Impl_Init\0",
                            ))
                            .as_ptr(),
                            270 as libc::c_int as uint32,
                            b"Error: Mutex could not be created: %s\n\0" as *const u8
                                as *const libc::c_char,
                            strerror(status),
                        );
                        return_code = -(1 as libc::c_int);
                        break;
                    } else {
                        idx = idx.wrapping_add(1);
                        idx;
                    }
                }
                OS_SharedGlobalVars.TicksPerSecond = sysconf(_SC_CLK_TCK as libc::c_int) as uint32;
                if OS_SharedGlobalVars.TicksPerSecond <= 0 as libc::c_int as libc::c_uint {
                    OS_DebugPrintf(
                        1 as libc::c_int as uint32,
                        (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
                            b"OS_Posix_TimeBaseAPI_Impl_Init\0",
                        ))
                        .as_ptr(),
                        282 as libc::c_int as uint32,
                        b"Error: Unable to determine OS ticks per second: %s\n\0" as *const u8
                            as *const libc::c_char,
                        strerror(*__errno_location()),
                    );
                    return_code = -(1 as libc::c_int);
                } else {
                    OS_SharedGlobalVars.MicroSecPerTick = (1000000 as libc::c_int as libc::c_uint)
                        .wrapping_add(
                            (OS_SharedGlobalVars.TicksPerSecond)
                                .wrapping_div(2 as libc::c_int as libc::c_uint),
                        )
                        .wrapping_div(OS_SharedGlobalVars.TicksPerSecond);
                }
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseCreate_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut return_code: int32 = 0;
    let mut status: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut idx: osal_index_t = 0;
    let mut evp: sigevent = sigevent {
        sigev_value: sigval { sival_int: 0 },
        sigev_signo: 0,
        sigev_notify: 0,
        _sigev_un: C2RustUnnamed { _pad: [0; 12] },
    };
    let mut ts: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut local: *mut OS_impl_timebase_internal_record_t =
        0 as *mut OS_impl_timebase_internal_record_t;
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    let mut arg: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    local = &mut *OS_impl_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_timebase_internal_record_t;
    timebase = &mut *OS_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_timebase_internal_record_t;
    memset(
        &mut arg as *mut OS_VoidPtrValueWrapper_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_VoidPtrValueWrapper_t>() as libc::c_ulong,
    );
    arg.id = OS_ObjectIdFromToken(token);
    return_code = OS_Posix_InternalTaskCreate_Impl(
        &mut (*local).handler_thread,
        0 as libc::c_int as osal_priority_t,
        0 as libc::c_int as size_t,
        Some(
            OS_TimeBasePthreadEntry as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        ),
        arg.opaque_arg,
    );
    if return_code != 0 as libc::c_int {
        return return_code;
    }
    (*local).assigned_signal = 0 as libc::c_int;
    if ((*timebase).external_sync).is_none() {
        sigemptyset(&mut (*local).sigset);
        idx = 0 as libc::c_int as osal_index_t;
        while idx < 5 as libc::c_int as libc::c_uint {
            if OS_ObjectIdIsValid((*OS_global_timebase_table.offset(idx as isize)).active_id)
                as libc::c_int
                != 0
                && OS_impl_timebase_table[idx as usize].assigned_signal != 0 as libc::c_int
            {
                sigaddset(
                    &mut (*local).sigset,
                    OS_impl_timebase_table[idx as usize].assigned_signal,
                );
            }
            idx = idx.wrapping_add(1);
            idx;
        }
        i = __libc_current_sigrtmin();
        while i <= __libc_current_sigrtmax() {
            if sigismember(&mut (*local).sigset, i) == 0 {
                (*local).assigned_signal = i;
                break;
            } else {
                i += 1;
                i;
            }
        }
        if (*local).assigned_signal == 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"OS_TimeBaseCreate_Impl\0",
                ))
                .as_ptr(),
                399 as libc::c_int as uint32,
                b"No free RT signals to use for simulated time base\n\0" as *const u8
                    as *const libc::c_char,
            );
            return_code = -(31 as libc::c_int);
        } else {
            sigemptyset(&mut (*local).sigset);
            sigaddset(&mut (*local).sigset, (*local).assigned_signal);
            i = sysconf(_SC_SIGQUEUE_MAX as libc::c_int) as libc::c_int;
            loop {
                ts.tv_sec = 0 as libc::c_int as __time_t;
                ts.tv_nsec = 0 as libc::c_int as __syscall_slong_t;
                if sigtimedwait(&mut (*local).sigset, 0 as *mut siginfo_t, &mut ts)
                    < 0 as libc::c_int
                {
                    break;
                }
                i -= 1;
                i;
                if !(i > 0 as libc::c_int) {
                    break;
                }
            }
            memset(
                &mut evp as *mut sigevent as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sigevent>() as libc::c_ulong,
            );
            evp.sigev_notify = SIGEV_SIGNAL as libc::c_int;
            evp.sigev_signo = (*local).assigned_signal;
            evp.sigev_value.sival_int =
                OS_ObjectIdToSerialNumber_Impl(OS_ObjectIdFromToken(token)) as libc::c_int;
            status = timer_create(1 as libc::c_int, &mut evp, &mut (*local).host_timerid);
            if status < 0 as libc::c_int {
                return_code = -(31 as libc::c_int);
            } else {
                (*timebase).external_sync =
                    Some(OS_TimeBase_SigWaitImpl as unsafe extern "C" fn(osal_id_t) -> uint32);
            }
        }
    }
    if return_code != 0 as libc::c_int {
        pthread_cancel((*local).handler_thread);
        (*local).assigned_signal = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseSet_Impl(
    mut token: *const OS_object_token_t,
    mut start_time: uint32,
    mut interval_time: uint32,
) -> int32 {
    let mut local: *mut OS_impl_timebase_internal_record_t =
        0 as *mut OS_impl_timebase_internal_record_t;
    let mut timeout: itimerspec = itimerspec {
        it_interval: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        it_value: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
    };
    let mut return_code: int32 = 0;
    let mut status: libc::c_int = 0;
    let mut timebase: *mut OS_timebase_internal_record_t = 0 as *mut OS_timebase_internal_record_t;
    local = &mut *OS_impl_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_timebase_internal_record_t;
    timebase = &mut *OS_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_timebase_internal_record_t;
    return_code = 0 as libc::c_int;
    if (*local).assigned_signal != 0 as libc::c_int {
        memset(
            &mut timeout as *mut itimerspec as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<itimerspec>() as libc::c_ulong,
        );
        OS_UsecToTimespec(start_time, &mut timeout.it_value);
        OS_UsecToTimespec(interval_time, &mut timeout.it_interval);
        status = timer_settime(
            (*local).host_timerid,
            0 as libc::c_int,
            &mut timeout,
            0 as *mut itimerspec,
        );
        if status < 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_TimeBaseSet_Impl\0",
                ))
                .as_ptr(),
                517 as libc::c_int as uint32,
                b"Error in timer_settime: %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__errno_location()),
            );
            return_code = -(32 as libc::c_int);
        } else if interval_time > 0 as libc::c_int as libc::c_uint {
            (*timebase).accuracy_usec =
                ((timeout.it_interval.tv_nsec + 999 as libc::c_int as libc::c_long)
                    / 1000 as libc::c_int as libc::c_long) as uint32;
        } else {
            (*timebase).accuracy_usec =
                ((timeout.it_value.tv_nsec + 999 as libc::c_int as libc::c_long)
                    / 1000 as libc::c_int as libc::c_long) as uint32;
        }
    }
    (*local).reset_flag = (return_code == 0 as libc::c_int) as libc::c_int;
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut timer_prop: *mut OS_timebase_prop_t,
) -> int32 {
    return 0 as libc::c_int;
}
unsafe extern "C" fn OS_TimeBasePthreadEntry(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut local_arg: OS_VoidPtrValueWrapper_t = OS_VoidPtrValueWrapper_t {
        opaque_arg: 0 as *mut libc::c_void,
    };
    local_arg.opaque_arg = arg;
    OS_TimeBase_CallbackThread(local_arg.id);
    return 0 as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn OS_TimeBaseDelete_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut local: *mut OS_impl_timebase_internal_record_t =
        0 as *mut OS_impl_timebase_internal_record_t;
    let mut status: libc::c_int = 0;
    local = &mut *OS_impl_timebase_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_timebase_internal_record_t;
    pthread_cancel((*local).handler_thread);
    if (*local).assigned_signal != 0 as libc::c_int {
        status = timer_delete((*local).host_timerid);
        if status < 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"OS_TimeBaseDelete_Impl\0",
                ))
                .as_ptr(),
                557 as libc::c_int as uint32,
                b"Error deleting timer: %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__errno_location()),
            );
            return -(32 as libc::c_int);
        }
        (*local).assigned_signal = 0 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SetLocalTime_Impl(mut time_struct: *const OS_time_t) -> int32 {
    let mut Status: libc::c_int = 0;
    let mut ReturnCode: int32 = 0;
    let mut TimeSp: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    TimeSp.tv_sec = OS_TimeGetTotalSeconds(*time_struct);
    TimeSp.tv_nsec = OS_TimeGetNanosecondsPart(*time_struct) as __syscall_slong_t;
    Status = clock_settime(0 as libc::c_int, &mut TimeSp);
    if Status == 0 as libc::c_int {
        ReturnCode = 0 as libc::c_int;
    } else {
        ReturnCode = -(1 as libc::c_int);
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GetLocalTime_Impl(mut time_struct: *mut OS_time_t) -> int32 {
    let mut Status: libc::c_int = 0;
    let mut ReturnCode: int32 = 0;
    let mut TimeSp: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    Status = clock_gettime(0 as libc::c_int, &mut TimeSp);
    if Status == 0 as libc::c_int {
        *time_struct = OS_TimeAssembleFromNanoseconds(TimeSp.tv_sec, TimeSp.tv_nsec as uint32);
        ReturnCode = 0 as libc::c_int;
    } else {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_GetLocalTime_Impl\0"))
                .as_ptr(),
            83 as libc::c_int as uint32,
            b"Error calling clock_gettime: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
        ReturnCode = -(1 as libc::c_int);
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ConsoleOutput_Impl(mut token: *const OS_object_token_t) {
    let mut StartPos: size_t = 0;
    let mut EndPos: size_t = 0;
    let mut WriteSize: size_t = 0;
    let mut console: *mut OS_console_internal_record_t = 0 as *mut OS_console_internal_record_t;
    console = &mut *OS_console_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_console_internal_record_t;
    StartPos = (*console).ReadPos;
    EndPos = (*console).WritePos;
    OS_BSP_Lock_Impl();
    while StartPos != EndPos {
        if StartPos > EndPos {
            WriteSize = ((*console).BufSize).wrapping_sub(StartPos);
        } else {
            WriteSize = EndPos.wrapping_sub(StartPos);
        }
        OS_BSP_ConsoleOutput_Impl(
            &mut *((*console).BufBase).offset(StartPos as isize),
            WriteSize,
        );
        StartPos = (StartPos as libc::c_ulong).wrapping_add(WriteSize) as size_t as size_t;
        if StartPos >= (*console).BufSize {
            StartPos = 0 as libc::c_int as size_t;
        }
    }
    OS_BSP_Unlock_Impl();
    ::core::ptr::write_volatile(&mut (*console).ReadPos as *mut size_t, StartPos);
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectSingle_Impl(
    mut token: *const OS_object_token_t,
    mut SelectFlags: *mut uint32,
    mut msecs: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut wr_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut rd_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    if !(*impl_0).selectable {
        return -(38 as libc::c_int);
    }
    if (*impl_0).fd >= 1024 as libc::c_int {
        return -(38 as libc::c_int);
    }
    if *SelectFlags != 0 as libc::c_int as libc::c_uint {
        let mut __i: libc::c_uint = 0;
        let mut __arr: *mut fd_set = &mut wr_set;
        __i = 0 as libc::c_int as libc::c_uint;
        while (__i as libc::c_ulong)
            < (::core::mem::size_of::<fd_set>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<__fd_mask>() as libc::c_ulong)
        {
            (*__arr).fds_bits[__i as usize] = 0 as libc::c_int as __fd_mask;
            __i = __i.wrapping_add(1);
            __i;
        }
        let mut __i_0: libc::c_uint = 0;
        let mut __arr_0: *mut fd_set = &mut rd_set;
        __i_0 = 0 as libc::c_int as libc::c_uint;
        while (__i_0 as libc::c_ulong)
            < (::core::mem::size_of::<fd_set>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<__fd_mask>() as libc::c_ulong)
        {
            (*__arr_0).fds_bits[__i_0 as usize] = 0 as libc::c_int as __fd_mask;
            __i_0 = __i_0.wrapping_add(1);
            __i_0;
        }
        if *SelectFlags & OS_STREAM_STATE_READABLE as libc::c_int as libc::c_uint != 0 {
            rd_set.fds_bits[((*impl_0).fd
                / (8 as libc::c_int
                    * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                as usize] |= ((1 as libc::c_ulong)
                << (*impl_0).fd
                    % (8 as libc::c_int
                        * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                as __fd_mask;
        }
        if *SelectFlags & OS_STREAM_STATE_WRITABLE as libc::c_int as libc::c_uint != 0 {
            wr_set.fds_bits[((*impl_0).fd
                / (8 as libc::c_int
                    * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                as usize] |= ((1 as libc::c_ulong)
                << (*impl_0).fd
                    % (8 as libc::c_int
                        * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                as __fd_mask;
        }
        return_code = OS_DoSelect((*impl_0).fd, &mut rd_set, &mut wr_set, msecs);
        if return_code == 0 as libc::c_int {
            if !(rd_set.fds_bits[((*impl_0).fd
                / (8 as libc::c_int
                    * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                as usize]
                & ((1 as libc::c_ulong)
                    << (*impl_0).fd
                        % (8 as libc::c_int
                            * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                    as __fd_mask
                != 0 as libc::c_int as libc::c_long)
            {
                *SelectFlags &= !(OS_STREAM_STATE_READABLE as libc::c_int) as libc::c_uint;
            }
            if !(wr_set.fds_bits[((*impl_0).fd
                / (8 as libc::c_int
                    * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                as usize]
                & ((1 as libc::c_ulong)
                    << (*impl_0).fd
                        % (8 as libc::c_int
                            * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                    as __fd_mask
                != 0 as libc::c_int as libc::c_long)
            {
                *SelectFlags &= !(OS_STREAM_STATE_WRITABLE as libc::c_int) as libc::c_uint;
            }
        } else {
            *SelectFlags = 0 as libc::c_int as uint32;
        }
    } else {
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SelectMultiple_Impl(
    mut ReadSet: *mut OS_FdSet,
    mut WriteSet: *mut OS_FdSet,
    mut msecs: int32,
) -> int32 {
    let mut wr_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut rd_set: fd_set = fd_set { fds_bits: [0; 16] };
    let mut maxfd: libc::c_int = 0;
    let mut return_code: int32 = 0;
    let mut __i: libc::c_uint = 0;
    let mut __arr: *mut fd_set = &mut rd_set;
    __i = 0 as libc::c_int as libc::c_uint;
    while (__i as libc::c_ulong)
        < (::core::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<__fd_mask>() as libc::c_ulong)
    {
        (*__arr).fds_bits[__i as usize] = 0 as libc::c_int as __fd_mask;
        __i = __i.wrapping_add(1);
        __i;
    }
    let mut __i_0: libc::c_uint = 0;
    let mut __arr_0: *mut fd_set = &mut wr_set;
    __i_0 = 0 as libc::c_int as libc::c_uint;
    while (__i_0 as libc::c_ulong)
        < (::core::mem::size_of::<fd_set>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<__fd_mask>() as libc::c_ulong)
    {
        (*__arr_0).fds_bits[__i_0 as usize] = 0 as libc::c_int as __fd_mask;
        __i_0 = __i_0.wrapping_add(1);
        __i_0;
    }
    maxfd = -(1 as libc::c_int);
    if !ReadSet.is_null() {
        return_code = OS_FdSet_ConvertIn_Impl(&mut maxfd, &mut rd_set, ReadSet);
        if return_code != 0 as libc::c_int {
            return return_code;
        }
    }
    if !WriteSet.is_null() {
        return_code = OS_FdSet_ConvertIn_Impl(&mut maxfd, &mut wr_set, WriteSet);
        if return_code != 0 as libc::c_int {
            return return_code;
        }
    }
    if maxfd >= 0 as libc::c_int {
        return_code = OS_DoSelect(maxfd, &mut rd_set, &mut wr_set, msecs);
    } else {
        return_code = -(16 as libc::c_int);
    }
    if return_code == 0 as libc::c_int {
        if !ReadSet.is_null() {
            OS_FdSet_ConvertOut_Impl(&mut rd_set, ReadSet);
        }
        if !WriteSet.is_null() {
            OS_FdSet_ConvertOut_Impl(&mut wr_set, WriteSet);
        }
    }
    return return_code;
}
unsafe extern "C" fn OS_FdSet_ConvertIn_Impl(
    mut os_maxfd: *mut libc::c_int,
    mut os_set: *mut fd_set,
    mut OSAL_set: *const OS_FdSet,
) -> int32 {
    let mut offset: size_t = 0;
    let mut bit: size_t = 0;
    let mut id: osal_index_t = 0;
    let mut objids: uint8 = 0;
    let mut osfd: libc::c_int = 0;
    let mut status: int32 = 0;
    status = 0 as libc::c_int;
    offset = 0 as libc::c_int as size_t;
    while offset < ::core::mem::size_of::<[uint8; 7]>() as libc::c_ulong {
        objids = (*OSAL_set).object_ids[offset as usize];
        bit = 0 as libc::c_int as size_t;
        while objids as libc::c_int != 0 as libc::c_int {
            id = offset
                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                .wrapping_add(bit) as osal_index_t;
            if objids as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int
                && id < 50 as libc::c_int as libc::c_uint
            {
                osfd = OS_impl_filehandle_table[id as usize].fd;
                if osfd >= 0 as libc::c_int {
                    if osfd >= 1024 as libc::c_int
                        || !OS_impl_filehandle_table[id as usize].selectable
                    {
                        status = -(38 as libc::c_int);
                    } else {
                        (*os_set).fds_bits[(osfd
                            / (8 as libc::c_int
                                * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong
                                    as libc::c_int))
                            as usize] |= ((1 as libc::c_ulong)
                            << osfd
                                % (8 as libc::c_int
                                    * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong
                                        as libc::c_int))
                            as __fd_mask;
                        if osfd > *os_maxfd {
                            *os_maxfd = osfd;
                        }
                    }
                }
            }
            bit = bit.wrapping_add(1);
            bit;
            objids = (objids as libc::c_int >> 1 as libc::c_int) as uint8;
        }
        offset = offset.wrapping_add(1);
        offset;
    }
    return status;
}
unsafe extern "C" fn OS_FdSet_ConvertOut_Impl(
    mut OS_set: *mut fd_set,
    mut OSAL_set: *mut OS_FdSet,
) {
    let mut offset: size_t = 0;
    let mut bit: size_t = 0;
    let mut id: osal_index_t = 0;
    let mut objids: uint8 = 0;
    let mut osfd: libc::c_int = 0;
    offset = 0 as libc::c_int as size_t;
    while offset < ::core::mem::size_of::<[uint8; 7]>() as libc::c_ulong {
        objids = (*OSAL_set).object_ids[offset as usize];
        bit = 0 as libc::c_int as size_t;
        while objids as libc::c_int != 0 as libc::c_int {
            id = offset
                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                .wrapping_add(bit) as osal_index_t;
            if objids as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int
                && id < 50 as libc::c_int as libc::c_uint
            {
                osfd = OS_impl_filehandle_table[id as usize].fd;
                if osfd < 0 as libc::c_int
                    || !((*OS_set).fds_bits[(osfd
                        / (8 as libc::c_int
                            * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong as libc::c_int))
                        as usize]
                        & ((1 as libc::c_ulong)
                            << osfd
                                % (8 as libc::c_int
                                    * ::core::mem::size_of::<__fd_mask>() as libc::c_ulong
                                        as libc::c_int)) as __fd_mask
                        != 0 as libc::c_int as libc::c_long)
                {
                    (*OSAL_set).object_ids[offset as usize] =
                        ((*OSAL_set).object_ids[offset as usize] as libc::c_int
                            & !((1 as libc::c_int) << bit)) as uint8;
                }
            }
            bit = bit.wrapping_add(1);
            bit;
            objids = (objids as libc::c_int >> 1 as libc::c_int) as uint8;
        }
        offset = offset.wrapping_add(1);
        offset;
    }
}
unsafe extern "C" fn OS_DoSelect(
    mut maxfd: libc::c_int,
    mut rd_set: *mut fd_set,
    mut wr_set: *mut fd_set,
    mut msecs: int32,
) -> int32 {
    let mut os_status: libc::c_int = 0;
    let mut return_code: int32 = 0;
    let mut tv: timeval = timeval {
        tv_sec: 0,
        tv_usec: 0,
    };
    let mut tvptr: *mut timeval = 0 as *mut timeval;
    let mut ts_now: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let mut ts_end: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    if msecs > 0 as libc::c_int {
        clock_gettime(1 as libc::c_int, &mut ts_now);
        ts_end.tv_sec = ts_now.tv_sec + (msecs / 1000 as libc::c_int) as libc::c_long;
        ts_end.tv_nsec = ts_now.tv_nsec
            + (1000000 as libc::c_int * (msecs % 1000 as libc::c_int)) as libc::c_long;
        if ts_end.tv_nsec >= 1000000000 as libc::c_int as libc::c_long {
            ts_end.tv_sec += 1;
            ts_end.tv_sec;
            ts_end.tv_nsec -= 1000000000 as libc::c_int as libc::c_long;
        }
    } else {
        memset(
            &mut ts_end as *mut timespec as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<timespec>() as libc::c_ulong,
        );
    }
    loop {
        if msecs < 0 as libc::c_int {
            tvptr = 0 as *mut timeval;
        } else if msecs == 0 as libc::c_int {
            tvptr = &mut tv;
            tv.tv_sec = 0 as libc::c_int as __time_t;
            tv.tv_usec = 0 as libc::c_int as __suseconds_t;
        } else {
            tvptr = &mut tv;
            clock_gettime(1 as libc::c_int, &mut ts_now);
            tv.tv_sec = ts_end.tv_sec - ts_now.tv_sec;
            tv.tv_usec = (ts_end.tv_nsec - ts_now.tv_nsec) / 1000 as libc::c_int as libc::c_long;
            if tv.tv_sec < 0 as libc::c_int as libc::c_long
                || tv.tv_sec == 0 as libc::c_int as libc::c_long
                    && tv.tv_usec < 0 as libc::c_int as libc::c_long
            {
                os_status = 0 as libc::c_int;
                break;
            } else if tv.tv_usec < 0 as libc::c_int as libc::c_long {
                tv.tv_usec += 1000000 as libc::c_int as libc::c_long;
                tv.tv_sec -= 1;
                tv.tv_sec;
            }
        }
        os_status = select(
            maxfd + 1 as libc::c_int,
            rd_set,
            wr_set,
            0 as *mut fd_set,
            tvptr,
        );
        if !(os_status < 0 as libc::c_int
            && (*__errno_location() == 4 as libc::c_int
                || *__errno_location() == 11 as libc::c_int))
        {
            break;
        }
    }
    if os_status < 0 as libc::c_int {
        return_code = -(1 as libc::c_int);
    } else if os_status == 0 as libc::c_int {
        return_code = -(4 as libc::c_int);
    } else {
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GenericClose_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut result: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    result = close((*impl_0).fd);
    if result < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_GenericClose_Impl\0"))
                .as_ptr(),
            87 as libc::c_int as uint32,
            b"close: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
    }
    (*impl_0).fd = -(1 as libc::c_int);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GenericSeek_Impl(
    mut token: *const OS_object_token_t,
    mut offset: int32,
    mut whence: uint32,
) -> int32 {
    let mut where_0: libc::c_int = 0;
    let mut os_result: off_t = 0;
    let mut retval: int32 = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    match whence {
        0 => {
            where_0 = 0 as libc::c_int;
        }
        1 => {
            where_0 = 1 as libc::c_int;
        }
        2 => {
            where_0 = 2 as libc::c_int;
        }
        _ => return -(1 as libc::c_int),
    }
    os_result = lseek((*impl_0).fd, offset as off_t, where_0);
    if os_result == -(1 as libc::c_int) as off_t {
        if *__errno_location() == 29 as libc::c_int {
            retval = -(38 as libc::c_int);
        } else {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"OS_GenericSeek_Impl\0",
                ))
                .as_ptr(),
                142 as libc::c_int as uint32,
                b"lseek: %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__errno_location()),
            );
            retval = -(1 as libc::c_int);
        }
    } else {
        retval = os_result as int32;
    }
    return retval;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GenericRead_Impl(
    mut token: *const OS_object_token_t,
    mut buffer: *mut libc::c_void,
    mut nbytes: size_t,
    mut timeout: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut os_result: ssize_t = 0;
    let mut operation: uint32 = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    return_code = 0 as libc::c_int;
    if nbytes > 0 as libc::c_int as libc::c_ulong {
        operation = OS_STREAM_STATE_READABLE as libc::c_int as uint32;
        if (*impl_0).selectable {
            return_code = OS_SelectSingle_Impl(token, &mut operation, timeout);
        }
        if return_code == 0 as libc::c_int
            && operation & OS_STREAM_STATE_READABLE as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
        {
            os_result = read((*impl_0).fd, buffer, nbytes);
            if os_result < 0 as libc::c_int as libc::c_long {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                        b"OS_GenericRead_Impl\0",
                    ))
                    .as_ptr(),
                    198 as libc::c_int as uint32,
                    b"read: %s\n\0" as *const u8 as *const libc::c_char,
                    strerror(*__errno_location()),
                );
                return_code = -(1 as libc::c_int);
            } else {
                return_code = os_result as int32;
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GenericWrite_Impl(
    mut token: *const OS_object_token_t,
    mut buffer: *const libc::c_void,
    mut nbytes: size_t,
    mut timeout: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut os_result: ssize_t = 0;
    let mut operation: uint32 = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    return_code = 0 as libc::c_int;
    if nbytes > 0 as libc::c_int as libc::c_ulong {
        operation = OS_STREAM_STATE_WRITABLE as libc::c_int as uint32;
        if (*impl_0).selectable {
            return_code = OS_SelectSingle_Impl(token, &mut operation, timeout);
        }
        if return_code == 0 as libc::c_int
            && operation & OS_STREAM_STATE_WRITABLE as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
        {
            os_result = write((*impl_0).fd, buffer, nbytes);
            if os_result < 0 as libc::c_int as libc::c_long {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                        b"OS_GenericWrite_Impl\0",
                    ))
                    .as_ptr(),
                    253 as libc::c_int as uint32,
                    b"write: %s\n\0" as *const u8 as *const libc::c_char,
                    strerror(*__errno_location()),
                );
                return_code = -(1 as libc::c_int);
            } else {
                return_code = os_result as int32;
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileOpen_Impl(
    mut token: *const OS_object_token_t,
    mut local_path: *const libc::c_char,
    mut flags: int32,
    mut access_mode: int32,
) -> int32 {
    let mut os_perm: libc::c_int = 0;
    let mut os_mode: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    match access_mode {
        1 => {
            os_perm = 0o1 as libc::c_int;
        }
        0 => {
            os_perm = 0 as libc::c_int;
        }
        2 => {
            os_perm = 0o2 as libc::c_int;
        }
        _ => return -(1 as libc::c_int),
    }
    if flags & OS_FILE_FLAG_CREATE as libc::c_int != 0 {
        os_perm |= 0o100 as libc::c_int;
    }
    if flags & OS_FILE_FLAG_TRUNCATE as libc::c_int != 0 {
        os_perm |= 0o1000 as libc::c_int;
    }
    os_perm |= OS_IMPL_REGULAR_FILE_FLAGS;
    os_mode = 0o400 as libc::c_int
        | 0o200 as libc::c_int
        | 0o400 as libc::c_int >> 3 as libc::c_int
        | 0o200 as libc::c_int >> 3 as libc::c_int
        | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int
        | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int;
    (*impl_0).fd = open(local_path, os_perm, os_mode);
    if (*impl_0).fd < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"OS_FileOpen_Impl\0"))
                .as_ptr(),
            110 as libc::c_int as uint32,
            b"open(%s): %s\n\0" as *const u8 as *const libc::c_char,
            local_path,
            strerror(*__errno_location()),
        );
        return -(1 as libc::c_int);
    }
    (*impl_0).selectable = os_perm & 0o4000 as libc::c_int != 0 as libc::c_int;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileStat_Impl(
    mut local_path: *const libc::c_char,
    mut filestat: *mut os_fstat_t,
) -> int32 {
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    let mut readbits: mode_t = 0;
    let mut writebits: mode_t = 0;
    let mut execbits: mode_t = 0;
    let mut filetime: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    if stat(local_path, &mut st) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    (*filestat).FileSize = st.st_size as size_t;
    filetime = st.st_mtim;
    (*filestat).FileTime =
        OS_TimeAssembleFromNanoseconds(filetime.tv_sec, filetime.tv_nsec as uint32);
    if st.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        (*filestat).FileModeBits |= OS_FILESTAT_MODE_DIR as libc::c_int as libc::c_uint;
    }
    readbits = (0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int) as mode_t;
    writebits = (0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int) as mode_t;
    execbits = (0o100 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int) as mode_t;
    if OS_IMPL_SELF_EUID == st.st_uid {
        readbits |= 0o400 as libc::c_int as libc::c_uint;
        writebits |= 0o200 as libc::c_int as libc::c_uint;
        execbits |= 0o100 as libc::c_int as libc::c_uint;
    }
    if OS_IMPL_SELF_EGID == st.st_gid {
        readbits |= (0o400 as libc::c_int >> 3 as libc::c_int) as libc::c_uint;
        writebits |= (0o200 as libc::c_int >> 3 as libc::c_int) as libc::c_uint;
        execbits |= (0o100 as libc::c_int >> 3 as libc::c_int) as libc::c_uint;
    }
    if st.st_mode & readbits != 0 {
        (*filestat).FileModeBits |= OS_FILESTAT_MODE_READ as libc::c_int as libc::c_uint;
    }
    if st.st_mode & writebits != 0 {
        (*filestat).FileModeBits |= OS_FILESTAT_MODE_WRITE as libc::c_int as libc::c_uint;
    }
    if st.st_mode & execbits != 0 {
        (*filestat).FileModeBits |= OS_FILESTAT_MODE_EXEC as libc::c_int as libc::c_uint;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileChmod_Impl(
    mut local_path: *const libc::c_char,
    mut access_mode: uint32,
) -> int32 {
    let mut readbits: mode_t = 0;
    let mut writebits: mode_t = 0;
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    let mut fd: libc::c_int = 0;
    let mut status: int32 = 0;
    fd = open(local_path, 0 as libc::c_int, 0 as libc::c_int);
    if fd < 0 as libc::c_int {
        fd = open(local_path, 0o1 as libc::c_int, 0 as libc::c_int);
        if fd < 0 as libc::c_int {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_FileChmod_Impl\0"))
                    .as_ptr(),
                233 as libc::c_int as uint32,
                b"open(%s): %s (%d)\n\0" as *const u8 as *const libc::c_char,
                local_path,
                strerror(*__errno_location()),
                *__errno_location(),
            );
            return -(1 as libc::c_int);
        }
    }
    if fstat(fd, &mut st) < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"OS_FileChmod_Impl\0"))
                .as_ptr(),
            254 as libc::c_int as uint32,
            b"fstat(%s): %s (%d)\n\0" as *const u8 as *const libc::c_char,
            local_path,
            strerror(*__errno_location()),
            *__errno_location(),
        );
        status = -(1 as libc::c_int);
    } else {
        readbits = (0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int) as mode_t;
        writebits = (0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int) as mode_t;
        if OS_IMPL_SELF_EUID == st.st_uid {
            readbits |= 0o400 as libc::c_int as libc::c_uint;
            writebits |= 0o200 as libc::c_int as libc::c_uint;
        }
        if OS_IMPL_SELF_EGID == st.st_gid {
            readbits |= (0o400 as libc::c_int >> 3 as libc::c_int) as libc::c_uint;
            writebits |= (0o200 as libc::c_int >> 3 as libc::c_int) as libc::c_uint;
        }
        if access_mode == 1 as libc::c_int as libc::c_uint
            || access_mode == 2 as libc::c_int as libc::c_uint
        {
            st.st_mode |= writebits;
        } else {
            st.st_mode &= !writebits;
        }
        if access_mode == 0 as libc::c_int as libc::c_uint
            || access_mode == 2 as libc::c_int as libc::c_uint
        {
            st.st_mode |= readbits;
        } else {
            st.st_mode &= !readbits;
        }
        if fchmod(fd, st.st_mode) < 0 as libc::c_int {
            if *__errno_location() == 95 as libc::c_int
                || *__errno_location() == 38 as libc::c_int
                || *__errno_location() == 30 as libc::c_int
            {
                status = -(28 as libc::c_int);
            } else {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(
                        b"OS_FileChmod_Impl\0",
                    ))
                    .as_ptr(),
                    316 as libc::c_int as uint32,
                    b"fchmod(%s): %s (%d)\n\0" as *const u8 as *const libc::c_char,
                    local_path,
                    strerror(*__errno_location()),
                    *__errno_location(),
                );
                status = -(1 as libc::c_int);
            }
        } else {
            status = 0 as libc::c_int;
        }
    }
    close(fd);
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileRemove_Impl(mut local_path: *const libc::c_char) -> int32 {
    if remove(local_path) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_FileRename_Impl(
    mut old_path: *const libc::c_char,
    mut new_path: *const libc::c_char,
) -> int32 {
    if rename(old_path, new_path) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirCreate_Impl(
    mut local_path: *const libc::c_char,
    mut access: uint32,
) -> int32 {
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    let mut return_code: int32 = 0;
    if mkdir(
        local_path,
        (0o40000 as libc::c_int
            | (0o400 as libc::c_int | 0o200 as libc::c_int | 0o100 as libc::c_int)
            | (0o400 as libc::c_int | 0o200 as libc::c_int | 0o100 as libc::c_int)
                >> 3 as libc::c_int
            | (0o400 as libc::c_int | 0o200 as libc::c_int | 0o100 as libc::c_int)
                >> 3 as libc::c_int
                >> 3 as libc::c_int) as __mode_t,
    ) < 0 as libc::c_int
    {
        return_code = -(1 as libc::c_int);
        if *__errno_location() == 17 as libc::c_int {
            if stat(local_path, &mut st) == 0 as libc::c_int
                && st.st_mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o40000 as libc::c_int as libc::c_uint
            {
                return_code = 0 as libc::c_int;
            }
        }
    } else {
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirOpen_Impl(
    mut token: *const OS_object_token_t,
    mut local_path: *const libc::c_char,
) -> int32 {
    let mut dp: *mut DIR = opendir(local_path);
    let mut impl_0: *mut OS_impl_dir_internal_record_t = 0 as *mut OS_impl_dir_internal_record_t;
    if dp.is_null() {
        return -(1 as libc::c_int);
    }
    impl_0 = &mut *OS_impl_dir_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_dir_internal_record_t;
    (*impl_0).dp = dp;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirClose_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_dir_internal_record_t = 0 as *mut OS_impl_dir_internal_record_t;
    impl_0 = &mut *OS_impl_dir_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_dir_internal_record_t;
    closedir((*impl_0).dp);
    (*impl_0).dp = 0 as *mut DIR;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirRead_Impl(
    mut token: *const OS_object_token_t,
    mut dirent: *mut os_dirent_t,
) -> int32 {
    let mut de: *mut dirent = 0 as *mut dirent;
    let mut impl_0: *mut OS_impl_dir_internal_record_t = 0 as *mut OS_impl_dir_internal_record_t;
    impl_0 = &mut *OS_impl_dir_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_dir_internal_record_t;
    de = readdir((*impl_0).dp);
    if de.is_null() {
        return -(1 as libc::c_int);
    }
    strncpy(
        ((*dirent).FileName).as_mut_ptr(),
        ((*de).d_name).as_mut_ptr(),
        (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    (*dirent).FileName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
        0 as libc::c_int as libc::c_char;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirRewind_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut impl_0: *mut OS_impl_dir_internal_record_t = 0 as *mut OS_impl_dir_internal_record_t;
    impl_0 = &mut *OS_impl_dir_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_dir_internal_record_t;
    rewinddir((*impl_0).dp);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_DirRemove_Impl(mut local_path: *const libc::c_char) -> int32 {
    if rmdir(local_path) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ShellOutputToFile_Impl(
    mut token: *const OS_object_token_t,
    mut Cmd: *const libc::c_char,
) -> int32 {
    return -(28 as libc::c_int);
}
#[no_mangle]
pub static mut OS_impl_module_table: [OS_impl_module_internal_record_t; 20] =
    [OS_impl_module_internal_record_t {
        dl_handle: 0 as *const libc::c_void as *mut libc::c_void,
    }; 20];
#[no_mangle]
pub unsafe extern "C" fn OS_Posix_ModuleAPI_Impl_Init() -> int32 {
    memset(
        OS_impl_module_table.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[OS_impl_module_internal_record_t; 20]>() as libc::c_ulong,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleLoad_Impl(
    mut token: *const OS_object_token_t,
    mut translated_path: *const libc::c_char,
) -> int32 {
    let mut status: int32 = -(1 as libc::c_int);
    let mut dl_mode: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_module_internal_record_t =
        0 as *mut OS_impl_module_internal_record_t;
    let mut module: *mut OS_module_internal_record_t = 0 as *mut OS_module_internal_record_t;
    impl_0 = &mut *OS_impl_module_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_module_internal_record_t;
    module = &mut *OS_module_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_module_internal_record_t;
    dl_mode = 0x2 as libc::c_int;
    if (*module).flags & 0x1 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint {
        dl_mode |= 0 as libc::c_int;
    } else {
        dl_mode |= 0x100 as libc::c_int;
    }
    dlerror();
    (*impl_0).dl_handle = dlopen(translated_path, dl_mode);
    if !((*impl_0).dl_handle).is_null() {
        status = 0 as libc::c_int;
    } else {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"OS_ModuleLoad_Impl\0"))
                .as_ptr(),
            107 as libc::c_int as uint32,
            b"Error loading shared library: %s\n\0" as *const u8 as *const libc::c_char,
            dlerror(),
        );
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleUnload_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut status: int32 = -(1 as libc::c_int);
    let mut impl_0: *mut OS_impl_module_internal_record_t =
        0 as *mut OS_impl_module_internal_record_t;
    impl_0 = &mut *OS_impl_module_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_module_internal_record_t;
    dlerror();
    if dlclose((*impl_0).dl_handle) == 0 as libc::c_int {
        (*impl_0).dl_handle = 0 as *mut libc::c_void;
        status = 0 as libc::c_int;
    } else {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_ModuleUnload_Impl\0"))
                .as_ptr(),
            137 as libc::c_int as uint32,
            b"Error unloading shared library: %s\n\0" as *const u8 as *const libc::c_char,
            dlerror(),
        );
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut module_prop: *mut OS_module_prop_t,
) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_GenericSymbolLookup_Impl(
    mut dl_handle: *mut libc::c_void,
    mut SymbolAddress: *mut cpuaddr,
    mut SymbolName: *const libc::c_char,
) -> int32 {
    let mut dlError: *const libc::c_char = 0 as *const libc::c_char;
    let mut Function: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut status: int32 = 0;
    status = -(1 as libc::c_int);
    dlerror();
    Function = dlsym(dl_handle, SymbolName);
    dlError = dlerror();
    if !dlError.is_null() {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                b"OS_GenericSymbolLookup_Impl\0",
            ))
            .as_ptr(),
            114 as libc::c_int as uint32,
            b"Error: %s: %s\n\0" as *const u8 as *const libc::c_char,
            SymbolName,
            dlError,
        );
    } else if Function.is_null() {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                b"OS_GenericSymbolLookup_Impl\0",
            ))
            .as_ptr(),
            119 as libc::c_int as uint32,
            b"Error: %s: dlsym() returned NULL\n\0" as *const u8 as *const libc::c_char,
            SymbolName,
        );
    } else {
        status = 0 as libc::c_int;
    }
    *SymbolAddress = Function as cpuaddr;
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SymbolLookup_Impl(
    mut SymbolAddress: *mut cpuaddr,
    mut SymbolName: *const libc::c_char,
) -> int32 {
    let mut status: int32 = 0;
    let mut local_status: int32 = 0;
    let mut iter: OS_object_iter_t = OS_object_iter_t {
        base: 0 as *mut OS_common_record_t,
        match_0: None,
        arg: 0 as *mut libc::c_void,
        limit: 0,
        token: OS_object_token_t {
            lock_mode: OS_LOCK_MODE_NONE,
            lock_key: osal_key_t { key_value: 0 },
            obj_type: 0,
            obj_idx: 0,
            obj_id: 0,
        },
    };
    status = OS_GenericSymbolLookup_Impl(0 as *mut libc::c_void, SymbolAddress, SymbolName);
    if status != 0 as libc::c_int {
        OS_ObjectIdIterateActive(0xa as libc::c_int as osal_objtype_t, &mut iter);
        while OS_ObjectIdIteratorGetNext(&mut iter) {
            local_status = OS_ModuleSymbolLookup_Impl(&mut iter.token, SymbolAddress, SymbolName);
            if !(local_status == 0 as libc::c_int) {
                continue;
            }
            status = local_status;
            break;
        }
        OS_ObjectIdIteratorDestroy(&mut iter);
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_ModuleSymbolLookup_Impl(
    mut token: *const OS_object_token_t,
    mut SymbolAddress: *mut cpuaddr,
    mut SymbolName: *const libc::c_char,
) -> int32 {
    let mut status: int32 = 0;
    let mut impl_0: *mut OS_impl_module_internal_record_t =
        0 as *mut OS_impl_module_internal_record_t;
    impl_0 = &mut *OS_impl_module_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_module_internal_record_t;
    status = OS_GenericSymbolLookup_Impl((*impl_0).dl_handle, SymbolAddress, SymbolName);
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SymbolTableDump_Impl(
    mut filename: *const libc::c_char,
    mut size_limit: size_t,
) -> int32 {
    return -(28 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn OS_SetSocketDefaultFlags_Impl(mut token: *const OS_object_token_t) {
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    let mut os_flags: libc::c_int = 0;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    os_flags = fcntl((*impl_0).fd, 3 as libc::c_int);
    if os_flags == -(1 as libc::c_int) {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
                b"OS_SetSocketDefaultFlags_Impl\0",
            ))
            .as_ptr(),
            115 as libc::c_int as uint32,
            b"fcntl(F_GETFL): %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
    } else {
        os_flags |= 0o4000 as libc::c_int;
        if fcntl((*impl_0).fd, 4 as libc::c_int, os_flags) == -(1 as libc::c_int) {
            OS_DebugPrintf(
                1 as libc::c_int as uint32,
                (*::core::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
                    b"OS_SetSocketDefaultFlags_Impl\0",
                ))
                .as_ptr(),
                123 as libc::c_int as uint32,
                b"fcntl(F_SETFL): %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__errno_location()),
            );
        }
    }
    (*impl_0).selectable = 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketGetInfo_Impl(
    mut token: *const OS_object_token_t,
    mut sock_prop: *mut OS_socket_prop_t,
) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketSendTo_Impl(
    mut token: *const OS_object_token_t,
    mut buffer: *const libc::c_void,
    mut buflen: size_t,
    mut RemoteAddr: *const OS_SockAddr_t,
) -> int32 {
    let mut os_result: libc::c_int = 0;
    let mut addrlen: socklen_t = 0;
    let mut sa: *const sockaddr = 0 as *const sockaddr;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    sa = &(*RemoteAddr).AddrData as *const OS_SockAddrData_t as *const sockaddr;
    match (*sa).sa_family as libc::c_int {
        2 => {
            addrlen = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
        }
        10 => {
            addrlen = ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong as socklen_t;
        }
        _ => {
            addrlen = 0 as libc::c_int as socklen_t;
        }
    }
    if addrlen as libc::c_ulong != (*RemoteAddr).ActualLength {
        return -(34 as libc::c_int);
    }
    os_result = sendto(
        (*impl_0).fd,
        buffer,
        buflen,
        MSG_DONTWAIT as libc::c_int,
        __CONST_SOCKADDR_ARG { __sockaddr__: sa },
        addrlen,
    ) as libc::c_int;
    if os_result < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketSendTo_Impl\0"))
                .as_ptr(),
            602 as libc::c_int as uint32,
            b"sendto: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
        return -(1 as libc::c_int);
    }
    return os_result;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketRecvFrom_Impl(
    mut token: *const OS_object_token_t,
    mut buffer: *mut libc::c_void,
    mut buflen: size_t,
    mut RemoteAddr: *mut OS_SockAddr_t,
    mut timeout: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut os_result: libc::c_int = 0;
    let mut waitflags: libc::c_int = 0;
    let mut operation: uint32 = 0;
    let mut sa: *mut sockaddr = 0 as *mut sockaddr;
    let mut addrlen: socklen_t = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    if RemoteAddr.is_null() {
        sa = 0 as *mut sockaddr;
        addrlen = 0 as libc::c_int as socklen_t;
    } else {
        addrlen = 28 as libc::c_int as socklen_t;
        sa = &mut (*RemoteAddr).AddrData as *mut OS_SockAddrData_t as *mut sockaddr;
    }
    operation = OS_STREAM_STATE_READABLE as libc::c_int as uint32;
    if (*impl_0).selectable {
        waitflags = MSG_DONTWAIT as libc::c_int;
        return_code = OS_SelectSingle_Impl(token, &mut operation, timeout);
    } else {
        if timeout == 0 as libc::c_int {
            waitflags = MSG_DONTWAIT as libc::c_int;
        } else {
            waitflags = 0 as libc::c_int;
        }
        return_code = 0 as libc::c_int;
    }
    if return_code == 0 as libc::c_int {
        if operation & OS_STREAM_STATE_READABLE as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        {
            return_code = -(4 as libc::c_int);
        } else {
            os_result = recvfrom(
                (*impl_0).fd,
                buffer,
                buflen,
                waitflags,
                __SOCKADDR_ARG { __sockaddr__: sa },
                &mut addrlen,
            ) as libc::c_int;
            if os_result < 0 as libc::c_int {
                if *__errno_location() == 11 as libc::c_int
                    || *__errno_location() == 11 as libc::c_int
                {
                    return_code = -(8 as libc::c_int);
                } else {
                    OS_DebugPrintf(
                        1 as libc::c_int as uint32,
                        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                            b"OS_SocketRecvFrom_Impl\0",
                        ))
                        .as_ptr(),
                        543 as libc::c_int as uint32,
                        b"recvfrom: %s\n\0" as *const u8 as *const libc::c_char,
                        strerror(*__errno_location()),
                    );
                    return_code = -(1 as libc::c_int);
                }
            } else {
                return_code = os_result;
                if !RemoteAddr.is_null() {
                    (*RemoteAddr).ActualLength = addrlen as size_t;
                }
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAccept_Impl(
    mut sock_token: *const OS_object_token_t,
    mut conn_token: *const OS_object_token_t,
    mut Addr: *mut OS_SockAddr_t,
    mut timeout: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut operation: uint32 = 0;
    let mut addrlen: socklen_t = 0;
    let mut sock_impl: *mut OS_impl_file_internal_record_t =
        0 as *mut OS_impl_file_internal_record_t;
    let mut conn_impl: *mut OS_impl_file_internal_record_t =
        0 as *mut OS_impl_file_internal_record_t;
    sock_impl = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            sock_token
        ) as isize) as *mut OS_impl_file_internal_record_t;
    conn_impl = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(
            conn_token
        ) as isize) as *mut OS_impl_file_internal_record_t;
    operation = OS_STREAM_STATE_READABLE as libc::c_int as uint32;
    if (*sock_impl).selectable {
        return_code = OS_SelectSingle_Impl(sock_token, &mut operation, timeout);
    } else {
        return_code = 0 as libc::c_int;
    }
    if return_code == 0 as libc::c_int {
        if operation & OS_STREAM_STATE_READABLE as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        {
            return_code = -(4 as libc::c_int);
        } else {
            addrlen = (*Addr).ActualLength as socklen_t;
            (*conn_impl).fd = accept(
                (*sock_impl).fd,
                __SOCKADDR_ARG {
                    __sockaddr__: &mut (*Addr).AddrData as *mut OS_SockAddrData_t as *mut sockaddr,
                },
                &mut addrlen,
            );
            if (*conn_impl).fd < 0 as libc::c_int {
                return_code = -(1 as libc::c_int);
            } else {
                (*Addr).ActualLength = addrlen as size_t;
                OS_SetSocketDefaultFlags_Impl(conn_token);
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketShutdown_Impl(
    mut token: *const OS_object_token_t,
    mut Mode: OS_SocketShutdownMode_t,
) -> int32 {
    let mut conn_impl: *mut OS_impl_file_internal_record_t =
        0 as *mut OS_impl_file_internal_record_t;
    let mut return_code: int32 = 0;
    let mut how: libc::c_int = 0;
    conn_impl = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    if Mode as libc::c_uint == OS_SocketShutdownMode_SHUT_READ as libc::c_int as libc::c_uint {
        how = SHUT_RD as libc::c_int;
    } else if Mode as libc::c_uint
        == OS_SocketShutdownMode_SHUT_WRITE as libc::c_int as libc::c_uint
    {
        how = SHUT_WR as libc::c_int;
    } else {
        how = SHUT_RDWR as libc::c_int;
    }
    if shutdown((*conn_impl).fd, how) == 0 as libc::c_int {
        return_code = 0 as libc::c_int;
    } else {
        return_code = -(1 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketConnect_Impl(
    mut token: *const OS_object_token_t,
    mut Addr: *const OS_SockAddr_t,
    mut timeout: int32,
) -> int32 {
    let mut return_code: int32 = 0;
    let mut os_status: libc::c_int = 0;
    let mut sockopt: libc::c_int = 0;
    let mut slen: socklen_t = 0;
    let mut operation: uint32 = 0;
    let mut sa: *const sockaddr = 0 as *const sockaddr;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    sa = &(*Addr).AddrData as *const OS_SockAddrData_t as *const sockaddr;
    match (*sa).sa_family as libc::c_int {
        2 => {
            slen = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
        }
        10 => {
            slen = ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong as socklen_t;
        }
        _ => {
            slen = 0 as libc::c_int as socklen_t;
        }
    }
    if slen as libc::c_ulong != (*Addr).ActualLength {
        return_code = -(34 as libc::c_int);
    } else {
        return_code = 0 as libc::c_int;
        os_status = connect(
            (*impl_0).fd,
            __CONST_SOCKADDR_ARG { __sockaddr__: sa },
            slen,
        );
        if os_status < 0 as libc::c_int {
            if *__errno_location() != 115 as libc::c_int {
                OS_DebugPrintf(
                    1 as libc::c_int as uint32,
                    (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(
                        b"OS_SocketConnect_Impl\0",
                    ))
                    .as_ptr(),
                    327 as libc::c_int as uint32,
                    b"connect: %s\n\0" as *const u8 as *const libc::c_char,
                    strerror(*__errno_location()),
                );
                return_code = -(1 as libc::c_int);
            } else {
                operation = OS_STREAM_STATE_WRITABLE as libc::c_int as uint32;
                if (*impl_0).selectable {
                    return_code = OS_SelectSingle_Impl(token, &mut operation, timeout);
                }
                if return_code == 0 as libc::c_int {
                    if operation & OS_STREAM_STATE_WRITABLE as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        return_code = -(4 as libc::c_int);
                    } else {
                        sockopt = 0 as libc::c_int;
                        slen = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t;
                        os_status = getsockopt(
                            (*impl_0).fd,
                            1 as libc::c_int,
                            4 as libc::c_int,
                            &mut sockopt as *mut libc::c_int as *mut libc::c_void,
                            &mut slen,
                        );
                        if os_status < 0 as libc::c_int || sockopt != 0 as libc::c_int {
                            return_code = -(1 as libc::c_int);
                        }
                    }
                }
            }
        }
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketBindAddress_Impl(
    mut token: *const OS_object_token_t,
    mut Addr: *const OS_SockAddr_t,
) -> int32 {
    let mut os_result: libc::c_int = 0;
    let mut addrlen: socklen_t = 0;
    let mut sa: *const sockaddr = 0 as *const sockaddr;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    sa = &(*Addr).AddrData as *const OS_SockAddrData_t as *const sockaddr;
    match (*sa).sa_family as libc::c_int {
        2 => {
            addrlen = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
        }
        10 => {
            addrlen = ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong as socklen_t;
        }
        _ => {
            addrlen = 0 as libc::c_int as socklen_t;
        }
    }
    if addrlen == 0 as libc::c_int as libc::c_uint {
        return -(34 as libc::c_int);
    }
    os_result = bind(
        (*impl_0).fd,
        __CONST_SOCKADDR_ARG { __sockaddr__: sa },
        addrlen,
    );
    if os_result < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
                b"OS_SocketBindAddress_Impl\0",
            ))
            .as_ptr(),
            251 as libc::c_int as uint32,
            b"bind: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketListen_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut os_result: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    os_result = listen((*impl_0).fd, 10 as libc::c_int);
    if os_result < 0 as libc::c_int {
        OS_DebugPrintf(
            1 as libc::c_int as uint32,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"OS_SocketListen_Impl\0"))
                .as_ptr(),
            274 as libc::c_int as uint32,
            b"listen: %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__errno_location()),
        );
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketOpen_Impl(mut token: *const OS_object_token_t) -> int32 {
    let mut os_domain: libc::c_int = 0;
    let mut os_type: libc::c_int = 0;
    let mut os_proto: libc::c_int = 0;
    let mut os_flags: libc::c_int = 0;
    let mut impl_0: *mut OS_impl_file_internal_record_t = 0 as *mut OS_impl_file_internal_record_t;
    let mut stream: *mut OS_stream_internal_record_t = 0 as *mut OS_stream_internal_record_t;
    impl_0 = &mut *OS_impl_filehandle_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_impl_file_internal_record_t;
    stream = &mut *OS_stream_table
        .as_mut_ptr()
        .offset((OS_ObjectIndexFromToken
            as unsafe extern "C" fn(*const OS_object_token_t) -> osal_index_t)(token)
            as isize) as *mut OS_stream_internal_record_t;
    os_proto = 0 as libc::c_int;
    match (*stream).socket_type as libc::c_int {
        1 => {
            os_type = SOCK_DGRAM as libc::c_int;
            os_proto = IPPROTO_UDP as libc::c_int;
        }
        2 => {
            os_type = SOCK_STREAM as libc::c_int;
            os_proto = IPPROTO_TCP as libc::c_int;
        }
        _ => return -(28 as libc::c_int),
    }
    match (*stream).socket_domain as libc::c_int {
        1 => {
            os_domain = 2 as libc::c_int;
        }
        2 => {
            os_domain = 10 as libc::c_int;
        }
        _ => return -(28 as libc::c_int),
    }
    (*impl_0).fd = socket(os_domain, os_type, os_proto);
    if (*impl_0).fd < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    os_flags = 1 as libc::c_int;
    setsockopt(
        (*impl_0).fd,
        1 as libc::c_int,
        2 as libc::c_int,
        &mut os_flags as *mut libc::c_int as *const libc::c_void,
        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as socklen_t,
    );
    OS_SetSocketDefaultFlags_Impl(token);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrSetPort_Impl(
    mut Addr: *mut OS_SockAddr_t,
    mut PortNum: uint16,
) -> int32 {
    let mut sa_port: in_port_t = 0;
    let mut Accessor: *mut OS_SockAddr_Accessor_t = 0 as *mut OS_SockAddr_Accessor_t;
    sa_port = htons(PortNum);
    Accessor = &mut (*Addr).AddrData as *mut OS_SockAddrData_t as *mut OS_SockAddr_Accessor_t;
    match (*Accessor).sa.sa_family as libc::c_int {
        2 => {
            (*Accessor).sa_in.sin_port = sa_port;
        }
        10 => {
            (*Accessor).sa_in6.sin6_port = sa_port;
        }
        _ => return -(34 as libc::c_int),
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrGetPort_Impl(
    mut PortNum: *mut uint16,
    mut Addr: *const OS_SockAddr_t,
) -> int32 {
    let mut sa_port: in_port_t = 0;
    let mut Accessor: *const OS_SockAddr_Accessor_t = 0 as *const OS_SockAddr_Accessor_t;
    Accessor = &(*Addr).AddrData as *const OS_SockAddrData_t as *const OS_SockAddr_Accessor_t;
    match (*Accessor).sa.sa_family as libc::c_int {
        2 => {
            sa_port = (*Accessor).sa_in.sin_port;
        }
        10 => {
            sa_port = (*Accessor).sa_in6.sin6_port;
        }
        _ => return -(34 as libc::c_int),
    }
    *PortNum = ntohs(sa_port);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrFromString_Impl(
    mut Addr: *mut OS_SockAddr_t,
    mut string: *const libc::c_char,
) -> int32 {
    let mut addrbuffer: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut Accessor: *mut OS_SockAddr_Accessor_t = 0 as *mut OS_SockAddr_Accessor_t;
    Accessor = &mut (*Addr).AddrData as *mut OS_SockAddrData_t as *mut OS_SockAddr_Accessor_t;
    match (*Accessor).sa.sa_family as libc::c_int {
        2 => {
            addrbuffer = &mut (*Accessor).sa_in.sin_addr as *mut in_addr as *mut libc::c_void;
        }
        10 => {
            addrbuffer = &mut (*Accessor).sa_in6.sin6_addr as *mut in6_addr as *mut libc::c_void;
        }
        _ => return -(34 as libc::c_int),
    }
    if inet_pton((*Accessor).sa.sa_family as libc::c_int, string, addrbuffer) != 1 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrToString_Impl(
    mut buffer: *mut libc::c_char,
    mut buflen: size_t,
    mut Addr: *const OS_SockAddr_t,
) -> int32 {
    let mut addrbuffer: *const libc::c_void = 0 as *const libc::c_void;
    let mut Accessor: *const OS_SockAddr_Accessor_t = 0 as *const OS_SockAddr_Accessor_t;
    Accessor = &(*Addr).AddrData as *const OS_SockAddrData_t as *const OS_SockAddr_Accessor_t;
    match (*Accessor).sa.sa_family as libc::c_int {
        2 => {
            addrbuffer = &(*Accessor).sa_in.sin_addr as *const in_addr as *const libc::c_void;
        }
        10 => {
            addrbuffer = &(*Accessor).sa_in6.sin6_addr as *const in6_addr as *const libc::c_void;
        }
        _ => return -(34 as libc::c_int),
    }
    if (inet_ntop(
        (*Accessor).sa.sa_family as libc::c_int,
        addrbuffer,
        buffer,
        buflen as socklen_t,
    ))
    .is_null()
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_SocketAddrInit_Impl(
    mut Addr: *mut OS_SockAddr_t,
    mut Domain: OS_SocketDomain_t,
) -> int32 {
    let mut sa_family: sa_family_t = 0;
    let mut addrlen: socklen_t = 0;
    let mut Accessor: *mut OS_SockAddr_Accessor_t = 0 as *mut OS_SockAddr_Accessor_t;
    memset(
        Addr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_SockAddr_t>() as libc::c_ulong,
    );
    Accessor = &mut (*Addr).AddrData as *mut OS_SockAddrData_t as *mut OS_SockAddr_Accessor_t;
    match Domain as libc::c_uint {
        1 => {
            sa_family = 2 as libc::c_int as sa_family_t;
            addrlen = ::core::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
        }
        2 => {
            sa_family = 10 as libc::c_int as sa_family_t;
            addrlen = ::core::mem::size_of::<sockaddr_in6>() as libc::c_ulong as socklen_t;
        }
        _ => {
            sa_family = 0 as libc::c_int as sa_family_t;
            addrlen = 0 as libc::c_int as socklen_t;
        }
    }
    if addrlen == 0 as libc::c_int as libc::c_uint {
        return -(28 as libc::c_int);
    }
    (*Addr).ActualLength = addrlen as size_t;
    (*Accessor).sa.sa_family = sa_family;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OS_NetworkGetHostName_Impl(
    mut host_name: *mut libc::c_char,
    mut name_len: size_t,
) -> int32 {
    let mut return_code: int32 = 0;
    if gethostname(host_name, name_len) < 0 as libc::c_int {
        return_code = -(1 as libc::c_int);
    } else {
        *host_name.offset(name_len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) =
            0 as libc::c_int as libc::c_char;
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn OS_NetworkGetID_Impl(mut IdBuf: *mut int32) -> int32 {
    *IdBuf = gethostid() as int32;
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn CFE_ResourceId_ToInteger(mut id: CFE_ResourceId_t) -> libc::c_ulong {
    return id as libc::c_ulong;
}
#[inline]
unsafe extern "C" fn CFE_ResourceId_FromInteger(mut Value: libc::c_ulong) -> CFE_ResourceId_t {
    return Value as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn CFE_ResourceId_Equal(
    mut id1: CFE_ResourceId_t,
    mut id2: CFE_ResourceId_t,
) -> bool {
    return id1 == id2;
}
#[inline]
unsafe extern "C" fn CFE_ResourceId_IsDefined(mut id: CFE_ResourceId_t) -> bool {
    return !CFE_ResourceId_Equal(id, 0 as libc::c_int as CFE_ResourceId_t);
}
#[no_mangle]
pub unsafe extern "C" fn CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_endian_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_msg_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_error_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_h_c__CheckHeader() {}
#[inline]
unsafe extern "C" fn CFE_SB_ValueToMsgId(mut MsgIdValue: CFE_SB_MsgId_Atom_t) -> CFE_SB_MsgId_t {
    let mut Result: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t { Value: MsgIdValue };
        init
    };
    return Result;
}
#[inline]
unsafe extern "C" fn CFE_SB_MsgIdToValue(mut MsgId: CFE_SB_MsgId_t) -> CFE_SB_MsgId_Atom_t {
    return MsgId.Value;
}
#[inline]
unsafe extern "C" fn CFE_SB_MsgId_Equal(
    mut MsgId1: CFE_SB_MsgId_t,
    mut MsgId2: CFE_SB_MsgId_t,
) -> bool {
    return MsgId1.Value == MsgId2.Value;
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_version_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_es_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_evs_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_fs_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_sb_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_tbl_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_time_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_api_src_check_cfe_tbl_filedef_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_private_src_check_cfe_es_erlog_typedef_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_private_src_check_cfe_evs_log_typedef_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_private_src_check_cfe_es_resetdata_typedef_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_private_src_check_cfe_sbr_h_c__CheckHeader()
{
}
#[inline]
unsafe extern "C" fn CFE_SBR_IsValidRouteId(mut RouteId: CFE_SBR_RouteId_t) -> bool {
    return RouteId.RouteId as libc::c_int != 0 as libc::c_int
        && RouteId.RouteId as libc::c_int <= 256 as libc::c_int;
}
#[inline]
unsafe extern "C" fn CFE_SBR_ValueToRouteId(mut Value: CFE_SB_RouteId_Atom_t) -> CFE_SBR_RouteId_t {
    return {
        let mut init = CFE_SBR_RouteId_t {
            RouteId: (1 as libc::c_int + Value as libc::c_int) as CFE_SB_RouteId_Atom_t,
        };
        init
    };
}
#[inline]
unsafe extern "C" fn CFE_SBR_RouteIdToValue(
    mut RouteId: CFE_SBR_RouteId_t,
) -> CFE_SB_RouteId_Atom_t {
    return (RouteId.RouteId as libc::c_int - 1 as libc::c_int) as CFE_SB_RouteId_Atom_t;
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_private_src_check_cfe_sb_destination_typedef_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_private_src_check_cfe_es_perfdata_typedef_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_core_private_src_check_cfe_core_resourceid_basevalues_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetLibInfo(
    mut LibInfo: *mut CFE_ES_AppInfo_t,
    mut LibId: CFE_ES_LibId_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut LibRecPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    let mut ModuleId: osal_id_t = 0;
    if LibInfo.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Invalid Parameter ( Null Pointer )\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetLibInfo\0"))
                .as_ptr(),
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    memset(
        LibInfo as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_AppInfo_t>() as libc::c_ulong,
    );
    ModuleId = 0 as libc::c_int as osal_id_t;
    LibRecPtr = CFE_ES_LocateLibRecordByID(LibId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetLibInfo\0"))
            .as_ptr(),
        1098 as libc::c_int,
    );
    if !CFE_ES_LibRecordIsMatch(LibRecPtr, LibId) {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Lib ID not active: %lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetLibInfo\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(LibId),
        );
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
    } else {
        (*LibInfo).ResourceId = LibId;
        (*LibInfo).Type = CFE_ES_AppType_LIBRARY as libc::c_int as uint32;
        strncpy(
            ((*LibInfo).Name).as_mut_ptr(),
            CFE_ES_LibRecordGetName(LibRecPtr),
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        CFE_ES_CopyModuleBasicInfo(&mut (*LibRecPtr).LoadParams, LibInfo);
        CFE_ES_CopyModuleStatusInfo(&mut (*LibRecPtr).LoadStatus, LibInfo);
        ModuleId = (*LibRecPtr).LoadStatus.ModuleId;
        Status = 0 as libc::c_int;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetLibInfo\0"))
            .as_ptr(),
        1124 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_ES_CopyModuleAddressInfo(ModuleId, LibInfo);
    }
    return Status;
}
#[inline]
unsafe extern "C" fn CFE_ES_CDSBlockRecordSetFree(mut CDSBlockRecPtr: *mut CFE_ES_CDS_RegRec_t) {
    (*CDSBlockRecPtr).BlockID = 0 as libc::c_int as CFE_ResourceId_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetAppIDByName(
    mut AppIdPtr: *mut CFE_ES_AppId_t,
    mut AppName: *const libc::c_char,
) -> CFE_Status_t {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut Result: int32 = 0;
    if AppName.is_null() || AppIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_GetAppIDByName\0"))
            .as_ptr(),
        682 as libc::c_int,
    );
    AppRecPtr = CFE_ES_LocateAppRecordByName(AppName);
    if AppRecPtr.is_null() {
        Result = 0xc4000002 as libc::c_uint as CFE_Status_t;
        *AppIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
    } else {
        Result = 0 as libc::c_int;
        *AppIdPtr = CFE_ES_AppRecordGetID(AppRecPtr);
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_GetAppIDByName\0"))
            .as_ptr(),
        700 as libc::c_int,
    );
    return Result;
}
#[inline]
unsafe extern "C" fn CFE_ES_CDSBlockRecordIsUsed(
    mut CDSBlockRecPtr: *const CFE_ES_CDS_RegRec_t,
) -> bool {
    return CFE_ResourceId_IsDefined((*CDSBlockRecPtr).BlockID);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_WaitForSystemState(
    mut MinSystemState: uint32,
    mut TimeOutMilliseconds: uint32,
) -> CFE_Status_t {
    let mut Status: int32 = 0 as libc::c_int;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut RequiredAppState: uint32 = 0;
    let mut WaitTime: uint32 = 0;
    let mut WaitRemaining: uint32 = 0;
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(b"CFE_ES_WaitForSystemState\0"))
            .as_ptr(),
        573 as libc::c_int,
    );
    AppRecPtr = CFE_ES_GetAppRecordByContext();
    if !AppRecPtr.is_null() {
        RequiredAppState = CFE_ES_AppState_EARLY_INIT as libc::c_int as uint32;
        if (*AppRecPtr).Type as libc::c_int == CFE_ES_AppType_CORE as libc::c_int {
            if MinSystemState >= CFE_ES_SystemState_CORE_READY as libc::c_int as libc::c_uint {
                RequiredAppState = CFE_ES_AppState_RUNNING as libc::c_int as uint32;
            }
        } else if MinSystemState >= CFE_ES_SystemState_SHUTDOWN as libc::c_int as libc::c_uint {
            RequiredAppState = CFE_ES_AppState_STOPPED as libc::c_int as uint32;
        } else if MinSystemState >= CFE_ES_SystemState_OPERATIONAL as libc::c_int as libc::c_uint {
            RequiredAppState = CFE_ES_AppState_RUNNING as libc::c_int as uint32;
        } else if MinSystemState >= CFE_ES_SystemState_APPS_INIT as libc::c_int as libc::c_uint {
            RequiredAppState = CFE_ES_AppState_LATE_INIT as libc::c_int as uint32;
        }
        if (*AppRecPtr).AppState < RequiredAppState {
            (*AppRecPtr).AppState = RequiredAppState;
        }
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(b"CFE_ES_WaitForSystemState\0"))
            .as_ptr(),
        621 as libc::c_int,
    );
    WaitRemaining = TimeOutMilliseconds;
    while (CFE_ES_Global.SystemState as libc::c_uint) < MinSystemState {
        if WaitRemaining > 50 as libc::c_int as libc::c_uint {
            WaitTime = 50 as libc::c_int as uint32;
        } else if WaitRemaining > 0 as libc::c_int as libc::c_uint {
            WaitTime = WaitRemaining;
        } else {
            Status = 0xc4000027 as libc::c_uint as CFE_Status_t;
            break;
        }
        OS_TaskDelay(WaitTime);
        WaitRemaining = (WaitRemaining as libc::c_uint).wrapping_sub(WaitTime) as uint32 as uint32;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RunLoop(mut RunStatus: *mut uint32) -> bool {
    let mut ReturnCode: bool = false;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    CFE_ES_IncrementTaskCounter();
    if !RunStatus.is_null() && *RunStatus != CFE_ES_RunStatus_APP_RUN as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_RunLoop\0")).as_ptr(),
        502 as libc::c_int,
    );
    AppRecPtr = CFE_ES_GetAppRecordByContext();
    if !AppRecPtr.is_null() {
        if (*AppRecPtr).AppState < CFE_ES_AppState_RUNNING as libc::c_int as libc::c_uint {
            (*AppRecPtr).AppState =
                CFE_ES_AppState_RUNNING as libc::c_int as CFE_ES_AppState_Enum_t;
        }
        if (*AppRecPtr).ControlReq.AppControlRequest
            == CFE_ES_RunStatus_APP_RUN as libc::c_int as libc::c_uint
        {
            ReturnCode = 1 as libc::c_int != 0;
        } else {
            if !RunStatus.is_null() {
                *RunStatus = (*AppRecPtr).ControlReq.AppControlRequest;
            }
            ReturnCode = 0 as libc::c_int != 0;
        }
    } else {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Error getting AppID for the caller\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_RunLoop\0"))
                .as_ptr(),
        );
        ReturnCode = 0 as libc::c_int != 0;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_RunLoop\0")).as_ptr(),
        548 as libc::c_int,
    );
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_WaitForStartupSync(mut TimeOutMilliseconds: uint32) {
    CFE_ES_WaitForSystemState(
        CFE_ES_SystemState_OPERATIONAL as libc::c_int as uint32,
        TimeOutMilliseconds,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetLibName(
    mut LibName: *mut libc::c_char,
    mut LibId: CFE_ES_LibId_t,
    mut BufferLength: size_t,
) -> CFE_Status_t {
    let mut Result: int32 = 0;
    let mut LibRecPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    if BufferLength == 0 as libc::c_int as libc::c_ulong || LibName.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    LibRecPtr = CFE_ES_LocateLibRecordByID(LibId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetLibName\0"))
            .as_ptr(),
        910 as libc::c_int,
    );
    if CFE_ES_LibRecordIsMatch(LibRecPtr, LibId) {
        strncpy(
            LibName,
            CFE_ES_LibRecordGetName(LibRecPtr),
            BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        *LibName.offset(BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) =
            '\0' as i32 as libc::c_char;
        Result = 0 as libc::c_int;
    } else {
        *LibName.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
        Result = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetLibName\0"))
            .as_ptr(),
        928 as libc::c_int,
    );
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetTaskIDByName(
    mut TaskIdPtr: *mut CFE_ES_TaskId_t,
    mut TaskName: *const libc::c_char,
) -> CFE_Status_t {
    let mut OsalId: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut OsStatus: int32 = 0;
    let mut Result: CFE_Status_t = 0;
    if TaskName.is_null() || TaskIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_TaskGetIdByName(&mut OsalId, TaskName);
    if OsStatus == 0 as libc::c_int {
        Result = 0 as libc::c_int;
        *TaskIdPtr = CFE_ES_TaskId_FromOSAL(OsalId);
    } else {
        Result = 0xc4000002 as libc::c_uint as CFE_Status_t;
        *TaskIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetTaskName(
    mut TaskName: *mut libc::c_char,
    mut TaskId: CFE_ES_TaskId_t,
    mut BufferLength: size_t,
) -> CFE_Status_t {
    let mut OsStatus: int32 = 0;
    let mut OsalId: osal_id_t = 0;
    if BufferLength == 0 as libc::c_int as libc::c_ulong || TaskName.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if !CFE_ResourceId_IsDefined(TaskId) {
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    OsalId = CFE_ES_TaskId_ToOSAL(TaskId);
    OsStatus = OS_GetResourceName(OsalId, TaskName, BufferLength);
    if OsStatus == -(16 as libc::c_int) {
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    if OsStatus == -(13 as libc::c_int) {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s(): Unexpected error from OS_GetResourceName(): %ld\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_GetTaskName\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn CFE_ES_MemPoolRecordIsMatch(
    mut PoolRecPtr: *const CFE_ES_MemPoolRecord_t,
    mut PoolID: CFE_ES_MemHandle_t,
) -> bool {
    return !PoolRecPtr.is_null()
        && CFE_ResourceId_Equal((*PoolRecPtr).PoolID, PoolID) as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn CFE_ES_CounterRecordSetUsed(
    mut CounterRecPtr: *mut CFE_ES_GenCounterRecord_t,
    mut PendingId: CFE_ResourceId_t,
) {
    (*CounterRecPtr).CounterId = PendingId;
}
#[inline]
unsafe extern "C" fn CFE_ES_CounterRecordIsUsed(
    mut CounterRecPtr: *const CFE_ES_GenCounterRecord_t,
) -> bool {
    return CFE_ResourceId_IsDefined((*CounterRecPtr).CounterId);
}
#[inline]
unsafe extern "C" fn CFE_ES_CounterRecordGetName(
    mut CounterRecPtr: *const CFE_ES_GenCounterRecord_t,
) -> *const libc::c_char {
    return ((*CounterRecPtr).CounterName).as_ptr();
}
#[inline]
unsafe extern "C" fn CFE_ES_CounterRecordSetFree(
    mut CounterRecPtr: *mut CFE_ES_GenCounterRecord_t,
) {
    (*CounterRecPtr).CounterId = 0 as libc::c_int as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn CFE_ES_CounterRecordIsMatch(
    mut CounterRecPtr: *const CFE_ES_GenCounterRecord_t,
    mut CounterID: CFE_ES_CounterId_t,
) -> bool {
    return !CounterRecPtr.is_null()
        && CFE_ResourceId_Equal((*CounterRecPtr).CounterId, CounterID) as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn CFE_ES_CounterRecordGetID(
    mut CounterRecPtr: *const CFE_ES_GenCounterRecord_t,
) -> CFE_ES_CounterId_t {
    return (*CounterRecPtr).CounterId;
}
#[inline]
unsafe extern "C" fn CFE_ES_AppRecordGetID(
    mut AppRecPtr: *const CFE_ES_AppRecord_t,
) -> CFE_ES_AppId_t {
    return (*AppRecPtr).AppId;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetAppID(mut AppIdPtr: *mut CFE_ES_AppId_t) -> CFE_Status_t {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut Result: int32 = 0;
    if AppIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_GetAppID\0")).as_ptr(),
        793 as libc::c_int,
    );
    AppRecPtr = CFE_ES_GetAppRecordByContext();
    if !AppRecPtr.is_null() {
        *AppIdPtr = CFE_ES_AppRecordGetID(AppRecPtr);
        Result = 0 as libc::c_int;
    } else {
        *AppIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
        Result = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_GetAppID\0")).as_ptr(),
        808 as libc::c_int,
    );
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetTaskID(mut TaskIdPtr: *mut CFE_ES_TaskId_t) -> CFE_Status_t {
    let mut Result: int32 = 0;
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    if TaskIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_GetTaskID\0")).as_ptr(),
        829 as libc::c_int,
    );
    TaskRecPtr = CFE_ES_GetTaskRecordByContext();
    if TaskRecPtr.is_null() {
        *TaskIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
        Result = 0xc4000001 as libc::c_uint as CFE_Status_t;
    } else {
        *TaskIdPtr = CFE_ES_TaskRecordGetID(TaskRecPtr);
        Result = 0 as libc::c_int;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_GetTaskID\0")).as_ptr(),
        841 as libc::c_int,
    );
    return Result;
}
#[inline]
unsafe extern "C" fn CFE_ES_CDSBlockRecordGetID(
    mut CDSBlockRecPtr: *const CFE_ES_CDS_RegRec_t,
) -> CFE_ES_CDSHandle_t {
    return (*CDSBlockRecPtr).BlockID;
}
#[inline]
unsafe extern "C" fn CFE_ES_CDSBlockRecordGetUserSize(
    mut CDSBlockRecPtr: *const CFE_ES_CDS_RegRec_t,
) -> size_t {
    return ((*CDSBlockRecPtr).BlockSize)
        .wrapping_sub(::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetAppName(
    mut AppName: *mut libc::c_char,
    mut AppId: CFE_ES_AppId_t,
    mut BufferLength: size_t,
) -> CFE_Status_t {
    let mut Result: int32 = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    if BufferLength == 0 as libc::c_int as libc::c_ulong || AppName.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    AppRecPtr = CFE_ES_LocateAppRecordByID(AppId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetAppName\0"))
            .as_ptr(),
        866 as libc::c_int,
    );
    if CFE_ES_AppRecordIsMatch(AppRecPtr, AppId) {
        strncpy(
            AppName,
            CFE_ES_AppRecordGetName(AppRecPtr),
            BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        *AppName.offset(BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) =
            '\0' as i32 as libc::c_char;
        Result = 0 as libc::c_int;
    } else {
        *AppName.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
        Result = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetAppName\0"))
            .as_ptr(),
        884 as libc::c_int,
    );
    return Result;
}
#[inline]
unsafe extern "C" fn CFE_ES_MemPoolRecordSetUsed(
    mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t,
    mut PendingId: CFE_ResourceId_t,
) {
    (*PoolRecPtr).PoolID = PendingId;
}
#[inline]
unsafe extern "C" fn CFE_ES_TaskRecordGetName(
    mut TaskRecPtr: *const CFE_ES_TaskRecord_t,
) -> *const libc::c_char {
    return ((*TaskRecPtr).TaskName).as_ptr();
}
#[inline]
unsafe extern "C" fn CFE_ES_CDSBlockRecordSetUsed(
    mut CDSBlockRecPtr: *mut CFE_ES_CDS_RegRec_t,
    mut PendingId: CFE_ResourceId_t,
) {
    (*CDSBlockRecPtr).BlockID = PendingId;
}
#[inline]
unsafe extern "C" fn CFE_ES_CDSBlockRecordIsMatch(
    mut CDSBlockRecPtr: *const CFE_ES_CDS_RegRec_t,
    mut BlockID: CFE_ES_CDSHandle_t,
) -> bool {
    return !CDSBlockRecPtr.is_null()
        && CFE_ResourceId_Equal((*CDSBlockRecPtr).BlockID, BlockID) as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn CFE_ES_AppRecordIsMatch(
    mut AppRecPtr: *const CFE_ES_AppRecord_t,
    mut AppID: CFE_ES_AppId_t,
) -> bool {
    return !AppRecPtr.is_null()
        && CFE_ResourceId_Equal((*AppRecPtr).AppId, AppID) as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn CFE_ES_LibRecordIsMatch(
    mut LibRecPtr: *const CFE_ES_LibRecord_t,
    mut LibID: CFE_ES_LibId_t,
) -> bool {
    return !LibRecPtr.is_null()
        && CFE_ResourceId_Equal((*LibRecPtr).LibId, LibID) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetAppInfo(
    mut AppInfo: *mut CFE_ES_AppInfo_t,
    mut AppId: CFE_ES_AppId_t,
) -> CFE_Status_t {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut Status: int32 = 0;
    let mut ModuleId: osal_id_t = 0;
    let mut i: uint32 = 0;
    if AppInfo.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Invalid Parameter ( Null Pointer )\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetAppInfo\0"))
                .as_ptr(),
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    memset(
        AppInfo as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_AppInfo_t>() as libc::c_ulong,
    );
    ModuleId = 0 as libc::c_int as osal_id_t;
    AppRecPtr = CFE_ES_LocateAppRecordByID(AppId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetAppInfo\0"))
            .as_ptr(),
        1005 as libc::c_int,
    );
    if !CFE_ES_AppRecordIsMatch(AppRecPtr, AppId) {
        CFE_ES_WriteToSysLog(
            b"%s: App ID not active: %lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetAppInfo\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(AppId),
        );
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
    } else {
        (*AppInfo).ResourceId = AppId;
        (*AppInfo).Type = (*AppRecPtr).Type as uint32;
        strncpy(
            ((*AppInfo).Name).as_mut_ptr(),
            CFE_ES_AppRecordGetName(AppRecPtr),
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        CFE_ES_CopyModuleBasicInfo(&mut (*AppRecPtr).StartParams.BasicInfo, AppInfo);
        CFE_ES_CopyModuleStatusInfo(&mut (*AppRecPtr).LoadStatus, AppInfo);
        (*AppInfo).ExceptionAction = (*AppRecPtr).StartParams.ExceptionAction;
        (*AppInfo).MainTaskId = (*AppRecPtr).MainTaskId;
        ModuleId = (*AppRecPtr).LoadStatus.ModuleId;
        (*AppInfo).NumOfChildTasks = 0 as libc::c_int as uint32;
        TaskRecPtr = (CFE_ES_Global.TaskTable).as_mut_ptr();
        i = 0 as libc::c_int as uint32;
        while i < 64 as libc::c_int as libc::c_uint {
            if CFE_ES_TaskRecordIsUsed(TaskRecPtr) as libc::c_int != 0
                && CFE_ResourceId_Equal((*TaskRecPtr).AppId, AppId) as libc::c_int != 0
            {
                if CFE_ResourceId_Equal(CFE_ES_TaskRecordGetID(TaskRecPtr), (*AppInfo).MainTaskId) {
                    (*AppInfo).ExecutionCounter = (*TaskRecPtr).ExecutionCounter;
                    strncpy(
                        ((*AppInfo).MainTaskName).as_mut_ptr(),
                        ((*TaskRecPtr).TaskName).as_mut_ptr(),
                        (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    );
                    (*AppInfo).MainTaskName[(::core::mem::size_of::<[libc::c_char; 20]>()
                        as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        as usize] = '\0' as i32 as libc::c_char;
                    (*AppInfo).StackSize =
                        (*TaskRecPtr).StartParams.StackSize as CFE_ES_MemOffset_t;
                    (*AppInfo).Priority = (*TaskRecPtr).StartParams.Priority;
                } else {
                    (*AppInfo).NumOfChildTasks = ((*AppInfo).NumOfChildTasks).wrapping_add(1);
                    (*AppInfo).NumOfChildTasks;
                }
            }
            TaskRecPtr = TaskRecPtr.offset(1);
            TaskRecPtr;
            i = i.wrapping_add(1);
            i;
        }
        Status = 0 as libc::c_int;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetAppInfo\0"))
            .as_ptr(),
        1062 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_ES_CopyModuleAddressInfo(ModuleId, AppInfo);
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ResetCFE(mut ResetType: uint32) -> CFE_Status_t {
    let mut ReturnCode: int32 = 0;
    if ResetType == 1 as libc::c_int as libc::c_uint {
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount =
            ((*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount).wrapping_add(1);
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount;
        if (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount
            > (*CFE_ES_Global.ResetDataPtr)
                .ResetVars
                .MaxProcessorResetCount
        {
            CFE_ES_WriteToSysLog(
                b"%s: POWER ON RESET due to max proc resets (Commanded).\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_ResetCFE\0"))
                    .as_ptr(),
            );
            CFE_ES_WriteToERLog(
                CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                2 as libc::c_int as uint32,
                5 as libc::c_int as uint32,
                b"POWER ON RESET due to max proc resets (Commanded).\0" as *const u8
                    as *const libc::c_char,
            );
            CFE_PSP_Restart(2 as libc::c_int as uint32);
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: PROCESSOR RESET called from CFE_ES_ResetCFE (Commanded).\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_ResetCFE\0"))
                    .as_ptr(),
            );
            (*CFE_ES_Global.ResetDataPtr).ResetVars.ES_CausedReset = 1 as libc::c_int as uint32;
            CFE_ES_WriteToERLog(
                CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                1 as libc::c_int as uint32,
                5 as libc::c_int as uint32,
                b"PROCESSOR RESET called from CFE_ES_ResetCFE (Commanded).\0" as *const u8
                    as *const libc::c_char,
            );
            CFE_PSP_Restart(1 as libc::c_int as uint32);
        }
        ReturnCode = 0xc400ffff as libc::c_uint as CFE_Status_t;
    } else if ResetType == 2 as libc::c_int as libc::c_uint {
        CFE_ES_WriteToSysLog(
            b"%s: POWERON RESET called from CFE_ES_ResetCFE (Commanded).\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_ResetCFE\0"))
                .as_ptr(),
        );
        CFE_ES_WriteToERLog(
            CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
            2 as libc::c_int as uint32,
            5 as libc::c_int as uint32,
            b"POWERON RESET called from CFE_ES_ResetCFE (Commanded).\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Restart(2 as libc::c_int as uint32);
        ReturnCode = 0xc400ffff as libc::c_uint as CFE_Status_t;
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Invalid Reset Type: %d.\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_ResetCFE\0"))
                .as_ptr(),
            ResetType as libc::c_int,
        );
        ReturnCode = 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ExitApp(mut ExitStatus: uint32) {
    let mut ReturnCode: int32 = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_ExitApp\0")).as_ptr(),
        345 as libc::c_int,
    );
    if ExitStatus == CFE_ES_RunStatus_UNDEFINED as libc::c_int as libc::c_uint
        || ExitStatus >= CFE_ES_RunStatus_MAX as libc::c_int as libc::c_uint
    {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Called with invalid status (%u).\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_ExitApp\0"))
                .as_ptr(),
            ExitStatus,
        );
        ExitStatus = CFE_ES_RunStatus_APP_ERROR as libc::c_int as uint32;
    }
    AppRecPtr = CFE_ES_GetAppRecordByContext();
    if !AppRecPtr.is_null() {
        if (*AppRecPtr).ControlReq.AppControlRequest
            == CFE_ES_RunStatus_APP_RUN as libc::c_int as libc::c_uint
        {
            (*AppRecPtr).ControlReq.AppControlRequest = ExitStatus;
        }
        if (*AppRecPtr).Type as libc::c_int == CFE_ES_AppType_CORE as libc::c_int {
            if ExitStatus == CFE_ES_RunStatus_CORE_APP_INIT_ERROR as libc::c_int as libc::c_uint {
                CFE_ES_SysLogWrite_Unsync(
                    b"%s: CORE Application %s Had an Init Error.\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(
                        b"CFE_ES_ExitApp\0",
                    ))
                    .as_ptr(),
                    CFE_ES_AppRecordGetName(AppRecPtr),
                );
                CFE_ES_UnlockSharedData(
                    (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(
                        b"CFE_ES_ExitApp\0",
                    ))
                    .as_ptr(),
                    394 as libc::c_int,
                );
                ReturnCode = CFE_ES_ResetCFE(1 as libc::c_int as uint32);
                CFE_ES_WriteToSysLog(
                    b"%s: CORE Application Init Error Processor Reset, RC = 0x%08X\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(
                        b"CFE_ES_ExitApp\0",
                    ))
                    .as_ptr(),
                    ReturnCode as libc::c_uint,
                );
                return;
            } else if ExitStatus
                == CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR as libc::c_int as libc::c_uint
            {
                CFE_ES_SysLogWrite_Unsync(
                    b"%s: CORE Application %s Had a Runtime Error.\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(
                        b"CFE_ES_ExitApp\0",
                    ))
                    .as_ptr(),
                    CFE_ES_AppRecordGetName(AppRecPtr),
                );
                CFE_ES_UnlockSharedData(
                    (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(
                        b"CFE_ES_ExitApp\0",
                    ))
                    .as_ptr(),
                    419 as libc::c_int,
                );
                OS_TaskExit();
                return;
            } else {
                CFE_ES_SysLogWrite_Unsync(
                    b"%s: Cannot Exit CORE Application %s\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(
                        b"CFE_ES_ExitApp\0",
                    ))
                    .as_ptr(),
                    CFE_ES_AppRecordGetName(AppRecPtr),
                );
            }
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Application %s called CFE_ES_ExitApp\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_ExitApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            (*AppRecPtr).AppState =
                CFE_ES_AppState_STOPPED as libc::c_int as CFE_ES_AppState_Enum_t;
            CFE_ES_UnlockSharedData(
                (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_ExitApp\0"))
                    .as_ptr(),
                447 as libc::c_int,
            );
            loop {
                OS_TaskDelay(500 as libc::c_int as uint32);
            }
        }
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_ES_ExitApp\0")).as_ptr(),
        461 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetLibIDByName(
    mut LibIdPtr: *mut CFE_ES_LibId_t,
    mut LibName: *const libc::c_char,
) -> CFE_Status_t {
    let mut LibRecPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    let mut Result: int32 = 0;
    if LibName.is_null() || LibIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_GetLibIDByName\0"))
            .as_ptr(),
        721 as libc::c_int,
    );
    LibRecPtr = CFE_ES_LocateLibRecordByName(LibName);
    if LibRecPtr.is_null() {
        Result = 0xc4000002 as libc::c_uint as CFE_Status_t;
        *LibIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
    } else {
        Result = 0 as libc::c_int;
        *LibIdPtr = CFE_ES_LibRecordGetID(LibRecPtr);
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_GetLibIDByName\0"))
            .as_ptr(),
        739 as libc::c_int,
    );
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ReloadApp(
    mut AppID: CFE_ES_AppId_t,
    mut AppFileName: *const libc::c_char,
) -> CFE_Status_t {
    let mut ReturnCode: int32 = 0 as libc::c_int;
    let mut FileStatus: os_fstat_t = os_fstat_t {
        FileModeBits: 0,
        FileTime: OS_time_t { ticks: 0 },
        FileSize: 0,
    };
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = CFE_ES_LocateAppRecordByID(AppID);
    if !AppRecPtr.is_null() {
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_ReloadApp\0"))
                .as_ptr(),
            232 as libc::c_int,
        );
        if (*AppRecPtr).Type as libc::c_int == CFE_ES_AppType_CORE as libc::c_int {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Reload a CORE Application: %s.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_ReloadApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        } else if (*AppRecPtr).AppState != CFE_ES_AppState_RUNNING as libc::c_int as libc::c_uint {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Reload Application %s, It is not running.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_ReloadApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        } else if OS_stat(AppFileName, &mut FileStatus) == 0 as libc::c_int {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Reload Application %s Initiated. New filename = %s\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_ReloadApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
                AppFileName,
            );
            strncpy(
                ((*AppRecPtr).StartParams.BasicInfo.FileName).as_mut_ptr(),
                AppFileName,
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*AppRecPtr).StartParams.BasicInfo.FileName[(::core::mem::size_of::<[libc::c_char; 64]>(
            ) as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
            (*AppRecPtr).ControlReq.AppControlRequest =
                CFE_ES_RunStatus_SYS_RELOAD as libc::c_int as uint32;
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Reload Application %s, File %s does not exist.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_ReloadApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
                AppFileName,
            );
            ReturnCode = 0xc4000014 as libc::c_uint as CFE_Status_t;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_ReloadApp\0"))
                .as_ptr(),
            271 as libc::c_int,
        );
    } else {
        ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        CFE_ES_WriteToSysLog(
            b"%s: Invalid Application ID received, AppID = %lu\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_ReloadApp\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(AppID),
        );
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RestartApp(mut AppID: CFE_ES_AppId_t) -> CFE_Status_t {
    let mut ReturnCode: int32 = 0 as libc::c_int;
    let mut FileStatus: os_fstat_t = os_fstat_t {
        FileModeBits: 0,
        FileTime: OS_time_t { ticks: 0 },
        FileSize: 0,
    };
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    AppRecPtr = CFE_ES_LocateAppRecordByID(AppID);
    if !AppRecPtr.is_null() {
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RestartApp\0"))
                .as_ptr(),
            168 as libc::c_int,
        );
        if (*AppRecPtr).Type as libc::c_int == CFE_ES_AppType_CORE as libc::c_int {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Restart a CORE Application: %s.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RestartApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        } else if (*AppRecPtr).AppState != CFE_ES_AppState_RUNNING as libc::c_int as libc::c_uint {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Restart Application %s, It is not running.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RestartApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        } else if OS_stat(
            ((*AppRecPtr).StartParams.BasicInfo.FileName).as_mut_ptr(),
            &mut FileStatus,
        ) == 0 as libc::c_int
        {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Restart Application %s Initiated\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RestartApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            (*AppRecPtr).ControlReq.AppControlRequest =
                CFE_ES_RunStatus_SYS_RESTART as libc::c_int as uint32;
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Restart Application %s, File %s does not exist.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RestartApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
                ((*AppRecPtr).StartParams.BasicInfo.FileName).as_mut_ptr(),
            );
            ReturnCode = 0xc4000014 as libc::c_uint as CFE_Status_t;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RestartApp\0"))
                .as_ptr(),
            205 as libc::c_int,
        );
    } else {
        ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        CFE_ES_WriteToSysLog(
            b"%s: Invalid Application ID received, AppID = %lu\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RestartApp\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(AppID),
        );
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_DeleteApp(mut AppID: CFE_ES_AppId_t) -> CFE_Status_t {
    let mut ReturnCode: int32 = 0 as libc::c_int;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = CFE_ES_LocateAppRecordByID(AppID);
    if !AppRecPtr.is_null() {
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_DeleteApp\0"))
                .as_ptr(),
            297 as libc::c_int,
        );
        if (*AppRecPtr).Type as libc::c_int == CFE_ES_AppType_CORE as libc::c_int {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Delete a CORE Application: %s.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_DeleteApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        } else if (*AppRecPtr).AppState != CFE_ES_AppState_RUNNING as libc::c_int as libc::c_uint {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Cannot Delete Application %s, It is not running.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_DeleteApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Delete Application %s Initiated\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_DeleteApp\0"))
                    .as_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
            );
            (*AppRecPtr).ControlReq.AppControlRequest =
                CFE_ES_RunStatus_SYS_DELETE as libc::c_int as uint32;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_DeleteApp\0"))
                .as_ptr(),
            321 as libc::c_int,
        );
    } else {
        ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        CFE_ES_WriteToSysLog(
            b"%s: Invalid Application ID received, AppID = %lu\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_DeleteApp\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(AppID),
        );
    }
    return ReturnCode;
}
#[inline]
unsafe extern "C" fn CFE_ES_TaskRecordIsMatch(
    mut TaskRecPtr: *const CFE_ES_TaskRecord_t,
    mut TaskID: CFE_ES_TaskId_t,
) -> bool {
    return !TaskRecPtr.is_null()
        && CFE_ResourceId_Equal((*TaskRecPtr).TaskId, TaskID) as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn CFE_ES_TaskRecordIsUsed(mut TaskRecPtr: *const CFE_ES_TaskRecord_t) -> bool {
    return CFE_ResourceId_IsDefined((*TaskRecPtr).TaskId);
}
#[inline]
unsafe extern "C" fn CFE_ES_TaskRecordSetUsed(
    mut TaskRecPtr: *mut CFE_ES_TaskRecord_t,
    mut PendingId: CFE_ResourceId_t,
) {
    (*TaskRecPtr).TaskId = PendingId;
}
#[inline]
unsafe extern "C" fn CFE_ES_TaskRecordGetID(
    mut TaskRecPtr: *const CFE_ES_TaskRecord_t,
) -> CFE_ES_TaskId_t {
    return (*TaskRecPtr).TaskId;
}
#[inline]
unsafe extern "C" fn CFE_ES_AppRecordSetUsed(
    mut AppRecPtr: *mut CFE_ES_AppRecord_t,
    mut PendingId: CFE_ResourceId_t,
) {
    (*AppRecPtr).AppId = PendingId;
}
#[inline]
unsafe extern "C" fn CFE_ES_AppRecordSetFree(mut AppRecPtr: *mut CFE_ES_AppRecord_t) {
    (*AppRecPtr).AppId = 0 as libc::c_int as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn CFE_ES_LibRecordGetName(
    mut LibRecPtr: *const CFE_ES_LibRecord_t,
) -> *const libc::c_char {
    return ((*LibRecPtr).LibName).as_ptr();
}
#[inline]
unsafe extern "C" fn CFE_ES_AppRecordGetName(
    mut AppRecPtr: *const CFE_ES_AppRecord_t,
) -> *const libc::c_char {
    return ((*AppRecPtr).AppName).as_ptr();
}
#[inline]
unsafe extern "C" fn CFE_ES_LibRecordGetID(
    mut LibRecPtr: *const CFE_ES_LibRecord_t,
) -> CFE_ES_LibId_t {
    return (*LibRecPtr).LibId;
}
#[inline]
unsafe extern "C" fn CFE_ES_LibRecordIsUsed(mut LibRecPtr: *const CFE_ES_LibRecord_t) -> bool {
    return CFE_ResourceId_IsDefined((*LibRecPtr).LibId);
}
#[inline]
unsafe extern "C" fn CFE_ES_TaskRecordSetFree(mut TaskRecPtr: *mut CFE_ES_TaskRecord_t) {
    (*TaskRecPtr).TaskId = 0 as libc::c_int as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn CFE_ES_MemPoolRecordSetFree(mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t) {
    (*PoolRecPtr).PoolID = 0 as libc::c_int as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn CFE_ES_MemPoolRecordGetID(
    mut PoolRecPtr: *const CFE_ES_MemPoolRecord_t,
) -> CFE_ES_MemHandle_t {
    return (*PoolRecPtr).PoolID;
}
#[inline]
unsafe extern "C" fn CFE_ES_MemPoolRecordIsUsed(
    mut PoolRecPtr: *const CFE_ES_MemPoolRecord_t,
) -> bool {
    return CFE_ResourceId_IsDefined((*PoolRecPtr).PoolID);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetResetType(mut ResetSubtypePtr: *mut uint32) -> int32 {
    if !ResetSubtypePtr.is_null() {
        *ResetSubtypePtr = (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype;
    }
    return (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetType as int32;
}
#[inline]
unsafe extern "C" fn CFE_ES_LibRecordSetUsed(
    mut LibRecPtr: *mut CFE_ES_LibRecord_t,
    mut PendingId: CFE_ResourceId_t,
) {
    (*LibRecPtr).LibId = PendingId;
}
#[inline]
unsafe extern "C" fn CFE_ES_LibRecordSetFree(mut LibRecPtr: *mut CFE_ES_LibRecord_t) {
    (*LibRecPtr).LibId = 0 as libc::c_int as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn CFE_ES_AppRecordIsUsed(mut AppRecPtr: *const CFE_ES_AppRecord_t) -> bool {
    return CFE_ResourceId_IsDefined((*AppRecPtr).AppId);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_StatusToString(
    mut status: CFE_Status_t,
    mut status_string: *mut CFE_StatusString_t,
) -> *mut libc::c_char {
    let mut string: *mut libc::c_char = 0 as *mut libc::c_char;
    if !status_string.is_null() {
        snprintf(
            (*status_string).as_mut_ptr(),
            ::core::mem::size_of::<CFE_StatusString_t>() as libc::c_ulong,
            b"0x%08x\0" as *const u8 as *const libc::c_char,
            status as libc::c_uint,
        );
        string = (*status_string).as_mut_ptr();
    }
    return string;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetGenCounterName(
    mut CounterName: *mut libc::c_char,
    mut CounterId: CFE_ES_CounterId_t,
    mut BufferLength: size_t,
) -> CFE_Status_t {
    let mut CountRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    let mut Status: CFE_Status_t = 0;
    if BufferLength == 0 as libc::c_int as libc::c_ulong || CounterName.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CountRecPtr = CFE_ES_LocateCounterRecordByID(CounterId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"CFE_ES_GetGenCounterName\0"))
            .as_ptr(),
        1998 as libc::c_int,
    );
    if CFE_ES_CounterRecordIsMatch(CountRecPtr, CounterId) {
        strncpy(
            CounterName,
            CFE_ES_CounterRecordGetName(CountRecPtr),
            BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        *CounterName
            .offset(BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) =
            0 as libc::c_int as libc::c_char;
        Status = 0 as libc::c_int;
    } else {
        *CounterName.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"CFE_ES_GetGenCounterName\0"))
            .as_ptr(),
        2012 as libc::c_int,
    );
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CreateChildTask(
    mut TaskIdPtr: *mut CFE_ES_TaskId_t,
    mut TaskName: *const libc::c_char,
    mut FunctionPtr: CFE_ES_ChildTaskMainFuncPtr_t,
    mut StackPtr: CFE_ES_StackPointer_t,
    mut StackSize: size_t,
    mut Priority: CFE_ES_TaskPriority_Atom_t,
    mut Flags: uint32,
) -> CFE_Status_t {
    let mut ReturnCode: int32 = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut ParentAppId: CFE_ES_AppId_t = 0;
    let mut SelfTaskId: CFE_ES_TaskId_t = 0;
    let mut Params: CFE_ES_TaskStartParams_t = CFE_ES_TaskStartParams_t {
        StackSize: 0,
        Priority: 0,
    };
    ParentAppId = 0 as libc::c_int as CFE_ResourceId_t;
    memset(
        &mut Params as *mut CFE_ES_TaskStartParams_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_TaskStartParams_t>() as libc::c_ulong,
    );
    Params.Priority = Priority;
    Params.StackSize = StackSize;
    if TaskIdPtr.is_null() {
        if TaskName.is_null() {
            CFE_ES_WriteToSysLog(
                b"%s: Task Id and Name Pointer Parameters are NULL.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"CFE_ES_CreateChildTask\0",
                ))
                .as_ptr(),
            );
            ReturnCode = 0xc400000a as libc::c_uint as CFE_Status_t;
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Task Id Pointer Parameter is NULL for Task '%s'.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"CFE_ES_CreateChildTask\0",
                ))
                .as_ptr(),
                TaskName,
            );
            ReturnCode = 0xc400000a as libc::c_uint as CFE_Status_t;
        }
    } else if TaskName.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: TaskName Parameter is NULL\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_CreateChildTask\0",
            ))
            .as_ptr(),
        );
        ReturnCode = 0xc400000a as libc::c_uint as CFE_Status_t;
    } else if FunctionPtr.is_none() {
        CFE_ES_WriteToSysLog(
            b"%s: Function Pointer Parameter is NULL for Task '%s'\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_CreateChildTask\0",
            ))
            .as_ptr(),
            TaskName,
        );
        ReturnCode = 0xc400000a as libc::c_uint as CFE_Status_t;
    } else {
        SelfTaskId = CFE_ES_TaskId_FromOSAL(OS_TaskGetId());
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_CreateChildTask\0",
            ))
            .as_ptr(),
            1297 as libc::c_int,
        );
        AppRecPtr = CFE_ES_GetAppRecordByContext();
        if AppRecPtr.is_null() {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Invalid calling context when creating Task '%s'\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"CFE_ES_CreateChildTask\0",
                ))
                .as_ptr(),
                TaskName,
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        } else if !CFE_ResourceId_Equal(SelfTaskId, (*AppRecPtr).MainTaskId) {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Error: Cannot call from a Child Task (for Task '%s').\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"CFE_ES_CreateChildTask\0",
                ))
                .as_ptr(),
                TaskName,
            );
            ReturnCode = 0xc4000005 as libc::c_uint as CFE_Status_t;
        } else {
            ParentAppId = CFE_ES_AppRecordGetID(AppRecPtr);
            ReturnCode = 0 as libc::c_int;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_CreateChildTask\0",
            ))
            .as_ptr(),
            1320 as libc::c_int,
        );
    }
    if ReturnCode == 0 as libc::c_int {
        ReturnCode =
            CFE_ES_StartAppTask(TaskIdPtr, TaskName, FunctionPtr, &mut Params, ParentAppId);
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ProcessAsyncEvent() {
    CFE_ES_BackgroundWakeup();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SetGenCount(
    mut CounterId: CFE_ES_CounterId_t,
    mut Count: uint32,
) -> CFE_Status_t {
    let mut Status: int32 = 0xc400000a as libc::c_uint as CFE_Status_t;
    let mut CountRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    CountRecPtr = CFE_ES_LocateCounterRecordByID(CounterId);
    if CFE_ES_CounterRecordIsMatch(CountRecPtr, CounterId) {
        (*CountRecPtr).Counter = Count;
        Status = 0 as libc::c_int;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_IncrementGenCounter(
    mut CounterId: CFE_ES_CounterId_t,
) -> CFE_Status_t {
    let mut Status: int32 = 0xc400000a as libc::c_uint as CFE_Status_t;
    let mut CountRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    CountRecPtr = CFE_ES_LocateCounterRecordByID(CounterId);
    if CFE_ES_CounterRecordIsMatch(CountRecPtr, CounterId) {
        (*CountRecPtr).Counter = ((*CountRecPtr).Counter).wrapping_add(1);
        (*CountRecPtr).Counter;
        Status = 0 as libc::c_int;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_DeleteGenCounter(
    mut CounterId: CFE_ES_CounterId_t,
) -> CFE_Status_t {
    let mut CountRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    let mut Status: int32 = 0xc400000a as libc::c_uint as CFE_Status_t;
    CountRecPtr = CFE_ES_LocateCounterRecordByID(CounterId);
    if !CountRecPtr.is_null() {
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_ES_DeleteGenCounter\0",
            ))
            .as_ptr(),
            1865 as libc::c_int,
        );
        if CFE_ES_CounterRecordIsMatch(CountRecPtr, CounterId) {
            (*CountRecPtr).Counter = 0 as libc::c_int as uint32;
            CFE_ES_CounterRecordSetFree(CountRecPtr);
            Status = 0 as libc::c_int;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_ES_DeleteGenCounter\0",
            ))
            .as_ptr(),
            1872 as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RegisterGenCounter(
    mut CounterIdPtr: *mut CFE_ES_CounterId_t,
    mut CounterName: *const libc::c_char,
) -> CFE_Status_t {
    let mut CountRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    let mut PendingResourceId: CFE_ResourceId_t = 0;
    let mut Status: int32 = 0;
    if CounterName.is_null() || CounterIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if strlen(CounterName) >= ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(b"CFE_ES_RegisterGenCounter\0"))
            .as_ptr(),
        1810 as libc::c_int,
    );
    CountRecPtr = CFE_ES_LocateCounterRecordByName(CounterName);
    if !CountRecPtr.is_null() {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Duplicate Counter name '%s'\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
                b"CFE_ES_RegisterGenCounter\0",
            ))
            .as_ptr(),
            CounterName,
        );
        Status = 0xc400002e as libc::c_uint as CFE_Status_t;
        PendingResourceId = 0 as libc::c_int as CFE_ResourceId_t;
    } else {
        PendingResourceId = CFE_ResourceId_FindNext(
            CFE_ES_Global.LastCounterId,
            8 as libc::c_int as uint32,
            Some(CFE_ES_CheckCounterIdSlotUsed as unsafe extern "C" fn(CFE_ResourceId_t) -> bool),
        );
        CountRecPtr = CFE_ES_LocateCounterRecordByID(PendingResourceId);
        if CountRecPtr.is_null() {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: No free Counter slots available\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(
                    b"CFE_ES_RegisterGenCounter\0",
                ))
                .as_ptr(),
            );
            Status = 0xc400002b as libc::c_uint as CFE_Status_t;
        } else {
            strncpy(
                ((*CountRecPtr).CounterName).as_mut_ptr(),
                CounterName,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*CountRecPtr).CounterName[(::core::mem::size_of::<[libc::c_char; 20]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = '\0' as i32 as libc::c_char;
            (*CountRecPtr).Counter = 0 as libc::c_int as uint32;
            CFE_ES_CounterRecordSetUsed(CountRecPtr, PendingResourceId);
            CFE_ES_Global.LastCounterId = PendingResourceId;
            Status = 0 as libc::c_int;
        }
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 26], &[libc::c_char; 26]>(b"CFE_ES_RegisterGenCounter\0"))
            .as_ptr(),
        1845 as libc::c_int,
    );
    *CounterIdPtr = PendingResourceId;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetCDSBlockName(
    mut BlockName: *mut libc::c_char,
    mut BlockId: CFE_ES_CDSHandle_t,
    mut BufferLength: size_t,
) -> CFE_Status_t {
    let mut Status: CFE_Status_t = 0;
    let mut RegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    if BufferLength == 0 as libc::c_int as libc::c_ulong || BlockName.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if !CFE_ES_Global.CDSIsAvailable {
        return 0xc400ffff as libc::c_uint as CFE_Status_t;
    }
    RegRecPtr = CFE_ES_LocateCDSBlockRecordByID(BlockId);
    CFE_ES_LockCDS();
    if CFE_ES_CDSBlockRecordIsMatch(RegRecPtr, BlockId) {
        strncpy(
            BlockName,
            ((*RegRecPtr).Name).as_mut_ptr(),
            BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        *BlockName.offset(BufferLength.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize) =
            0 as libc::c_int as libc::c_char;
        Status = 0 as libc::c_int;
    } else {
        *BlockName.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockCDS();
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetTaskInfo(
    mut TaskInfo: *mut CFE_ES_TaskInfo_t,
    mut TaskId: CFE_ES_TaskId_t,
) -> CFE_Status_t {
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut Status: int32 = 0;
    if TaskInfo.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Invalid Parameter ( Null Pointer )\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_GetTaskInfo\0"))
                .as_ptr(),
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    memset(
        TaskInfo as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_TaskInfo_t>() as libc::c_ulong,
    );
    TaskRecPtr = CFE_ES_LocateTaskRecordByID(TaskId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_GetTaskInfo\0"))
            .as_ptr(),
        1190 as libc::c_int,
    );
    if !CFE_ES_TaskRecordIsMatch(TaskRecPtr, TaskId) {
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Task ID Not Active: %lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_GetTaskInfo\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(TaskId),
        );
    } else {
        (*TaskInfo).AppId = (*TaskRecPtr).AppId;
        strncpy(
            ((*TaskInfo).TaskName).as_mut_ptr(),
            CFE_ES_TaskRecordGetName(TaskRecPtr),
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*TaskInfo).TaskName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as usize] = '\0' as i32 as libc::c_char;
        (*TaskInfo).TaskId = CFE_ES_TaskRecordGetID(TaskRecPtr);
        (*TaskInfo).ExecutionCounter = (*TaskRecPtr).ExecutionCounter;
        (*TaskInfo).StackSize = (*TaskRecPtr).StartParams.StackSize as CFE_ES_MemOffset_t;
        (*TaskInfo).Priority = (*TaskRecPtr).StartParams.Priority;
        AppRecPtr = CFE_ES_LocateAppRecordByID((*TaskRecPtr).AppId);
        if CFE_ES_AppRecordIsMatch(AppRecPtr, (*TaskRecPtr).AppId) {
            strncpy(
                ((*TaskInfo).AppName).as_mut_ptr(),
                CFE_ES_AppRecordGetName(AppRecPtr),
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*TaskInfo).AppName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = '\0' as i32 as libc::c_char;
            Status = 0 as libc::c_int;
        } else {
            Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
        }
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_GetTaskInfo\0"))
            .as_ptr(),
        1236 as libc::c_int,
    );
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RestoreFromCDS(
    mut RestoreToMemory: *mut libc::c_void,
    mut Handle: CFE_ES_CDSHandle_t,
) -> CFE_Status_t {
    if RestoreToMemory.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    return CFE_ES_CDSBlockRead(RestoreToMemory, Handle);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetCDSBlockIDByName(
    mut BlockIdPtr: *mut CFE_ES_CDSHandle_t,
    mut BlockName: *const libc::c_char,
) -> CFE_Status_t {
    let mut Status: CFE_Status_t = 0;
    let mut RegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    if BlockName.is_null() || BlockIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if !CFE_ES_Global.CDSIsAvailable {
        return 0xc400ffff as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockCDS();
    RegRecPtr = CFE_ES_LocateCDSBlockRecordByName(BlockName);
    if !RegRecPtr.is_null() {
        *BlockIdPtr = CFE_ES_CDSBlockRecordGetID(RegRecPtr);
        Status = 0 as libc::c_int;
    } else {
        *BlockIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
        Status = 0xc4000002 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockCDS();
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RegisterCDS(
    mut CDSHandlePtr: *mut CFE_ES_CDSHandle_t,
    mut BlockSize: size_t,
    mut Name: *const libc::c_char,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut NameLen: size_t = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut AppName: [libc::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [libc::c_char; 20],
    >(b"UNKNOWN\0\0\0\0\0\0\0\0\0\0\0\0\0");
    let mut CDSName: [libc::c_char; 40] =
        *::core::mem::transmute::<&[u8; 40], &mut [libc::c_char; 40]>(
            b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        );
    Status = CFE_ES_GetAppID(&mut ThisAppId);
    if CDSHandlePtr.is_null() || Name.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Failed invalid arguments\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_RegisterCDS\0"))
                .as_ptr(),
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    *CDSHandlePtr = 0 as libc::c_int as CFE_ResourceId_t;
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Bad AppId context\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_RegisterCDS\0"))
                .as_ptr(),
        );
    } else if !CFE_ES_Global.CDSIsAvailable {
        CFE_ES_WriteToSysLog(
            b"%s: CDS not available\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_RegisterCDS\0"))
                .as_ptr(),
        );
        Status = 0xc400ffff as libc::c_uint as CFE_Status_t;
    } else {
        NameLen = strlen(Name);
        if NameLen > 16 as libc::c_int as libc::c_ulong
            || NameLen == 0 as libc::c_int as libc::c_ulong
        {
            Status = 0xc400000f as libc::c_uint as CFE_Status_t;
            strncpy(
                CDSName.as_mut_ptr(),
                Name,
                (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            CDSName[(::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
                '\0' as i32 as libc::c_char;
            CFE_ES_WriteToSysLog(
                b"%s: CDS Name (%s) is too long\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(
                    b"CFE_ES_RegisterCDS\0",
                ))
                .as_ptr(),
                CDSName.as_mut_ptr(),
            );
        } else {
            CFE_ES_FormCDSName(CDSName.as_mut_ptr(), Name, ThisAppId);
            Status = CFE_ES_RegisterCDSEx(
                CDSHandlePtr,
                BlockSize,
                CDSName.as_mut_ptr(),
                0 as libc::c_int != 0,
            );
            if Status == 0xc4000010 as libc::c_uint as CFE_Status_t {
                CFE_ES_WriteToSysLog(
                    b"%s: CDS %s has invalid size (%lu)\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(
                        b"CFE_ES_RegisterCDS\0",
                    ))
                    .as_ptr(),
                    Name,
                    BlockSize,
                );
            }
        }
    }
    if Status < 0 as libc::c_int {
        CFE_ES_GetAppName(
            AppName.as_mut_ptr(),
            ThisAppId,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        CFE_EVS_SendEventWithAppID(
            69 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            ThisAppId,
            b"%s Failed to Register CDS '%s', Status=0x%08X\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            Name,
            Status as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ExitChildTask() {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_ExitChildTask\0"))
            .as_ptr(),
        1488 as libc::c_int,
    );
    TaskRecPtr = CFE_ES_GetTaskRecordByContext();
    if !TaskRecPtr.is_null() {
        AppRecPtr = CFE_ES_LocateAppRecordByID((*TaskRecPtr).AppId);
        if CFE_ES_AppRecordIsMatch(AppRecPtr, (*TaskRecPtr).AppId) as libc::c_int != 0
            && !CFE_ES_TaskRecordIsMatch(TaskRecPtr, (*AppRecPtr).MainTaskId)
        {
            CFE_ES_TaskRecordSetFree(TaskRecPtr);
            CFE_ES_Global.RegisteredTasks = (CFE_ES_Global.RegisteredTasks).wrapping_sub(1);
            CFE_ES_Global.RegisteredTasks;
            CFE_ES_UnlockSharedData(
                (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                    b"CFE_ES_ExitChildTask\0",
                ))
                .as_ptr(),
                1508 as libc::c_int,
            );
            OS_TaskExit();
            return;
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Error: Cannot Call from a cFE App Main Task. ID = %lu\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                    b"CFE_ES_ExitChildTask\0",
                ))
                .as_ptr(),
                CFE_ResourceId_ToInteger(CFE_ES_TaskRecordGetID(TaskRecPtr)),
            );
        }
    } else {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Called from invalid task context\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_ExitChildTask\0"))
                .as_ptr(),
        );
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_ExitChildTask\0"))
            .as_ptr(),
        1530 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CopyToCDS(
    mut Handle: CFE_ES_CDSHandle_t,
    mut DataToCopy: *const libc::c_void,
) -> CFE_Status_t {
    if DataToCopy.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    return CFE_ES_CDSBlockWrite(Handle, DataToCopy);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_DeleteChildTask(mut TaskId: CFE_ES_TaskId_t) -> CFE_Status_t {
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut i: uint32 = 0;
    let mut TaskIsMain: bool = false;
    let mut ReturnCode: int32 = 0 as libc::c_int;
    let mut OsStatus: int32 = 0;
    let mut OsalId: osal_id_t = 0;
    TaskRecPtr = CFE_ES_LocateTaskRecordByID(TaskId);
    if !TaskRecPtr.is_null() {
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_DeleteChildTask\0",
            ))
            .as_ptr(),
            1387 as libc::c_int,
        );
        if CFE_ES_TaskRecordIsMatch(TaskRecPtr, TaskId) {
            TaskIsMain = 0 as libc::c_int != 0;
            AppRecPtr = (CFE_ES_Global.AppTable).as_mut_ptr();
            i = 0 as libc::c_int as uint32;
            while i < 32 as libc::c_int as libc::c_uint {
                if CFE_ES_AppRecordIsUsed(AppRecPtr) {
                    if CFE_ResourceId_Equal((*AppRecPtr).MainTaskId, TaskId) {
                        TaskIsMain = 1 as libc::c_int != 0;
                        break;
                    }
                }
                AppRecPtr = AppRecPtr.offset(1);
                AppRecPtr;
                i = i.wrapping_add(1);
                i;
            }
            if TaskIsMain as libc::c_int == 0 as libc::c_int {
                OsalId = CFE_ES_TaskId_ToOSAL(TaskId);
                OsStatus = OS_TaskDelete(OsalId);
                if OsStatus == 0 as libc::c_int {
                    CFE_ES_TaskRecordSetFree(TaskRecPtr);
                    CFE_ES_Global.RegisteredTasks = (CFE_ES_Global.RegisteredTasks).wrapping_sub(1);
                    CFE_ES_Global.RegisteredTasks;
                    CFE_ES_SysLogWrite_Unsync(
                        b"%s: Task %lu Deleted\n\0" as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                            b"CFE_ES_DeleteChildTask\0",
                        ))
                        .as_ptr(),
                        CFE_ResourceId_ToInteger(TaskId),
                    );
                    ReturnCode = 0 as libc::c_int;
                } else {
                    CFE_ES_SysLogWrite_Unsync(
                        b"%s: Error Calling OS_TaskDelete: Task %lu, RC = %ld\n\0" as *const u8
                            as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                            b"CFE_ES_DeleteChildTask\0",
                        ))
                        .as_ptr(),
                        CFE_ResourceId_ToInteger(TaskId),
                        OsStatus as libc::c_long,
                    );
                    ReturnCode = 0xc4000018 as libc::c_uint as CFE_Status_t;
                }
            } else {
                CFE_ES_SysLogWrite_Unsync(
                    b"%s: Error: Task %lu is a cFE Main Task.\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                        b"CFE_ES_DeleteChildTask\0",
                    ))
                    .as_ptr(),
                    CFE_ResourceId_ToInteger(TaskId),
                );
                ReturnCode = 0xc4000019 as libc::c_uint as CFE_Status_t;
            }
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Error: Task ID is not active: %lu\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"CFE_ES_DeleteChildTask\0",
                ))
                .as_ptr(),
                CFE_ResourceId_ToInteger(TaskId),
            );
            ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_DeleteChildTask\0",
            ))
            .as_ptr(),
            1464 as libc::c_int,
        );
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Error: Invalid Task ID: %lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_DeleteChildTask\0",
            ))
            .as_ptr(),
            CFE_ResourceId_ToInteger(TaskId),
        );
        ReturnCode = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CounterID_ToIndex(
    mut CounterId: CFE_ES_CounterId_t,
    mut Idx: *mut uint32,
) -> CFE_Status_t {
    return CFE_ResourceId_ToIndex(
        CounterId,
        CFE_ES_COUNTID_BASE as libc::c_int as uint32,
        8 as libc::c_int as uint32,
        Idx,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetGenCounterIDByName(
    mut CounterIdPtr: *mut CFE_ES_CounterId_t,
    mut CounterName: *const libc::c_char,
) -> CFE_Status_t {
    let mut CounterRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    let mut Result: int32 = 0;
    if CounterName.is_null() || CounterIdPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"CFE_ES_GetGenCounterIDByName\0",
        ))
        .as_ptr(),
        1957 as libc::c_int,
    );
    CounterRecPtr = CFE_ES_LocateCounterRecordByName(CounterName);
    if CounterRecPtr.is_null() {
        Result = 0xc4000002 as libc::c_uint as CFE_Status_t;
        *CounterIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
    } else {
        Result = 0 as libc::c_int;
        *CounterIdPtr = CFE_ES_CounterRecordGetID(CounterRecPtr);
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"CFE_ES_GetGenCounterIDByName\0",
        ))
        .as_ptr(),
        1975 as libc::c_int,
    );
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_WriteToSysLog(
    mut SpecStringPtr: *const libc::c_char,
    mut args: ...
) -> CFE_Status_t {
    let mut TmpString: [libc::c_char; 148] = [0; 148];
    let mut ReturnCode: int32 = 0;
    let mut ArgPtr: ::core::ffi::VaListImpl;
    if SpecStringPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    ArgPtr = args.clone();
    CFE_ES_SysLog_vsnprintf(
        TmpString.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
        SpecStringPtr,
        ArgPtr.as_va_list(),
    );
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_WriteToSysLog\0"))
            .as_ptr(),
        1558 as libc::c_int,
    );
    ReturnCode = CFE_ES_SysLogAppend_Unsync(TmpString.as_mut_ptr());
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_WriteToSysLog\0"))
            .as_ptr(),
        1560 as libc::c_int,
    );
    OS_printf(
        b"%s\0" as *const u8 as *const libc::c_char,
        TmpString.as_mut_ptr(),
    );
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_UnlockSharedData(
    mut FunctionName: *const libc::c_char,
    mut LineNumber: int32,
) {
    let mut OsStatus: int32 = 0;
    OsStatus = OS_MutSemGive(CFE_ES_Global.SharedDataMutex);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: SharedData Mutex Give Err Stat=%ld,Func=%s,Line=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_ES_UnlockSharedData\0",
            ))
            .as_ptr(),
            OsStatus as libc::c_long,
            FunctionName,
            LineNumber,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LibID_ToIndex(
    mut LibId: CFE_ES_LibId_t,
    mut Idx: *mut uint32,
) -> int32 {
    return CFE_ResourceId_ToIndex(
        LibId,
        CFE_ES_LIBID_BASE as libc::c_int as uint32,
        10 as libc::c_int as uint32,
        Idx,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetModuleInfo(
    mut ModuleInfo: *mut CFE_ES_AppInfo_t,
    mut ResourceId: CFE_ResourceId_t,
) -> int32 {
    let mut Status: int32 = 0;
    match CFE_ResourceId_GetBase(ResourceId) {
        1114112 => {
            Status = CFE_ES_GetAppInfo(ModuleInfo, ResourceId);
        }
        1179648 => {
            Status = CFE_ES_GetLibInfo(ModuleInfo, ResourceId);
        }
        _ => {
            CFE_ES_WriteToSysLog(
                b"%s: Resource ID not valid: %lu\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                    b"CFE_ES_GetModuleInfo\0",
                ))
                .as_ptr(),
                CFE_ResourceId_ToInteger(ResourceId),
            );
            Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CalculateCRC(
    mut DataPtr: *const libc::c_void,
    mut DataLength: size_t,
    mut InputCRC: uint32,
    mut TypeCRC: CFE_ES_CrcType_Enum_t,
) -> uint32 {
    let mut CrcParams: *const CFE_ES_ComputeCRC_Params_t = 0 as *const CFE_ES_ComputeCRC_Params_t;
    let mut CrcResult: uint32 = 0;
    if DataPtr.is_null() || DataLength == 0 as libc::c_int as libc::c_ulong {
        CrcResult = InputCRC;
    } else {
        CrcParams = CFE_ES_ComputeCRC_GetParams(TypeCRC);
        CrcResult = ((*CrcParams).Algorithm).expect("non-null function pointer")(
            DataPtr, DataLength, InputCRC,
        );
    }
    return CrcResult;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LockSharedData(
    mut FunctionName: *const libc::c_char,
    mut LineNumber: int32,
) {
    let mut OsStatus: int32 = 0;
    OsStatus = OS_MutSemTake(CFE_ES_Global.SharedDataMutex);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: SharedData Mutex Take Err Stat=%ld,Func=%s,Line=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_LockSharedData\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
            FunctionName,
            LineNumber,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetGenCount(
    mut CounterId: CFE_ES_CounterId_t,
    mut Count: *mut uint32,
) -> CFE_Status_t {
    let mut Status: int32 = 0xc400000a as libc::c_uint as CFE_Status_t;
    let mut CountRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    CountRecPtr = CFE_ES_LocateCounterRecordByID(CounterId);
    if CFE_ES_CounterRecordIsMatch(CountRecPtr, CounterId) as libc::c_int != 0 && !Count.is_null() {
        *Count = (*CountRecPtr).Counter;
        Status = 0 as libc::c_int;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_AppID_ToIndex(
    mut AppID: CFE_ES_AppId_t,
    mut Idx: *mut uint32,
) -> CFE_Status_t {
    return CFE_ResourceId_ToIndex(
        AppID,
        CFE_ES_APPID_BASE as libc::c_int as uint32,
        32 as libc::c_int as uint32,
        Idx,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_IncrementTaskCounter() {
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut TaskID: CFE_ES_TaskId_t = 0;
    TaskID = CFE_ES_TaskId_FromOSAL(OS_TaskGetId());
    TaskRecPtr = CFE_ES_LocateTaskRecordByID(TaskID);
    if !TaskRecPtr.is_null() {
        (*TaskRecPtr).ExecutionCounter = ((*TaskRecPtr).ExecutionCounter).wrapping_add(1);
        (*TaskRecPtr).ExecutionCounter;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_TaskID_ToIndex(
    mut TaskID: CFE_ES_TaskId_t,
    mut Idx: *mut uint32,
) -> CFE_Status_t {
    let mut OsalID: osal_id_t = 0;
    let mut OsalIndex: osal_index_t = 0 as libc::c_int as osal_index_t;
    let mut OsStatus: int32 = 0;
    if !CFE_ResourceId_IsDefined(TaskID) {
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    if Idx.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    OsalID = CFE_ES_TaskId_ToOSAL(TaskID);
    OsStatus =
        OS_ObjectIdToArrayIndex(0x1 as libc::c_int as osal_objtype_t, OsalID, &mut OsalIndex);
    if OsStatus != 0 as libc::c_int {
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    *Idx = OsalIndex;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CleanupTaskResources(mut TaskId: CFE_ES_TaskId_t) -> int32 {
    let mut CleanState: CFE_ES_CleanupState_t = CFE_ES_CleanupState_t {
        ErrorFlag: 0,
        FoundObjects: 0,
        PrevFoundObjects: 0,
        DeletedObjects: 0,
        OverallStatus: 0,
    };
    let mut OsStatus: int32 = 0;
    let mut Result: int32 = 0;
    let mut OsalId: osal_id_t = 0;
    OsalId = CFE_ES_TaskId_ToOSAL(TaskId);
    memset(
        &mut CleanState as *mut CFE_ES_CleanupState_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_CleanupState_t>() as libc::c_ulong,
    );
    CleanState.PrevFoundObjects = (CleanState.PrevFoundObjects).wrapping_sub(1);
    CleanState.PrevFoundObjects;
    loop {
        OS_ForEachObject(
            OsalId,
            Some(
                CFE_ES_CleanupObjectCallback
                    as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> (),
            ),
            &mut CleanState as *mut CFE_ES_CleanupState_t as *mut libc::c_void,
        );
        if CleanState.FoundObjects == 0 as libc::c_int as libc::c_uint
            || CleanState.ErrorFlag != 0 as libc::c_int as libc::c_uint
        {
            break;
        }
        CleanState.ErrorFlag = (CleanState.DeletedObjects == 0 as libc::c_int as libc::c_uint
            || CleanState.FoundObjects >= CleanState.PrevFoundObjects)
            as libc::c_int as uint32;
        CleanState.PrevFoundObjects = CleanState.FoundObjects;
        CleanState.FoundObjects = 0 as libc::c_int as uint32;
        CleanState.DeletedObjects = 0 as libc::c_int as uint32;
    }
    OsStatus = OS_TaskDelete(OsalId);
    if OsStatus == 0 as libc::c_int || OsStatus == -(16 as libc::c_int) {
        Result = CleanState.OverallStatus;
        if Result == 0 as libc::c_int && CleanState.FoundObjects > 0 as libc::c_int as libc::c_uint
        {
            Result = 0xc4000023 as libc::c_uint as CFE_Status_t;
        }
    } else {
        Result = 0xc4000026 as libc::c_uint as CFE_Status_t;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CleanupObjectCallback(
    mut ObjectId: osal_id_t,
    mut arg: *mut libc::c_void,
) {
    let mut CleanState: *mut CFE_ES_CleanupState_t = 0 as *mut CFE_ES_CleanupState_t;
    let mut OsStatus: int32 = 0;
    let mut ObjType: osal_objtype_t = 0;
    let mut ObjIsValid: bool = false;
    CleanState = arg as *mut CFE_ES_CleanupState_t;
    ObjIsValid = 1 as libc::c_int != 0;
    ObjType = OS_IdentifyObject(ObjectId);
    match ObjType {
        1 => {
            OsStatus = OS_TaskDelete(ObjectId);
        }
        2 => {
            OsStatus = OS_QueueDelete(ObjectId);
        }
        4 => {
            OsStatus = OS_BinSemDelete(ObjectId);
        }
        3 => {
            OsStatus = OS_CountSemDelete(ObjectId);
        }
        5 => {
            OsStatus = OS_MutSemDelete(ObjectId);
        }
        9 => {
            OsStatus = OS_TimerDelete(ObjectId);
        }
        6 => {
            OsStatus = OS_close(ObjectId);
        }
        10 => {
            OsStatus = OS_ModuleUnload(ObjectId);
        }
        _ => {
            ObjIsValid = 0 as libc::c_int != 0;
            OsStatus = -(1 as libc::c_int);
        }
    }
    if ObjIsValid {
        (*CleanState).FoundObjects = ((*CleanState).FoundObjects).wrapping_add(1);
        (*CleanState).FoundObjects;
        if OsStatus == 0 as libc::c_int {
            (*CleanState).DeletedObjects = ((*CleanState).DeletedObjects).wrapping_add(1);
            (*CleanState).DeletedObjects;
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Call to OSAL Delete Object (ID:%lu) failed. RC=%ld\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                    b"CFE_ES_CleanupObjectCallback\0",
                ))
                .as_ptr(),
                OS_ObjectIdToInteger(ObjectId),
                OsStatus as libc::c_long,
            );
            if (*CleanState).OverallStatus == 0 as libc::c_int {
                match ObjType {
                    1 => {
                        (*CleanState).OverallStatus = 0xc4000018 as libc::c_uint as CFE_Status_t;
                    }
                    2 => {
                        (*CleanState).OverallStatus = 0xc400001e as libc::c_uint as CFE_Status_t;
                    }
                    4 => {
                        (*CleanState).OverallStatus = 0xc400001c as libc::c_uint as CFE_Status_t;
                    }
                    3 => {
                        (*CleanState).OverallStatus = 0xc400001d as libc::c_uint as CFE_Status_t;
                    }
                    5 => {
                        (*CleanState).OverallStatus = 0xc400001b as libc::c_uint as CFE_Status_t;
                    }
                    9 => {
                        (*CleanState).OverallStatus = 0xc4000024 as libc::c_uint as CFE_Status_t;
                    }
                    _ => {
                        (*CleanState).OverallStatus = 0xc4000023 as libc::c_uint as CFE_Status_t;
                    }
                }
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_AppCreate(
    mut ApplicationIdPtr: *mut CFE_ES_AppId_t,
    mut AppName: *const libc::c_char,
    mut Params: *const CFE_ES_AppStartParams_t,
) -> int32 {
    let mut Status: CFE_Status_t = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut PendingResourceId: CFE_ResourceId_t = 0 as libc::c_int as CFE_ResourceId_t;
    if AppName.is_null() || Params.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if (memchr(
        AppName as *const libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_AppCreate\0")).as_ptr(),
        677 as libc::c_int,
    );
    AppRecPtr = CFE_ES_LocateAppRecordByName(AppName);
    if !AppRecPtr.is_null() {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Duplicate app name '%s'\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_AppCreate\0"))
                .as_ptr(),
            AppName,
        );
        Status = 0xc400002e as libc::c_uint as CFE_Status_t;
    } else {
        PendingResourceId = CFE_ResourceId_FindNext(
            CFE_ES_Global.LastAppId,
            32 as libc::c_int as uint32,
            Some(CFE_ES_CheckAppIdSlotUsed as unsafe extern "C" fn(CFE_ResourceId_t) -> bool),
        );
        AppRecPtr = CFE_ES_LocateAppRecordByID(PendingResourceId);
        if AppRecPtr.is_null() {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: No free application slots available\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_AppCreate\0"))
                    .as_ptr(),
            );
            Status = 0xc400002b as libc::c_uint as CFE_Status_t;
        } else {
            memset(
                AppRecPtr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<CFE_ES_AppRecord_t>() as libc::c_ulong,
            );
            strncpy(
                ((*AppRecPtr).AppName).as_mut_ptr(),
                AppName,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*AppRecPtr).Type = CFE_ES_AppType_EXTERNAL as libc::c_int as CFE_ES_AppType_Enum_t;
            (*AppRecPtr).StartParams = *Params;
            (*AppRecPtr).ControlReq.AppControlRequest =
                CFE_ES_RunStatus_APP_RUN as libc::c_int as uint32;
            (*AppRecPtr).ControlReq.AppTimerMsec = 0 as libc::c_int;
            CFE_ES_AppRecordSetUsed(AppRecPtr, 0xffffffff as libc::c_uint);
            CFE_ES_Global.LastAppId = PendingResourceId;
            Status = 0 as libc::c_int;
        }
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_AppCreate\0")).as_ptr(),
        746 as libc::c_int,
    );
    if Status != 0 as libc::c_int {
        return Status;
    }
    Status = CFE_ES_LoadModule(
        PendingResourceId,
        AppName,
        &mut (*AppRecPtr).StartParams.BasicInfo,
        &mut (*AppRecPtr).LoadStatus,
    );
    if Status == 0 as libc::c_int {
        Status = CFE_ES_StartAppTask(
            &mut (*AppRecPtr).MainTaskId,
            AppName,
            ::core::mem::transmute::<libc::intptr_t, CFE_ES_TaskEntryFuncPtr_t>(
                (*AppRecPtr).LoadStatus.InitSymbolAddress as libc::intptr_t,
            ),
            &mut (*AppRecPtr).StartParams.MainTaskInfo,
            PendingResourceId,
        );
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_AppCreate\0")).as_ptr(),
        780 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_ES_AppRecordSetUsed(AppRecPtr, PendingResourceId);
        CFE_ES_Global.RegisteredExternalApps =
            (CFE_ES_Global.RegisteredExternalApps).wrapping_add(1);
        CFE_ES_Global.RegisteredExternalApps;
    } else {
        CFE_ES_AppRecordSetFree(AppRecPtr);
        PendingResourceId = 0 as libc::c_int as CFE_ResourceId_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_AppCreate\0")).as_ptr(),
        804 as libc::c_int,
    );
    *ApplicationIdPtr = PendingResourceId;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_TaskEntryPoint() {
    let mut RealEntryFunc: CFE_ES_TaskEntryFuncPtr_t = None;
    if CFE_ES_GetTaskFunction(&mut RealEntryFunc) == 0 as libc::c_int && RealEntryFunc.is_some() {
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_TaskEntryPoint\0"))
                .as_ptr(),
            559 as libc::c_int,
        );
        CFE_PSP_SetDefaultExceptionEnvironment();
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_TaskEntryPoint\0"))
                .as_ptr(),
            561 as libc::c_int,
        );
        (Some(RealEntryFunc.expect("non-null function pointer")))
            .expect("non-null function pointer")();
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_StartApplications(
    mut ResetType: uint32,
    mut StartFilePath: *const libc::c_char,
) {
    let mut ES_AppLoadBuffer: [libc::c_char; 128] = [0; 128];
    let mut ScriptFileName: [libc::c_char; 64] = [0; 64];
    let mut TokenList: [*const libc::c_char; 8] = [0 as *const libc::c_char; 8];
    let mut NumTokens: uint32 = 0;
    let mut NumLines: uint32 = 0;
    let mut BuffLen: uint32 = 0;
    let mut AppFile: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut c: libc::c_char = 0 as libc::c_int as libc::c_char;
    let mut LineTooLong: bool = 0 as libc::c_int != 0;
    let mut FileOpened: bool = 0 as libc::c_int != 0;
    if ResetType == 1 as libc::c_int as libc::c_uint {
        Status = CFE_FS_ParseInputFileName(
            ScriptFileName.as_mut_ptr(),
            b"/ram/cfe_es_startup.scr\0" as *const u8 as *const libc::c_char,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            CFE_FS_FileCategory_TEMP,
        );
        if Status == 0 as libc::c_int {
            OsStatus = OS_OpenCreate(
                &mut AppFile,
                ScriptFileName.as_mut_ptr(),
                OS_FILE_FLAG_NONE as libc::c_int,
                0 as libc::c_int,
            );
            if OsStatus == 0 as libc::c_int {
                FileOpened = 1 as libc::c_int != 0;
            } else {
                CFE_ES_WriteToSysLog(
                    b"%s: Cannot Open Volatile Startup file: %s, Trying Nonvolatile.\n\0"
                        as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                        b"CFE_ES_StartApplications\0",
                    ))
                    .as_ptr(),
                    ScriptFileName.as_mut_ptr(),
                );
            }
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: CFE_FS_ParseInputFileName() RC=%08x parsing volatile script file name.\n\0"
                    as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                    b"CFE_ES_StartApplications\0",
                ))
                .as_ptr(),
                Status as libc::c_uint,
            );
        }
    }
    if FileOpened as libc::c_int == 0 as libc::c_int {
        Status = CFE_FS_ParseInputFileName(
            ScriptFileName.as_mut_ptr(),
            StartFilePath,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            CFE_FS_FileCategory_SCRIPT,
        );
        if Status == 0 as libc::c_int {
            OsStatus = OS_OpenCreate(
                &mut AppFile,
                ScriptFileName.as_mut_ptr(),
                OS_FILE_FLAG_NONE as libc::c_int,
                0 as libc::c_int,
            );
            if OsStatus == 0 as libc::c_int {
                FileOpened = 1 as libc::c_int != 0;
            } else {
                CFE_ES_WriteToSysLog(
                    b"%s: Error, Can't Open ES App Startup file: %s, EC = %ld\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                        b"CFE_ES_StartApplications\0",
                    ))
                    .as_ptr(),
                    ScriptFileName.as_mut_ptr(),
                    OsStatus as libc::c_long,
                );
            }
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: CFE_FS_ParseInputFileName() RC=%08x parsing StartFilePath.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                    b"CFE_ES_StartApplications\0",
                ))
                .as_ptr(),
                Status as libc::c_uint,
            );
        }
    }
    if FileOpened as libc::c_int == 1 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Opened ES App Startup file: %s\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_ES_StartApplications\0",
            ))
            .as_ptr(),
            ScriptFileName.as_mut_ptr(),
        );
        memset(
            ES_AppLoadBuffer.as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            128 as libc::c_int as libc::c_ulong,
        );
        BuffLen = 0 as libc::c_int as uint32;
        NumTokens = 0 as libc::c_int as uint32;
        NumLines = 0 as libc::c_int as uint32;
        TokenList[0 as libc::c_int as usize] = ES_AppLoadBuffer.as_mut_ptr();
        loop {
            OsStatus = OS_read(
                AppFile,
                &mut c as *mut libc::c_char as *mut libc::c_void,
                1 as libc::c_int as size_t,
            );
            if OsStatus < 0 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: Error Reading Startup file. EC = %ld\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                        b"CFE_ES_StartApplications\0",
                    ))
                    .as_ptr(),
                    OsStatus as libc::c_long,
                );
                break;
            } else {
                if OsStatus == 0 as libc::c_int {
                    break;
                }
                if !(c as libc::c_int != '!' as i32) {
                    break;
                }
                if !(c as libc::c_int <= ' ' as i32) {
                    if c as libc::c_int == ',' as i32 {
                        if BuffLen < 128 as libc::c_int as libc::c_uint {
                            ES_AppLoadBuffer[BuffLen as usize] = 0 as libc::c_int as libc::c_char;
                        } else {
                            LineTooLong = 1 as libc::c_int != 0;
                        }
                        BuffLen = BuffLen.wrapping_add(1);
                        BuffLen;
                        NumTokens = NumTokens.wrapping_add(1);
                        NumTokens;
                        if NumTokens < 8 as libc::c_int as libc::c_uint {
                            TokenList[NumTokens as usize] =
                                &mut *ES_AppLoadBuffer.as_mut_ptr().offset(BuffLen as isize)
                                    as *mut libc::c_char;
                        } else {
                            LineTooLong = 1 as libc::c_int != 0;
                        }
                    } else if c as libc::c_int != ';' as i32 {
                        if BuffLen < 128 as libc::c_int as libc::c_uint {
                            ES_AppLoadBuffer[BuffLen as usize] = c;
                        } else {
                            LineTooLong = 1 as libc::c_int != 0;
                        }
                        BuffLen = BuffLen.wrapping_add(1);
                        BuffLen;
                    } else {
                        NumLines = NumLines.wrapping_add(1);
                        NumLines;
                        if LineTooLong as libc::c_int == 1 as libc::c_int {
                            CFE_ES_WriteToSysLog(
                                b"%s: **WARNING** File Line %u is malformed: %u bytes, %u tokens.\n\0"
                                    as *const u8 as *const libc::c_char,
                                (*::core::mem::transmute::<
                                    &[u8; 25],
                                    &[libc::c_char; 25],
                                >(b"CFE_ES_StartApplications\0"))
                                    .as_ptr(),
                                NumLines,
                                BuffLen,
                                NumTokens,
                            );
                            LineTooLong = 0 as libc::c_int != 0;
                        } else {
                            ES_AppLoadBuffer[BuffLen as usize] = 0 as libc::c_int as libc::c_char;
                            CFE_ES_ParseFileEntry(
                                TokenList.as_mut_ptr(),
                                (1 as libc::c_int as libc::c_uint).wrapping_add(NumTokens),
                            );
                        }
                        BuffLen = 0 as libc::c_int as uint32;
                        NumTokens = 0 as libc::c_int as uint32;
                    }
                }
            }
        }
        OS_close(AppFile);
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CleanUpApp(mut AppId: CFE_ES_AppId_t) -> int32 {
    let mut i: uint32 = 0;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut ReturnCode: int32 = 0;
    let mut TaskList: [CFE_ES_TaskId_t; 64] = [0; 64];
    let mut PoolList: [CFE_ES_MemHandle_t; 10] = [0; 10];
    let mut ModuleId: osal_id_t = 0;
    let mut NumTasks: uint32 = 0;
    let mut NumPools: uint32 = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut MemPoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    NumTasks = 0 as libc::c_int as uint32;
    NumPools = 0 as libc::c_int as uint32;
    ModuleId = 0 as libc::c_int as osal_id_t;
    ReturnCode = 0 as libc::c_int;
    AppRecPtr = CFE_ES_LocateAppRecordByID(AppId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
            .as_ptr(),
        1341 as libc::c_int,
    );
    if CFE_ES_AppRecordIsMatch(AppRecPtr, AppId) {
        if (*AppRecPtr).Type as libc::c_int == CFE_ES_AppType_EXTERNAL as libc::c_int {
            CFE_ES_Global.RegisteredExternalApps =
                (CFE_ES_Global.RegisteredExternalApps).wrapping_sub(1);
            CFE_ES_Global.RegisteredExternalApps;
            ModuleId = (*AppRecPtr).LoadStatus.ModuleId;
        }
        TaskRecPtr = (CFE_ES_Global.TaskTable).as_mut_ptr();
        i = 0 as libc::c_int as uint32;
        while i < 64 as libc::c_int as libc::c_uint {
            if CFE_ES_TaskRecordIsUsed(TaskRecPtr) as libc::c_int != 0
                && CFE_ResourceId_Equal((*TaskRecPtr).AppId, AppId) as libc::c_int != 0
            {
                TaskList[NumTasks as usize] = CFE_ES_TaskRecordGetID(TaskRecPtr);
                if CFE_ResourceId_Equal(TaskList[NumTasks as usize], (*AppRecPtr).MainTaskId)
                    as libc::c_int
                    != 0
                    && NumTasks != 0 as libc::c_int as libc::c_uint
                {
                    TaskList[NumTasks as usize] = TaskList[0 as libc::c_int as usize];
                    TaskList[0 as libc::c_int as usize] = (*AppRecPtr).MainTaskId;
                }
                CFE_ES_TaskRecordSetUsed(TaskRecPtr, 0xffffffff as libc::c_uint);
                NumTasks = NumTasks.wrapping_add(1);
                NumTasks;
            }
            TaskRecPtr = TaskRecPtr.offset(1);
            TaskRecPtr;
            i = i.wrapping_add(1);
            i;
        }
        CFE_ES_Global.RegisteredTasks = (CFE_ES_Global.RegisteredTasks as libc::c_uint)
            .wrapping_sub(NumTasks) as uint32 as uint32;
        MemPoolRecPtr = (CFE_ES_Global.MemPoolTable).as_mut_ptr();
        i = 0 as libc::c_int as uint32;
        while i < 10 as libc::c_int as libc::c_uint {
            if CFE_ES_MemPoolRecordIsUsed(MemPoolRecPtr) as libc::c_int != 0
                && CFE_ResourceId_Equal((*MemPoolRecPtr).OwnerAppID, AppId) as libc::c_int != 0
            {
                PoolList[NumPools as usize] = CFE_ES_MemPoolRecordGetID(MemPoolRecPtr);
                NumPools = NumPools.wrapping_add(1);
                NumPools;
            }
            MemPoolRecPtr = MemPoolRecPtr.offset(1);
            MemPoolRecPtr;
            i = i.wrapping_add(1);
            i;
        }
        CFE_ES_AppRecordSetUsed(AppRecPtr, 0xffffffff as libc::c_uint);
    } else {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: AppID %lu is not valid for deletion\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(AppId),
        );
        ReturnCode = 0xc4000023 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
            .as_ptr(),
        1415 as libc::c_int,
    );
    if ReturnCode != 0 as libc::c_int {
        return ReturnCode;
    }
    CFE_TBL_CleanUpApp(AppId);
    CFE_SB_CleanUpApp(AppId);
    CFE_TIME_CleanUpApp(AppId);
    Status = CFE_EVS_CleanUpApp(AppId);
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_EVS_CleanUpApp returned Error: 0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        ReturnCode = 0xc4000023 as libc::c_uint as CFE_Status_t;
    }
    i = NumTasks;
    while i > 0 as libc::c_int as libc::c_uint {
        i = i.wrapping_sub(1);
        i;
        Status = CFE_ES_CleanupTaskResources(TaskList[i as usize]);
        if Status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: CleanUpTaskResources for Task ID:%lu returned Error: 0x%08X\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
                    .as_ptr(),
                CFE_ResourceId_ToInteger(TaskList[i as usize]),
                Status as libc::c_uint,
            );
            ReturnCode = 0xc4000023 as libc::c_uint as CFE_Status_t;
        }
    }
    i = 0 as libc::c_int as uint32;
    while i < NumPools {
        Status = CFE_ES_PoolDelete(PoolList[i as usize]);
        if Status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: delete pool %lu returned Error: 0x%08X\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
                    .as_ptr(),
                CFE_ResourceId_ToInteger(PoolList[i as usize]),
                Status as libc::c_uint,
            );
            ReturnCode = 0xc4000023 as libc::c_uint as CFE_Status_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    if OS_ObjectIdDefined(ModuleId) {
        OsStatus = OS_ModuleUnload(ModuleId);
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Module (ID:0x%08lX) Unload failed. RC=%ld\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
                    .as_ptr(),
                OS_ObjectIdToInteger(ModuleId),
                OsStatus as libc::c_long,
            );
            ReturnCode = 0xc4000023 as libc::c_uint as CFE_Status_t;
        }
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
            .as_ptr(),
        1511 as libc::c_int,
    );
    i = 0 as libc::c_int as uint32;
    while i < NumTasks {
        TaskRecPtr = CFE_ES_LocateTaskRecordByID(TaskList[i as usize]);
        if CFE_ES_TaskRecordIsMatch(TaskRecPtr, 0xffffffff as libc::c_uint) {
            CFE_ES_TaskRecordSetFree(TaskRecPtr);
        }
        i = i.wrapping_add(1);
        i;
    }
    if CFE_ES_AppRecordIsMatch(AppRecPtr, 0xffffffff as libc::c_uint) {
        CFE_ES_AppRecordSetFree(AppRecPtr);
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_CleanUpApp\0"))
            .as_ptr(),
        1533 as libc::c_int,
    );
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ParseFileEntry(
    mut TokenList: *mut *const libc::c_char,
    mut NumTokens: uint32,
) -> int32 {
    let mut ModuleName: *const libc::c_char = 0 as *const libc::c_char;
    let mut EntryType: *const libc::c_char = 0 as *const libc::c_char;
    let mut ParsedValue: libc::c_ulong = 0;
    let mut IdBuf: C2RustUnnamed_8 = C2RustUnnamed_8 { AppId: 0 };
    let mut Status: int32 = 0;
    let mut ParamBuf: CFE_ES_AppStartParams_t = CFE_ES_AppStartParams_t {
        BasicInfo: CFE_ES_ModuleLoadParams_t {
            InitSymbolName: [0; 20],
            FileName: [0; 64],
        },
        MainTaskInfo: CFE_ES_TaskStartParams_t {
            StackSize: 0,
            Priority: 0,
        },
        ExceptionAction: 0,
    };
    if NumTokens < 8 as libc::c_int as libc::c_uint {
        CFE_ES_WriteToSysLog(
            b"%s: Invalid ES Startup file entry: %u\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_ParseFileEntry\0"))
                .as_ptr(),
            NumTokens,
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    EntryType = *TokenList.offset(0 as libc::c_int as isize);
    ModuleName = *TokenList.offset(3 as libc::c_int as isize);
    memset(
        &mut ParamBuf as *mut CFE_ES_AppStartParams_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_AppStartParams_t>() as libc::c_ulong,
    );
    Status = CFE_FS_ParseInputFileName(
        (ParamBuf.BasicInfo.FileName).as_mut_ptr(),
        *TokenList.offset(1 as libc::c_int as isize),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        CFE_FS_FileCategory_DYNAMIC_MODULE,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Invalid ES Startup script file name: %s\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_ParseFileEntry\0"))
                .as_ptr(),
            *TokenList.offset(1 as libc::c_int as isize),
        );
        return Status;
    }
    strncpy(
        (ParamBuf.BasicInfo.InitSymbolName).as_mut_ptr(),
        *TokenList.offset(2 as libc::c_int as isize),
        (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    if strcmp(EntryType, b"CFE_APP\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Loading file: %s, APP: %s\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_ParseFileEntry\0"))
                .as_ptr(),
            (ParamBuf.BasicInfo.FileName).as_mut_ptr(),
            ModuleName,
        );
        ParsedValue = strtoul(
            *TokenList.offset(4 as libc::c_int as isize),
            0 as *mut *mut libc::c_char,
            0 as libc::c_int,
        );
        if ParsedValue > 255 as libc::c_int as libc::c_ulong {
            ParamBuf.MainTaskInfo.Priority = 255 as libc::c_int as CFE_ES_TaskPriority_Atom_t;
        } else {
            ParamBuf.MainTaskInfo.Priority = ParsedValue as CFE_ES_TaskPriority_Atom_t;
        }
        ParamBuf.MainTaskInfo.StackSize = strtoul(
            *TokenList.offset(5 as libc::c_int as isize),
            0 as *mut *mut libc::c_char,
            0 as libc::c_int,
        );
        ParsedValue = strtoul(
            *TokenList.offset(7 as libc::c_int as isize),
            0 as *mut *mut libc::c_char,
            0 as libc::c_int,
        );
        if ParsedValue > CFE_ES_ExceptionAction_RESTART_APP as libc::c_int as libc::c_ulong {
            ParamBuf.ExceptionAction =
                CFE_ES_ExceptionAction_PROC_RESTART as libc::c_int as CFE_ES_ExceptionAction_Enum_t;
        } else {
            ParamBuf.ExceptionAction = ParsedValue as CFE_ES_ExceptionAction_Enum_t;
        }
        Status = CFE_ES_AppCreate(&mut IdBuf.AppId, ModuleName, &mut ParamBuf);
    } else if strcmp(EntryType, b"CFE_LIB\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        CFE_ES_WriteToSysLog(
            b"%s: Loading shared library: %s\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_ParseFileEntry\0"))
                .as_ptr(),
            (ParamBuf.BasicInfo.FileName).as_mut_ptr(),
        );
        Status = CFE_ES_LoadLibrary(&mut IdBuf.LibId, ModuleName, &mut ParamBuf.BasicInfo);
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Unexpected EntryType %s in startup file.\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_ParseFileEntry\0"))
                .as_ptr(),
            EntryType,
        );
        Status = 0xc4000004 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LoadLibrary(
    mut LibraryIdPtr: *mut CFE_ES_LibId_t,
    mut LibName: *const libc::c_char,
    mut Params: *const CFE_ES_ModuleLoadParams_t,
) -> int32 {
    let mut FunctionPointer: CFE_ES_LibraryEntryFuncPtr_t = None;
    let mut LibSlotPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    let mut Status: int32 = 0;
    let mut PendingResourceId: CFE_ResourceId_t = 0;
    if LibName.is_null() || Params.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if (memchr(
        LibName as *const libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    ))
    .is_null()
    {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    FunctionPointer = None;
    PendingResourceId = 0 as libc::c_int as CFE_ResourceId_t;
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_LoadLibrary\0"))
            .as_ptr(),
        856 as libc::c_int,
    );
    LibSlotPtr = CFE_ES_LocateLibRecordByName(LibName);
    if !LibSlotPtr.is_null() || !(CFE_ES_LocateAppRecordByName(LibName)).is_null() {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Duplicate Lib name '%s'\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_LoadLibrary\0"))
                .as_ptr(),
            LibName,
        );
        if !LibSlotPtr.is_null() {
            PendingResourceId = CFE_ES_LibRecordGetID(LibSlotPtr);
        }
        Status = 0xc400002e as libc::c_uint as CFE_Status_t;
    } else {
        PendingResourceId = CFE_ResourceId_FindNext(
            CFE_ES_Global.LastLibId,
            10 as libc::c_int as uint32,
            Some(CFE_ES_CheckLibIdSlotUsed as unsafe extern "C" fn(CFE_ResourceId_t) -> bool),
        );
        LibSlotPtr = CFE_ES_LocateLibRecordByID(PendingResourceId);
        if LibSlotPtr.is_null() {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: No free library slots available\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(
                    b"CFE_ES_LoadLibrary\0",
                ))
                .as_ptr(),
            );
            Status = 0xc400002b as libc::c_uint as CFE_Status_t;
        } else {
            memset(
                LibSlotPtr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<CFE_ES_LibRecord_t>() as libc::c_ulong,
            );
            strncpy(
                ((*LibSlotPtr).LibName).as_mut_ptr(),
                LibName,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*LibSlotPtr).LibName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = '\0' as i32 as libc::c_char;
            (*LibSlotPtr).LoadParams = *Params;
            CFE_ES_LibRecordSetUsed(LibSlotPtr, 0xffffffff as libc::c_uint);
            CFE_ES_Global.LastLibId = PendingResourceId;
            Status = 0 as libc::c_int;
        }
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_LoadLibrary\0"))
            .as_ptr(),
        903 as libc::c_int,
    );
    if Status != 0 as libc::c_int {
        *LibraryIdPtr = PendingResourceId;
        return Status;
    }
    Status = CFE_ES_LoadModule(
        PendingResourceId,
        LibName,
        &mut (*LibSlotPtr).LoadParams,
        &mut (*LibSlotPtr).LoadStatus,
    );
    if Status == 0 as libc::c_int {
        FunctionPointer = ::core::mem::transmute::<libc::intptr_t, CFE_ES_LibraryEntryFuncPtr_t>(
            (*LibSlotPtr).LoadStatus.InitSymbolAddress as libc::intptr_t,
        );
        if FunctionPointer.is_some() {
            Status = (Some(FunctionPointer.expect("non-null function pointer")))
                .expect("non-null function pointer")(PendingResourceId);
            if Status != 0 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: Load Shared Library Init Error = 0x%08x\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(
                        b"CFE_ES_LoadLibrary\0",
                    ))
                    .as_ptr(),
                    Status as libc::c_uint,
                );
            }
        }
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_LoadLibrary\0"))
            .as_ptr(),
        937 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_ES_LibRecordSetUsed(LibSlotPtr, PendingResourceId);
        CFE_ES_Global.RegisteredLibs = (CFE_ES_Global.RegisteredLibs).wrapping_add(1);
        CFE_ES_Global.RegisteredLibs;
    } else {
        CFE_ES_LibRecordSetFree(LibSlotPtr);
        PendingResourceId = 0 as libc::c_int as CFE_ResourceId_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_LoadLibrary\0"))
            .as_ptr(),
        958 as libc::c_int,
    );
    *LibraryIdPtr = PendingResourceId;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LoadModule(
    mut ParentResourceId: CFE_ResourceId_t,
    mut ModuleName: *const libc::c_char,
    mut LoadParams: *const CFE_ES_ModuleLoadParams_t,
    mut LoadStatus: *mut CFE_ES_ModuleLoadStatus_t,
) -> int32 {
    let mut ModuleId: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut InitSymbolAddress: cpuaddr = 0;
    let mut ReturnCode: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut LoadFlags: uint32 = 0;
    LoadFlags = 0 as libc::c_int as uint32;
    InitSymbolAddress = 0 as libc::c_int as cpuaddr;
    ReturnCode = 0 as libc::c_int;
    if (*LoadParams).FileName[0 as libc::c_int as usize] as libc::c_int != 0 as libc::c_int {
        match CFE_ResourceId_GetBase(ParentResourceId) {
            1114112 => {
                LoadFlags |= 0x1 as libc::c_int as libc::c_uint;
            }
            1179648 => {
                LoadFlags |= 0 as libc::c_int as libc::c_uint;
            }
            _ => {}
        }
        OsStatus = OS_ModuleLoad(
            &mut ModuleId,
            ModuleName,
            ((*LoadParams).FileName).as_ptr(),
            LoadFlags,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Could not load file:%s. EC = %ld\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_LoadModule\0"))
                    .as_ptr(),
                ((*LoadParams).FileName).as_ptr(),
                OsStatus as libc::c_long,
            );
            ModuleId = 0 as libc::c_int as osal_id_t;
            ReturnCode = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    } else {
        ModuleId = 0 as libc::c_int as osal_id_t;
    }
    if ReturnCode == 0 as libc::c_int
        && (*LoadParams).InitSymbolName[0 as libc::c_int as usize] as libc::c_int
            != 0 as libc::c_int
        && strcmp(
            ((*LoadParams).InitSymbolName).as_ptr(),
            b"NULL\0" as *const u8 as *const libc::c_char,
        ) != 0 as libc::c_int
    {
        OsStatus = OS_ModuleSymbolLookup(
            ModuleId,
            &mut InitSymbolAddress,
            ((*LoadParams).InitSymbolName).as_ptr(),
        );
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Could not find symbol:%s. EC = %ld\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_LoadModule\0"))
                    .as_ptr(),
                ((*LoadParams).InitSymbolName).as_ptr(),
                OsStatus as libc::c_long,
            );
            ReturnCode = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    }
    if ReturnCode == 0 as libc::c_int {
        (*LoadStatus).ModuleId = ModuleId;
        (*LoadStatus).InitSymbolAddress = InitSymbolAddress;
    } else if OS_ObjectIdDefined(ModuleId) {
        OsStatus = OS_ModuleUnload(ModuleId);
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Failed to unload: %s. EC = %ld\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_LoadModule\0"))
                    .as_ptr(),
                ModuleName,
                OsStatus as libc::c_long,
            );
        }
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetTaskFunction(
    mut FuncPtr: *mut CFE_ES_TaskEntryFuncPtr_t,
) -> int32 {
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut EntryFunc: CFE_ES_TaskEntryFuncPtr_t = None;
    let mut ReturnCode: int32 = 0;
    let mut Timeout: int32 = 0;
    ReturnCode = 0xc4000017 as libc::c_uint as CFE_Status_t;
    Timeout = 1000 as libc::c_int;
    EntryFunc = None;
    loop {
        OS_TaskDelay(50 as libc::c_int as uint32);
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_GetTaskFunction\0",
            ))
            .as_ptr(),
            512 as libc::c_int,
        );
        TaskRecPtr = CFE_ES_GetTaskRecordByContext();
        if !TaskRecPtr.is_null() {
            EntryFunc = (*TaskRecPtr).EntryFunc;
            if CFE_ResourceId_IsDefined((*TaskRecPtr).AppId) as libc::c_int != 0
                && EntryFunc.is_some()
            {
                ReturnCode = 0 as libc::c_int;
            }
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_GetTaskFunction\0",
            ))
            .as_ptr(),
            522 as libc::c_int,
        );
        if ReturnCode == 0 as libc::c_int || Timeout <= 0 as libc::c_int {
            break;
        }
        Timeout -= 50 as libc::c_int;
    }
    if !FuncPtr.is_null() {
        *FuncPtr = EntryFunc;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RunAppTableScan(
    mut ElapsedTime: uint32,
    mut Arg: *mut libc::c_void,
) -> bool {
    let mut State: *mut CFE_ES_AppTableScanState_t = Arg as *mut CFE_ES_AppTableScanState_t;
    let mut i: uint32 = 0;
    let mut AppPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut AppTimeoutList: [CFE_ES_AppId_t; 32] = [0; 32];
    let mut NumAppTimeouts: uint32 = 0;
    if (*State).PendingAppStateChanges == 0 as libc::c_int as libc::c_uint {
        if (*State).LastScanCommandCount as libc::c_int
            == CFE_ES_Global.TaskData.CommandCounter as libc::c_int
            && (*State).BackgroundScanTimer > ElapsedTime
        {
            (*State).BackgroundScanTimer = ((*State).BackgroundScanTimer as libc::c_uint)
                .wrapping_sub(ElapsedTime) as uint32
                as uint32;
            return 0 as libc::c_int != 0;
        }
    }
    NumAppTimeouts = 0 as libc::c_int as uint32;
    (*State).BackgroundScanTimer = 1000 as libc::c_int as uint32;
    (*State).LastScanCommandCount = CFE_ES_Global.TaskData.CommandCounter;
    (*State).PendingAppStateChanges = 0 as libc::c_int as uint32;
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_ES_RunAppTableScan\0"))
            .as_ptr(),
        1009 as libc::c_int,
    );
    AppPtr = (CFE_ES_Global.AppTable).as_mut_ptr();
    i = 0 as libc::c_int as uint32;
    while i < 32 as libc::c_int as libc::c_uint {
        if CFE_ES_AppRecordIsUsed(AppPtr) as libc::c_int != 0
            && (*AppPtr).Type as libc::c_int == CFE_ES_AppType_EXTERNAL as libc::c_int
        {
            if (*AppPtr).AppState > CFE_ES_AppState_RUNNING as libc::c_int as libc::c_uint {
                (*State).PendingAppStateChanges = ((*State).PendingAppStateChanges).wrapping_add(1);
                (*State).PendingAppStateChanges;
                if (*AppPtr).ControlReq.AppTimerMsec as libc::c_uint > ElapsedTime {
                    (*AppPtr).ControlReq.AppTimerMsec =
                        ((*AppPtr).ControlReq.AppTimerMsec as libc::c_uint)
                            .wrapping_sub(ElapsedTime) as int32 as int32;
                } else {
                    (*AppPtr).ControlReq.AppTimerMsec = 0 as libc::c_int;
                    AppTimeoutList[NumAppTimeouts as usize] = CFE_ES_AppRecordGetID(AppPtr);
                    NumAppTimeouts = NumAppTimeouts.wrapping_add(1);
                    NumAppTimeouts;
                }
            } else if (*AppPtr).AppState == CFE_ES_AppState_RUNNING as libc::c_int as libc::c_uint
                && (*AppPtr).ControlReq.AppControlRequest
                    > CFE_ES_RunStatus_APP_RUN as libc::c_int as libc::c_uint
            {
                (*AppPtr).AppState =
                    CFE_ES_AppState_WAITING as libc::c_int as CFE_ES_AppState_Enum_t;
                (*AppPtr).ControlReq.AppTimerMsec = 5 as libc::c_int * 1000 as libc::c_int;
            }
        }
        AppPtr = AppPtr.offset(1);
        AppPtr;
        i = i.wrapping_add(1);
        i;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_ES_RunAppTableScan\0"))
            .as_ptr(),
        1061 as libc::c_int,
    );
    i = 0 as libc::c_int as uint32;
    while i < NumAppTimeouts {
        CFE_ES_ProcessControlRequest(AppTimeoutList[i as usize]);
        i = i.wrapping_add(1);
        i;
    }
    return (*State).PendingAppStateChanges != 0 as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ProcessControlRequest(mut AppId: CFE_ES_AppId_t) {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut PendingControlReq: uint32 = 0;
    let mut RestartParams: CFE_ES_AppStartParams_t = CFE_ES_AppStartParams_t {
        BasicInfo: CFE_ES_ModuleLoadParams_t {
            InitSymbolName: [0; 20],
            FileName: [0; 64],
        },
        MainTaskInfo: CFE_ES_TaskStartParams_t {
            StackSize: 0,
            Priority: 0,
        },
        ExceptionAction: 0,
    };
    let mut OrigAppName: [libc::c_char; 20] = [0; 20];
    let mut CleanupStatus: CFE_Status_t = 0;
    let mut StartupStatus: CFE_Status_t = 0;
    let mut NewAppId: CFE_ES_AppId_t = 0;
    let mut ReqName: *const libc::c_char = 0 as *const libc::c_char;
    let mut MessageDetail: [libc::c_char; 48] = [0; 48];
    let mut EventID: uint16 = 0;
    let mut EventType: CFE_EVS_EventType_Enum_t = 0;
    ReqName = 0 as *const libc::c_char;
    MessageDetail[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    EventID = 0 as libc::c_int as uint16;
    EventType = 0 as libc::c_int as CFE_EVS_EventType_Enum_t;
    StartupStatus = 0 as libc::c_int;
    PendingControlReq = 0 as libc::c_int as uint32;
    NewAppId = 0 as libc::c_int as CFE_ResourceId_t;
    OrigAppName[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    memset(
        &mut RestartParams as *mut CFE_ES_AppStartParams_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_AppStartParams_t>() as libc::c_ulong,
    );
    AppRecPtr = CFE_ES_LocateAppRecordByID(AppId);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"CFE_ES_ProcessControlRequest\0",
        ))
        .as_ptr(),
        1124 as libc::c_int,
    );
    if CFE_ES_AppRecordIsMatch(AppRecPtr, AppId) {
        PendingControlReq = (*AppRecPtr).ControlReq.AppControlRequest;
        strncpy(
            OrigAppName.as_mut_ptr(),
            ((*AppRecPtr).AppName).as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        OrigAppName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
            0 as libc::c_int as libc::c_char;
        if PendingControlReq == CFE_ES_RunStatus_SYS_RESTART as libc::c_int as libc::c_uint
            || PendingControlReq == CFE_ES_RunStatus_SYS_RELOAD as libc::c_int as libc::c_uint
        {
            RestartParams = (*AppRecPtr).StartParams;
        }
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"CFE_ES_ProcessControlRequest\0",
        ))
        .as_ptr(),
        1139 as libc::c_int,
    );
    CleanupStatus = CFE_ES_CleanUpApp(AppId);
    if PendingControlReq == CFE_ES_RunStatus_SYS_RESTART as libc::c_int as libc::c_uint
        || PendingControlReq == CFE_ES_RunStatus_SYS_RELOAD as libc::c_int as libc::c_uint
    {
        StartupStatus =
            CFE_ES_AppCreate(&mut NewAppId, OrigAppName.as_mut_ptr(), &mut RestartParams);
    }
    match PendingControlReq {
        2 => {
            ReqName = b"Exit\0" as *const u8 as *const libc::c_char;
            if CleanupStatus != 0 as libc::c_int {
                EventID = 46 as libc::c_int as uint16;
            } else {
                EventID = 13 as libc::c_int as uint16;
            }
        }
        3 => {
            ReqName = b"Exit\0" as *const u8 as *const libc::c_char;
            if CleanupStatus != 0 as libc::c_int {
                EventID = 33 as libc::c_int as uint16;
            } else {
                EventID = 14 as libc::c_int as uint16;
            }
        }
        7 => {
            ReqName = b"Stop\0" as *const u8 as *const libc::c_char;
            if CleanupStatus != 0 as libc::c_int {
                EventID = 37 as libc::c_int as uint16;
            } else {
                EventID = 8 as libc::c_int as uint16;
            }
        }
        5 => {
            ReqName = b"Restart\0" as *const u8 as *const libc::c_char;
            if CleanupStatus != 0 as libc::c_int {
                EventID = 41 as libc::c_int as uint16;
            } else if StartupStatus != 0 as libc::c_int {
                EventID = 40 as libc::c_int as uint16;
            } else {
                EventID = 10 as libc::c_int as uint16;
            }
        }
        6 => {
            ReqName = b"Reload\0" as *const u8 as *const libc::c_char;
            if CleanupStatus != 0 as libc::c_int {
                EventID = 45 as libc::c_int as uint16;
            } else if StartupStatus != 0 as libc::c_int {
                EventID = 44 as libc::c_int as uint16;
            } else {
                EventID = 12 as libc::c_int as uint16;
            }
        }
        4 => {
            ReqName = b"ES_ProcControlReq: Invalid State\0" as *const u8 as *const libc::c_char;
            EventID = 47 as libc::c_int as uint16;
            snprintf(
                MessageDetail.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 48]>() as libc::c_ulong,
                b"EXCEPTION\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {
            ReqName = b"ES_ProcControlReq: Unknown State\0" as *const u8 as *const libc::c_char;
            EventID = 48 as libc::c_int as uint16;
            snprintf(
                MessageDetail.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 48]>() as libc::c_ulong,
                b"( %lu )\0" as *const u8 as *const libc::c_char,
                PendingControlReq as libc::c_ulong,
            );
        }
    }
    if MessageDetail[0 as libc::c_int as usize] as libc::c_int != 0 as libc::c_int {
        EventType = CFE_EVS_EventType_ERROR as libc::c_int as CFE_EVS_EventType_Enum_t;
    } else if StartupStatus != 0 as libc::c_int {
        EventType = CFE_EVS_EventType_ERROR as libc::c_int as CFE_EVS_EventType_Enum_t;
        snprintf(
            MessageDetail.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 48]>() as libc::c_ulong,
            b"Failed: AppCreate Error 0x%08X.\0" as *const u8 as *const libc::c_char,
            StartupStatus as libc::c_uint,
        );
    } else if CleanupStatus != 0 as libc::c_int {
        EventType = CFE_EVS_EventType_ERROR as libc::c_int as CFE_EVS_EventType_Enum_t;
        snprintf(
            MessageDetail.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 48]>() as libc::c_ulong,
            b"Failed: CleanUpApp Error 0x%08X.\0" as *const u8 as *const libc::c_char,
            CleanupStatus as libc::c_uint,
        );
    } else if CFE_ResourceId_IsDefined(NewAppId) {
        EventType = CFE_EVS_EventType_INFORMATION as libc::c_int as CFE_EVS_EventType_Enum_t;
        snprintf(
            MessageDetail.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 48]>() as libc::c_ulong,
            b"Completed, AppID=%lu\0" as *const u8 as *const libc::c_char,
            CFE_ResourceId_ToInteger(NewAppId),
        );
    } else {
        EventType = CFE_EVS_EventType_INFORMATION as libc::c_int as CFE_EVS_EventType_Enum_t;
        snprintf(
            MessageDetail.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 48]>() as libc::c_ulong,
            b"Completed.\0" as *const u8 as *const libc::c_char,
        );
    }
    CFE_EVS_SendEvent(
        EventID,
        EventType,
        b"%s Application %s %s\0" as *const u8 as *const libc::c_char,
        ReqName,
        OrigAppName.as_mut_ptr(),
        MessageDetail.as_mut_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_StartAppTask(
    mut TaskIdPtr: *mut CFE_ES_TaskId_t,
    mut TaskName: *const libc::c_char,
    mut EntryFunc: CFE_ES_TaskEntryFuncPtr_t,
    mut Params: *const CFE_ES_TaskStartParams_t,
    mut ParentAppId: CFE_ES_AppId_t,
) -> int32 {
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut OsalTaskId: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut LocalTaskId: CFE_ES_TaskId_t = 0;
    let mut OsStatus: int32 = 0;
    let mut ReturnCode: int32 = 0;
    OsStatus = OS_TaskCreate(
        &mut OsalTaskId,
        TaskName,
        Some(CFE_ES_TaskEntryPoint as unsafe extern "C" fn() -> ()),
        0 as *mut libc::c_void,
        (*Params).StackSize,
        (*Params).Priority as osal_priority_t,
        1 as libc::c_int as uint32,
    );
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_StartAppTask\0"))
            .as_ptr(),
        596 as libc::c_int,
    );
    if OsStatus == 0 as libc::c_int {
        LocalTaskId = CFE_ES_TaskId_FromOSAL(OsalTaskId);
        TaskRecPtr = CFE_ES_LocateTaskRecordByID(LocalTaskId);
        if CFE_ES_TaskRecordIsUsed(TaskRecPtr) {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: Error: ES_TaskTable slot for ID %lx in use at task creation!\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"CFE_ES_StartAppTask\0",
                ))
                .as_ptr(),
                OS_ObjectIdToInteger(OsalTaskId),
            );
        }
        memset(
            TaskRecPtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_ES_TaskRecord_t>() as libc::c_ulong,
        );
        (*TaskRecPtr).AppId = ParentAppId;
        (*TaskRecPtr).EntryFunc = EntryFunc;
        (*TaskRecPtr).StartParams = *Params;
        strncpy(
            ((*TaskRecPtr).TaskName).as_mut_ptr(),
            TaskName,
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*TaskRecPtr).TaskName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as usize] = 0 as libc::c_int as libc::c_char;
        CFE_ES_TaskRecordSetUsed(TaskRecPtr, LocalTaskId);
        CFE_ES_Global.RegisteredTasks = (CFE_ES_Global.RegisteredTasks).wrapping_add(1);
        CFE_ES_Global.RegisteredTasks;
        ReturnCode = 0 as libc::c_int;
        *TaskIdPtr = CFE_ES_TaskRecordGetID(TaskRecPtr);
    } else {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: AppCreate Error: TaskCreate %s Failed. EC = %ld!\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_StartAppTask\0"))
                .as_ptr(),
            TaskName,
            OsStatus as libc::c_long,
        );
        ReturnCode = 0xc8000005 as libc::c_uint as CFE_Status_t;
        *TaskIdPtr = 0 as libc::c_int as CFE_ResourceId_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_StartAppTask\0"))
            .as_ptr(),
        643 as libc::c_int,
    );
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CopyModuleBasicInfo(
    mut ParamsPtr: *const CFE_ES_ModuleLoadParams_t,
    mut AppInfoPtr: *mut CFE_ES_AppInfo_t,
) {
    strncpy(
        ((*AppInfoPtr).EntryPoint).as_mut_ptr(),
        ((*ParamsPtr).InitSymbolName).as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    (*AppInfoPtr).EntryPoint[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] = '\0' as i32 as libc::c_char;
    strncpy(
        ((*AppInfoPtr).FileName).as_mut_ptr(),
        ((*ParamsPtr).FileName).as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    (*AppInfoPtr).FileName[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] = '\0' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CopyModuleStatusInfo(
    mut StatusPtr: *const CFE_ES_ModuleLoadStatus_t,
    mut AppInfoPtr: *mut CFE_ES_AppInfo_t,
) {
    (*AppInfoPtr).StartAddress = ((*StatusPtr).InitSymbolAddress
        & 0xffffffff as libc::c_uint as libc::c_ulong)
        as CFE_ES_MemAddress_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CopyModuleAddressInfo(
    mut ModuleId: osal_id_t,
    mut AppInfoPtr: *mut CFE_ES_AppInfo_t,
) {
    let mut ModuleInfo: OS_module_prop_t = OS_module_prop_t {
        entry_point: 0,
        host_module_id: 0,
        filename: [0; 64],
        name: [0; 20],
        addr: OS_module_address_t {
            valid: 0,
            flags: 0,
            code_address: 0,
            code_size: 0,
            data_address: 0,
            data_size: 0,
            bss_address: 0,
            bss_size: 0,
        },
    };
    let mut OsStatus: int32 = 0;
    memset(
        &mut ModuleInfo as *mut OS_module_prop_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_module_prop_t>() as libc::c_ulong,
    );
    OsStatus = OS_ModuleInfo(ModuleId, &mut ModuleInfo);
    if OsStatus == 0 as libc::c_int {
        (*AppInfoPtr).AddressesAreValid = (::core::mem::size_of::<cpuaddr>() as libc::c_ulong
            <= ::core::mem::size_of::<CFE_ES_MemAddress_t>() as libc::c_ulong
            && ModuleInfo.addr.valid != 0) as libc::c_int
            as uint32;
    } else {
        (*AppInfoPtr).AddressesAreValid = 0 as libc::c_int as uint32;
    }
    (*AppInfoPtr).CodeAddress = (ModuleInfo.addr.code_address
        & 0xffffffff as libc::c_uint as libc::c_ulong)
        as CFE_ES_MemAddress_t;
    (*AppInfoPtr).CodeSize = ModuleInfo.addr.code_size as CFE_ES_MemOffset_t;
    (*AppInfoPtr).DataAddress = (ModuleInfo.addr.data_address
        & 0xffffffff as libc::c_uint as libc::c_ulong)
        as CFE_ES_MemAddress_t;
    (*AppInfoPtr).DataSize = ModuleInfo.addr.data_size as CFE_ES_MemOffset_t;
    (*AppInfoPtr).BSSAddress = (ModuleInfo.addr.bss_address
        & 0xffffffff as libc::c_uint as libc::c_ulong)
        as CFE_ES_MemAddress_t;
    (*AppInfoPtr).BSSSize = ModuleInfo.addr.bss_size as CFE_ES_MemOffset_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_BackgroundCleanup() {
    CFE_ES_DeleteChildTask(CFE_ES_Global.BackgroundTask.TaskID);
    OS_BinSemDelete(CFE_ES_Global.BackgroundTask.WorkSem);
    CFE_ES_Global.BackgroundTask.TaskID = 0 as libc::c_int as CFE_ResourceId_t;
    CFE_ES_Global.BackgroundTask.WorkSem = 0 as libc::c_int as osal_id_t;
}
#[no_mangle]
pub static mut CFE_ES_BACKGROUND_JOB_TABLE: [CFE_ES_BackgroundJobEntry_t; 4] =
    [CFE_ES_BackgroundJobEntry_t {
        RunFunc: None,
        JobArg: 0 as *mut libc::c_void,
        ActivePeriod: 0,
        IdlePeriod: 0,
    }; 4];
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_BackgroundTask() {
    let mut OsStatus: int32 = 0;
    let mut JobTotal: uint32 = 0;
    let mut NumJobsRunning: uint32 = 0;
    let mut NextDelay: uint32 = 0;
    let mut ElapsedTime: uint32 = 0;
    let mut CurrTime: OS_time_t = OS_time_t { ticks: 0 };
    let mut LastTime: OS_time_t = OS_time_t { ticks: 0 };
    let mut JobPtr: *const CFE_ES_BackgroundJobEntry_t = 0 as *const CFE_ES_BackgroundJobEntry_t;
    memset(
        &mut LastTime as *mut OS_time_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_time_t>() as libc::c_ulong,
    );
    memset(
        &mut CurrTime as *mut OS_time_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_time_t>() as libc::c_ulong,
    );
    CFE_PSP_GetTime(&mut LastTime);
    loop {
        CFE_PSP_GetTime(&mut CurrTime);
        ElapsedTime = OS_TimeGetTotalMilliseconds(OS_TimeSubtract(CurrTime, LastTime)) as uint32;
        LastTime = CurrTime;
        NextDelay = 30000 as libc::c_int as uint32;
        JobPtr = CFE_ES_BACKGROUND_JOB_TABLE.as_ptr();
        JobTotal = (::core::mem::size_of::<[CFE_ES_BackgroundJobEntry_t; 4]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<CFE_ES_BackgroundJobEntry_t>() as libc::c_ulong)
            as uint32;
        NumJobsRunning = 0 as libc::c_int as uint32;
        while JobTotal > 0 as libc::c_int as libc::c_uint {
            if ((*JobPtr).RunFunc).is_some()
                && ((*JobPtr).RunFunc).expect("non-null function pointer")(
                    ElapsedTime,
                    (*JobPtr).JobArg,
                ) as libc::c_int
                    != 0
            {
                NumJobsRunning = NumJobsRunning.wrapping_add(1);
                NumJobsRunning;
                if (*JobPtr).ActivePeriod != 0 as libc::c_int as libc::c_uint
                    && NextDelay > (*JobPtr).ActivePeriod
                {
                    NextDelay = (*JobPtr).ActivePeriod;
                }
            } else if (*JobPtr).IdlePeriod != 0 as libc::c_int as libc::c_uint
                && NextDelay > (*JobPtr).IdlePeriod
            {
                NextDelay = (*JobPtr).IdlePeriod;
            }
            JobTotal = JobTotal.wrapping_sub(1);
            JobTotal;
            JobPtr = JobPtr.offset(1);
            JobPtr;
        }
        CFE_ES_Global.BackgroundTask.NumJobsRunning = NumJobsRunning;
        OsStatus = OS_BinSemTimedWait(CFE_ES_Global.BackgroundTask.WorkSem, NextDelay);
        if !(OsStatus != 0 as libc::c_int && OsStatus != -(7 as libc::c_int)) {
            continue;
        }
        CFE_ES_WriteToSysLog(
            b"%s: Failed to take background sem: %ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_BackgroundTask\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        break;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_BackgroundInit() -> int32 {
    let mut status: int32 = 0;
    let mut OsStatus: int32 = 0;
    OsStatus = OS_BinSemCreate(
        &mut CFE_ES_Global.BackgroundTask.WorkSem,
        b"ES_BG_SEM\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to create background sem: %ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_BackgroundInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    status = CFE_ES_CreateChildTask(
        &mut CFE_ES_Global.BackgroundTask.TaskID,
        b"ES_BG_TASK\0" as *const u8 as *const libc::c_char,
        Some(CFE_ES_BackgroundTask as unsafe extern "C" fn() -> ()),
        0 as *mut libc::c_void,
        4096 as libc::c_int as size_t,
        200 as libc::c_int as CFE_ES_TaskPriority_Atom_t,
        0 as libc::c_int as uint32,
    );
    if status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to create background task: %08lx\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_BackgroundInit\0"))
                .as_ptr(),
            status as libc::c_ulong,
        );
        return status;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_BackgroundWakeup() {
    OS_BinSemGive(CFE_ES_Global.BackgroundTask.WorkSem);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDS_EarlyInit() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut PlatformSize: uint32 = 0;
    let mut MinRequiredSize: size_t = 0;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut PspStatus: int32 = 0;
    CFE_ES_Global.CDSIsAvailable = 0 as libc::c_int != 0;
    OsStatus = OS_MutSemCreate(
        &mut (*CDS).GenMutex,
        b"CDS_MUTEX\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Failed to create mutex with error %ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_CDS_EarlyInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    (*CDS).LastCDSBlockId =
        CFE_ResourceId_FromInteger(CFE_ES_CDSBLOCKID_BASE as libc::c_int as libc::c_ulong);
    PspStatus = CFE_PSP_GetCDSSize(&mut PlatformSize);
    if PspStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Unable to obtain CDS Size from BSP (Err=0x%08X)\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_CDS_EarlyInit\0"))
                .as_ptr(),
            PspStatus as libc::c_uint,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    (*CDS).TotalSize = (PlatformSize & 0xfffffffc as libc::c_uint) as size_t;
    MinRequiredSize = (::core::mem::size_of::<CFE_ES_CDS_PersistentHeader_t>() as libc::c_ulong)
        .wrapping_add(::core::mem::size_of::<CFE_ES_CDS_PersistentTrailer_t>() as libc::c_ulong);
    MinRequiredSize = (MinRequiredSize as libc::c_ulong)
        .wrapping_add(CFE_ES_CDSReqdMinSize(512 as libc::c_int as uint32))
        as size_t as size_t;
    if (*CDS).TotalSize < MinRequiredSize {
        CFE_ES_WriteToSysLog(
            b"%s: CDS Size (%lu) less than required (%lu)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_CDS_EarlyInit\0"))
                .as_ptr(),
            (*CDS).TotalSize,
            MinRequiredSize,
        );
        Status = 0 as libc::c_int;
    } else {
        (*CDS).DataSize = (*CDS).TotalSize;
        (*CDS).DataSize = ((*CDS).DataSize as libc::c_ulong).wrapping_sub(
            (::core::mem::size_of::<CFE_ES_CDS_PersistentHeader_t>() as libc::c_ulong)
                .wrapping_add(
                    ::core::mem::size_of::<CFE_ES_CDS_PersistentTrailer_t>() as libc::c_ulong
                ),
        ) as size_t as size_t;
        Status = CFE_ES_ValidateCDS();
        if Status == 0 as libc::c_int {
            Status = CFE_ES_RebuildCDS();
        }
        if Status == 0xc4000012 as libc::c_uint as CFE_Status_t {
            Status = CFE_ES_ClearCDS();
            if Status == 0 as libc::c_int {
                Status = CFE_ES_InitCDSSignatures();
            }
            if Status == 0 as libc::c_int {
                Status = CFE_ES_CreateCDSPool(
                    (*CDS).DataSize,
                    ::core::mem::size_of::<CFE_ES_CDS_PersistentHeader_t>() as libc::c_ulong,
                );
            }
            if Status == 0 as libc::c_int {
                Status = CFE_ES_InitCDSRegistry();
            }
        }
        if Status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Error validating/initializing CDS (0x%08lX)\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                    b"CFE_ES_CDS_EarlyInit\0",
                ))
                .as_ptr(),
                Status as libc::c_ulong,
            );
        } else {
            CFE_ES_Global.CDSIsAvailable = 1 as libc::c_int != 0;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDSHandle_ToIndex(
    mut BlockID: CFE_ES_CDSHandle_t,
    mut Idx: *mut uint32,
) -> int32 {
    return CFE_ResourceId_ToIndex(
        BlockID,
        CFE_ES_CDSBLOCKID_BASE as libc::c_int as uint32,
        512 as libc::c_int as uint32,
        Idx,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CheckCDSHandleSlotUsed(mut CheckId: CFE_ResourceId_t) -> bool {
    let mut CDSRegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    CDSRegRecPtr = CFE_ES_LocateCDSBlockRecordByID(CheckId);
    return CDSRegRecPtr.is_null() || CFE_ES_CDSBlockRecordIsUsed(CDSRegRecPtr) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateCDSBlockRecordByID(
    mut BlockID: CFE_ES_CDSHandle_t,
) -> *mut CFE_ES_CDS_RegRec_t {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut CDSRegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    let mut Idx: uint32 = 0;
    if CFE_ES_CDSHandle_ToIndex(BlockID, &mut Idx) == 0 as libc::c_int {
        CDSRegRecPtr =
            &mut *((*CDS).Registry).as_mut_ptr().offset(Idx as isize) as *mut CFE_ES_CDS_RegRec_t;
    } else {
        CDSRegRecPtr = 0 as *mut CFE_ES_CDS_RegRec_t;
    }
    return CDSRegRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDS_CacheFetch(
    mut Cache: *mut CFE_ES_CDS_AccessCache_t,
    mut Offset: size_t,
    mut Size: size_t,
) -> int32 {
    let mut Status: int32 = 0;
    if Size > 0 as libc::c_int as libc::c_ulong
        && Size <= ::core::mem::size_of::<CFE_ES_CDS_AccessCacheData_t>() as libc::c_ulong
    {
        (*Cache).AccessStatus = CFE_PSP_ReadFromCDS(
            &mut (*Cache).Data as *mut CFE_ES_CDS_AccessCacheData_t as *mut libc::c_void,
            Offset as uint32,
            Size as uint32,
        );
        if (*Cache).AccessStatus == 0 as libc::c_int {
            (*Cache).Offset = Offset;
            (*Cache).Size = Size;
            Status = 0 as libc::c_int;
        } else {
            Status = 0xc4000013 as libc::c_uint as CFE_Status_t;
        }
    } else {
        Status = 0xc4000010 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDS_CacheFlush(mut Cache: *mut CFE_ES_CDS_AccessCache_t) -> int32 {
    let mut Status: int32 = 0;
    if (*Cache).Size > 0 as libc::c_int as libc::c_ulong
        && (*Cache).Size <= ::core::mem::size_of::<CFE_ES_CDS_AccessCacheData_t>() as libc::c_ulong
    {
        (*Cache).AccessStatus = CFE_PSP_WriteToCDS(
            &mut (*Cache).Data as *mut CFE_ES_CDS_AccessCacheData_t as *const libc::c_void,
            (*Cache).Offset as uint32,
            (*Cache).Size as uint32,
        );
        if (*Cache).AccessStatus == 0 as libc::c_int {
            Status = 0 as libc::c_int;
        } else {
            Status = 0xc4000013 as libc::c_uint as CFE_Status_t;
        }
    } else {
        Status = 0xc4000010 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDS_CachePreload(
    mut Cache: *mut CFE_ES_CDS_AccessCache_t,
    mut Source: *const libc::c_void,
    mut Offset: size_t,
    mut Size: size_t,
) -> int32 {
    let mut Status: int32 = 0;
    if Size > 0 as libc::c_int as libc::c_ulong
        && Size <= ::core::mem::size_of::<CFE_ES_CDS_AccessCacheData_t>() as libc::c_ulong
    {
        if Source.is_null() {
            memset(
                &mut (*Cache).Data as *mut CFE_ES_CDS_AccessCacheData_t as *mut libc::c_void,
                0 as libc::c_int,
                Size,
            );
        } else if Source
            != &mut (*Cache).Data as *mut CFE_ES_CDS_AccessCacheData_t as *const libc::c_void
        {
            memcpy(
                &mut (*Cache).Data as *mut CFE_ES_CDS_AccessCacheData_t as *mut libc::c_void,
                Source,
                Size,
            );
        }
        (*Cache).Size = Size;
        (*Cache).Offset = Offset;
        Status = 0 as libc::c_int;
    } else {
        Status = 0xc4000010 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RegisterCDSEx(
    mut HandlePtr: *mut CFE_ES_CDSHandle_t,
    mut UserBlockSize: size_t,
    mut Name: *const libc::c_char,
    mut CriticalTbl: bool,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut Status: int32 = 0;
    let mut RegUpdateStatus: int32 = 0;
    let mut RegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    let mut BlockOffset: size_t = 0;
    let mut OldBlockSize: size_t = 0;
    let mut NewBlockSize: size_t = 0;
    let mut PendingBlockId: CFE_ResourceId_t = 0;
    let mut IsNewEntry: bool = false;
    let mut IsNewOffset: bool = false;
    Status = 0 as libc::c_int;
    RegUpdateStatus = 0 as libc::c_int;
    IsNewEntry = 0 as libc::c_int != 0;
    IsNewOffset = 0 as libc::c_int != 0;
    if UserBlockSize == 0 as libc::c_int as libc::c_ulong
        || UserBlockSize
            > (((1 as libc::c_int) << 30 as libc::c_int) as size_t)
                .wrapping_sub(::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong)
    {
        return 0xc4000010 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockCDS();
    RegRecPtr = CFE_ES_LocateCDSBlockRecordByName(Name);
    if !RegRecPtr.is_null() {
        PendingBlockId = CFE_ES_CDSBlockRecordGetID(RegRecPtr);
    } else {
        PendingBlockId = CFE_ResourceId_FindNext(
            (*CDS).LastCDSBlockId,
            512 as libc::c_int as uint32,
            Some(CFE_ES_CheckCDSHandleSlotUsed as unsafe extern "C" fn(CFE_ResourceId_t) -> bool),
        );
        RegRecPtr = CFE_ES_LocateCDSBlockRecordByID(PendingBlockId);
        if !RegRecPtr.is_null() {
            memset(
                RegRecPtr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<CFE_ES_CDS_RegRec_t>() as libc::c_ulong,
            );
            (*CDS).LastCDSBlockId = PendingBlockId;
            IsNewEntry = 1 as libc::c_int != 0;
            Status = 0 as libc::c_int;
        } else {
            Status = 0xc400002b as libc::c_uint as CFE_Status_t;
            PendingBlockId = 0 as libc::c_int as CFE_ResourceId_t;
        }
    }
    if !RegRecPtr.is_null() {
        NewBlockSize = UserBlockSize;
        NewBlockSize = (NewBlockSize as libc::c_ulong)
            .wrapping_add(::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong)
            as size_t as size_t;
        if Status == 0 as libc::c_int
            && (*RegRecPtr).BlockOffset != 0 as libc::c_int as libc::c_ulong
            && NewBlockSize != (*RegRecPtr).BlockSize
        {
            Status = CFE_ES_GenPoolPutBlock(
                &mut (*CDS).Pool,
                &mut OldBlockSize,
                (*RegRecPtr).BlockOffset,
            );
            if Status == 0 as libc::c_int {
                (*RegRecPtr).BlockOffset = 0 as libc::c_int as size_t;
                (*RegRecPtr).BlockSize = 0 as libc::c_int as size_t;
            }
        }
        if Status == 0 as libc::c_int
            && (*RegRecPtr).BlockOffset == 0 as libc::c_int as libc::c_ulong
        {
            Status = CFE_ES_GenPoolGetBlock(&mut (*CDS).Pool, &mut BlockOffset, NewBlockSize);
            if Status == 0 as libc::c_int {
                (*RegRecPtr).BlockOffset = BlockOffset;
                (*RegRecPtr).BlockSize = NewBlockSize;
                IsNewOffset = 1 as libc::c_int != 0;
            }
        }
        if Status == 0 as libc::c_int && IsNewEntry as libc::c_int != 0 {
            (*RegRecPtr).Table = CriticalTbl;
            strncpy(
                ((*RegRecPtr).Name).as_mut_ptr(),
                Name,
                (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*RegRecPtr).Name[(::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
            CFE_ES_CDSBlockRecordSetUsed(RegRecPtr, PendingBlockId);
        }
        if Status == 0 as libc::c_int && IsNewOffset as libc::c_int != 0 {
            RegUpdateStatus = CFE_ES_UpdateCDSRegistry();
        }
    }
    CFE_ES_UnlockCDS();
    if RegUpdateStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to update CDS Registry (Stat=0x%08X)\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_RegisterCDSEx\0"))
                .as_ptr(),
            RegUpdateStatus as libc::c_uint,
        );
        if Status == 0 as libc::c_int {
            Status = RegUpdateStatus;
        }
    }
    if Status == 0 as libc::c_int && !IsNewOffset {
        Status = 0x4400000d as libc::c_int;
    }
    *HandlePtr = PendingBlockId;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ValidateCDS() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut TrailerOffset: size_t = 0;
    let SIG_CDS_SIZE: size_t = 8 as libc::c_int as size_t;
    let mut Status: int32 = 0;
    Status = CFE_ES_CDS_CacheFetch(&mut (*CDS).Cache, 0 as libc::c_ulong, SIG_CDS_SIZE);
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: 1st ReadFromCDS Failed. Status=0x%X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_ValidateCDS\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    if strncmp(
        ((*CDS).Cache.Data.Sig).as_mut_ptr(),
        b"_CDSBeg_\0" as *const u8 as *const libc::c_char,
        8 as libc::c_int as libc::c_ulong,
    ) != 0 as libc::c_int
    {
        return 0xc4000012 as libc::c_uint as CFE_Status_t;
    }
    TrailerOffset = (*CDS).TotalSize;
    TrailerOffset = (TrailerOffset as libc::c_ulong)
        .wrapping_sub(::core::mem::size_of::<CFE_ES_CDS_PersistentTrailer_t>() as libc::c_ulong)
        as size_t as size_t;
    Status = CFE_ES_CDS_CacheFetch(&mut (*CDS).Cache, TrailerOffset, SIG_CDS_SIZE);
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: 2nd ReadFromCDS Failed. Status=0x%X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_ValidateCDS\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    if strncmp(
        ((*CDS).Cache.Data.Sig).as_mut_ptr(),
        b"_CDSEnd_\0" as *const u8 as *const libc::c_char,
        8 as libc::c_int as libc::c_ulong,
    ) != 0 as libc::c_int
    {
        return 0xc4000012 as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ClearCDS() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut RemainSize: size_t = 0;
    let mut Status: int32 = 0;
    Status = 0 as libc::c_int;
    CFE_ES_CDS_CachePreload(
        &mut (*CDS).Cache,
        0 as *const libc::c_void,
        0 as libc::c_int as size_t,
        ::core::mem::size_of::<[uint32; 4]>() as libc::c_ulong,
    );
    while (*CDS).Cache.Offset < (*CDS).TotalSize {
        RemainSize = ((*CDS).TotalSize).wrapping_sub((*CDS).Cache.Offset);
        if RemainSize < ::core::mem::size_of::<[uint32; 4]>() as libc::c_ulong {
            (*CDS).Cache.Size = RemainSize;
        }
        Status = CFE_ES_CDS_CacheFlush(&mut (*CDS).Cache);
        if Status != 0 as libc::c_int {
            break;
        }
        (*CDS).Cache.Offset = ((*CDS).Cache.Offset as libc::c_ulong).wrapping_add((*CDS).Cache.Size)
            as size_t as size_t;
    }
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Clear CDS failed @ Offset=%lu Status=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_ClearCDS\0"))
                .as_ptr(),
            (*CDS).Cache.Offset,
            (*CDS).Cache.AccessStatus as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_InitCDSSignatures() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut SigOffset: size_t = 0;
    let mut Status: int32 = 0;
    SigOffset = 0 as libc::c_int as size_t;
    CFE_ES_CDS_CachePreload(
        &mut (*CDS).Cache,
        b"_CDSBeg_\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        SigOffset,
        8 as libc::c_int as size_t,
    );
    Status = CFE_ES_CDS_CacheFlush(&mut (*CDS).Cache);
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: '_CDSBeg_' write failed. Status=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_ES_InitCDSSignatures\0",
            ))
            .as_ptr(),
            (*CDS).Cache.AccessStatus as libc::c_uint,
        );
        return Status;
    }
    SigOffset = (*CDS).TotalSize;
    SigOffset = (SigOffset as libc::c_ulong)
        .wrapping_sub(::core::mem::size_of::<CFE_ES_CDS_PersistentTrailer_t>() as libc::c_ulong)
        as size_t as size_t;
    CFE_ES_CDS_CachePreload(
        &mut (*CDS).Cache,
        b"_CDSEnd_\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        SigOffset,
        8 as libc::c_int as size_t,
    );
    Status = CFE_ES_CDS_CacheFlush(&mut (*CDS).Cache);
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: '_CDSEnd_' write failed. Status=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_ES_InitCDSSignatures\0",
            ))
            .as_ptr(),
            (*CDS).Cache.AccessStatus as libc::c_uint,
        );
        return Status;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_InitCDSRegistry() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut Status: int32 = 0;
    let mut RegSize: uint32 = 0;
    RegSize = 512 as libc::c_int as uint32;
    CFE_ES_CDS_CachePreload(
        &mut (*CDS).Cache,
        &mut RegSize as *mut uint32 as *const libc::c_void,
        8 as libc::c_ulong,
        ::core::mem::size_of::<uint32>() as libc::c_ulong,
    );
    Status = CFE_ES_CDS_CacheFlush(&mut (*CDS).Cache);
    if Status == 0 as libc::c_int {
        memset(
            ((*CDS).Registry).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<[CFE_ES_CDS_RegRec_t; 512]>() as libc::c_ulong,
        );
        Status = CFE_ES_UpdateCDSRegistry();
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to write Reg Size. Status=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_InitCDSRegistry\0",
            ))
            .as_ptr(),
            (*CDS).Cache.AccessStatus as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_UpdateCDSRegistry() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut PspStatus: int32 = 0;
    PspStatus = CFE_PSP_WriteToCDS(
        ((*CDS).Registry).as_mut_ptr() as *const libc::c_void,
        12 as libc::c_ulong as uint32,
        ::core::mem::size_of::<[CFE_ES_CDS_RegRec_t; 512]>() as libc::c_ulong as uint32,
    );
    if PspStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to write CDS Registry. Status=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_ES_UpdateCDSRegistry\0",
            ))
            .as_ptr(),
            PspStatus as libc::c_uint,
        );
        return 0xc4000013 as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_FormCDSName(
    mut FullCDSName: *mut libc::c_char,
    mut CDSName: *const libc::c_char,
    mut ThisAppId: CFE_ES_AppId_t,
) {
    let mut AppName: [libc::c_char; 20] = [0; 20];
    CFE_ES_GetAppName(
        AppName.as_mut_ptr(),
        ThisAppId,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    AppName[(20 as libc::c_int - 1 as libc::c_int) as usize] = '\0' as i32 as libc::c_char;
    sprintf(
        FullCDSName,
        b"%s.%s\0" as *const u8 as *const libc::c_char,
        AppName.as_mut_ptr(),
        CDSName,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LockCDS() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    OsStatus = OS_MutSemTake((*CDS).GenMutex);
    if OsStatus == 0 as libc::c_int {
        Status = 0 as libc::c_int;
    } else {
        Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_UnlockCDS() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    OsStatus = OS_MutSemGive((*CDS).GenMutex);
    if OsStatus == 0 as libc::c_int {
        Status = 0 as libc::c_int;
    } else {
        Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateCDSBlockRecordByName(
    mut CDSName: *const libc::c_char,
) -> *mut CFE_ES_CDS_RegRec_t {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut CDSRegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    let mut NumReg: uint32 = 0;
    CDSRegRecPtr = ((*CDS).Registry).as_mut_ptr();
    NumReg = 512 as libc::c_int as uint32;
    loop {
        if NumReg == 0 as libc::c_int as libc::c_uint {
            CDSRegRecPtr = 0 as *mut CFE_ES_CDS_RegRec_t;
            break;
        } else {
            if CFE_ES_CDSBlockRecordIsUsed(CDSRegRecPtr) {
                if strcmp(CDSName, ((*CDSRegRecPtr).Name).as_mut_ptr()) == 0 as libc::c_int {
                    break;
                }
            }
            CDSRegRecPtr = CDSRegRecPtr.offset(1);
            CDSRegRecPtr;
            NumReg = NumReg.wrapping_sub(1);
            NumReg;
        }
    }
    return CDSRegRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RebuildCDS() -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut Status: int32 = 0;
    let mut PspStatus: int32 = 0;
    Status = CFE_ES_CDS_CacheFetch(
        &mut (*CDS).Cache,
        8 as libc::c_ulong,
        ::core::mem::size_of::<uint32>() as libc::c_ulong,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: PSP Error reading Registry size (%lx)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RebuildCDS\0"))
                .as_ptr(),
            (*CDS).Cache.AccessStatus as libc::c_ulong,
        );
        return 0xc4000012 as libc::c_uint as CFE_Status_t;
    }
    if (*CDS).Cache.Data.RegistrySize != 512 as libc::c_int as libc::c_uint {
        CFE_ES_WriteToSysLog(
            b"%s: Registry in CDS incorrect size (%lu)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RebuildCDS\0"))
                .as_ptr(),
            (*CDS).Cache.Data.RegistrySize as libc::c_ulong,
        );
        return 0xc4000012 as libc::c_uint as CFE_Status_t;
    }
    PspStatus = CFE_PSP_ReadFromCDS(
        &mut (*CDS).Registry as *mut [CFE_ES_CDS_RegRec_t; 512] as *mut libc::c_void,
        12 as libc::c_ulong as uint32,
        ::core::mem::size_of::<[CFE_ES_CDS_RegRec_t; 512]>() as libc::c_ulong as uint32,
    );
    if PspStatus == 0 as libc::c_int {
        Status = CFE_ES_RebuildCDSPool(
            (*CDS).DataSize,
            ::core::mem::size_of::<CFE_ES_CDS_PersistentHeader_t>() as libc::c_ulong,
        );
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Registry in CDS is unreadable, PSP error %lx\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_RebuildCDS\0"))
                .as_ptr(),
            PspStatus as libc::c_ulong,
        );
        Status = 0xc4000012 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_DeleteCDS(
    mut CDSName: *const libc::c_char,
    mut CalledByTblServices: bool,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut Status: int32 = 0;
    let mut RegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    let mut OwnerName: [libc::c_char; 20] = [0; 20];
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut i: uint32 = 0;
    let mut LogMessage: [libc::c_char; 148] = [0; 148];
    let mut OldBlockSize: size_t = 0;
    LogMessage[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    CFE_ES_LockCDS();
    RegRecPtr = CFE_ES_LocateCDSBlockRecordByName(CDSName);
    if !RegRecPtr.is_null() {
        if (*RegRecPtr).Table as libc::c_int != CalledByTblServices as libc::c_int {
            Status = 0xc4000020 as libc::c_uint as CFE_Status_t;
        } else {
            i = 0 as libc::c_int as uint32;
            while i < (20 as libc::c_int - 1 as libc::c_int) as libc::c_uint
                && (*RegRecPtr).Name[i as usize] as libc::c_int != '.' as i32
            {
                OwnerName[i as usize] = (*RegRecPtr).Name[i as usize];
                i = i.wrapping_add(1);
                i;
            }
            OwnerName[i as usize] = '\0' as i32 as libc::c_char;
            Status = CFE_ES_GetAppIDByName(&mut AppId, OwnerName.as_mut_ptr());
            if Status != 0 as libc::c_int {
                Status = CFE_ES_GenPoolPutBlock(
                    &mut (*CDS).Pool,
                    &mut OldBlockSize,
                    (*RegRecPtr).BlockOffset,
                );
                if Status != 0 as libc::c_int {
                    snprintf(
                        LogMessage.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
                        b"Failed to free CDS Mem Block (Handle=0x%08lX)(Stat=0x%08X)\n\0"
                            as *const u8 as *const libc::c_char,
                        (*RegRecPtr).BlockOffset,
                        Status as libc::c_uint,
                    );
                } else {
                    CFE_ES_CDSBlockRecordSetFree(RegRecPtr);
                    Status = CFE_ES_UpdateCDSRegistry();
                    if Status != 0 as libc::c_int {
                        snprintf(
                            LogMessage.as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
                            b"Failed to update CDS Registry (Stat=0x%08X)\n\0" as *const u8
                                as *const libc::c_char,
                            Status as libc::c_uint,
                        );
                    }
                }
            } else {
                Status = 0xc4000022 as libc::c_uint as CFE_Status_t;
            }
        }
    } else {
        Status = 0xc4000002 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockCDS();
    if LogMessage[0 as libc::c_int as usize] as libc::c_int != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: %s\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_ES_DeleteCDS\0"))
                .as_ptr(),
            LogMessage.as_mut_ptr(),
        );
    }
    return Status;
}
#[no_mangle]
pub static mut CFE_ES_CDSMemPoolDefSize: [size_t; 17] = [
    80000 as libc::c_int as size_t,
    32768 as libc::c_int as size_t,
    16384 as libc::c_int as size_t,
    8192 as libc::c_int as size_t,
    4096 as libc::c_int as size_t,
    2048 as libc::c_int as size_t,
    1024 as libc::c_int as size_t,
    512 as libc::c_int as size_t,
    256 as libc::c_int as size_t,
    160 as libc::c_int as size_t,
    128 as libc::c_int as size_t,
    96 as libc::c_int as size_t,
    64 as libc::c_int as size_t,
    48 as libc::c_int as size_t,
    32 as libc::c_int as size_t,
    16 as libc::c_int as size_t,
    8 as libc::c_int as size_t,
];
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDS_PoolRetrieve(
    mut GenPoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut Offset: size_t,
    mut BdPtr: *mut *mut CFE_ES_GenPoolBD_t,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = GenPoolRecPtr as *mut CFE_ES_CDS_Instance_t;
    *BdPtr = &mut (*CDS).Cache.Data.Desc;
    return CFE_ES_CDS_CacheFetch(
        &mut (*CDS).Cache,
        Offset,
        ::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDS_PoolCommit(
    mut GenPoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut Offset: size_t,
    mut BdPtr: *const CFE_ES_GenPoolBD_t,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = GenPoolRecPtr as *mut CFE_ES_CDS_Instance_t;
    CFE_ES_CDS_CachePreload(
        &mut (*CDS).Cache,
        BdPtr as *const libc::c_void,
        Offset,
        ::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong,
    );
    return CFE_ES_CDS_CacheFlush(&mut (*CDS).Cache);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CreateCDSPool(
    mut CDSPoolSize: size_t,
    mut StartOffset: size_t,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut Status: int32 = 0;
    let mut SizeCheck: size_t = 0;
    let mut ActualSize: size_t = 0;
    SizeCheck = CFE_ES_GenPoolCalcMinSize(
        17 as libc::c_int as uint16,
        CFE_ES_CDSMemPoolDefSize.as_ptr(),
        1 as libc::c_int as uint32,
    );
    ActualSize = CDSPoolSize;
    if ActualSize < SizeCheck {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Pool size(%lu) too small for one CDS Block, need >=%lu\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_CreateCDSPool\0"))
                .as_ptr(),
            ActualSize,
            SizeCheck,
        );
        return 0xc4000010 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_GenPoolInitialize(
        &mut (*CDS).Pool,
        StartOffset,
        ActualSize,
        4 as libc::c_int as size_t,
        17 as libc::c_int as uint16,
        CFE_ES_CDSMemPoolDefSize.as_ptr(),
        Some(
            CFE_ES_CDS_PoolRetrieve
                as unsafe extern "C" fn(
                    *mut CFE_ES_GenPoolRecord_t,
                    size_t,
                    *mut *mut CFE_ES_GenPoolBD_t,
                ) -> int32,
        ),
        Some(
            CFE_ES_CDS_PoolCommit
                as unsafe extern "C" fn(
                    *mut CFE_ES_GenPoolRecord_t,
                    size_t,
                    *const CFE_ES_GenPoolBD_t,
                ) -> int32,
        ),
    );
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RebuildCDSPool(
    mut CDSPoolSize: size_t,
    mut StartOffset: size_t,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut Status: int32 = 0;
    Status = CFE_ES_CreateCDSPool(CDSPoolSize, StartOffset);
    if Status != 0 as libc::c_int {
        return Status;
    }
    Status = CFE_ES_GenPoolRebuild(&mut (*CDS).Pool);
    if Status != 0 as libc::c_int {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Err rebuilding CDS (Stat=0x%08x)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_RebuildCDSPool\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        Status = 0xc4000013 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDSBlockWrite(
    mut Handle: CFE_ES_CDSHandle_t,
    mut DataToWrite: *const libc::c_void,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut LogMessage: [libc::c_char; 148] = [0; 148];
    let mut Status: int32 = 0;
    let mut PspStatus: int32 = 0;
    let mut BlockSize: size_t = 0;
    let mut UserDataSize: size_t = 0;
    let mut UserDataOffset: size_t = 0;
    let mut CDSRegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    LogMessage[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    CDSRegRecPtr = CFE_ES_LocateCDSBlockRecordByID(Handle);
    CFE_ES_LockCDS();
    if CFE_ES_CDSBlockRecordIsMatch(CDSRegRecPtr, Handle) {
        Status = CFE_ES_GenPoolGetBlockSize(
            &mut (*CDS).Pool,
            &mut BlockSize,
            (*CDSRegRecPtr).BlockOffset,
        );
        if Status != 0 as libc::c_int {
            snprintf(
                LogMessage.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
                b"Invalid Handle or Block Descriptor.\n\0" as *const u8 as *const libc::c_char,
            );
        } else if BlockSize <= ::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong
            || BlockSize != (*CDSRegRecPtr).BlockSize
        {
            snprintf(
                LogMessage.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
                b"Block size %lu invalid, expected %lu\n\0" as *const u8 as *const libc::c_char,
                BlockSize,
                (*CDSRegRecPtr).BlockSize,
            );
            Status = 0xc4000010 as libc::c_uint as CFE_Status_t;
        } else {
            UserDataSize = (*CDSRegRecPtr).BlockSize;
            UserDataSize = (UserDataSize as libc::c_ulong)
                .wrapping_sub(::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong)
                as size_t as size_t;
            UserDataOffset = (*CDSRegRecPtr).BlockOffset;
            UserDataOffset = (UserDataOffset as libc::c_ulong)
                .wrapping_add(::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong)
                as size_t as size_t;
            (*CDS).Cache.Data.BlockHeader.Crc = CFE_ES_CalculateCRC(
                DataToWrite,
                UserDataSize,
                0 as libc::c_int as uint32,
                CFE_ES_CrcType_16_ARC,
            );
            (*CDS).Cache.Offset = (*CDSRegRecPtr).BlockOffset;
            (*CDS).Cache.Size = ::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong;
            Status = CFE_ES_CDS_CacheFlush(&mut (*CDS).Cache);
            if Status != 0 as libc::c_int {
                snprintf(
                    LogMessage.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
                    b"Err writing header data to CDS (Stat=0x%08x) @Offset=0x%08lx\n\0" as *const u8
                        as *const libc::c_char,
                    (*CDS).Cache.AccessStatus as libc::c_uint,
                    (*CDSRegRecPtr).BlockOffset,
                );
            } else {
                PspStatus = CFE_PSP_WriteToCDS(
                    DataToWrite,
                    UserDataOffset as uint32,
                    UserDataSize as uint32,
                );
                if PspStatus != 0 as libc::c_int {
                    snprintf(
                        LogMessage.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
                        b"Err writing user data to CDS (Stat=0x%08x) @Offset=0x%08lx\n\0"
                            as *const u8 as *const libc::c_char,
                        PspStatus as libc::c_uint,
                        UserDataOffset,
                    );
                    Status = 0xc4000013 as libc::c_uint as CFE_Status_t;
                }
            }
        }
    } else {
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockCDS();
    if LogMessage[0 as libc::c_int as usize] as libc::c_int != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: %s\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_CDSBlockWrite\0"))
                .as_ptr(),
            LogMessage.as_mut_ptr(),
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDSBlockRead(
    mut DataRead: *mut libc::c_void,
    mut Handle: CFE_ES_CDSHandle_t,
) -> int32 {
    let mut CDS: *mut CFE_ES_CDS_Instance_t = &mut CFE_ES_Global.CDSVars;
    let mut Status: int32 = 0;
    let mut PspStatus: int32 = 0;
    let mut CrcOfCDSData: uint32 = 0;
    let mut BlockSize: size_t = 0;
    let mut UserDataSize: size_t = 0;
    let mut UserDataOffset: size_t = 0;
    let mut CDSRegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    CDSRegRecPtr = CFE_ES_LocateCDSBlockRecordByID(Handle);
    CFE_ES_LockCDS();
    if CFE_ES_CDSBlockRecordIsMatch(CDSRegRecPtr, Handle) {
        Status = CFE_ES_GenPoolGetBlockSize(
            &mut (*CDS).Pool,
            &mut BlockSize,
            (*CDSRegRecPtr).BlockOffset,
        );
        if Status == 0 as libc::c_int {
            if BlockSize <= ::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong
                || BlockSize != (*CDSRegRecPtr).BlockSize
            {
                Status = 0xc4000010 as libc::c_uint as CFE_Status_t;
            } else {
                UserDataSize = (*CDSRegRecPtr).BlockSize;
                UserDataSize = (UserDataSize as libc::c_ulong)
                    .wrapping_sub(
                        ::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong
                    ) as size_t as size_t;
                UserDataOffset = (*CDSRegRecPtr).BlockOffset;
                UserDataOffset =
                    (UserDataOffset as libc::c_ulong)
                        .wrapping_add(
                            ::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong
                        ) as size_t as size_t;
                Status = CFE_ES_CDS_CacheFetch(
                    &mut (*CDS).Cache,
                    (*CDSRegRecPtr).BlockOffset,
                    ::core::mem::size_of::<CFE_ES_CDS_BlockHeader_t>() as libc::c_ulong,
                );
                if Status == 0 as libc::c_int {
                    PspStatus = CFE_PSP_ReadFromCDS(
                        DataRead,
                        UserDataOffset as uint32,
                        UserDataSize as uint32,
                    );
                    if PspStatus == 0 as libc::c_int {
                        CrcOfCDSData = CFE_ES_CalculateCRC(
                            DataRead,
                            UserDataSize,
                            0 as libc::c_int as uint32,
                            CFE_ES_CrcType_16_ARC,
                        );
                        if CrcOfCDSData != (*CDS).Cache.Data.BlockHeader.Crc {
                            Status = 0xc400001a as libc::c_uint as CFE_Status_t;
                        } else {
                            Status = 0 as libc::c_int;
                        }
                    } else {
                        Status = 0xc4000013 as libc::c_uint as CFE_Status_t;
                    }
                }
            }
        }
    } else {
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockCDS();
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CDSReqdMinSize(mut MaxNumBlocksToSupport: uint32) -> size_t {
    let mut ReqSize: size_t = 0;
    ReqSize = CFE_ES_GenPoolCalcMinSize(
        17 as libc::c_int as uint16,
        CFE_ES_CDSMemPoolDefSize.as_ptr(),
        MaxNumBlocksToSupport,
    );
    return ReqSize;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ComputeCRC_Algo_NONE(
    mut DataPtr: *const libc::c_void,
    mut DataLength: size_t,
    mut InputCRC: uint32,
) -> uint32 {
    return 0 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ComputeCRC_Algo_16_ARC(
    mut DataPtr: *const libc::c_void,
    mut DataLength: size_t,
    mut InputCRC: uint32,
) -> uint32 {
    let mut i: size_t = 0;
    let mut Index: uint16 = 0;
    let mut Crc: uint16 = 0;
    let mut BufPtr: *const uint8 = 0 as *const uint8;
    static mut CrcTable: [uint16; 256] = [
        0 as libc::c_int as uint16,
        0xc0c1 as libc::c_int as uint16,
        0xc181 as libc::c_int as uint16,
        0x140 as libc::c_int as uint16,
        0xc301 as libc::c_int as uint16,
        0x3c0 as libc::c_int as uint16,
        0x280 as libc::c_int as uint16,
        0xc241 as libc::c_int as uint16,
        0xc601 as libc::c_int as uint16,
        0x6c0 as libc::c_int as uint16,
        0x780 as libc::c_int as uint16,
        0xc741 as libc::c_int as uint16,
        0x500 as libc::c_int as uint16,
        0xc5c1 as libc::c_int as uint16,
        0xc481 as libc::c_int as uint16,
        0x440 as libc::c_int as uint16,
        0xcc01 as libc::c_int as uint16,
        0xcc0 as libc::c_int as uint16,
        0xd80 as libc::c_int as uint16,
        0xcd41 as libc::c_int as uint16,
        0xf00 as libc::c_int as uint16,
        0xcfc1 as libc::c_int as uint16,
        0xce81 as libc::c_int as uint16,
        0xe40 as libc::c_int as uint16,
        0xa00 as libc::c_int as uint16,
        0xcac1 as libc::c_int as uint16,
        0xcb81 as libc::c_int as uint16,
        0xb40 as libc::c_int as uint16,
        0xc901 as libc::c_int as uint16,
        0x9c0 as libc::c_int as uint16,
        0x880 as libc::c_int as uint16,
        0xc841 as libc::c_int as uint16,
        0xd801 as libc::c_int as uint16,
        0x18c0 as libc::c_int as uint16,
        0x1980 as libc::c_int as uint16,
        0xd941 as libc::c_int as uint16,
        0x1b00 as libc::c_int as uint16,
        0xdbc1 as libc::c_int as uint16,
        0xda81 as libc::c_int as uint16,
        0x1a40 as libc::c_int as uint16,
        0x1e00 as libc::c_int as uint16,
        0xdec1 as libc::c_int as uint16,
        0xdf81 as libc::c_int as uint16,
        0x1f40 as libc::c_int as uint16,
        0xdd01 as libc::c_int as uint16,
        0x1dc0 as libc::c_int as uint16,
        0x1c80 as libc::c_int as uint16,
        0xdc41 as libc::c_int as uint16,
        0x1400 as libc::c_int as uint16,
        0xd4c1 as libc::c_int as uint16,
        0xd581 as libc::c_int as uint16,
        0x1540 as libc::c_int as uint16,
        0xd701 as libc::c_int as uint16,
        0x17c0 as libc::c_int as uint16,
        0x1680 as libc::c_int as uint16,
        0xd641 as libc::c_int as uint16,
        0xd201 as libc::c_int as uint16,
        0x12c0 as libc::c_int as uint16,
        0x1380 as libc::c_int as uint16,
        0xd341 as libc::c_int as uint16,
        0x1100 as libc::c_int as uint16,
        0xd1c1 as libc::c_int as uint16,
        0xd081 as libc::c_int as uint16,
        0x1040 as libc::c_int as uint16,
        0xf001 as libc::c_int as uint16,
        0x30c0 as libc::c_int as uint16,
        0x3180 as libc::c_int as uint16,
        0xf141 as libc::c_int as uint16,
        0x3300 as libc::c_int as uint16,
        0xf3c1 as libc::c_int as uint16,
        0xf281 as libc::c_int as uint16,
        0x3240 as libc::c_int as uint16,
        0x3600 as libc::c_int as uint16,
        0xf6c1 as libc::c_int as uint16,
        0xf781 as libc::c_int as uint16,
        0x3740 as libc::c_int as uint16,
        0xf501 as libc::c_int as uint16,
        0x35c0 as libc::c_int as uint16,
        0x3480 as libc::c_int as uint16,
        0xf441 as libc::c_int as uint16,
        0x3c00 as libc::c_int as uint16,
        0xfcc1 as libc::c_int as uint16,
        0xfd81 as libc::c_int as uint16,
        0x3d40 as libc::c_int as uint16,
        0xff01 as libc::c_int as uint16,
        0x3fc0 as libc::c_int as uint16,
        0x3e80 as libc::c_int as uint16,
        0xfe41 as libc::c_int as uint16,
        0xfa01 as libc::c_int as uint16,
        0x3ac0 as libc::c_int as uint16,
        0x3b80 as libc::c_int as uint16,
        0xfb41 as libc::c_int as uint16,
        0x3900 as libc::c_int as uint16,
        0xf9c1 as libc::c_int as uint16,
        0xf881 as libc::c_int as uint16,
        0x3840 as libc::c_int as uint16,
        0x2800 as libc::c_int as uint16,
        0xe8c1 as libc::c_int as uint16,
        0xe981 as libc::c_int as uint16,
        0x2940 as libc::c_int as uint16,
        0xeb01 as libc::c_int as uint16,
        0x2bc0 as libc::c_int as uint16,
        0x2a80 as libc::c_int as uint16,
        0xea41 as libc::c_int as uint16,
        0xee01 as libc::c_int as uint16,
        0x2ec0 as libc::c_int as uint16,
        0x2f80 as libc::c_int as uint16,
        0xef41 as libc::c_int as uint16,
        0x2d00 as libc::c_int as uint16,
        0xedc1 as libc::c_int as uint16,
        0xec81 as libc::c_int as uint16,
        0x2c40 as libc::c_int as uint16,
        0xe401 as libc::c_int as uint16,
        0x24c0 as libc::c_int as uint16,
        0x2580 as libc::c_int as uint16,
        0xe541 as libc::c_int as uint16,
        0x2700 as libc::c_int as uint16,
        0xe7c1 as libc::c_int as uint16,
        0xe681 as libc::c_int as uint16,
        0x2640 as libc::c_int as uint16,
        0x2200 as libc::c_int as uint16,
        0xe2c1 as libc::c_int as uint16,
        0xe381 as libc::c_int as uint16,
        0x2340 as libc::c_int as uint16,
        0xe101 as libc::c_int as uint16,
        0x21c0 as libc::c_int as uint16,
        0x2080 as libc::c_int as uint16,
        0xe041 as libc::c_int as uint16,
        0xa001 as libc::c_int as uint16,
        0x60c0 as libc::c_int as uint16,
        0x6180 as libc::c_int as uint16,
        0xa141 as libc::c_int as uint16,
        0x6300 as libc::c_int as uint16,
        0xa3c1 as libc::c_int as uint16,
        0xa281 as libc::c_int as uint16,
        0x6240 as libc::c_int as uint16,
        0x6600 as libc::c_int as uint16,
        0xa6c1 as libc::c_int as uint16,
        0xa781 as libc::c_int as uint16,
        0x6740 as libc::c_int as uint16,
        0xa501 as libc::c_int as uint16,
        0x65c0 as libc::c_int as uint16,
        0x6480 as libc::c_int as uint16,
        0xa441 as libc::c_int as uint16,
        0x6c00 as libc::c_int as uint16,
        0xacc1 as libc::c_int as uint16,
        0xad81 as libc::c_int as uint16,
        0x6d40 as libc::c_int as uint16,
        0xaf01 as libc::c_int as uint16,
        0x6fc0 as libc::c_int as uint16,
        0x6e80 as libc::c_int as uint16,
        0xae41 as libc::c_int as uint16,
        0xaa01 as libc::c_int as uint16,
        0x6ac0 as libc::c_int as uint16,
        0x6b80 as libc::c_int as uint16,
        0xab41 as libc::c_int as uint16,
        0x6900 as libc::c_int as uint16,
        0xa9c1 as libc::c_int as uint16,
        0xa881 as libc::c_int as uint16,
        0x6840 as libc::c_int as uint16,
        0x7800 as libc::c_int as uint16,
        0xb8c1 as libc::c_int as uint16,
        0xb981 as libc::c_int as uint16,
        0x7940 as libc::c_int as uint16,
        0xbb01 as libc::c_int as uint16,
        0x7bc0 as libc::c_int as uint16,
        0x7a80 as libc::c_int as uint16,
        0xba41 as libc::c_int as uint16,
        0xbe01 as libc::c_int as uint16,
        0x7ec0 as libc::c_int as uint16,
        0x7f80 as libc::c_int as uint16,
        0xbf41 as libc::c_int as uint16,
        0x7d00 as libc::c_int as uint16,
        0xbdc1 as libc::c_int as uint16,
        0xbc81 as libc::c_int as uint16,
        0x7c40 as libc::c_int as uint16,
        0xb401 as libc::c_int as uint16,
        0x74c0 as libc::c_int as uint16,
        0x7580 as libc::c_int as uint16,
        0xb541 as libc::c_int as uint16,
        0x7700 as libc::c_int as uint16,
        0xb7c1 as libc::c_int as uint16,
        0xb681 as libc::c_int as uint16,
        0x7640 as libc::c_int as uint16,
        0x7200 as libc::c_int as uint16,
        0xb2c1 as libc::c_int as uint16,
        0xb381 as libc::c_int as uint16,
        0x7340 as libc::c_int as uint16,
        0xb101 as libc::c_int as uint16,
        0x71c0 as libc::c_int as uint16,
        0x7080 as libc::c_int as uint16,
        0xb041 as libc::c_int as uint16,
        0x5000 as libc::c_int as uint16,
        0x90c1 as libc::c_int as uint16,
        0x9181 as libc::c_int as uint16,
        0x5140 as libc::c_int as uint16,
        0x9301 as libc::c_int as uint16,
        0x53c0 as libc::c_int as uint16,
        0x5280 as libc::c_int as uint16,
        0x9241 as libc::c_int as uint16,
        0x9601 as libc::c_int as uint16,
        0x56c0 as libc::c_int as uint16,
        0x5780 as libc::c_int as uint16,
        0x9741 as libc::c_int as uint16,
        0x5500 as libc::c_int as uint16,
        0x95c1 as libc::c_int as uint16,
        0x9481 as libc::c_int as uint16,
        0x5440 as libc::c_int as uint16,
        0x9c01 as libc::c_int as uint16,
        0x5cc0 as libc::c_int as uint16,
        0x5d80 as libc::c_int as uint16,
        0x9d41 as libc::c_int as uint16,
        0x5f00 as libc::c_int as uint16,
        0x9fc1 as libc::c_int as uint16,
        0x9e81 as libc::c_int as uint16,
        0x5e40 as libc::c_int as uint16,
        0x5a00 as libc::c_int as uint16,
        0x9ac1 as libc::c_int as uint16,
        0x9b81 as libc::c_int as uint16,
        0x5b40 as libc::c_int as uint16,
        0x9901 as libc::c_int as uint16,
        0x59c0 as libc::c_int as uint16,
        0x5880 as libc::c_int as uint16,
        0x9841 as libc::c_int as uint16,
        0x8801 as libc::c_int as uint16,
        0x48c0 as libc::c_int as uint16,
        0x4980 as libc::c_int as uint16,
        0x8941 as libc::c_int as uint16,
        0x4b00 as libc::c_int as uint16,
        0x8bc1 as libc::c_int as uint16,
        0x8a81 as libc::c_int as uint16,
        0x4a40 as libc::c_int as uint16,
        0x4e00 as libc::c_int as uint16,
        0x8ec1 as libc::c_int as uint16,
        0x8f81 as libc::c_int as uint16,
        0x4f40 as libc::c_int as uint16,
        0x8d01 as libc::c_int as uint16,
        0x4dc0 as libc::c_int as uint16,
        0x4c80 as libc::c_int as uint16,
        0x8c41 as libc::c_int as uint16,
        0x4400 as libc::c_int as uint16,
        0x84c1 as libc::c_int as uint16,
        0x8581 as libc::c_int as uint16,
        0x4540 as libc::c_int as uint16,
        0x8701 as libc::c_int as uint16,
        0x47c0 as libc::c_int as uint16,
        0x4680 as libc::c_int as uint16,
        0x8641 as libc::c_int as uint16,
        0x8201 as libc::c_int as uint16,
        0x42c0 as libc::c_int as uint16,
        0x4380 as libc::c_int as uint16,
        0x8341 as libc::c_int as uint16,
        0x4100 as libc::c_int as uint16,
        0x81c1 as libc::c_int as uint16,
        0x8081 as libc::c_int as uint16,
        0x4040 as libc::c_int as uint16,
    ];
    i = DataLength;
    BufPtr = DataPtr as *const uint8;
    Crc = InputCRC as uint16;
    while i > 0 as libc::c_int as libc::c_ulong {
        Index = *BufPtr as uint16;
        Index = ((Crc as libc::c_int ^ Index as libc::c_int) & 0xff as libc::c_int) as uint16;
        Crc = (Crc as libc::c_int >> 8 as libc::c_int & 0xff as libc::c_int
            ^ CrcTable[Index as usize] as libc::c_int) as uint16;
        i = i.wrapping_sub(1);
        i;
        BufPtr = BufPtr.offset(1);
        BufPtr;
    }
    return Crc as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ComputeCRC_GetParams(
    mut CrcType: CFE_ES_CrcType_Enum_t,
) -> *const CFE_ES_ComputeCRC_Params_t {
    let mut ParamPtr: *const CFE_ES_ComputeCRC_Params_t = 0 as *const CFE_ES_ComputeCRC_Params_t;
    static mut CRC_PARAM_NONE: CFE_ES_ComputeCRC_Params_t = unsafe {
        {
            let mut init = CFE_ES_ComputeCRC_Params {
                InitialValue: 0 as libc::c_int as uint32,
                FinalXOR: 0 as libc::c_int as uint32,
                Algorithm: Some(
                    CFE_ES_ComputeCRC_Algo_NONE
                        as unsafe extern "C" fn(*const libc::c_void, size_t, uint32) -> uint32,
                ),
            };
            init
        }
    };
    static mut CRC_PARAM_TABLE: [CFE_ES_ComputeCRC_Params_t; 2] = unsafe {
        [
            CFE_ES_ComputeCRC_Params_t {
                InitialValue: 0,
                FinalXOR: 0,
                Algorithm: None,
            },
            {
                let mut init = CFE_ES_ComputeCRC_Params {
                    InitialValue: 0 as libc::c_int as uint32,
                    FinalXOR: 0 as libc::c_int as uint32,
                    Algorithm: Some(
                        CFE_ES_ComputeCRC_Algo_16_ARC
                            as unsafe extern "C" fn(*const libc::c_void, size_t, uint32) -> uint32,
                    ),
                };
                init
            },
        ]
    };
    if (CrcType as libc::c_uint) < CFE_ES_CrcType_MAX as libc::c_int as libc::c_uint {
        ParamPtr = &*CRC_PARAM_TABLE.as_ptr().offset(CrcType as isize)
            as *const CFE_ES_ComputeCRC_Params_t;
    } else {
        ParamPtr = 0 as *const CFE_ES_ComputeCRC_Params_t;
    }
    if ParamPtr.is_null() || ((*ParamPtr).Algorithm).is_none() {
        ParamPtr = &CRC_PARAM_NONE;
    }
    return ParamPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_VerifyCmdLength(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut ExpectedLength: size_t,
) -> bool {
    let mut result: bool = 1 as libc::c_int != 0;
    let mut ActualLength: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetSize(MsgPtr, &mut ActualLength);
    if ExpectedLength != ActualLength {
        CFE_MSG_GetMsgId(MsgPtr, &mut MsgId);
        CFE_MSG_GetFcnCode(MsgPtr, &mut FcnCode);
        CFE_EVS_SendEvent(
            23 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid msg length: ID = 0x%X,  CC = %u, Len = %u, Expected = %u\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            FcnCode as libc::c_uint,
            ActualLength as libc::c_uint,
            ExpectedLength as libc::c_uint,
        );
        result = 0 as libc::c_int != 0;
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_TaskPipe(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MessageID: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    let mut CommandCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MessageID);
    match CFE_SB_MsgIdToValue(MessageID) {
        6152 => {
            CFE_ES_HousekeepingCmd(SBBufPtr as *const CFE_ES_SendHkCmd_t);
        }
        6150 => {
            CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut CommandCode);
            match CommandCode as libc::c_int {
                0 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_NoopCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_NoopCmd(SBBufPtr as *const CFE_ES_NoopCmd_t);
                    }
                }
                1 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_ResetCountersCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_ResetCountersCmd(SBBufPtr as *const CFE_ES_ResetCountersCmd_t);
                    }
                }
                2 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_RestartCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_RestartCmd(SBBufPtr as *const CFE_ES_RestartCmd_t);
                    }
                }
                4 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_StartAppCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_StartAppCmd(SBBufPtr as *const CFE_ES_StartAppCmd_t);
                    }
                }
                5 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_StopAppCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_StopAppCmd(SBBufPtr as *const CFE_ES_StopAppCmd_t);
                    }
                }
                6 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_RestartAppCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_RestartAppCmd(SBBufPtr as *const CFE_ES_RestartAppCmd_t);
                    }
                }
                7 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_ReloadAppCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_ReloadAppCmd(SBBufPtr as *const CFE_ES_ReloadAppCmd_t);
                    }
                }
                8 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_QueryOneCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_QueryOneCmd(SBBufPtr as *const CFE_ES_QueryOneCmd_t);
                    }
                }
                9 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_QueryAllCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_QueryAllCmd(SBBufPtr as *const CFE_ES_QueryAllCmd_t);
                    }
                }
                24 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_QueryAllTasksCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_QueryAllTasksCmd(SBBufPtr as *const CFE_ES_QueryAllTasksCmd_t);
                    }
                }
                10 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_ClearSysLogCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_ClearSysLogCmd(SBBufPtr as *const CFE_ES_ClearSysLogCmd_t);
                    }
                }
                11 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_WriteSysLogCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_WriteSysLogCmd(SBBufPtr as *const CFE_ES_WriteSysLogCmd_t);
                    }
                }
                18 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_OverWriteSysLogCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_OverWriteSysLogCmd(SBBufPtr as *const CFE_ES_OverWriteSysLogCmd_t);
                    }
                }
                12 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_ClearERLogCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_ClearERLogCmd(SBBufPtr as *const CFE_ES_ClearERLogCmd_t);
                    }
                }
                13 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_WriteERLogCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_WriteERLogCmd(SBBufPtr as *const CFE_ES_WriteERLogCmd_t);
                    }
                }
                14 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_StartPerfDataCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_StartPerfDataCmd(SBBufPtr as *const CFE_ES_StartPerfDataCmd_t);
                    }
                }
                15 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_StopPerfDataCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_StopPerfDataCmd(SBBufPtr as *const CFE_ES_StopPerfDataCmd_t);
                    }
                }
                16 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_SetPerfFilterMaskCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_SetPerfFilterMaskCmd(
                            SBBufPtr as *const CFE_ES_SetPerfFilterMaskCmd_t,
                        );
                    }
                }
                17 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_SetPerfTriggerMaskCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_SetPerfTriggerMaskCmd(
                            SBBufPtr as *const CFE_ES_SetPerfTriggerMaskCmd_t,
                        );
                    }
                }
                19 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_ResetPRCountCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_ResetPRCountCmd(SBBufPtr as *const CFE_ES_ResetPRCountCmd_t);
                    }
                }
                20 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_SetMaxPRCountCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_SetMaxPRCountCmd(SBBufPtr as *const CFE_ES_SetMaxPRCountCmd_t);
                    }
                }
                21 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_DeleteCDSCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_DeleteCDSCmd(SBBufPtr as *const CFE_ES_DeleteCDSCmd_t);
                    }
                }
                22 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_SendMemPoolStatsCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_SendMemPoolStatsCmd(SBBufPtr as *const CFE_ES_SendMemPoolStatsCmd_t);
                    }
                }
                23 => {
                    if CFE_ES_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_ES_DumpCDSRegistryCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_ES_DumpCDSRegistryCmd(SBBufPtr as *const CFE_ES_DumpCDSRegistryCmd_t);
                    }
                }
                _ => {
                    CFE_EVS_SendEvent(
                        22 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Invalid ground command code: ID = 0x%X, CC = %d\0" as *const u8
                            as *const libc::c_char,
                        CFE_SB_MsgIdToValue(MessageID),
                        CommandCode as libc::c_int,
                    );
                    CFE_ES_Global.TaskData.CommandErrorCounter =
                        (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
                    CFE_ES_Global.TaskData.CommandErrorCounter;
                }
            }
        }
        _ => {
            CFE_EVS_SendEvent(
                21 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Invalid command pipe message ID: 0x%X\0" as *const u8 as *const libc::c_char,
                CFE_SB_MsgIdToValue(MessageID),
            );
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_WriteToERLogWithContext(
    mut EntryType: CFE_ES_LogEntryType_Enum_t,
    mut ResetType: uint32,
    mut ResetSubtype: uint32,
    mut Description: *const libc::c_char,
    mut AppId: CFE_ES_AppId_t,
    mut PspContextId: uint32,
) -> int32 {
    let mut LogIdx: uint32 = 0;
    let mut EntryPtr: *mut CFE_ES_ERLog_MetaData_t = 0 as *mut CFE_ES_ERLog_MetaData_t;
    let mut PendingTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    PendingTime = CFE_TIME_GetTime();
    if Description.is_null() {
        Description = b"No Description String Given.\0" as *const u8 as *const libc::c_char;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"CFE_ES_WriteToERLogWithContext\0",
        ))
        .as_ptr(),
        75 as libc::c_int,
    );
    if (*CFE_ES_Global.ResetDataPtr).ERLogIndex >= 20 as libc::c_int as libc::c_uint {
        (*CFE_ES_Global.ResetDataPtr).ERLogIndex = 0 as libc::c_int as uint32;
    }
    LogIdx = (*CFE_ES_Global.ResetDataPtr).ERLogIndex;
    (*CFE_ES_Global.ResetDataPtr).ERLogIndex =
        ((*CFE_ES_Global.ResetDataPtr).ERLogIndex).wrapping_add(1);
    (*CFE_ES_Global.ResetDataPtr).ERLogIndex;
    if (*CFE_ES_Global.ResetDataPtr).ERLogIndex >= 20 as libc::c_int as libc::c_uint {
        (*CFE_ES_Global.ResetDataPtr).ERLogIndex = 0 as libc::c_int as uint32;
    }
    EntryPtr = &mut *((*CFE_ES_Global.ResetDataPtr).ERLog)
        .as_mut_ptr()
        .offset(LogIdx as isize) as *mut CFE_ES_ERLog_MetaData_t;
    memset(
        EntryPtr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_ERLog_MetaData_t>() as libc::c_ulong,
    );
    (*EntryPtr).BaseInfo.LogEntryType = EntryType as uint32;
    (*EntryPtr).BaseInfo.ResetType = ResetType;
    (*EntryPtr).BaseInfo.ResetSubtype = ResetSubtype;
    (*EntryPtr).BaseInfo.BootSource = (*CFE_ES_Global.ResetDataPtr).ResetVars.BootSource;
    (*EntryPtr).BaseInfo.ProcessorResetCount =
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount;
    (*EntryPtr).BaseInfo.MaxProcessorResetCount = (*CFE_ES_Global.ResetDataPtr)
        .ResetVars
        .MaxProcessorResetCount;
    memcpy(
        &mut (*EntryPtr).BaseInfo.DebugVars as *mut CFE_ES_DebugVariables_t as *mut libc::c_void,
        &mut CFE_ES_Global.DebugVars as *mut CFE_ES_DebugVariables_t as *const libc::c_void,
        ::core::mem::size_of::<CFE_ES_DebugVariables_t>() as libc::c_ulong,
    );
    (*EntryPtr).BaseInfo.TimeCode = PendingTime;
    strncpy(
        ((*EntryPtr).BaseInfo.Description).as_mut_ptr(),
        Description,
        (::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    (*EntryPtr).BaseInfo.Description[(::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = '\0' as i32 as libc::c_char;
    (*EntryPtr).AppID = AppId;
    (*EntryPtr).PspContextId = PspContextId;
    (*CFE_ES_Global.ResetDataPtr).ERLogEntries =
        ((*CFE_ES_Global.ResetDataPtr).ERLogEntries).wrapping_add(1);
    (*CFE_ES_Global.ResetDataPtr).ERLogEntries;
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
            b"CFE_ES_WriteToERLogWithContext\0",
        ))
        .as_ptr(),
        141 as libc::c_int,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_WriteToERLog(
    mut EntryType: CFE_ES_LogEntryType_Enum_t,
    mut ResetType: uint32,
    mut ResetSubtype: uint32,
    mut Description: *const libc::c_char,
) -> int32 {
    return CFE_ES_WriteToERLogWithContext(
        EntryType,
        ResetType,
        ResetSubtype,
        Description,
        0 as libc::c_int as CFE_ResourceId_t,
        0 as libc::c_int as uint32,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_BackgroundERLogFileDataGetter(
    mut Meta: *mut libc::c_void,
    mut RecordNum: uint32,
    mut Buffer: *mut *mut libc::c_void,
    mut BufSize: *mut size_t,
) -> bool {
    let mut BgFilePtr: *mut CFE_ES_BackgroundLogDumpGlobal_t =
        0 as *mut CFE_ES_BackgroundLogDumpGlobal_t;
    let mut FileBufferPtr: *mut CFE_ES_ERLog_FileEntry_t = 0 as *mut CFE_ES_ERLog_FileEntry_t;
    let mut EntryPtr: *mut CFE_ES_ERLog_MetaData_t = 0 as *mut CFE_ES_ERLog_MetaData_t;
    let mut PspStatus: int32 = 0;
    BgFilePtr = Meta as *mut CFE_ES_BackgroundLogDumpGlobal_t;
    FileBufferPtr = &mut (*BgFilePtr).EntryBuffer;
    if RecordNum < 20 as libc::c_int as libc::c_uint {
        EntryPtr = &mut *((*CFE_ES_Global.ResetDataPtr).ERLog)
            .as_mut_ptr()
            .offset(RecordNum as isize) as *mut CFE_ES_ERLog_MetaData_t;
        memset(
            FileBufferPtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_ES_ERLog_FileEntry_t>() as libc::c_ulong,
        );
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
                b"CFE_ES_BackgroundERLogFileDataGetter\0",
            ))
            .as_ptr(),
            183 as libc::c_int,
        );
        (*FileBufferPtr).BaseInfo = (*EntryPtr).BaseInfo;
        PspStatus = CFE_PSP_Exception_CopyContext(
            (*EntryPtr).PspContextId,
            &mut (*FileBufferPtr).Context as *mut [uint8; 256] as *mut libc::c_void,
            ::core::mem::size_of::<[uint8; 256]>() as libc::c_ulong as uint32,
        );
        if PspStatus > 0 as libc::c_int {
            (*FileBufferPtr).ContextSize = PspStatus as uint32;
        } else {
            (*FileBufferPtr).ContextSize = 0 as libc::c_int as uint32;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 37], &[libc::c_char; 37]>(
                b"CFE_ES_BackgroundERLogFileDataGetter\0",
            ))
            .as_ptr(),
            207 as libc::c_int,
        );
        *Buffer = FileBufferPtr as *mut libc::c_void;
        *BufSize = ::core::mem::size_of::<CFE_ES_ERLog_FileEntry_t>() as libc::c_ulong;
    } else {
        *Buffer = 0 as *mut libc::c_void;
        *BufSize = 0 as libc::c_int as size_t;
    }
    return RecordNum >= (20 as libc::c_int - 1 as libc::c_int) as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_BackgroundERLogFileEventHandler(
    mut Meta: *mut libc::c_void,
    mut Event: CFE_FS_FileWriteEvent_t,
    mut Status: int32,
    mut RecordNum: uint32,
    mut BlockSize: size_t,
    mut Position: size_t,
) {
    let mut BgFilePtr: *mut CFE_ES_BackgroundLogDumpGlobal_t =
        0 as *mut CFE_ES_BackgroundLogDumpGlobal_t;
    BgFilePtr = Meta as *mut CFE_ES_BackgroundLogDumpGlobal_t;
    match Event as libc::c_uint {
        1 => {
            CFE_EVS_SendEvent(
                20 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"%s written:Size=%lu\0" as *const u8 as *const libc::c_char,
                ((*BgFilePtr).FileWrite.FileName).as_mut_ptr(),
                Position,
            );
        }
        3 | 4 => {
            CFE_EVS_SendEvent(
                74 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"File write,byte cnt err,file %s,request=%u,actual=%u\0" as *const u8
                    as *const libc::c_char,
                ((*BgFilePtr).FileWrite.FileName).as_mut_ptr(),
                BlockSize as libc::c_int,
                Status,
            );
        }
        2 => {
            CFE_EVS_SendEvent(
                56 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error creating file %s, RC = %d\0" as *const u8 as *const libc::c_char,
                ((*BgFilePtr).FileWrite.FileName).as_mut_ptr(),
                Status,
            );
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RunExceptionScan(
    mut ElapsedTime: uint32,
    mut Arg: *mut libc::c_void,
) -> bool {
    let mut Status: int32 = 0;
    let mut PspStatus: int32 = 0;
    let mut PspContextId: uint32 = 0;
    let mut ReasonString: [libc::c_char; 80] = [0; 80];
    let mut EsTaskInfo: CFE_ES_TaskInfo_t = CFE_ES_TaskInfo_t {
        TaskId: 0,
        ExecutionCounter: 0,
        TaskName: [0; 20],
        AppId: 0,
        AppName: [0; 20],
        StackSize: 0,
        Priority: 0,
        Spare: [0; 2],
    };
    let mut ExceptionTaskID: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut ResetType: uint32 = 0;
    let mut LogType: CFE_ES_LogEntryType_Enum_t = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    if CFE_PSP_Exception_GetCount() == 0 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int != 0;
    }
    ResetType = 0 as libc::c_int as uint32;
    memset(
        &mut EsTaskInfo as *mut CFE_ES_TaskInfo_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_TaskInfo_t>() as libc::c_ulong,
    );
    PspStatus = CFE_PSP_Exception_GetSummary(
        &mut PspContextId,
        &mut ExceptionTaskID,
        ReasonString.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong as uint32,
    );
    if PspStatus != 0 as libc::c_int {
        snprintf(
            ReasonString.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
            b"Unknown - CFE_PSP_ExceptionGetSummary() error %ld\0" as *const u8
                as *const libc::c_char,
            PspStatus as libc::c_long,
        );
        PspContextId = 0 as libc::c_int as uint32;
        ExceptionTaskID = 0 as libc::c_int as osal_id_t;
    }
    CFE_ES_WriteToSysLog(
        b"%s: ExceptionID 0x%lx in TaskID %lu: %s\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"CFE_ES_RunExceptionScan\0"))
            .as_ptr(),
        PspContextId as libc::c_ulong,
        OS_ObjectIdToInteger(ExceptionTaskID),
        ReasonString.as_mut_ptr(),
    );
    if OS_ObjectIdDefined(ExceptionTaskID) {
        Status = CFE_ES_GetTaskInfo(&mut EsTaskInfo, CFE_ES_TaskId_FromOSAL(ExceptionTaskID));
        if Status == 0 as libc::c_int {
            AppRecPtr = CFE_ES_LocateAppRecordByID(EsTaskInfo.AppId);
            CFE_ES_LockSharedData(
                (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                    b"CFE_ES_RunExceptionScan\0",
                ))
                .as_ptr(),
                339 as libc::c_int,
            );
            if CFE_ES_AppRecordIsMatch(AppRecPtr, EsTaskInfo.AppId) as libc::c_int != 0
                && (*AppRecPtr).StartParams.ExceptionAction as libc::c_int
                    == CFE_ES_ExceptionAction_RESTART_APP as libc::c_int
            {
                ResetType = 3 as libc::c_int as uint32;
            }
            CFE_ES_UnlockSharedData(
                (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                    b"CFE_ES_RunExceptionScan\0",
                ))
                .as_ptr(),
                348 as libc::c_int,
            );
        }
    }
    loop {
        if ResetType == 0 as libc::c_int as libc::c_uint {
            if (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount
                >= (*CFE_ES_Global.ResetDataPtr)
                    .ResetVars
                    .MaxProcessorResetCount
            {
                CFE_ES_WriteToSysLog(
                    b"%s: Maximum Processor Reset count reached (%u)\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                        b"CFE_ES_RunExceptionScan\0",
                    ))
                    .as_ptr(),
                    (*CFE_ES_Global.ResetDataPtr)
                        .ResetVars
                        .MaxProcessorResetCount,
                );
                ResetType = 2 as libc::c_int as uint32;
            } else {
                CFE_ES_WriteToSysLog(
                    b"%s: Processor Reset count not reached (%u/%u)\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                        b"CFE_ES_RunExceptionScan\0",
                    ))
                    .as_ptr(),
                    (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount,
                    (*CFE_ES_Global.ResetDataPtr)
                        .ResetVars
                        .MaxProcessorResetCount,
                );
                (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount =
                    ((*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount).wrapping_add(1);
                (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount;
                (*CFE_ES_Global.ResetDataPtr).ResetVars.ES_CausedReset = 1 as libc::c_int as uint32;
                ResetType = 1 as libc::c_int as uint32;
            }
        }
        if ResetType == 3 as libc::c_int as libc::c_uint {
            LogType = CFE_ES_LogEntryType_APPLICATION as libc::c_int as CFE_ES_LogEntryType_Enum_t;
        } else {
            LogType = CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t;
        }
        CFE_ES_WriteToERLogWithContext(
            LogType,
            ResetType,
            6 as libc::c_int as uint32,
            ReasonString.as_mut_ptr(),
            EsTaskInfo.AppId,
            PspContextId,
        );
        if ResetType == 3 as libc::c_int as libc::c_uint {
            Status = CFE_ES_RestartApp(EsTaskInfo.AppId);
            if Status != 0 as libc::c_int {
                ResetType = 0 as libc::c_int as uint32;
                snprintf(
                    ReasonString.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
                    b"App Restart Failed\0" as *const u8 as *const libc::c_char,
                );
            }
        } else {
            CFE_PSP_Restart(ResetType);
        }
        if !(ResetType == 0 as libc::c_int as libc::c_uint) {
            break;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolFindBucket(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut ReqSize: size_t,
) -> uint16 {
    let mut Index: uint16 = 0;
    Index = 0 as libc::c_int as uint16;
    while (Index as libc::c_int) < (*PoolRecPtr).NumBuckets as libc::c_int {
        if ReqSize <= (*PoolRecPtr).Buckets[Index as usize].BlockSize {
            break;
        }
        Index = Index.wrapping_add(1);
        Index;
    }
    return ((*PoolRecPtr).NumBuckets as libc::c_int - Index as libc::c_int) as uint16;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolGetBucketState(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut BucketId: uint16,
) -> *mut CFE_ES_GenPoolBucket_t {
    let mut Index: uint16 = 0;
    Index = ((*PoolRecPtr).NumBuckets as libc::c_int - BucketId as libc::c_int) as uint16;
    if Index as libc::c_int >= (*PoolRecPtr).NumBuckets as libc::c_int {
        return 0 as *mut CFE_ES_GenPoolBucket_t;
    }
    return &mut *((*PoolRecPtr).Buckets).as_mut_ptr().offset(Index as isize)
        as *mut CFE_ES_GenPoolBucket_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolRecyclePoolBlock(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut BucketId: uint16,
    mut NewSize: size_t,
    mut BlockOffsetPtr: *mut size_t,
) -> int32 {
    let mut BucketPtr: *mut CFE_ES_GenPoolBucket_t = 0 as *mut CFE_ES_GenPoolBucket_t;
    let mut DescOffset: size_t = 0;
    let mut BlockOffset: size_t = 0;
    let mut NextOffset: size_t = 0;
    let mut BdPtr: *mut CFE_ES_GenPoolBD_t = 0 as *mut CFE_ES_GenPoolBD_t;
    let mut RecycleBucketId: uint16 = 0;
    let mut Status: int32 = 0;
    BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
    if BucketPtr.is_null()
        || (*BucketPtr).RecycleCount == (*BucketPtr).ReleaseCount
        || (*BucketPtr).FirstOffset == 0 as libc::c_int as libc::c_ulong
    {
        return 0xc4000025 as libc::c_uint as CFE_Status_t;
    }
    BlockOffset = (*BucketPtr).FirstOffset;
    DescOffset =
        BlockOffset.wrapping_sub(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong);
    Status = ((*PoolRecPtr).Retrieve).expect("non-null function pointer")(
        PoolRecPtr, DescOffset, &mut BdPtr,
    );
    if Status == 0 as libc::c_int {
        RecycleBucketId = ((*BdPtr).Allocated as libc::c_int
            - 0xdddd as libc::c_int as uint16 as libc::c_int) as uint16;
        if (*BdPtr).CheckBits as libc::c_int != 0x5a5a as libc::c_int as uint16 as libc::c_int
            || RecycleBucketId as libc::c_int != BucketId as libc::c_int
        {
            Status = 0xc4000025 as libc::c_uint as CFE_Status_t;
        } else {
            NextOffset = (*BdPtr).NextOffset;
            (*BdPtr).Allocated = (0xaaaa as libc::c_int as uint16 as libc::c_int
                + BucketId as libc::c_int) as uint16;
            (*BdPtr).ActualSize = NewSize;
            (*BdPtr).NextOffset = 0 as libc::c_int as size_t;
            Status = ((*PoolRecPtr).Commit).expect("non-null function pointer")(
                PoolRecPtr, DescOffset, BdPtr,
            );
            if Status == 0 as libc::c_int {
                *BlockOffsetPtr = BlockOffset;
                (*BucketPtr).FirstOffset = NextOffset;
                (*BucketPtr).RecycleCount = ((*BucketPtr).RecycleCount).wrapping_add(1);
                (*BucketPtr).RecycleCount;
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolCreatePoolBlock(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut BucketId: uint16,
    mut NewSize: size_t,
    mut BlockOffsetPtr: *mut size_t,
) -> int32 {
    let mut BucketPtr: *mut CFE_ES_GenPoolBucket_t = 0 as *mut CFE_ES_GenPoolBucket_t;
    let mut DescOffset: size_t = 0;
    let mut BlockOffset: size_t = 0;
    let mut NextTailPosition: size_t = 0;
    let mut BdPtr: *mut CFE_ES_GenPoolBD_t = 0 as *mut CFE_ES_GenPoolBD_t;
    let mut Status: int32 = 0;
    BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
    if BucketPtr.is_null() {
        return 0xc4000025 as libc::c_uint as CFE_Status_t;
    }
    BlockOffset = ((*PoolRecPtr).TailPosition)
        .wrapping_add(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong);
    BlockOffset =
        (BlockOffset as libc::c_ulong).wrapping_add((*PoolRecPtr).AlignMask) as size_t as size_t;
    BlockOffset &= !(*PoolRecPtr).AlignMask;
    DescOffset =
        BlockOffset.wrapping_sub(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong);
    NextTailPosition = BlockOffset.wrapping_add((*BucketPtr).BlockSize);
    if NextTailPosition > (*PoolRecPtr).PoolMaxOffset {
        return 0xc4000008 as libc::c_uint as CFE_Status_t;
    }
    Status = ((*PoolRecPtr).Retrieve).expect("non-null function pointer")(
        PoolRecPtr, DescOffset, &mut BdPtr,
    );
    if Status == 0 as libc::c_int {
        (*BdPtr).CheckBits = 0x5a5a as libc::c_int as uint16;
        (*BdPtr).Allocated =
            (0xaaaa as libc::c_int as uint16 as libc::c_int + BucketId as libc::c_int) as uint16;
        (*BdPtr).ActualSize = NewSize;
        (*BdPtr).NextOffset = 0 as libc::c_int as size_t;
        Status = ((*PoolRecPtr).Commit).expect("non-null function pointer")(
            PoolRecPtr, DescOffset, BdPtr,
        );
        if Status == 0 as libc::c_int {
            (*PoolRecPtr).TailPosition = NextTailPosition;
            (*BucketPtr).AllocationCount = ((*BucketPtr).AllocationCount).wrapping_add(1);
            (*BucketPtr).AllocationCount;
            (*PoolRecPtr).AllocationCount = ((*PoolRecPtr).AllocationCount).wrapping_add(1);
            (*PoolRecPtr).AllocationCount;
            *BlockOffsetPtr = BlockOffset;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolInitialize(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut StartOffset: size_t,
    mut PoolSize: size_t,
    mut AlignSize: size_t,
    mut NumBlockSizes: uint16,
    mut BlockSizeList: *const size_t,
    mut RetrieveFunc: CFE_ES_PoolRetrieve_Func_t,
    mut CommitFunc: CFE_ES_PoolCommit_Func_t,
) -> int32 {
    let mut AlignMask: cpuaddr = 0;
    let mut i: uint32 = 0;
    let mut j: uint32 = 0;
    let mut BucketPtr: *mut CFE_ES_GenPoolBucket_t = 0 as *mut CFE_ES_GenPoolBucket_t;
    memset(
        PoolRecPtr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_GenPoolRecord_t>() as libc::c_ulong,
    );
    if AlignSize <= 1 as libc::c_int as libc::c_ulong {
        AlignMask = 0 as libc::c_int as cpuaddr;
    } else {
        AlignMask = AlignSize.wrapping_sub(1 as libc::c_int as libc::c_ulong);
    }
    if AlignMask & AlignSize != 0 as libc::c_int as libc::c_ulong {
        CFE_ES_WriteToSysLog(
            b"%s: invalid alignment for pool: %lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_ES_GenPoolInitialize\0",
            ))
            .as_ptr(),
            AlignSize,
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    (*PoolRecPtr).AlignMask = AlignMask;
    (*PoolRecPtr).PoolTotalSize = PoolSize;
    (*PoolRecPtr).PoolMaxOffset = PoolSize.wrapping_add(StartOffset);
    (*PoolRecPtr).NumBuckets = NumBlockSizes;
    (*PoolRecPtr).Retrieve = RetrieveFunc;
    (*PoolRecPtr).Commit = CommitFunc;
    (*PoolRecPtr).TailPosition = StartOffset;
    BucketPtr = ((*PoolRecPtr).Buckets).as_mut_ptr();
    i = 0 as libc::c_int as uint32;
    while i < NumBlockSizes as libc::c_uint {
        (*BucketPtr).BlockSize = *BlockSizeList.offset(i as isize);
        BucketPtr = BucketPtr.offset(1);
        BucketPtr;
        i = i.wrapping_add(1);
        i;
    }
    loop {
        j = 0 as libc::c_int as uint32;
        BucketPtr = ((*PoolRecPtr).Buckets).as_mut_ptr();
        i = 1 as libc::c_int as uint32;
        while i < NumBlockSizes as libc::c_uint {
            if (*BucketPtr.offset(0 as libc::c_int as isize)).BlockSize
                > (*BucketPtr.offset(1 as libc::c_int as isize)).BlockSize
            {
                let ref mut fresh15 = (*BucketPtr.offset(0 as libc::c_int as isize)).BlockSize;
                *fresh15 ^= (*BucketPtr.offset(1 as libc::c_int as isize)).BlockSize;
                let ref mut fresh16 = (*BucketPtr.offset(1 as libc::c_int as isize)).BlockSize;
                *fresh16 ^= (*BucketPtr.offset(0 as libc::c_int as isize)).BlockSize;
                let ref mut fresh17 = (*BucketPtr.offset(0 as libc::c_int as isize)).BlockSize;
                *fresh17 ^= (*BucketPtr.offset(1 as libc::c_int as isize)).BlockSize;
                j = j.wrapping_add(1);
                j;
            }
            BucketPtr = BucketPtr.offset(1);
            BucketPtr;
            i = i.wrapping_add(1);
            i;
        }
        if !(j > 0 as libc::c_int as libc::c_uint) {
            break;
        }
    }
    if (*PoolRecPtr).Buckets[0 as libc::c_int as usize].BlockSize
        == 0 as libc::c_int as libc::c_ulong
    {
        return 0xc4000008 as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolCalcMinSize(
    mut NumBlockSizes: uint16,
    mut BlockSizeList: *const size_t,
    mut NumBlocks: uint32,
) -> size_t {
    let mut BucketId: uint16 = 0;
    let mut MinBlockSize: size_t = 0;
    MinBlockSize = 0 as libc::c_int as size_t;
    if NumBlockSizes as libc::c_int > 0 as libc::c_int {
        MinBlockSize = *BlockSizeList.offset(0 as libc::c_int as isize);
        BucketId = 1 as libc::c_int as uint16;
        while (BucketId as libc::c_int) < NumBlockSizes as libc::c_int {
            if *BlockSizeList.offset(BucketId as isize) < MinBlockSize {
                MinBlockSize = *BlockSizeList.offset(BucketId as isize);
            }
            BucketId = BucketId.wrapping_add(1);
            BucketId;
        }
    }
    MinBlockSize = (MinBlockSize as libc::c_ulong)
        .wrapping_add(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong)
        as size_t as size_t;
    return (NumBlocks as libc::c_ulong).wrapping_mul(MinBlockSize);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolGetBlock(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut BlockOffsetPtr: *mut size_t,
    mut ReqSize: size_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut BucketId: uint16 = 0;
    BucketId = CFE_ES_GenPoolFindBucket(PoolRecPtr, ReqSize);
    if BucketId as libc::c_int == 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Err:size(%lu) > max(%lu)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_GenPoolGetBlock\0",
            ))
            .as_ptr(),
            ReqSize,
            (*PoolRecPtr).Buckets
                [((*PoolRecPtr).NumBuckets as libc::c_int - 1 as libc::c_int) as usize]
                .BlockSize,
        );
        return 0xc4000008 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_GenPoolRecyclePoolBlock(PoolRecPtr, BucketId, ReqSize, BlockOffsetPtr);
    if Status != 0 as libc::c_int {
        Status = CFE_ES_GenPoolCreatePoolBlock(PoolRecPtr, BucketId, ReqSize, BlockOffsetPtr);
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolGetBlockSize(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut BlockSizePtr: *mut size_t,
    mut BlockOffset: size_t,
) -> int32 {
    let mut DescOffset: size_t = 0;
    let mut BucketPtr: *mut CFE_ES_GenPoolBucket_t = 0 as *mut CFE_ES_GenPoolBucket_t;
    let mut BdPtr: *mut CFE_ES_GenPoolBD_t = 0 as *mut CFE_ES_GenPoolBD_t;
    let mut Status: int32 = 0;
    let mut BucketId: uint16 = 0;
    if BlockOffset >= (*PoolRecPtr).TailPosition
        || BlockOffset < ::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong
    {
        return 0xc4000025 as libc::c_uint as CFE_Status_t;
    }
    DescOffset =
        BlockOffset.wrapping_sub(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong);
    Status = ((*PoolRecPtr).Retrieve).expect("non-null function pointer")(
        PoolRecPtr, DescOffset, &mut BdPtr,
    );
    if Status == 0 as libc::c_int {
        BucketId = ((*BdPtr).Allocated as libc::c_int
            - 0xaaaa as libc::c_int as uint16 as libc::c_int) as uint16;
        BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
        if (*BdPtr).CheckBits as libc::c_int != 0x5a5a as libc::c_int as uint16 as libc::c_int
            || BucketPtr.is_null()
            || (*BdPtr).ActualSize == 0 as libc::c_int as libc::c_ulong
            || (*BucketPtr).BlockSize < (*BdPtr).ActualSize
        {
            Status = 0xc400002c as libc::c_uint as CFE_Status_t;
        } else {
            *BlockSizePtr = (*BdPtr).ActualSize;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolPutBlock(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut BlockSizePtr: *mut size_t,
    mut BlockOffset: size_t,
) -> int32 {
    let mut DescOffset: size_t = 0;
    let mut BucketPtr: *mut CFE_ES_GenPoolBucket_t = 0 as *mut CFE_ES_GenPoolBucket_t;
    let mut BdPtr: *mut CFE_ES_GenPoolBD_t = 0 as *mut CFE_ES_GenPoolBD_t;
    let mut Status: int32 = 0;
    let mut BucketId: uint16 = 0;
    if BlockOffset >= (*PoolRecPtr).TailPosition
        || BlockOffset < ::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong
    {
        return 0xc4000025 as libc::c_uint as CFE_Status_t;
    }
    DescOffset =
        BlockOffset.wrapping_sub(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong);
    Status = ((*PoolRecPtr).Retrieve).expect("non-null function pointer")(
        PoolRecPtr, DescOffset, &mut BdPtr,
    );
    if Status == 0 as libc::c_int {
        BucketId = ((*BdPtr).Allocated as libc::c_int
            - 0xaaaa as libc::c_int as uint16 as libc::c_int) as uint16;
        BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
        if (*BdPtr).CheckBits as libc::c_int != 0x5a5a as libc::c_int as uint16 as libc::c_int
            || BucketPtr.is_null()
            || (*BdPtr).ActualSize == 0 as libc::c_int as libc::c_ulong
            || (*BucketPtr).BlockSize < (*BdPtr).ActualSize
        {
            (*PoolRecPtr).ValidationErrorCount =
                ((*PoolRecPtr).ValidationErrorCount).wrapping_add(1);
            (*PoolRecPtr).ValidationErrorCount;
            Status = 0xc400002c as libc::c_uint as CFE_Status_t;
        } else {
            (*BdPtr).Allocated = (0xdddd as libc::c_int as uint16 as libc::c_int
                + BucketId as libc::c_int) as uint16;
            (*BdPtr).NextOffset = (*BucketPtr).FirstOffset;
            *BlockSizePtr = (*BdPtr).ActualSize;
            Status = ((*PoolRecPtr).Commit).expect("non-null function pointer")(
                PoolRecPtr, DescOffset, BdPtr,
            );
            if Status == 0 as libc::c_int {
                (*BucketPtr).FirstOffset = BlockOffset;
                (*BucketPtr).ReleaseCount = ((*BucketPtr).ReleaseCount).wrapping_add(1);
                (*BucketPtr).ReleaseCount;
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolRebuild(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut DescOffset: size_t = 0;
    let mut BlockOffset: size_t = 0;
    let mut BucketPtr: *mut CFE_ES_GenPoolBucket_t = 0 as *mut CFE_ES_GenPoolBucket_t;
    let mut BdPtr: *mut CFE_ES_GenPoolBD_t = 0 as *mut CFE_ES_GenPoolBD_t;
    let mut BucketId: uint16 = 0;
    let mut IsDeallocatedBlock: bool = false;
    Status = 0 as libc::c_int;
    loop {
        IsDeallocatedBlock = 0 as libc::c_int != 0;
        BucketId = 0 as libc::c_int as uint16;
        BucketPtr = 0 as *mut CFE_ES_GenPoolBucket_t;
        BlockOffset = ((*PoolRecPtr).TailPosition)
            .wrapping_add(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong);
        BlockOffset = (BlockOffset as libc::c_ulong).wrapping_add((*PoolRecPtr).AlignMask) as size_t
            as size_t;
        BlockOffset &= !(*PoolRecPtr).AlignMask;
        if BlockOffset > (*PoolRecPtr).PoolMaxOffset {
            break;
        }
        DescOffset =
            BlockOffset.wrapping_sub(::core::mem::size_of::<CFE_ES_GenPoolBD_t>() as libc::c_ulong);
        Status = ((*PoolRecPtr).Retrieve).expect("non-null function pointer")(
            PoolRecPtr, DescOffset, &mut BdPtr,
        );
        if Status != 0 as libc::c_int {
            break;
        }
        if (*BdPtr).CheckBits as libc::c_int == 0x5a5a as libc::c_int as uint16 as libc::c_int {
            BucketId = ((*BdPtr).Allocated as libc::c_int
                - 0xdddd as libc::c_int as uint16 as libc::c_int) as uint16;
            BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
            if !BucketPtr.is_null() {
                IsDeallocatedBlock = 1 as libc::c_int != 0;
            } else {
                BucketId = ((*BdPtr).Allocated as libc::c_int
                    - 0xaaaa as libc::c_int as uint16 as libc::c_int)
                    as uint16;
                BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
            }
        }
        if BucketPtr.is_null() || (*BucketPtr).BlockSize < (*BdPtr).ActualSize {
            break;
        }
        (*PoolRecPtr).TailPosition = BlockOffset.wrapping_add((*BucketPtr).BlockSize);
        BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
        (*BucketPtr).AllocationCount = ((*BucketPtr).AllocationCount).wrapping_add(1);
        (*BucketPtr).AllocationCount;
        (*PoolRecPtr).AllocationCount = ((*PoolRecPtr).AllocationCount).wrapping_add(1);
        (*PoolRecPtr).AllocationCount;
        if !IsDeallocatedBlock {
            continue;
        }
        (*BucketPtr).ReleaseCount = ((*BucketPtr).ReleaseCount).wrapping_add(1);
        (*BucketPtr).ReleaseCount;
        (*BdPtr).NextOffset = (*BucketPtr).FirstOffset;
        (*BucketPtr).FirstOffset = BlockOffset;
        Status = ((*PoolRecPtr).Commit).expect("non-null function pointer")(
            PoolRecPtr, DescOffset, BdPtr,
        );
        if Status != 0 as libc::c_int {
            break;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolValidateState(
    mut PoolRecPtr: *const CFE_ES_GenPoolRecord_t,
) -> bool {
    return (*PoolRecPtr).PoolTotalSize > 0 as libc::c_int as libc::c_ulong
        && (*PoolRecPtr).TailPosition <= (*PoolRecPtr).PoolMaxOffset
        && (*PoolRecPtr).NumBuckets as libc::c_int > 0 as libc::c_int
        && (*PoolRecPtr).NumBuckets as libc::c_int <= 17 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolGetUsage(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut FreeSizeBuf: *mut CFE_ES_MemOffset_t,
    mut TotalSizeBuf: *mut CFE_ES_MemOffset_t,
) {
    if !TotalSizeBuf.is_null() {
        *TotalSizeBuf = (*PoolRecPtr).PoolTotalSize as CFE_ES_MemOffset_t;
    }
    if !FreeSizeBuf.is_null() {
        *FreeSizeBuf = ((*PoolRecPtr).PoolMaxOffset).wrapping_sub((*PoolRecPtr).TailPosition)
            as CFE_ES_MemOffset_t;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolGetCounts(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut NumBucketsBuf: *mut uint16,
    mut AllocCountBuf: *mut uint32,
    mut ValidationErrorCountBuf: *mut uint32,
) {
    if !NumBucketsBuf.is_null() {
        *NumBucketsBuf = (*PoolRecPtr).NumBuckets;
    }
    if !AllocCountBuf.is_null() {
        *AllocCountBuf = (*PoolRecPtr).AllocationCount;
    }
    if !ValidationErrorCountBuf.is_null() {
        *ValidationErrorCountBuf = (*PoolRecPtr).ValidationErrorCount;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenPoolGetBucketUsage(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut BucketId: uint16,
    mut BlockStatsBuf: *mut CFE_ES_BlockStats_t,
) {
    let mut BucketPtr: *const CFE_ES_GenPoolBucket_t = 0 as *const CFE_ES_GenPoolBucket_t;
    static mut ZeroBucket: CFE_ES_GenPoolBucket_t = {
        let mut init = CFE_ES_GenPoolBucket {
            BlockSize: 0 as libc::c_int as size_t,
            FirstOffset: 0,
            AllocationCount: 0,
            ReleaseCount: 0,
            RecycleCount: 0,
        };
        init
    };
    BucketPtr = CFE_ES_GenPoolGetBucketState(PoolRecPtr, BucketId);
    if BucketPtr.is_null() {
        BucketPtr = &ZeroBucket;
    }
    if !BlockStatsBuf.is_null() {
        (*BlockStatsBuf).NumCreated = (*BucketPtr).AllocationCount;
        (*BlockStatsBuf).BlockSize = (*BucketPtr).BlockSize as CFE_ES_MemOffset_t;
        (*BlockStatsBuf).NumFree =
            ((*BucketPtr).ReleaseCount).wrapping_sub((*BucketPtr).RecycleCount);
    }
}
#[no_mangle]
pub static mut CFE_ES_MemPoolDefSize: [size_t; 17] = [
    80000 as libc::c_int as size_t,
    32768 as libc::c_int as size_t,
    16384 as libc::c_int as size_t,
    8192 as libc::c_int as size_t,
    4096 as libc::c_int as size_t,
    2048 as libc::c_int as size_t,
    1024 as libc::c_int as size_t,
    512 as libc::c_int as size_t,
    256 as libc::c_int as size_t,
    160 as libc::c_int as size_t,
    128 as libc::c_int as size_t,
    96 as libc::c_int as size_t,
    64 as libc::c_int as size_t,
    48 as libc::c_int as size_t,
    32 as libc::c_int as size_t,
    16 as libc::c_int as size_t,
    8 as libc::c_int as size_t,
];
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_MemPoolDirectRetrieve(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut Offset: size_t,
    mut BdPtr: *mut *mut CFE_ES_GenPoolBD_t,
) -> int32 {
    let mut DataAddress: cpuaddr = 0;
    let mut MemPoolRecPtr: *mut CFE_ES_MemPoolRecord_t = PoolRecPtr as *mut CFE_ES_MemPoolRecord_t;
    DataAddress = ((*MemPoolRecPtr).BaseAddr).wrapping_add(Offset);
    *BdPtr = DataAddress as *mut CFE_ES_GenPoolBD_t;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_MemPoolDirectCommit(
    mut PoolRecPtr: *mut CFE_ES_GenPoolRecord_t,
    mut Offset: size_t,
    mut BdPtr: *const CFE_ES_GenPoolBD_t,
) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_MemPoolID_ToIndex(
    mut PoolID: CFE_ES_MemHandle_t,
    mut Idx: *mut uint32,
) -> int32 {
    return CFE_ResourceId_ToIndex(
        PoolID,
        CFE_ES_POOLID_BASE as libc::c_int as uint32,
        10 as libc::c_int as uint32,
        Idx,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CheckMemPoolSlotUsed(mut CheckId: CFE_ResourceId_t) -> bool {
    let mut MemPoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    MemPoolRecPtr = CFE_ES_LocateMemPoolRecordByID(CheckId);
    return MemPoolRecPtr.is_null()
        || CFE_ES_MemPoolRecordIsUsed(MemPoolRecPtr) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateMemPoolRecordByID(
    mut PoolID: CFE_ES_MemHandle_t,
) -> *mut CFE_ES_MemPoolRecord_t {
    let mut MemPoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut Idx: uint32 = 0;
    if CFE_ES_MemPoolID_ToIndex(PoolID, &mut Idx) == 0 as libc::c_int {
        MemPoolRecPtr = &mut *(CFE_ES_Global.MemPoolTable)
            .as_mut_ptr()
            .offset(Idx as isize) as *mut CFE_ES_MemPoolRecord_t;
    } else {
        MemPoolRecPtr = 0 as *mut CFE_ES_MemPoolRecord_t;
    }
    return MemPoolRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_PoolCreateNoSem(
    mut PoolID: *mut CFE_ES_MemHandle_t,
    mut MemPtr: *mut libc::c_void,
    mut Size: size_t,
) -> CFE_Status_t {
    return CFE_ES_PoolCreateEx(
        PoolID,
        MemPtr,
        Size,
        17 as libc::c_int as uint16,
        &*CFE_ES_MemPoolDefSize
            .as_ptr()
            .offset(0 as libc::c_int as isize),
        0 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_PoolCreate(
    mut PoolID: *mut CFE_ES_MemHandle_t,
    mut MemPtr: *mut libc::c_void,
    mut Size: size_t,
) -> CFE_Status_t {
    return CFE_ES_PoolCreateEx(
        PoolID,
        MemPtr,
        Size,
        17 as libc::c_int as uint16,
        &*CFE_ES_MemPoolDefSize
            .as_ptr()
            .offset(0 as libc::c_int as isize),
        1 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_PoolCreateEx(
    mut PoolID: *mut CFE_ES_MemHandle_t,
    mut MemPtr: *mut libc::c_void,
    mut Size: size_t,
    mut NumBlockSizes: uint16,
    mut BlockSizes: *const size_t,
    mut UseMutex: bool,
) -> CFE_Status_t {
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut PendingID: CFE_ResourceId_t = 0;
    let mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut Alignment: size_t = 0;
    let mut MinimumSize: size_t = 0;
    let mut MutexName: [libc::c_char; 20] = [0; 20];
    if MemPtr.is_null() || PoolID.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if NumBlockSizes as libc::c_int > 17 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Num Block Sizes (%d) greater than max (%d)\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_PoolCreateEx\0"))
                .as_ptr(),
            NumBlockSizes as libc::c_int,
            17 as libc::c_int,
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    if BlockSizes.is_null() {
        BlockSizes = CFE_ES_MemPoolDefSize.as_ptr();
        if NumBlockSizes as libc::c_int == 0 as libc::c_int {
            NumBlockSizes = 17 as libc::c_int as uint16;
        }
    }
    MinimumSize = CFE_ES_GenPoolCalcMinSize(NumBlockSizes, BlockSizes, 1 as libc::c_int as uint32);
    if Size < MinimumSize {
        CFE_ES_WriteToSysLog(
            b"%s: Pool size(%lu) too small, need >=%lu bytes\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_PoolCreateEx\0"))
                .as_ptr(),
            Size,
            MinimumSize,
        );
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_PoolCreateEx\0"))
            .as_ptr(),
        231 as libc::c_int,
    );
    PendingID = CFE_ResourceId_FindNext(
        CFE_ES_Global.LastMemPoolId,
        10 as libc::c_int as uint32,
        Some(CFE_ES_CheckMemPoolSlotUsed as unsafe extern "C" fn(CFE_ResourceId_t) -> bool),
    );
    PoolRecPtr = CFE_ES_LocateMemPoolRecordByID(PendingID);
    if PoolRecPtr.is_null() {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: No free MemPool slots available\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_PoolCreateEx\0"))
                .as_ptr(),
        );
        Status = 0xc400002b as libc::c_uint as CFE_Status_t;
    } else {
        memset(
            PoolRecPtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_ES_MemPoolRecord_t>() as libc::c_ulong,
        );
        CFE_ES_MemPoolRecordSetUsed(PoolRecPtr, 0xffffffff as libc::c_uint);
        CFE_ES_Global.LastMemPoolId = PendingID;
        Status = 0 as libc::c_int;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_ES_PoolCreateEx\0"))
            .as_ptr(),
        252 as libc::c_int,
    );
    if Status != 0 as libc::c_int {
        return Status;
    }
    Alignment = core::mem::align_of::<CFE_ES_PoolAlign_t>() as _;
    if Alignment < 4 as libc::c_int as libc::c_ulong {
        Alignment = 4 as libc::c_int as size_t;
    }
    Status = CFE_ES_GenPoolInitialize(
        &mut (*PoolRecPtr).Pool,
        0 as libc::c_int as size_t,
        Size,
        Alignment,
        NumBlockSizes,
        BlockSizes,
        Some(
            CFE_ES_MemPoolDirectRetrieve
                as unsafe extern "C" fn(
                    *mut CFE_ES_GenPoolRecord_t,
                    size_t,
                    *mut *mut CFE_ES_GenPoolBD_t,
                ) -> int32,
        ),
        Some(
            CFE_ES_MemPoolDirectCommit
                as unsafe extern "C" fn(
                    *mut CFE_ES_GenPoolRecord_t,
                    size_t,
                    *const CFE_ES_GenPoolBD_t,
                ) -> int32,
        ),
    );
    if Status == 0 as libc::c_int && UseMutex as libc::c_int == 1 as libc::c_int {
        snprintf(
            MutexName.as_mut_ptr(),
            20 as libc::c_int as libc::c_ulong,
            b"Pool%08lX\0" as *const u8 as *const libc::c_char,
            CFE_ResourceId_ToInteger(PendingID),
        );
        OsStatus = OS_MutSemCreate(
            &mut (*PoolRecPtr).MutexId,
            MutexName.as_mut_ptr(),
            0 as libc::c_int as uint32,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: OSAL error %ld while creating mutex\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"CFE_ES_PoolCreateEx\0",
                ))
                .as_ptr(),
                OsStatus as libc::c_long,
            );
            Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    }
    if Status == 0 as libc::c_int {
        (*PoolRecPtr).BaseAddr = MemPtr as cpuaddr;
        CFE_ES_GetAppID(&mut (*PoolRecPtr).OwnerAppID);
        CFE_ES_MemPoolRecordSetUsed(PoolRecPtr, PendingID);
    } else {
        CFE_ES_MemPoolRecordSetFree(PoolRecPtr);
        PendingID = 0 as libc::c_int as CFE_ResourceId_t;
    }
    *PoolID = PendingID;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_PoolDelete(mut PoolID: CFE_ES_MemHandle_t) -> int32 {
    let mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut MutexId: osal_id_t = 0;
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    PoolRecPtr = CFE_ES_LocateMemPoolRecordByID(PoolID);
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_PoolDelete\0"))
            .as_ptr(),
        360 as libc::c_int,
    );
    if CFE_ES_MemPoolRecordIsMatch(PoolRecPtr, PoolID) {
        MutexId = (*PoolRecPtr).MutexId;
        CFE_ES_MemPoolRecordSetFree(PoolRecPtr);
        Status = 0 as libc::c_int;
    } else {
        MutexId = 0 as libc::c_int as osal_id_t;
        Status = 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_PoolDelete\0"))
            .as_ptr(),
        375 as libc::c_int,
    );
    if OS_ObjectIdDefined(MutexId) {
        OsStatus = OS_MutSemDelete(MutexId);
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Error %ld deleting mutex\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_PoolDelete\0"))
                    .as_ptr(),
                OsStatus as libc::c_long,
            );
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetPoolBuf(
    mut BufPtr: *mut CFE_ES_MemPoolBuf_t,
    mut Handle: CFE_ES_MemHandle_t,
    mut Size: size_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut DataOffset: size_t = 0;
    if BufPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    PoolRecPtr = CFE_ES_LocateMemPoolRecordByID(Handle);
    if !CFE_ES_MemPoolRecordIsMatch(PoolRecPtr, Handle) {
        CFE_ES_GetAppID(&mut AppId);
        CFE_ES_WriteToSysLog(
            b"%s: Err:Bad handle(0x%08lX) AppId=%lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_GetPoolBuf\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(Handle),
            CFE_ResourceId_ToInteger(AppId),
        );
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemTake((*PoolRecPtr).MutexId);
    }
    Status = CFE_ES_GenPoolGetBlock(&mut (*PoolRecPtr).Pool, &mut DataOffset, Size);
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemGive((*PoolRecPtr).MutexId);
    }
    if Status != 0 as libc::c_int {
        return Status;
    }
    *BufPtr = ((*PoolRecPtr).BaseAddr).wrapping_add(DataOffset) as CFE_ES_MemPoolBuf_t;
    return Size as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetPoolBufInfo(
    mut Handle: CFE_ES_MemHandle_t,
    mut BufPtr: CFE_ES_MemPoolBuf_t,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut DataOffset: size_t = 0;
    let mut DataSize: size_t = 0;
    if BufPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    PoolRecPtr = CFE_ES_LocateMemPoolRecordByID(Handle);
    if !CFE_ES_MemPoolRecordIsMatch(PoolRecPtr, Handle) {
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemTake((*PoolRecPtr).MutexId);
    }
    DataOffset = (BufPtr as cpuaddr).wrapping_sub((*PoolRecPtr).BaseAddr);
    Status = CFE_ES_GenPoolGetBlockSize(&mut (*PoolRecPtr).Pool, &mut DataSize, DataOffset);
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemGive((*PoolRecPtr).MutexId);
    }
    if Status == 0 as libc::c_int {
        Status = DataSize as int32;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_PutPoolBuf(
    mut Handle: CFE_ES_MemHandle_t,
    mut BufPtr: CFE_ES_MemPoolBuf_t,
) -> int32 {
    let mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut DataSize: size_t = 0;
    let mut DataOffset: size_t = 0;
    let mut Status: int32 = 0;
    if BufPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    PoolRecPtr = CFE_ES_LocateMemPoolRecordByID(Handle);
    if !CFE_ES_MemPoolRecordIsMatch(PoolRecPtr, Handle) {
        CFE_ES_WriteToSysLog(
            b"%s: Err:Invalid Memory Handle (0x%08lX).\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_PutPoolBuf\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(Handle),
        );
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemTake((*PoolRecPtr).MutexId);
    }
    DataOffset = (BufPtr as cpuaddr).wrapping_sub((*PoolRecPtr).BaseAddr);
    Status = CFE_ES_GenPoolPutBlock(&mut (*PoolRecPtr).Pool, &mut DataSize, DataOffset);
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemGive((*PoolRecPtr).MutexId);
    }
    if Status == 0 as libc::c_int {
        Status = DataSize as int32;
    } else if Status == 0xc400002c as libc::c_uint as CFE_Status_t {
        CFE_ES_WriteToSysLog(
            b"%s: Err:Deallocating invalid or corrupt memory block @ 0x%08lX\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_PutPoolBuf\0"))
                .as_ptr(),
            BufPtr as libc::c_ulong,
        );
    } else if Status == 0xc4000025 as libc::c_uint as CFE_Status_t {
        CFE_ES_WriteToSysLog(
            b"%s: Err:Bad offset(%lu) outside pool boundary\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_PutPoolBuf\0"))
                .as_ptr(),
            DataOffset,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetMemPoolStats(
    mut BufPtr: *mut CFE_ES_MemPoolStats_t,
    mut Handle: CFE_ES_MemHandle_t,
) -> CFE_Status_t {
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut NumBuckets: uint16 = 0;
    let mut Idx: uint16 = 0;
    if BufPtr.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    PoolRecPtr = CFE_ES_LocateMemPoolRecordByID(Handle);
    if !CFE_ES_MemPoolRecordIsMatch(PoolRecPtr, Handle) {
        CFE_ES_GetAppID(&mut AppId);
        CFE_ES_WriteToSysLog(
            b"%s: Err:Bad handle(0x%08lX) AppId=%lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_ES_GetMemPoolStats\0",
            ))
            .as_ptr(),
            CFE_ResourceId_ToInteger(Handle),
            CFE_ResourceId_ToInteger(AppId),
        );
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemTake((*PoolRecPtr).MutexId);
    }
    CFE_ES_GenPoolGetUsage(
        &mut (*PoolRecPtr).Pool,
        &mut (*BufPtr).NumFreeBytes,
        &mut (*BufPtr).PoolSize,
    );
    CFE_ES_GenPoolGetCounts(
        &mut (*PoolRecPtr).Pool,
        &mut NumBuckets,
        &mut (*BufPtr).NumBlocksRequested,
        &mut (*BufPtr).CheckErrCtr,
    );
    Idx = 0 as libc::c_int as uint16;
    while (Idx as libc::c_int) < 17 as libc::c_int {
        CFE_ES_GenPoolGetBucketUsage(
            &mut (*PoolRecPtr).Pool,
            NumBuckets,
            &mut *((*BufPtr).BlockStats).as_mut_ptr().offset(Idx as isize),
        );
        if NumBuckets as libc::c_int > 0 as libc::c_int {
            NumBuckets = NumBuckets.wrapping_sub(1);
            NumBuckets;
        }
        Idx = Idx.wrapping_add(1);
        Idx;
    }
    if OS_ObjectIdDefined((*PoolRecPtr).MutexId) {
        OS_MutSemGive((*PoolRecPtr).MutexId);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ValidateHandle(mut Handle: CFE_ES_MemHandle_t) -> bool {
    let mut PoolRecPtr: *mut CFE_ES_MemPoolRecord_t = 0 as *mut CFE_ES_MemPoolRecord_t;
    let mut TotalSize: CFE_ES_MemOffset_t = 0;
    PoolRecPtr = CFE_ES_LocateMemPoolRecordByID(Handle);
    if !CFE_ES_MemPoolRecordIsMatch(PoolRecPtr, Handle) {
        return 0 as libc::c_int != 0;
    }
    if !CFE_ES_GenPoolValidateState(&mut (*PoolRecPtr).Pool) {
        return 0 as libc::c_int != 0;
    }
    CFE_ES_GenPoolGetUsage(
        &mut (*PoolRecPtr).Pool,
        0 as *mut CFE_ES_MemOffset_t,
        &mut TotalSize,
    );
    if CFE_PSP_MemValidateRange(
        (*PoolRecPtr).BaseAddr,
        TotalSize as size_t,
        3 as libc::c_int as uint32,
    ) != 0 as libc::c_int
    {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub static mut CFE_ES_ObjectTable: [CFE_ES_ObjectTable_t; 30] = unsafe {
    [
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x4 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_Config_Init\0\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    FunctionPtr: Some(CFE_Config_Init as unsafe extern "C" fn() -> int32),
                },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x4 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_ES_CDSEarlyInit\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    FunctionPtr: Some(CFE_ES_CDS_EarlyInit as unsafe extern "C" fn() -> int32),
                },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x4 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_EVS_EarlyInit\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    FunctionPtr: Some(CFE_EVS_EarlyInit as unsafe extern "C" fn() -> int32),
                },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x4 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_SB_EarlyInit\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    FunctionPtr: Some(CFE_SB_EarlyInit as unsafe extern "C" fn() -> int32),
                },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x4 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_TIME_EarlyInit\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    FunctionPtr: Some(CFE_TIME_EarlyInit as unsafe extern "C" fn() -> int32),
                },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x4 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_TBL_EarlyInit\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    FunctionPtr: Some(CFE_TBL_EarlyInit as unsafe extern "C" fn() -> int32),
                },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x4 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_FS_EarlyInit\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    FunctionPtr: Some(CFE_FS_EarlyInit as unsafe extern "C" fn() -> int32),
                },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x1 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_EVS\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    MainTaskPtr: Some(CFE_EVS_TaskMain as unsafe extern "C" fn() -> ()),
                },
                ObjectPriority: 61 as libc::c_int as uint32,
                ObjectSize: 8192 as libc::c_int as uint32,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x1 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_SB\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    MainTaskPtr: Some(CFE_SB_TaskMain as unsafe extern "C" fn() -> ()),
                },
                ObjectPriority: 64 as libc::c_int as uint32,
                ObjectSize: 8192 as libc::c_int as uint32,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x1 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_ES\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    MainTaskPtr: Some(CFE_ES_TaskMain as unsafe extern "C" fn() -> ()),
                },
                ObjectPriority: 68 as libc::c_int as uint32,
                ObjectSize: 8192 as libc::c_int as uint32,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x1 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_TIME\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    MainTaskPtr: Some(CFE_TIME_TaskMain as unsafe extern "C" fn() -> ()),
                },
                ObjectPriority: 60 as libc::c_int as uint32,
                ObjectSize: 8192 as libc::c_int as uint32,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0x1 as libc::c_int as uint32,
                ObjectName: *::core::mem::transmute::<&[u8; 20], &mut [libc::c_char; 20]>(
                    b"CFE_TBL\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t {
                    MainTaskPtr: Some(CFE_TBL_TaskMain as unsafe extern "C" fn() -> ()),
                },
                ObjectPriority: 70 as libc::c_int as uint32,
                ObjectSize: 8192 as libc::c_int as uint32,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
        {
            let mut init = CFE_ES_ObjectTable_t {
                ObjectType: 0 as libc::c_int as uint32,
                ObjectName: [0; 20],
                FuncPtrUnion: CFE_ES_FuncPtrUnion_t { FunctionPtr: None },
                ObjectPriority: 0,
                ObjectSize: 0,
                ObjectFlags: 0,
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SetupPerfVariables(mut ResetType: uint32) {
    let EndianCheck: C2RustUnnamed_27 = C2RustUnnamed_27 {
        Word: 0x100 as libc::c_int as uint16,
    };
    let mut i: uint32 = 0;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    if ResetType == 1 as libc::c_int as libc::c_uint {
        ::core::ptr::write_volatile(
            &mut (*Perf).MetaData.State as *mut uint32,
            CFE_ES_PERF_IDLE as libc::c_int as uint32,
        );
    } else {
        (*Perf).MetaData.Version = 1 as libc::c_int as uint8;
        (*Perf).MetaData.Endian = EndianCheck.Endian;
        (*Perf).MetaData.TimerTicksPerSecond = CFE_PSP_GetTimerTicksPerSecond();
        (*Perf).MetaData.TimerLow32Rollover = CFE_PSP_GetTimerLow32Rollover();
        ::core::ptr::write_volatile(
            &mut (*Perf).MetaData.State as *mut uint32,
            CFE_ES_PERF_IDLE as libc::c_int as uint32,
        );
        (*Perf).MetaData.Mode = CFE_ES_PerfTrigger_START as libc::c_int as uint32;
        (*Perf).MetaData.TriggerCount = 0 as libc::c_int as uint32;
        (*Perf).MetaData.DataStart = 0 as libc::c_int as uint32;
        (*Perf).MetaData.DataEnd = 0 as libc::c_int as uint32;
        (*Perf).MetaData.DataCount = 0 as libc::c_int as uint32;
        (*Perf).MetaData.InvalidMarkerReported = 0 as libc::c_int as uint32;
        (*Perf).MetaData.FilterTriggerMaskSize = (128 as libc::c_int / 32 as libc::c_int) as uint32;
        i = 0 as libc::c_int as uint32;
        while i < (128 as libc::c_int / 32 as libc::c_int) as libc::c_uint {
            (*Perf).MetaData.FilterMask[i as usize] = !(0 as libc::c_int) as uint32;
            (*Perf).MetaData.TriggerMask[i as usize] = 0 as libc::c_int as uint32;
            i = i.wrapping_add(1);
            i;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetPerfLogDumpRemaining() -> uint32 {
    let mut PerfDumpState: *mut CFE_ES_PerfDumpGlobal_t =
        &mut CFE_ES_Global.BackgroundPerfDumpState;
    let mut CurrentState: CFE_ES_PerfDumpState_t = (*PerfDumpState).CurrentState;
    let mut Result: uint32 = 0;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    if CurrentState as libc::c_uint > CFE_ES_PerfDumpState_IDLE as libc::c_int as libc::c_uint
        && (CurrentState as libc::c_uint)
            < CFE_ES_PerfDumpState_WRITE_PERF_ENTRIES as libc::c_int as libc::c_uint
    {
        Result = (*Perf).MetaData.DataCount;
    } else if CurrentState as libc::c_uint
        == CFE_ES_PerfDumpState_WRITE_PERF_ENTRIES as libc::c_int as libc::c_uint
    {
        Result = (*PerfDumpState).StateCounter;
    } else {
        Result = 0 as libc::c_int as uint32;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_StartPerfDataCmd(
    mut data: *const CFE_ES_StartPerfDataCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_ES_StartPerfCmd_Payload_t = &(*data).Payload;
    let mut PerfDumpState: *mut CFE_ES_PerfDumpGlobal_t =
        &mut CFE_ES_Global.BackgroundPerfDumpState;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    if (*PerfDumpState).CurrentState as libc::c_uint
        == CFE_ES_PerfDumpState_IDLE as libc::c_int as libc::c_uint
        && (*PerfDumpState).PendingState as libc::c_uint
            == CFE_ES_PerfDumpState_IDLE as libc::c_int as libc::c_uint
    {
        if (*CmdPtr).TriggerMode <= CFE_ES_PerfTrigger_END as libc::c_int as libc::c_uint {
            CFE_ES_Global.TaskData.CommandCounter =
                (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandCounter;
            OS_MutSemTake(CFE_ES_Global.PerfDataMutex);
            (*Perf).MetaData.Mode = (*CmdPtr).TriggerMode;
            (*Perf).MetaData.TriggerCount = 0 as libc::c_int as uint32;
            (*Perf).MetaData.DataStart = 0 as libc::c_int as uint32;
            (*Perf).MetaData.DataEnd = 0 as libc::c_int as uint32;
            (*Perf).MetaData.DataCount = 0 as libc::c_int as uint32;
            (*Perf).MetaData.InvalidMarkerReported = 0 as libc::c_int as uint32;
            ::core::ptr::write_volatile(
                &mut (*Perf).MetaData.State as *mut uint32,
                CFE_ES_PERF_WAITING_FOR_TRIGGER as libc::c_int as uint32,
            );
            OS_MutSemGive(CFE_ES_Global.PerfDataMutex);
            CFE_EVS_SendEvent(
                57 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Start collecting performance data cmd received, trigger mode = %d\0" as *const u8
                    as *const libc::c_char,
                (*CmdPtr).TriggerMode as libc::c_int,
            );
        } else {
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                59 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Cannot start collecting performance data, trigger mode (%d) out of range (%d to %d)\0"
                    as *const u8 as *const libc::c_char,
                (*CmdPtr).TriggerMode as libc::c_int,
                CFE_ES_PerfTrigger_START as libc::c_int,
                CFE_ES_PerfTrigger_END as libc::c_int,
            );
        }
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            58 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Cannot start collecting performance data,perf data write in progress\0" as *const u8
                as *const libc::c_char,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_StopPerfDataCmd(
    mut data: *const CFE_ES_StopPerfDataCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_ES_StopPerfCmd_Payload_t = &(*data).Payload;
    let mut PerfDumpState: *mut CFE_ES_PerfDumpGlobal_t =
        &mut CFE_ES_Global.BackgroundPerfDumpState;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    let mut Status: int32 = 0;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    if (*PerfDumpState).CurrentState as libc::c_uint
        == CFE_ES_PerfDumpState_IDLE as libc::c_int as libc::c_uint
        && (*PerfDumpState).PendingState as libc::c_uint
            == CFE_ES_PerfDumpState_IDLE as libc::c_int as libc::c_uint
    {
        ::core::ptr::write_volatile(
            &mut (*Perf).MetaData.State as *mut uint32,
            CFE_ES_PERF_IDLE as libc::c_int as uint32,
        );
        Status = CFE_FS_ParseInputFileNameEx(
            ((*PerfDumpState).DataFileName).as_mut_ptr(),
            ((*CmdPtr).DataFileName).as_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"/ram/cfe_es_perf.dat\0" as *const u8 as *const libc::c_char,
            CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
            CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        );
        if Status == 0 as libc::c_int {
            (*PerfDumpState).PendingState = CFE_ES_PerfDumpState_INIT;
            CFE_ES_BackgroundWakeup();
            CFE_ES_Global.TaskData.CommandCounter =
                (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandCounter;
            CFE_EVS_SendEvent(
                60 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Perf Stop Cmd Rcvd, will write %d entries.%dmS dly every %d entries\0"
                    as *const u8 as *const libc::c_char,
                (*Perf).MetaData.DataCount as libc::c_int,
                20 as libc::c_int,
                50 as libc::c_int,
            );
        } else {
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                67 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error parsing filename, RC = %d\0" as *const u8 as *const libc::c_char,
                Status,
            );
        }
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            62 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Stop performance data cmd ignored,perf data write in progress\0" as *const u8
                as *const libc::c_char,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RunPerfLogDump(
    mut ElapsedTime: uint32,
    mut Arg: *mut libc::c_void,
) -> bool {
    let mut State: *mut CFE_ES_PerfDumpGlobal_t = Arg as *mut CFE_ES_PerfDumpGlobal_t;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut FileHdr: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut BlockSize: size_t = 0;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    (*State).WorkCredit = ((*State).WorkCredit as libc::c_uint).wrapping_add(
        ElapsedTime
            .wrapping_mul(50 as libc::c_int as libc::c_uint)
            .wrapping_div(20 as libc::c_int as libc::c_uint),
    ) as uint32 as uint32;
    if (*State).WorkCredit > 50 as libc::c_int as libc::c_uint {
        (*State).WorkCredit = 50 as libc::c_int as uint32;
    }
    while (*State).WorkCredit > 0 as libc::c_int as libc::c_uint {
        (*State).WorkCredit = ((*State).WorkCredit).wrapping_sub(1);
        (*State).WorkCredit;
        if (*State).PendingState as libc::c_uint != (*State).CurrentState as libc::c_uint {
            (*State).StateCounter = 0 as libc::c_int as uint32;
            match (*State).PendingState as libc::c_uint {
                2 => {
                    OsStatus = OS_OpenCreate(
                        &mut (*State).FileDesc,
                        ((*State).DataFileName).as_mut_ptr(),
                        OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
                        1 as libc::c_int,
                    );
                    if OsStatus != 0 as libc::c_int {
                        (*State).FileDesc = 0 as libc::c_int as osal_id_t;
                        CFE_EVS_SendEvent(
                            67 as libc::c_int as uint16,
                            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                            b"Error creating file %s, RC = %ld\0" as *const u8
                                as *const libc::c_char,
                            ((*State).DataFileName).as_mut_ptr(),
                            OsStatus as libc::c_long,
                        );
                    }
                    (*State).FileSize = 0 as libc::c_int as size_t;
                }
                3 => {
                    (*State).WorkCredit = 0 as libc::c_int as uint32;
                }
                4 => {
                    OS_MutSemTake(CFE_ES_Global.PerfDataMutex);
                }
                5 | 6 => {
                    (*State).StateCounter = 1 as libc::c_int as uint32;
                }
                7 => {
                    (*State).DataPos = (*Perf).MetaData.DataStart;
                    (*State).StateCounter = (*Perf).MetaData.DataCount;
                }
                9 => {
                    OS_MutSemGive(CFE_ES_Global.PerfDataMutex);
                }
                10 => {
                    if OS_ObjectIdDefined((*State).FileDesc) {
                        OS_close((*State).FileDesc);
                        (*State).FileDesc = 0 as libc::c_int as osal_id_t;
                    }
                }
                _ => {}
            }
            (*State).CurrentState = (*State).PendingState;
        }
        if (*State).CurrentState as libc::c_uint
            == CFE_ES_PerfDumpState_IDLE as libc::c_int as libc::c_uint
        {
            break;
        }
        if (*State).StateCounter == 0 as libc::c_int as libc::c_uint {
            (*State).PendingState = (1 as libc::c_int as libc::c_uint)
                .wrapping_add((*State).CurrentState as libc::c_uint)
                as CFE_ES_PerfDumpState_t;
            if (*State).PendingState as libc::c_uint
                >= CFE_ES_PerfDumpState_MAX as libc::c_int as libc::c_uint
            {
                (*State).PendingState = CFE_ES_PerfDumpState_IDLE;
            }
            match (*State).CurrentState as libc::c_uint {
                2 => {
                    if !OS_ObjectIdDefined((*State).FileDesc) {
                        (*State).PendingState = CFE_ES_PerfDumpState_IDLE;
                    }
                }
                7 => {
                    CFE_EVS_SendEvent(
                        68 as libc::c_int as uint16,
                        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                        b"%s written:Size=%lu,EntryCount=%lu\0" as *const u8 as *const libc::c_char,
                        ((*State).DataFileName).as_mut_ptr(),
                        (*State).FileSize,
                        (*Perf).MetaData.DataCount as libc::c_ulong,
                    );
                }
                _ => {}
            }
        } else {
            Status = 0 as libc::c_int;
            BlockSize = 0 as libc::c_int as size_t;
            match (*State).CurrentState as libc::c_uint {
                5 => {
                    CFE_FS_InitHeader(
                        &mut FileHdr,
                        b"ES Performance data file\0" as *const u8 as *const libc::c_char,
                        CFE_FS_SubType_ES_PERFDATA as libc::c_int as uint32,
                    );
                    FileHdr.Length = (::core::mem::size_of::<CFE_ES_PerfMetaData_t>()
                        as libc::c_ulong)
                        .wrapping_add(((*Perf).MetaData.DataCount as libc::c_ulong).wrapping_mul(
                            ::core::mem::size_of::<CFE_ES_PerfDataEntry_t>() as libc::c_ulong,
                        )) as uint32;
                    Status = CFE_FS_WriteHeader((*State).FileDesc, &mut FileHdr);
                    BlockSize = ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong;
                }
                6 => {
                    BlockSize = ::core::mem::size_of::<CFE_ES_PerfMetaData_t>() as libc::c_ulong;
                    OsStatus = OS_write(
                        (*State).FileDesc,
                        &mut (*Perf).MetaData as *mut CFE_ES_PerfMetaData_t as *const libc::c_void,
                        BlockSize,
                    );
                    Status = OsStatus as libc::c_long as int32;
                }
                7 => {
                    BlockSize = ::core::mem::size_of::<CFE_ES_PerfDataEntry_t>() as libc::c_ulong;
                    OsStatus = OS_write(
                        (*State).FileDesc,
                        &mut *((*Perf).DataBuffer)
                            .as_mut_ptr()
                            .offset((*State).DataPos as isize)
                            as *mut CFE_ES_PerfDataEntry_t
                            as *const libc::c_void,
                        BlockSize,
                    );
                    Status = OsStatus as libc::c_long as int32;
                    (*State).DataPos = ((*State).DataPos).wrapping_add(1);
                    (*State).DataPos;
                    if (*State).DataPos >= 10000 as libc::c_int as libc::c_uint {
                        (*State).DataPos = 0 as libc::c_int as uint32;
                    }
                }
                _ => {}
            }
            if BlockSize != 0 as libc::c_int as libc::c_ulong {
                if Status as libc::c_ulong != BlockSize {
                    CFE_ES_FileWriteByteCntErr(
                        ((*State).DataFileName).as_mut_ptr(),
                        BlockSize,
                        Status,
                    );
                    (*State).PendingState = CFE_ES_PerfDumpState_CLEANUP;
                } else {
                    (*State).FileSize = ((*State).FileSize as libc::c_ulong).wrapping_add(BlockSize)
                        as size_t as size_t;
                }
            }
            (*State).StateCounter = ((*State).StateCounter).wrapping_sub(1);
            (*State).StateCounter;
        }
    }
    return (*State).CurrentState as libc::c_uint
        != CFE_ES_PerfDumpState_IDLE as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SetPerfFilterMaskCmd(
    mut data: *const CFE_ES_SetPerfFilterMaskCmd_t,
) -> int32 {
    let mut cmd: *const CFE_ES_SetPerfFilterMaskCmd_Payload_t = &(*data).Payload;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    if (*cmd).FilterMaskNum < (128 as libc::c_int / 32 as libc::c_int) as libc::c_uint {
        (*Perf).MetaData.FilterMask[(*cmd).FilterMaskNum as usize] = (*cmd).FilterMask;
        CFE_EVS_SendEvent(
            63 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Set Performance Filter Mask Cmd rcvd, num %u, val 0x%08X\0" as *const u8
                as *const libc::c_char,
            (*cmd).FilterMaskNum,
            (*cmd).FilterMask,
        );
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
    } else {
        CFE_EVS_SendEvent(
            64 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Performance Filter Mask Cmd Error,Index(%u)out of range(%u)\0" as *const u8
                as *const libc::c_char,
            (*cmd).FilterMaskNum,
            (128 as libc::c_int / 32 as libc::c_int) as libc::c_uint,
        );
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SetPerfTriggerMaskCmd(
    mut data: *const CFE_ES_SetPerfTriggerMaskCmd_t,
) -> int32 {
    let mut cmd: *const CFE_ES_SetPerfTrigMaskCmd_Payload_t = &(*data).Payload;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    if (*cmd).TriggerMaskNum < (128 as libc::c_int / 32 as libc::c_int) as libc::c_uint {
        (*Perf).MetaData.TriggerMask[(*cmd).TriggerMaskNum as usize] = (*cmd).TriggerMask;
        CFE_EVS_SendEvent(
            65 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Set Performance Trigger Mask Cmd rcvd,num %u, val 0x%08X\0" as *const u8
                as *const libc::c_char,
            (*cmd).TriggerMaskNum,
            (*cmd).TriggerMask,
        );
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
    } else {
        CFE_EVS_SendEvent(
            66 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Performance Trigger Mask Cmd Error,Index(%u)out of range(%u)\0" as *const u8
                as *const libc::c_char,
            (*cmd).TriggerMaskNum,
            (128 as libc::c_int / 32 as libc::c_int) as libc::c_uint,
        );
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_PerfLogAdd(mut Marker: uint32, mut EntryExit: uint32) {
    let mut EntryData: CFE_ES_PerfDataEntry_t = CFE_ES_PerfDataEntry_t {
        Data: 0,
        TimerUpper32: 0,
        TimerLower32: 0,
    };
    let mut DataEnd: uint32 = 0;
    let mut Perf: *mut CFE_ES_PerfData_t = 0 as *mut CFE_ES_PerfData_t;
    Perf = &mut (*CFE_ES_Global.ResetDataPtr).Perf;
    if (*Perf).MetaData.State == CFE_ES_PERF_IDLE as libc::c_int as libc::c_uint {
        return;
    }
    if Marker >= 128 as libc::c_int as libc::c_uint {
        if (*Perf).MetaData.InvalidMarkerReported == 0 as libc::c_int as libc::c_uint {
            CFE_ES_WriteToSysLog(
                b"%s: Invalid performance marker %d,max is %d\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_PerfLogAdd\0"))
                    .as_ptr(),
                Marker,
                128 as libc::c_int - 1 as libc::c_int,
            );
            (*Perf).MetaData.InvalidMarkerReported = 1 as libc::c_int as uint32;
        }
        return;
    }
    if !((*Perf).MetaData.FilterMask
        [Marker.wrapping_div(32 as libc::c_int as libc::c_uint) as usize] as libc::c_long
        & (1 as libc::c_long) << Marker.wrapping_rem(32 as libc::c_int as libc::c_uint)
        != 0 as libc::c_int as libc::c_long)
    {
        return;
    }
    EntryData.Data = Marker | EntryExit << 31 as libc::c_int;
    CFE_PSP_Get_Timebase(&mut EntryData.TimerUpper32, &mut EntryData.TimerLower32);
    OS_MutSemTake(CFE_ES_Global.PerfDataMutex);
    if (*Perf).MetaData.State != CFE_ES_PERF_IDLE as libc::c_int as libc::c_uint {
        DataEnd = (*Perf).MetaData.DataEnd;
        (*Perf).DataBuffer[DataEnd as usize] = EntryData;
        DataEnd = DataEnd.wrapping_add(1);
        DataEnd;
        if DataEnd >= 10000 as libc::c_int as libc::c_uint {
            DataEnd = 0 as libc::c_int as uint32;
        }
        (*Perf).MetaData.DataEnd = DataEnd;
        if (*Perf).MetaData.DataCount < 10000 as libc::c_int as libc::c_uint {
            (*Perf).MetaData.DataCount = ((*Perf).MetaData.DataCount).wrapping_add(1);
            (*Perf).MetaData.DataCount;
        } else {
            (*Perf).MetaData.DataStart = (*Perf).MetaData.DataEnd;
        }
        if (*Perf).MetaData.State == CFE_ES_PERF_WAITING_FOR_TRIGGER as libc::c_int as libc::c_uint
        {
            if (*Perf).MetaData.TriggerMask
                [Marker.wrapping_div(32 as libc::c_int as libc::c_uint) as usize]
                as libc::c_long
                & (1 as libc::c_long) << Marker.wrapping_rem(32 as libc::c_int as libc::c_uint)
                != 0 as libc::c_int as libc::c_long
            {
                ::core::ptr::write_volatile(
                    &mut (*Perf).MetaData.State as *mut uint32,
                    CFE_ES_PERF_TRIGGERED as libc::c_int as uint32,
                );
            }
        }
        if (*Perf).MetaData.State == CFE_ES_PERF_TRIGGERED as libc::c_int as libc::c_uint {
            (*Perf).MetaData.TriggerCount = ((*Perf).MetaData.TriggerCount).wrapping_add(1);
            (*Perf).MetaData.TriggerCount;
            if (*Perf).MetaData.Mode == CFE_ES_PerfTrigger_START as libc::c_int as libc::c_uint {
                if (*Perf).MetaData.TriggerCount >= 10000 as libc::c_int as libc::c_uint {
                    ::core::ptr::write_volatile(
                        &mut (*Perf).MetaData.State as *mut uint32,
                        CFE_ES_PERF_IDLE as libc::c_int as uint32,
                    );
                }
            } else if (*Perf).MetaData.Mode
                == CFE_ES_PerfTrigger_CENTER as libc::c_int as libc::c_uint
            {
                if (*Perf).MetaData.TriggerCount
                    >= (10000 as libc::c_int / 2 as libc::c_int) as libc::c_uint
                {
                    ::core::ptr::write_volatile(
                        &mut (*Perf).MetaData.State as *mut uint32,
                        CFE_ES_PERF_IDLE as libc::c_int as uint32,
                    );
                }
            } else if (*Perf).MetaData.Mode == CFE_ES_PerfTrigger_END as libc::c_int as libc::c_uint
            {
                ::core::ptr::write_volatile(
                    &mut (*Perf).MetaData.State as *mut uint32,
                    CFE_ES_PERF_IDLE as libc::c_int as uint32,
                );
            }
        }
    }
    OS_MutSemGive(CFE_ES_Global.PerfDataMutex);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_TaskId_ToOSAL(mut id: CFE_ES_TaskId_t) -> osal_id_t {
    let mut Result: osal_id_t = 0;
    let mut Val: libc::c_ulong = 0;
    Val = CFE_ResourceId_ToInteger(id);
    Result = OS_ObjectIdFromInteger(Val ^ 0 as libc::c_int as libc::c_ulong);
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_TaskId_FromOSAL(mut id: osal_id_t) -> CFE_ES_TaskId_t {
    let mut Result: CFE_ResourceId_t = 0;
    let mut Val: libc::c_ulong = 0;
    Val = OS_ObjectIdToInteger(id);
    Result = CFE_ResourceId_FromInteger(Val ^ 0 as libc::c_int as libc::c_ulong);
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateAppRecordByName(
    mut Name: *const libc::c_char,
) -> *mut CFE_ES_AppRecord_t {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut Count: uint32 = 0;
    AppRecPtr = (CFE_ES_Global.AppTable).as_mut_ptr();
    Count = 32 as libc::c_int as uint32;
    loop {
        if Count == 0 as libc::c_int as libc::c_uint {
            AppRecPtr = 0 as *mut CFE_ES_AppRecord_t;
            break;
        } else {
            if CFE_ES_AppRecordIsUsed(AppRecPtr) as libc::c_int != 0
                && strcmp(Name, CFE_ES_AppRecordGetName(AppRecPtr)) == 0 as libc::c_int
            {
                break;
            }
            AppRecPtr = AppRecPtr.offset(1);
            AppRecPtr;
            Count = Count.wrapping_sub(1);
            Count;
        }
    }
    return AppRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateLibRecordByName(
    mut Name: *const libc::c_char,
) -> *mut CFE_ES_LibRecord_t {
    let mut LibRecPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    let mut Count: uint32 = 0;
    LibRecPtr = (CFE_ES_Global.LibTable).as_mut_ptr();
    Count = 10 as libc::c_int as uint32;
    loop {
        if Count == 0 as libc::c_int as libc::c_uint {
            LibRecPtr = 0 as *mut CFE_ES_LibRecord_t;
            break;
        } else {
            if CFE_ES_LibRecordIsUsed(LibRecPtr) as libc::c_int != 0
                && strcmp(Name, CFE_ES_LibRecordGetName(LibRecPtr)) == 0 as libc::c_int
            {
                break;
            }
            LibRecPtr = LibRecPtr.offset(1);
            LibRecPtr;
            Count = Count.wrapping_sub(1);
            Count;
        }
    }
    return LibRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateCounterRecordByName(
    mut Name: *const libc::c_char,
) -> *mut CFE_ES_GenCounterRecord_t {
    let mut CounterRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    let mut Count: uint32 = 0;
    CounterRecPtr = (CFE_ES_Global.CounterTable).as_mut_ptr();
    Count = 8 as libc::c_int as uint32;
    loop {
        if Count == 0 as libc::c_int as libc::c_uint {
            CounterRecPtr = 0 as *mut CFE_ES_GenCounterRecord_t;
            break;
        } else {
            if CFE_ES_CounterRecordIsUsed(CounterRecPtr) as libc::c_int != 0
                && strcmp(Name, CFE_ES_CounterRecordGetName(CounterRecPtr)) == 0 as libc::c_int
            {
                break;
            }
            CounterRecPtr = CounterRecPtr.offset(1);
            CounterRecPtr;
            Count = Count.wrapping_sub(1);
            Count;
        }
    }
    return CounterRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateAppRecordByID(
    mut AppID: CFE_ES_AppId_t,
) -> *mut CFE_ES_AppRecord_t {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut Idx: uint32 = 0;
    if CFE_ES_AppID_ToIndex(AppID, &mut Idx) == 0 as libc::c_int {
        AppRecPtr = &mut *(CFE_ES_Global.AppTable).as_mut_ptr().offset(Idx as isize)
            as *mut CFE_ES_AppRecord_t;
    } else {
        AppRecPtr = 0 as *mut CFE_ES_AppRecord_t;
    }
    return AppRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateLibRecordByID(
    mut LibID: CFE_ES_LibId_t,
) -> *mut CFE_ES_LibRecord_t {
    let mut LibRecPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    let mut Idx: uint32 = 0;
    if CFE_ES_LibID_ToIndex(LibID, &mut Idx) == 0 as libc::c_int {
        LibRecPtr = &mut *(CFE_ES_Global.LibTable).as_mut_ptr().offset(Idx as isize)
            as *mut CFE_ES_LibRecord_t;
    } else {
        LibRecPtr = 0 as *mut CFE_ES_LibRecord_t;
    }
    return LibRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateTaskRecordByID(
    mut TaskID: CFE_ES_TaskId_t,
) -> *mut CFE_ES_TaskRecord_t {
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut Idx: uint32 = 0;
    if CFE_ES_TaskID_ToIndex(TaskID, &mut Idx) == 0 as libc::c_int {
        TaskRecPtr = &mut *(CFE_ES_Global.TaskTable).as_mut_ptr().offset(Idx as isize)
            as *mut CFE_ES_TaskRecord_t;
    } else {
        TaskRecPtr = 0 as *mut CFE_ES_TaskRecord_t;
    }
    return TaskRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_LocateCounterRecordByID(
    mut CounterID: CFE_ES_CounterId_t,
) -> *mut CFE_ES_GenCounterRecord_t {
    let mut CounterRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    let mut Idx: uint32 = 0;
    if CFE_ES_CounterID_ToIndex(CounterID, &mut Idx) == 0 as libc::c_int {
        CounterRecPtr = &mut *(CFE_ES_Global.CounterTable)
            .as_mut_ptr()
            .offset(Idx as isize) as *mut CFE_ES_GenCounterRecord_t;
    } else {
        CounterRecPtr = 0 as *mut CFE_ES_GenCounterRecord_t;
    }
    return CounterRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetTaskRecordByContext() -> *mut CFE_ES_TaskRecord_t {
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    let mut TaskID: CFE_ES_TaskId_t = 0;
    TaskID = CFE_ES_TaskId_FromOSAL(OS_TaskGetId());
    TaskRecPtr = CFE_ES_LocateTaskRecordByID(TaskID);
    if !CFE_ES_TaskRecordIsMatch(TaskRecPtr, TaskID) {
        TaskRecPtr = 0 as *mut CFE_ES_TaskRecord_t;
    }
    return TaskRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GetAppRecordByContext() -> *mut CFE_ES_AppRecord_t {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    TaskRecPtr = CFE_ES_GetTaskRecordByContext();
    if !TaskRecPtr.is_null() {
        AppRecPtr = CFE_ES_LocateAppRecordByID((*TaskRecPtr).AppId);
        if !CFE_ES_AppRecordIsMatch(AppRecPtr, (*TaskRecPtr).AppId) {
            AppRecPtr = 0 as *mut CFE_ES_AppRecord_t;
        }
    } else {
        AppRecPtr = 0 as *mut CFE_ES_AppRecord_t;
    }
    return AppRecPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CheckCounterIdSlotUsed(mut CheckId: CFE_ResourceId_t) -> bool {
    let mut GenCounterRecPtr: *mut CFE_ES_GenCounterRecord_t = 0 as *mut CFE_ES_GenCounterRecord_t;
    GenCounterRecPtr = CFE_ES_LocateCounterRecordByID(CheckId);
    return GenCounterRecPtr.is_null()
        || CFE_ES_CounterRecordIsUsed(GenCounterRecPtr) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CheckAppIdSlotUsed(mut CheckId: CFE_ResourceId_t) -> bool {
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    AppRecPtr = CFE_ES_LocateAppRecordByID(CheckId);
    return AppRecPtr.is_null() || CFE_ES_AppRecordIsUsed(AppRecPtr) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CheckLibIdSlotUsed(mut CheckId: CFE_ResourceId_t) -> bool {
    let mut LibRecPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    LibRecPtr = CFE_ES_LocateLibRecordByID(CheckId);
    return LibRecPtr.is_null() || CFE_ES_LibRecordIsUsed(LibRecPtr) as libc::c_int != 0;
}
#[no_mangle]
pub static mut CFE_ES_Global: CFE_ES_Global_t = CFE_ES_Global_t {
    DebugVars: CFE_ES_DebugVariables_t {
        DebugFlag: 0,
        WatchdogWriteFlag: 0,
        PrintfEnabledFlag: 0,
        LastAppId: 0,
    },
    SharedDataMutex: 0,
    PerfDataMutex: 0,
    SystemState: 0,
    RegisteredTasks: 0,
    TaskTable: [CFE_ES_TaskRecord_t {
        TaskId: 0,
        TaskName: [0; 20],
        AppId: 0,
        StartParams: CFE_ES_TaskStartParams_t {
            StackSize: 0,
            Priority: 0,
        },
        EntryFunc: None,
        ExecutionCounter: 0,
    }; 64],
    RegisteredCoreApps: 0,
    RegisteredExternalApps: 0,
    LastAppId: 0,
    AppTable: [CFE_ES_AppRecord_t {
        AppId: 0,
        AppName: [0; 20],
        AppState: 0,
        Type: 0,
        StartParams: CFE_ES_AppStartParams_t {
            BasicInfo: CFE_ES_ModuleLoadParams_t {
                InitSymbolName: [0; 20],
                FileName: [0; 64],
            },
            MainTaskInfo: CFE_ES_TaskStartParams_t {
                StackSize: 0,
                Priority: 0,
            },
            ExceptionAction: 0,
        },
        LoadStatus: CFE_ES_ModuleLoadStatus_t {
            ModuleId: 0,
            InitSymbolAddress: 0,
        },
        ControlReq: CFE_ES_ControlReq_t {
            AppControlRequest: 0,
            AppTimerMsec: 0,
        },
        MainTaskId: 0,
    }; 32],
    RegisteredLibs: 0,
    LastLibId: 0,
    LibTable: [CFE_ES_LibRecord_t {
        LibId: 0,
        LibName: [0; 20],
        LoadParams: CFE_ES_ModuleLoadParams_t {
            InitSymbolName: [0; 20],
            FileName: [0; 64],
        },
        LoadStatus: CFE_ES_ModuleLoadStatus_t {
            ModuleId: 0,
            InitSymbolAddress: 0,
        },
    }; 10],
    LastCounterId: 0,
    CounterTable: [CFE_ES_GenCounterRecord_t {
        CounterId: 0,
        Counter: 0,
        CounterName: [0; 20],
    }; 8],
    CDSVars: CFE_ES_CDS_Instance_t {
        Pool: CFE_ES_GenPoolRecord_t {
            PoolTotalSize: 0,
            PoolMaxOffset: 0,
            AlignMask: 0,
            TailPosition: 0,
            Retrieve: None,
            Commit: None,
            AllocationCount: 0,
            ValidationErrorCount: 0,
            NumBuckets: 0,
            Buckets: [CFE_ES_GenPoolBucket_t {
                BlockSize: 0,
                FirstOffset: 0,
                AllocationCount: 0,
                ReleaseCount: 0,
                RecycleCount: 0,
            }; 17],
        },
        Cache: CFE_ES_CDS_AccessCache_t {
            Data: CFE_ES_CDS_AccessCacheData { Sig: [0; 8] },
            Offset: 0,
            Size: 0,
            AccessStatus: 0,
        },
        GenMutex: 0,
        TotalSize: 0,
        DataSize: 0,
        LastCDSBlockId: 0,
        Registry: [CFE_ES_CDS_RegRec_t {
            BlockID: 0,
            BlockOffset: 0,
            BlockSize: 0,
            Name: [0; 40],
            Table: false,
        }; 512],
    },
    CDSIsAvailable: false,
    BackgroundTask: CFE_ES_BackgroundTaskState_t {
        TaskID: 0,
        WorkSem: 0,
        NumJobsRunning: 0,
    },
    LastMemPoolId: 0,
    MemPoolTable: [CFE_ES_MemPoolRecord_t {
        Pool: CFE_ES_GenPoolRecord_t {
            PoolTotalSize: 0,
            PoolMaxOffset: 0,
            AlignMask: 0,
            TailPosition: 0,
            Retrieve: None,
            Commit: None,
            AllocationCount: 0,
            ValidationErrorCount: 0,
            NumBuckets: 0,
            Buckets: [CFE_ES_GenPoolBucket_t {
                BlockSize: 0,
                FirstOffset: 0,
                AllocationCount: 0,
                ReleaseCount: 0,
                RecycleCount: 0,
            }; 17],
        },
        PoolID: 0,
        BaseAddr: 0,
        OwnerAppID: 0,
        MutexId: 0,
    }; 10],
    BackgroundERLogDumpState: CFE_ES_BackgroundLogDumpGlobal_t {
        FileWrite: CFE_FS_FileWriteMetaData_t {
            IsPending: false,
            FileName: [0; 64],
            FileSubType: 0,
            Description: [0; 32],
            GetData: None,
            OnEvent: None,
        },
        EntryBuffer: CFE_ES_ERLog_FileEntry_t {
            BaseInfo: CFE_ES_ERLog_BaseInfo_t {
                LogEntryType: 0,
                ResetType: 0,
                ResetSubtype: 0,
                BootSource: 0,
                ProcessorResetCount: 0,
                MaxProcessorResetCount: 0,
                DebugVars: CFE_ES_DebugVariables_t {
                    DebugFlag: 0,
                    WatchdogWriteFlag: 0,
                    PrintfEnabledFlag: 0,
                    LastAppId: 0,
                },
                TimeCode: CFE_TIME_SysTime_t {
                    Seconds: 0,
                    Subseconds: 0,
                },
                Description: [0; 80],
            },
            ContextSize: 0,
            AppID: 0,
            Context: [0; 256],
        },
    },
    BackgroundPerfDumpState: CFE_ES_PerfDumpGlobal_t {
        CurrentState: CFE_ES_PerfDumpState_IDLE,
        PendingState: CFE_ES_PerfDumpState_IDLE,
        DataFileName: [0; 64],
        FileDesc: 0,
        WorkCredit: 0,
        StateCounter: 0,
        DataPos: 0,
        FileSize: 0,
    },
    BackgroundAppScanState: CFE_ES_AppTableScanState_t {
        PendingAppStateChanges: 0,
        BackgroundScanTimer: 0,
        LastScanCommandCount: 0,
    },
    TaskData: CFE_ES_TaskData_t {
        CommandCounter: 0,
        CommandErrorCounter: 0,
        HkPacket: CFE_ES_HousekeepingTlm_t {
            TelemetryHeader: CFE_MSG_TelemetryHeader_t {
                Msg: CFE_MSG_Message_t {
                    CCSDS: CCSDS_SpacePacket_t {
                        Pri: CCSDS_PrimaryHeader_t {
                            StreamId: [0; 2],
                            Sequence: [0; 2],
                            Length: [0; 2],
                        },
                    },
                },
                Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
                Spare: [0; 4],
            },
            Payload: CFE_ES_HousekeepingTlm_Payload_t {
                CommandCounter: 0,
                CommandErrorCounter: 0,
                CFECoreChecksum: 0,
                CFEMajorVersion: 0,
                CFEMinorVersion: 0,
                CFERevision: 0,
                CFEMissionRevision: 0,
                OSALMajorVersion: 0,
                OSALMinorVersion: 0,
                OSALRevision: 0,
                OSALMissionRevision: 0,
                PSPMajorVersion: 0,
                PSPMinorVersion: 0,
                PSPRevision: 0,
                PSPMissionRevision: 0,
                SysLogBytesUsed: 0,
                SysLogSize: 0,
                SysLogEntries: 0,
                SysLogMode: 0,
                ERLogIndex: 0,
                ERLogEntries: 0,
                RegisteredCoreApps: 0,
                RegisteredExternalApps: 0,
                RegisteredTasks: 0,
                RegisteredLibs: 0,
                ResetType: 0,
                ResetSubtype: 0,
                ProcessorResets: 0,
                MaxProcessorResets: 0,
                BootSource: 0,
                PerfState: 0,
                PerfMode: 0,
                PerfTriggerCount: 0,
                PerfFilterMask: [0; 4],
                PerfTriggerMask: [0; 4],
                PerfDataStart: 0,
                PerfDataEnd: 0,
                PerfDataCount: 0,
                PerfDataToWrite: 0,
                HeapBytesFree: 0,
                HeapBlocksFree: 0,
                HeapMaxBlockSize: 0,
            },
        },
        OneAppPacket: CFE_ES_OneAppTlm_t {
            TelemetryHeader: CFE_MSG_TelemetryHeader_t {
                Msg: CFE_MSG_Message_t {
                    CCSDS: CCSDS_SpacePacket_t {
                        Pri: CCSDS_PrimaryHeader_t {
                            StreamId: [0; 2],
                            Sequence: [0; 2],
                            Length: [0; 2],
                        },
                    },
                },
                Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
                Spare: [0; 4],
            },
            Payload: CFE_ES_OneAppTlm_Payload_t {
                AppInfo: CFE_ES_AppInfo_t {
                    ResourceId: 0,
                    Type: 0,
                    Name: [0; 20],
                    EntryPoint: [0; 20],
                    FileName: [0; 64],
                    StackSize: 0,
                    AddressesAreValid: 0,
                    CodeAddress: 0,
                    CodeSize: 0,
                    DataAddress: 0,
                    DataSize: 0,
                    BSSAddress: 0,
                    BSSSize: 0,
                    StartAddress: 0,
                    ExceptionAction: 0,
                    Priority: 0,
                    MainTaskId: 0,
                    ExecutionCounter: 0,
                    MainTaskName: [0; 20],
                    NumOfChildTasks: 0,
                },
            },
        },
        MemStatsPacket: CFE_ES_MemStatsTlm_t {
            TelemetryHeader: CFE_MSG_TelemetryHeader_t {
                Msg: CFE_MSG_Message_t {
                    CCSDS: CCSDS_SpacePacket_t {
                        Pri: CCSDS_PrimaryHeader_t {
                            StreamId: [0; 2],
                            Sequence: [0; 2],
                            Length: [0; 2],
                        },
                    },
                },
                Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
                Spare: [0; 4],
            },
            Payload: CFE_ES_PoolStatsTlm_Payload_t {
                PoolHandle: 0,
                PoolStats: CFE_ES_MemPoolStats_t {
                    PoolSize: 0,
                    NumBlocksRequested: 0,
                    CheckErrCtr: 0,
                    NumFreeBytes: 0,
                    BlockStats: [CFE_ES_BlockStats_t {
                        BlockSize: 0,
                        NumCreated: 0,
                        NumFree: 0,
                    }; 17],
                },
            },
        },
        CmdPipe: 0,
    },
    ResetDataPtr: 0 as *const CFE_ES_ResetData_t as *mut CFE_ES_ResetData_t,
};
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_Main(
    mut StartType: uint32,
    mut StartSubtype: uint32,
    mut ModeId: uint32,
    mut StartFilePath: *const libc::c_char,
) {
    let mut OsStatus: int32 = 0;
    memset(
        &mut CFE_ES_Global as *mut CFE_ES_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_ES_Global_t>() as libc::c_ulong,
    );
    ::core::ptr::write_volatile(
        &mut CFE_ES_Global.SystemState as *mut sig_atomic_t,
        CFE_ES_SystemState_EARLY_INIT as libc::c_int,
    );
    OsStatus = OS_MutSemCreate(
        &mut CFE_ES_Global.SharedDataMutex,
        b"ES_DATA_MUTEX\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        OS_printf(
            b"ES Startup: Error: ES Shared Data Mutex could not be created. RC=%ld\n\0" as *const u8
                as *const libc::c_char,
            OsStatus as libc::c_long,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(5 as libc::c_int);
        return;
    }
    CFE_ES_SetupResetVariables(StartType, StartSubtype, ModeId);
    CFE_ES_SetupPerfVariables(StartType);
    OsStatus = OS_MutSemCreate(
        &mut CFE_ES_Global.PerfDataMutex,
        b"ES_PERF_MUTEX\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_SysLogWrite_Unsync(
            b"%s: Error: ES Performance Data Mutex could not be created. RC=%ld\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
            OsStatus as libc::c_long,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(5 as libc::c_int);
        return;
    }
    CFE_ES_WriteToSysLog(
        b"%s: CFE_ES_Main in EARLY_INIT state\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
    );
    CFE_ES_InitializeFileSystems(StartType);
    CFE_PSP_AttachExceptions();
    CFE_ES_Global.LastAppId =
        CFE_ResourceId_FromInteger(CFE_ES_APPID_BASE as libc::c_int as libc::c_ulong);
    CFE_ES_Global.LastLibId =
        CFE_ResourceId_FromInteger(CFE_ES_LIBID_BASE as libc::c_int as libc::c_ulong);
    CFE_ES_Global.LastCounterId =
        CFE_ResourceId_FromInteger(CFE_ES_COUNTID_BASE as libc::c_int as libc::c_ulong);
    CFE_ES_Global.LastMemPoolId =
        CFE_ResourceId_FromInteger(CFE_ES_POOLID_BASE as libc::c_int as libc::c_ulong);
    CFE_ES_WriteToSysLog(
        b"%s: CFE_ES_Main entering CORE_STARTUP state\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
    );
    ::core::ptr::write_volatile(
        &mut CFE_ES_Global.SystemState as *mut sig_atomic_t,
        CFE_ES_SystemState_CORE_STARTUP as libc::c_int,
    );
    CFE_ES_CreateObjects();
    CFE_ES_WriteToSysLog(
        b"%s: CFE_ES_Main entering CORE_READY state\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
    );
    ::core::ptr::write_volatile(
        &mut CFE_ES_Global.SystemState as *mut sig_atomic_t,
        CFE_ES_SystemState_CORE_READY as libc::c_int,
    );
    CFE_ES_StartApplications(StartType, StartFilePath);
    if CFE_ES_MainTaskSyncDelay(
        CFE_ES_AppState_LATE_INIT as libc::c_int as uint32,
        1000 as libc::c_int as uint32,
    ) != 0 as libc::c_int
    {
        CFE_ES_WriteToSysLog(
            b"%s: Startup Sync failed - Applications may not have all initialized\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
        );
    }
    CFE_ES_WriteToSysLog(
        b"%s: CFE_ES_Main entering APPS_INIT state\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
    );
    ::core::ptr::write_volatile(
        &mut CFE_ES_Global.SystemState as *mut sig_atomic_t,
        CFE_ES_SystemState_APPS_INIT as libc::c_int,
    );
    if CFE_ES_MainTaskSyncDelay(
        CFE_ES_AppState_RUNNING as libc::c_int as uint32,
        1000 as libc::c_int as uint32,
    ) != 0 as libc::c_int
    {
        CFE_ES_WriteToSysLog(
            b"%s: Startup Sync failed - Applications may not have all started\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
        );
    }
    CFE_ES_WriteToSysLog(
        b"%s: CFE_ES_Main entering OPERATIONAL state\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"CFE_ES_Main\0")).as_ptr(),
    );
    ::core::ptr::write_volatile(
        &mut CFE_ES_Global.SystemState as *mut sig_atomic_t,
        CFE_ES_SystemState_OPERATIONAL as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SetupResetVariables(
    mut StartType: uint32,
    mut StartSubtype: uint32,
    mut BootSource: uint32,
) {
    let mut PspStatus: int32 = 0;
    let mut resetAreaSize: uint32 = 0;
    let mut ResetDataAddr: cpuaddr = 0;
    PspStatus = CFE_PSP_GetResetArea(&mut ResetDataAddr, &mut resetAreaSize);
    if PspStatus != 0 as libc::c_int {
        OS_printf(
            b"ES Startup: CFE_PSP_GetResetArea call Failed (0x%08x)!\n\0" as *const u8
                as *const libc::c_char,
            PspStatus as libc::c_uint,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(3 as libc::c_int);
        return;
    } else if (resetAreaSize as libc::c_ulong)
        < ::core::mem::size_of::<CFE_ES_ResetData_t>() as libc::c_ulong
    {
        OS_printf(
            b"ES Startup: Error: ES Reset area not big enough. Needed: %d, Given: %d.\n\0"
                as *const u8 as *const libc::c_char,
            ::core::mem::size_of::<CFE_ES_ResetData_t>() as libc::c_ulong as libc::c_int,
            resetAreaSize as libc::c_int,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(3 as libc::c_int);
        return;
    }
    CFE_ES_Global.ResetDataPtr = ResetDataAddr as *mut CFE_ES_ResetData_t;
    (*CFE_ES_Global.ResetDataPtr).ResetVars.BootSource = BootSource;
    if StartType == 2 as libc::c_int as libc::c_uint {
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype = StartSubtype;
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetType = 2 as libc::c_int as uint32;
        if StartSubtype == 1 as libc::c_int as libc::c_uint {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: POWER ON RESET due to Power Cycle (Power Cycle).\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                    b"CFE_ES_SetupResetVariables\0",
                ))
                .as_ptr(),
            );
            CFE_ES_WriteToERLog(
                CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                2 as libc::c_int as uint32,
                StartSubtype,
                b"POWER ON RESET due to Power Cycle (Power Cycle)\0" as *const u8
                    as *const libc::c_char,
            );
        } else if StartSubtype == 3 as libc::c_int as libc::c_uint {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: POWER ON RESET due to HW Special Cmd (Hw Spec Cmd).\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                    b"CFE_ES_SetupResetVariables\0",
                ))
                .as_ptr(),
            );
            CFE_ES_WriteToERLog(
                CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                2 as libc::c_int as uint32,
                StartSubtype,
                b"POWER ON RESET due to HW Special Cmd (Hw Spec Cmd)\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            CFE_ES_SysLogWrite_Unsync(
                b"%s: POWER ON RESET due to other cause (See Subtype).\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                    b"CFE_ES_SetupResetVariables\0",
                ))
                .as_ptr(),
            );
            CFE_ES_WriteToERLog(
                CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                2 as libc::c_int as uint32,
                StartSubtype,
                b"POWER ON RESET due to other cause (See Subtype)\0" as *const u8
                    as *const libc::c_char,
            );
        }
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount = 0 as libc::c_int as uint32;
        (*CFE_ES_Global.ResetDataPtr)
            .ResetVars
            .MaxProcessorResetCount = 2 as libc::c_int as uint32;
        CFE_ES_Global.DebugVars.DebugFlag = 0 as libc::c_int as uint32;
    } else if StartType == 1 as libc::c_int as libc::c_uint {
        if (*CFE_ES_Global.ResetDataPtr).ResetVars.ES_CausedReset
            != 1 as libc::c_int as libc::c_uint
        {
            (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetType = 1 as libc::c_int as uint32;
            (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount =
                ((*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount).wrapping_add(1);
            (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount;
            if (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount
                > (*CFE_ES_Global.ResetDataPtr)
                    .ResetVars
                    .MaxProcessorResetCount
            {
                if StartSubtype == 3 as libc::c_int as libc::c_uint {
                    (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype =
                        3 as libc::c_int as uint32;
                    CFE_ES_SysLogWrite_Unsync(
                        b"%s: POWER ON RESET due to max proc resets (HW Spec Cmd).\n\0" as *const u8
                            as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                            b"CFE_ES_SetupResetVariables\0",
                        ))
                        .as_ptr(),
                    );
                    CFE_ES_WriteToERLog(
                        CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                        2 as libc::c_int as uint32,
                        StartSubtype,
                        b"POWER ON RESET due to max proc resets (HW Spec Cmd).\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype =
                        4 as libc::c_int as uint32;
                    CFE_ES_SysLogWrite_Unsync(
                        b"%s: POWER ON RESET due to max proc resets (Watchdog).\n\0" as *const u8
                            as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                            b"CFE_ES_SetupResetVariables\0",
                        ))
                        .as_ptr(),
                    );
                    CFE_ES_WriteToERLog(
                        CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                        2 as libc::c_int as uint32,
                        StartSubtype,
                        b"POWER ON RESET due to max proc resets (Watchdog).\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                CFE_PSP_Restart(2 as libc::c_int as uint32);
                CFE_ES_SysLogWrite_Unsync(
                    b"%s: Error: CFE_PSP_Restart returned.\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                        b"CFE_ES_SetupResetVariables\0",
                    ))
                    .as_ptr(),
                );
            } else if StartSubtype == 3 as libc::c_int as libc::c_uint {
                (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype = 3 as libc::c_int as uint32;
                CFE_ES_SysLogWrite_Unsync(
                    b"%s: PROCESSOR RESET due to Hardware Special Command (HW Spec Cmd).\n\0"
                        as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                        b"CFE_ES_SetupResetVariables\0",
                    ))
                    .as_ptr(),
                );
                CFE_ES_WriteToERLog(
                    CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                    1 as libc::c_int as uint32,
                    StartSubtype,
                    b"PROCESSOR RESET due to Hardware Special Command (Hw Spec Cmd).\0" as *const u8
                        as *const libc::c_char,
                );
            } else {
                (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype = 4 as libc::c_int as uint32;
                CFE_ES_SysLogWrite_Unsync(
                    b"%s: PROCESSOR RESET due to Watchdog (Watchdog).\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                        b"CFE_ES_SetupResetVariables\0",
                    ))
                    .as_ptr(),
                );
                CFE_ES_WriteToERLog(
                    CFE_ES_LogEntryType_CORE as libc::c_int as CFE_ES_LogEntryType_Enum_t,
                    1 as libc::c_int as uint32,
                    StartSubtype,
                    b"PROCESSOR RESET due to Watchdog (Watchdog).\0" as *const u8
                        as *const libc::c_char,
                );
            }
        } else {
            (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetType = 1 as libc::c_int as uint32;
            (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype = StartSubtype;
        }
        CFE_ES_Global.DebugVars.DebugFlag = 0 as libc::c_int as uint32;
    }
    (*CFE_ES_Global.ResetDataPtr).ResetVars.ES_CausedReset = 0 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_InitializeFileSystems(mut StartType: uint32) {
    let mut OsStatus: int32 = 0;
    let mut PspStatus: int32 = 0;
    let mut RamDiskMemoryAddress: cpuaddr = 0 as libc::c_int as cpuaddr;
    let mut RamDiskMemorySize: uint32 = 0;
    let mut PercentFree: int32 = 0;
    let mut StatBuf: OS_statvfs_t = OS_statvfs_t {
        block_size: 0,
        total_blocks: 0,
        blocks_free: 0,
    };
    memset(
        &mut StatBuf as *mut OS_statvfs_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_statvfs_t>() as libc::c_ulong,
    );
    PspStatus = CFE_PSP_GetVolatileDiskMem(&mut RamDiskMemoryAddress, &mut RamDiskMemorySize);
    if PspStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Cannot Get Memory for Volatile Disk. EC = 0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_ES_InitializeFileSystems\0",
            ))
            .as_ptr(),
            PspStatus as libc::c_uint,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(2 as libc::c_int);
    }
    if StartType == 2 as libc::c_int as libc::c_uint {
        OsStatus = OS_mkfs(
            RamDiskMemoryAddress as *mut libc::c_void as *mut libc::c_char,
            b"/ramdev0\0" as *const u8 as *const libc::c_char,
            b"RAM\0" as *const u8 as *const libc::c_char,
            512 as libc::c_int as size_t,
            4096 as libc::c_int as osal_blockcount_t,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Error Creating Volatile(RAM) Volume. EC = %ld\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                    b"CFE_ES_InitializeFileSystems\0",
                ))
                .as_ptr(),
                OsStatus as libc::c_long,
            );
            OS_TaskDelay(500 as libc::c_int as uint32);
            CFE_PSP_Panic(2 as libc::c_int);
        }
    } else {
        OsStatus = OS_initfs(
            RamDiskMemoryAddress as *mut libc::c_void as *mut libc::c_char,
            b"/ramdev0\0" as *const u8 as *const libc::c_char,
            b"RAM\0" as *const u8 as *const libc::c_char,
            512 as libc::c_int as size_t,
            4096 as libc::c_int as osal_blockcount_t,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Error Initializing Volatile(RAM) Volume. EC = %ld\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                    b"CFE_ES_InitializeFileSystems\0",
                ))
                .as_ptr(),
                OsStatus as libc::c_long,
            );
            CFE_ES_WriteToSysLog(
                b"%s: Formatting Volatile(RAM) Volume.\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                    b"CFE_ES_InitializeFileSystems\0",
                ))
                .as_ptr(),
            );
            OsStatus = OS_mkfs(
                RamDiskMemoryAddress as *mut libc::c_void as *mut libc::c_char,
                b"/ramdev0\0" as *const u8 as *const libc::c_char,
                b"RAM\0" as *const u8 as *const libc::c_char,
                512 as libc::c_int as size_t,
                4096 as libc::c_int as osal_blockcount_t,
            );
            if OsStatus != 0 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: Error Creating Volatile(RAM) Volume. EC = %ld\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                        b"CFE_ES_InitializeFileSystems\0",
                    ))
                    .as_ptr(),
                    OsStatus as libc::c_long,
                );
                OS_TaskDelay(500 as libc::c_int as uint32);
                CFE_PSP_Panic(2 as libc::c_int);
            }
        }
    }
    OsStatus = OS_mount(
        b"/ramdev0\0" as *const u8 as *const libc::c_char,
        b"/ram\0" as *const u8 as *const libc::c_char,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error Mounting Volatile(RAM) Volume. EC = %ld\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_ES_InitializeFileSystems\0",
            ))
            .as_ptr(),
            OsStatus as libc::c_long,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(2 as libc::c_int);
    }
    if StartType == 1 as libc::c_int as libc::c_uint && 30 as libc::c_int > 0 as libc::c_int {
        OsStatus =
            OS_FileSysStatVolume(b"/ram\0" as *const u8 as *const libc::c_char, &mut StatBuf);
        if OsStatus == 0 as libc::c_int && StatBuf.total_blocks > 0 as libc::c_int as libc::c_ulong
        {
            PercentFree = (StatBuf.blocks_free)
                .wrapping_mul(100 as libc::c_int as libc::c_ulong)
                .wrapping_div(StatBuf.total_blocks) as int32;
            CFE_ES_WriteToSysLog(
                b"%s: Volatile Disk has %d Percent free space.\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                    b"CFE_ES_InitializeFileSystems\0",
                ))
                .as_ptr(),
                PercentFree,
            );
            if PercentFree < 30 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: Insufficient Free Space on Volatile Disk, Reformatting.\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                        b"CFE_ES_InitializeFileSystems\0",
                    ))
                    .as_ptr(),
                );
                OsStatus = OS_unmount(b"/ram\0" as *const u8 as *const libc::c_char);
                if OsStatus == 0 as libc::c_int {
                    OsStatus = OS_rmfs(b"/ramdev0\0" as *const u8 as *const libc::c_char);
                    if OsStatus == 0 as libc::c_int {
                        OsStatus = OS_mkfs(
                            RamDiskMemoryAddress as *mut libc::c_void as *mut libc::c_char,
                            b"/ramdev0\0" as *const u8 as *const libc::c_char,
                            b"RAM\0" as *const u8 as *const libc::c_char,
                            512 as libc::c_int as size_t,
                            4096 as libc::c_int as osal_blockcount_t,
                        );
                        if OsStatus == 0 as libc::c_int {
                            OsStatus = OS_mount(
                                b"/ramdev0\0" as *const u8 as *const libc::c_char,
                                b"/ram\0" as *const u8 as *const libc::c_char,
                            );
                            if OsStatus != 0 as libc::c_int {
                                CFE_ES_WriteToSysLog(
                                    b"%s: Error Re-Mounting Volatile(RAM) Volume. EC = %ld\n\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                                        b"CFE_ES_InitializeFileSystems\0",
                                    ))
                                    .as_ptr(),
                                    OsStatus as libc::c_long,
                                );
                                OS_TaskDelay(500 as libc::c_int as uint32);
                                CFE_PSP_Panic(2 as libc::c_int);
                            }
                        } else {
                            CFE_ES_WriteToSysLog(
                                b"%s: Error Re-Formatting Volatile(RAM) Volume. EC = %ld\n\0"
                                    as *const u8
                                    as *const libc::c_char,
                                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                                    b"CFE_ES_InitializeFileSystems\0",
                                ))
                                .as_ptr(),
                                OsStatus as libc::c_long,
                            );
                            OS_TaskDelay(500 as libc::c_int as uint32);
                            CFE_PSP_Panic(2 as libc::c_int);
                        }
                    } else {
                        CFE_ES_WriteToSysLog(
                            b"%s: Error Removing Volatile(RAM) Volume. EC = %ld\n\0" as *const u8
                                as *const libc::c_char,
                            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                                b"CFE_ES_InitializeFileSystems\0",
                            ))
                            .as_ptr(),
                            OsStatus as libc::c_long,
                        );
                        OS_TaskDelay(500 as libc::c_int as uint32);
                        CFE_PSP_Panic(2 as libc::c_int);
                    }
                } else {
                    CFE_ES_WriteToSysLog(
                        b"%s: Error Un-Mounting Volatile(RAM) Volume. EC = %ld\n\0" as *const u8
                            as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                            b"CFE_ES_InitializeFileSystems\0",
                        ))
                        .as_ptr(),
                        OsStatus as libc::c_long,
                    );
                    OS_TaskDelay(500 as libc::c_int as uint32);
                    CFE_PSP_Panic(2 as libc::c_int);
                }
            }
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Error Determining Blocks Free on Volume. EC = %ld\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                    b"CFE_ES_InitializeFileSystems\0",
                ))
                .as_ptr(),
                OsStatus as libc::c_long,
            );
            OS_TaskDelay(500 as libc::c_int as uint32);
            CFE_PSP_Panic(2 as libc::c_int);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_CreateObjects() {
    let mut ReturnCode: int32 = 0;
    let mut i: uint16 = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut PendingAppId: CFE_ResourceId_t = 0;
    CFE_ES_WriteToSysLog(
        b"%s: Starting Object Creation calls.\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_CreateObjects\0"))
            .as_ptr(),
    );
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < 30 as libc::c_int {
        match CFE_ES_ObjectTable[i as usize].ObjectType {
            2 | 1 => {
                CFE_ES_LockSharedData(
                    (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                        b"CFE_ES_CreateObjects\0",
                    ))
                    .as_ptr(),
                    726 as libc::c_int,
                );
                PendingAppId = CFE_ResourceId_FindNext(
                    CFE_ES_Global.LastAppId,
                    32 as libc::c_int as uint32,
                    Some(
                        CFE_ES_CheckAppIdSlotUsed as unsafe extern "C" fn(CFE_ResourceId_t) -> bool,
                    ),
                );
                AppRecPtr = CFE_ES_LocateAppRecordByID(PendingAppId);
                if !AppRecPtr.is_null() {
                    (*AppRecPtr).Type = CFE_ES_AppType_CORE as libc::c_int as CFE_ES_AppType_Enum_t;
                    strncpy(
                        ((*AppRecPtr).AppName).as_mut_ptr(),
                        (CFE_ES_ObjectTable[i as usize].ObjectName).as_mut_ptr(),
                        (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    );
                    (*AppRecPtr).AppName[(::core::mem::size_of::<[libc::c_char; 20]>()
                        as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        as usize] = '\0' as i32 as libc::c_char;
                    (*AppRecPtr).StartParams.MainTaskInfo.StackSize =
                        CFE_ES_ObjectTable[i as usize].ObjectSize as size_t;
                    (*AppRecPtr).StartParams.MainTaskInfo.Priority =
                        CFE_ES_ObjectTable[i as usize].ObjectPriority as CFE_ES_TaskPriority_Atom_t;
                    (*AppRecPtr).StartParams.ExceptionAction = CFE_ES_ExceptionAction_PROC_RESTART
                        as libc::c_int
                        as CFE_ES_ExceptionAction_Enum_t;
                    (*AppRecPtr).ControlReq.AppControlRequest =
                        CFE_ES_RunStatus_APP_RUN as libc::c_int as uint32;
                    (*AppRecPtr).ControlReq.AppTimerMsec = 0 as libc::c_int;
                    CFE_ES_AppRecordSetUsed(AppRecPtr, 0xffffffff as libc::c_uint);
                    CFE_ES_Global.LastAppId = PendingAppId;
                }
                CFE_ES_UnlockSharedData(
                    (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                        b"CFE_ES_CreateObjects\0",
                    ))
                    .as_ptr(),
                    756 as libc::c_int,
                );
                if !AppRecPtr.is_null() {
                    ReturnCode = CFE_ES_StartAppTask(
                        &mut (*AppRecPtr).MainTaskId,
                        ((*AppRecPtr).AppName).as_mut_ptr(),
                        CFE_ES_ObjectTable[i as usize].FuncPtrUnion.MainTaskPtr,
                        &mut (*AppRecPtr).StartParams.MainTaskInfo,
                        PendingAppId,
                    );
                    CFE_ES_LockSharedData(
                        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                            b"CFE_ES_CreateObjects\0",
                        ))
                        .as_ptr(),
                        776 as libc::c_int,
                    );
                    if ReturnCode == 0 as libc::c_int {
                        CFE_ES_AppRecordSetUsed(AppRecPtr, PendingAppId);
                        CFE_ES_Global.RegisteredCoreApps =
                            (CFE_ES_Global.RegisteredCoreApps).wrapping_add(1);
                        CFE_ES_Global.RegisteredCoreApps;
                    } else {
                        memset(
                            AppRecPtr as *mut libc::c_void,
                            0 as libc::c_int,
                            ::core::mem::size_of::<CFE_ES_AppRecord_t>() as libc::c_ulong,
                        );
                    }
                    CFE_ES_UnlockSharedData(
                        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                            b"CFE_ES_CreateObjects\0",
                        ))
                        .as_ptr(),
                        795 as libc::c_int,
                    );
                } else {
                    CFE_ES_WriteToSysLog(
                        b"%s: Error, No free application slots available for CORE App!\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                            b"CFE_ES_CreateObjects\0",
                        ))
                        .as_ptr(),
                    );
                    ReturnCode = 0xc4000004 as libc::c_uint as CFE_Status_t;
                }
                if ReturnCode == 0 as libc::c_int {
                    ReturnCode = CFE_ES_MainTaskSyncDelay(
                        CFE_ES_AppState_RUNNING as libc::c_int as uint32,
                        (30000 as libc::c_int * 1000 as libc::c_int) as uint32,
                    );
                }
                if ReturnCode != 0 as libc::c_int {
                    CFE_ES_WriteToSysLog(
                        b"%s: OS_TaskCreate error creating core App: %s: EC = 0x%08X\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                            b"CFE_ES_CreateObjects\0",
                        ))
                        .as_ptr(),
                        (CFE_ES_ObjectTable[i as usize].ObjectName).as_mut_ptr(),
                        ReturnCode as libc::c_uint,
                    );
                    OS_TaskDelay(500 as libc::c_int as uint32);
                    CFE_PSP_Panic(6 as libc::c_int);
                }
            }
            4 => {
                if (CFE_ES_ObjectTable[i as usize].FuncPtrUnion.FunctionPtr).is_some() {
                    CFE_ES_WriteToSysLog(
                        b"%s: Calling %s\n\0" as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                            b"CFE_ES_CreateObjects\0",
                        ))
                        .as_ptr(),
                        (CFE_ES_ObjectTable[i as usize].ObjectName).as_mut_ptr(),
                    );
                    ReturnCode = (Some(
                        ((*CFE_ES_ObjectTable.as_mut_ptr().offset(i as isize))
                            .FuncPtrUnion
                            .FunctionPtr)
                            .expect("non-null function pointer"),
                    ))
                    .expect("non-null function pointer")();
                    if ReturnCode != 0 as libc::c_int {
                        CFE_ES_WriteToSysLog(
                            b"%s: Error returned when calling function: %s: EC = 0x%08X\n\0"
                                as *const u8 as *const libc::c_char,
                            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                                b"CFE_ES_CreateObjects\0",
                            ))
                            .as_ptr(),
                            (CFE_ES_ObjectTable[i as usize].ObjectName).as_mut_ptr(),
                            ReturnCode as libc::c_uint,
                        );
                        OS_TaskDelay(500 as libc::c_int as uint32);
                        CFE_PSP_Panic(6 as libc::c_int);
                    }
                } else {
                    CFE_ES_WriteToSysLog(
                        b"%s: bad function pointer ( table entry = %d).\n\0" as *const u8
                            as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(
                            b"CFE_ES_CreateObjects\0",
                        ))
                        .as_ptr(),
                        i as libc::c_int,
                    );
                }
            }
            0 | _ => {}
        }
        i = i.wrapping_add(1);
        i;
    }
    CFE_ES_WriteToSysLog(
        b"%s: Finished ES CreateObject table entries.\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_ES_CreateObjects\0"))
            .as_ptr(),
    );
}
unsafe extern "C" fn CFE_ES_MainTaskSyncDelay(
    mut AppStateId: uint32,
    mut TimeOutMilliseconds: uint32,
) -> int32 {
    let mut Status: int32 = 0;
    let mut i: uint32 = 0;
    let mut WaitTime: uint32 = 0;
    let mut WaitRemaining: uint32 = 0;
    let mut AppNotReadyCounter: uint32 = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    Status = 0xc4000027 as libc::c_uint as CFE_Status_t;
    WaitRemaining = TimeOutMilliseconds;
    loop {
        AppNotReadyCounter = 0 as libc::c_int as uint32;
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_ES_MainTaskSyncDelay\0",
            ))
            .as_ptr(),
            899 as libc::c_int,
        );
        AppRecPtr = (CFE_ES_Global.AppTable).as_mut_ptr();
        i = 0 as libc::c_int as uint32;
        while i < 32 as libc::c_int as libc::c_uint {
            if CFE_ES_AppRecordIsUsed(AppRecPtr) as libc::c_int != 0
                && (*AppRecPtr).AppState < AppStateId
            {
                AppNotReadyCounter = AppNotReadyCounter.wrapping_add(1);
                AppNotReadyCounter;
            }
            AppRecPtr = AppRecPtr.offset(1);
            AppRecPtr;
            i = i.wrapping_add(1);
            i;
        }
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_ES_MainTaskSyncDelay\0",
            ))
            .as_ptr(),
            909 as libc::c_int,
        );
        if AppNotReadyCounter == 0 as libc::c_int as libc::c_uint {
            Status = 0 as libc::c_int;
            break;
        } else {
            if WaitRemaining > 50 as libc::c_int as libc::c_uint {
                WaitTime = 50 as libc::c_int as uint32;
            } else {
                if !(WaitRemaining > 0 as libc::c_int as libc::c_uint) {
                    break;
                }
                WaitTime = WaitRemaining;
            }
            OS_TaskDelay(WaitTime);
            WaitRemaining =
                (WaitRemaining as libc::c_uint).wrapping_sub(WaitTime) as uint32 as uint32;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLogClear_Unsync() {
    (*CFE_ES_Global.ResetDataPtr).SystemLogWriteIdx = 0 as libc::c_int as size_t;
    (*CFE_ES_Global.ResetDataPtr).SystemLogEndIdx = 0 as libc::c_int as size_t;
    (*CFE_ES_Global.ResetDataPtr).SystemLogEntryNum = 0 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLogReadStart_Unsync(mut Buffer: *mut CFE_ES_SysLogReadBuffer_t) {
    let mut ReadIdx: size_t = 0;
    let mut EndIdx: size_t = 0;
    let mut TotalSize: size_t = 0;
    ReadIdx = (*CFE_ES_Global.ResetDataPtr).SystemLogWriteIdx;
    EndIdx = (*CFE_ES_Global.ResetDataPtr).SystemLogEndIdx;
    TotalSize = EndIdx;
    while TotalSize > 0 as libc::c_int as libc::c_ulong && ReadIdx < EndIdx {
        ReadIdx = ReadIdx.wrapping_add(1);
        ReadIdx;
        TotalSize = TotalSize.wrapping_sub(1);
        TotalSize;
        if (*CFE_ES_Global.ResetDataPtr).SystemLog
            [ReadIdx.wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize]
            as libc::c_int
            == '\n' as i32
        {
            break;
        }
    }
    (*Buffer).SizeLeft = TotalSize;
    (*Buffer).LastOffset = ReadIdx;
    (*Buffer).EndIdx = EndIdx;
    (*Buffer).BlockSize = 0 as libc::c_int as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLogAppend_Unsync(mut LogString: *const libc::c_char) -> int32 {
    let mut ReturnCode: int32 = 0;
    let mut MessageLen: size_t = 0;
    let mut WriteIdx: size_t = 0;
    let mut EndIdx: size_t = 0;
    MessageLen = strlen(LogString);
    if MessageLen > (3072 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {
        MessageLen = (3072 as libc::c_int / 2 as libc::c_int) as size_t;
        ReturnCode = 0x44000029 as libc::c_int;
    } else {
        ReturnCode = 0 as libc::c_int;
    }
    if MessageLen == 0 as libc::c_int as libc::c_ulong {
        return ReturnCode;
    }
    WriteIdx = (*CFE_ES_Global.ResetDataPtr).SystemLogWriteIdx;
    EndIdx = (*CFE_ES_Global.ResetDataPtr).SystemLogEndIdx;
    if WriteIdx.wrapping_add(MessageLen) > 3072 as libc::c_int as libc::c_ulong {
        if (*CFE_ES_Global.ResetDataPtr).SystemLogMode
            == CFE_ES_LogMode_OVERWRITE as libc::c_int as libc::c_uint
        {
            EndIdx = WriteIdx;
            WriteIdx = 0 as libc::c_int as size_t;
        } else if WriteIdx < (3072 as libc::c_int - 24 as libc::c_int) as libc::c_ulong {
            MessageLen = (3072 as libc::c_int as libc::c_ulong).wrapping_sub(WriteIdx);
            ReturnCode = 0x44000029 as libc::c_int;
        } else {
            MessageLen = 0 as libc::c_int as size_t;
        }
    }
    if MessageLen == 0 as libc::c_int as libc::c_ulong {
        ReturnCode = 0xc4000006 as libc::c_uint as CFE_Status_t;
    } else {
        memcpy(
            &mut *((*CFE_ES_Global.ResetDataPtr).SystemLog)
                .as_mut_ptr()
                .offset(WriteIdx as isize) as *mut libc::c_char as *mut libc::c_void,
            LogString as *const libc::c_void,
            MessageLen.wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        WriteIdx = (WriteIdx as libc::c_ulong).wrapping_add(MessageLen) as size_t as size_t;
        (*CFE_ES_Global.ResetDataPtr).SystemLog
            [WriteIdx.wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
            '\n' as i32 as libc::c_char;
        if WriteIdx > EndIdx {
            EndIdx = WriteIdx;
        }
        (*CFE_ES_Global.ResetDataPtr).SystemLogWriteIdx = WriteIdx;
        (*CFE_ES_Global.ResetDataPtr).SystemLogEndIdx = EndIdx;
        (*CFE_ES_Global.ResetDataPtr).SystemLogEntryNum =
            ((*CFE_ES_Global.ResetDataPtr).SystemLogEntryNum).wrapping_add(1);
        (*CFE_ES_Global.ResetDataPtr).SystemLogEntryNum;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLogWrite_Unsync(
    mut SpecStringPtr: *const libc::c_char,
    mut args: ...
) -> int32 {
    let mut TmpString: [libc::c_char; 148] = [0; 148];
    let mut ArgPtr: ::core::ffi::VaListImpl;
    ArgPtr = args.clone();
    CFE_ES_SysLog_vsnprintf(
        TmpString.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 148]>() as libc::c_ulong,
        SpecStringPtr,
        ArgPtr.as_va_list(),
    );
    OS_printf(
        b"%s\0" as *const u8 as *const libc::c_char,
        TmpString.as_mut_ptr(),
    );
    return CFE_ES_SysLogAppend_Unsync(TmpString.as_mut_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLogReadData(mut Buffer: *mut CFE_ES_SysLogReadBuffer_t) {
    let mut BlockSize: size_t = 0;
    (*Buffer).BlockSize = 0 as libc::c_int as size_t;
    while (*Buffer).SizeLeft > 0 as libc::c_int as libc::c_ulong
        && (*Buffer).BlockSize < ::core::mem::size_of::<[libc::c_char; 444]>() as libc::c_ulong
    {
        BlockSize = (::core::mem::size_of::<[libc::c_char; 444]>() as libc::c_ulong)
            .wrapping_sub((*Buffer).BlockSize);
        if (*Buffer).LastOffset >= (*Buffer).EndIdx {
            (*Buffer).LastOffset = 0 as libc::c_int as size_t;
        }
        if ((*Buffer).LastOffset).wrapping_add(BlockSize) > (*Buffer).EndIdx {
            BlockSize = ((*Buffer).EndIdx).wrapping_sub((*Buffer).LastOffset);
        }
        if BlockSize > (*Buffer).SizeLeft {
            BlockSize = (*Buffer).SizeLeft;
        }
        if BlockSize == 0 as libc::c_int as libc::c_ulong {
            break;
        }
        memcpy(
            &mut *((*Buffer).Data)
                .as_mut_ptr()
                .offset((*Buffer).BlockSize as isize) as *mut libc::c_char
                as *mut libc::c_void,
            &mut *((*CFE_ES_Global.ResetDataPtr).SystemLog)
                .as_mut_ptr()
                .offset((*Buffer).LastOffset as isize) as *mut libc::c_char
                as *const libc::c_void,
            BlockSize,
        );
        (*Buffer).BlockSize =
            ((*Buffer).BlockSize as libc::c_ulong).wrapping_add(BlockSize) as size_t as size_t;
        (*Buffer).LastOffset =
            ((*Buffer).LastOffset as libc::c_ulong).wrapping_add(BlockSize) as size_t as size_t;
        (*Buffer).SizeLeft =
            ((*Buffer).SizeLeft as libc::c_ulong).wrapping_sub(BlockSize) as size_t as size_t;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLogSetMode(mut Mode: CFE_ES_LogMode_Enum_t) -> int32 {
    let mut Status: int32 = 0;
    if Mode as libc::c_int == CFE_ES_LogMode_OVERWRITE as libc::c_int
        || Mode as libc::c_int == CFE_ES_LogMode_DISCARD as libc::c_int
    {
        (*CFE_ES_Global.ResetDataPtr).SystemLogMode = Mode as uint32;
        Status = 0 as libc::c_int;
    } else {
        Status = 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLog_vsnprintf(
    mut Buffer: *mut libc::c_char,
    mut BufferSize: size_t,
    mut SpecStringPtr: *const libc::c_char,
    mut ArgPtr: ::core::ffi::VaList,
) {
    let mut StringLen: size_t = 0;
    let mut MaxLen: size_t = 0;
    let mut PrintLen: libc::c_int = 0;
    StringLen = 0 as libc::c_int as size_t;
    if BufferSize > (24 as libc::c_int + 2 as libc::c_int) as libc::c_ulong {
        MaxLen = BufferSize.wrapping_sub(2 as libc::c_int as libc::c_ulong);
        CFE_TIME_Print(Buffer, CFE_TIME_GetTime());
        StringLen = strlen(Buffer);
        if StringLen < MaxLen {
            *Buffer.offset(StringLen as isize) = ' ' as i32 as libc::c_char;
            StringLen = StringLen.wrapping_add(1);
            StringLen;
            PrintLen = vsnprintf(
                &mut *Buffer.offset(StringLen as isize),
                BufferSize.wrapping_sub(StringLen),
                SpecStringPtr,
                ArgPtr.as_va_list(),
            );
            if PrintLen > 0 as libc::c_int {
                StringLen = (StringLen as libc::c_ulong).wrapping_add(PrintLen as libc::c_ulong)
                    as size_t as size_t;
            }
        }
        if StringLen > MaxLen {
            StringLen = MaxLen;
        }
        while StringLen > 0 as libc::c_int as libc::c_ulong
            && *(*__ctype_b_loc()).offset(
                *Buffer.offset(StringLen.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
                    as libc::c_uchar as libc::c_int as isize,
            ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                != 0
        {
            StringLen = StringLen.wrapping_sub(1);
            StringLen;
        }
        *Buffer.offset(StringLen as isize) = '\n' as i32 as libc::c_char;
        StringLen = StringLen.wrapping_add(1);
        StringLen;
    }
    if BufferSize > 0 as libc::c_int as libc::c_ulong {
        *Buffer.offset(StringLen as isize) = 0 as libc::c_int as libc::c_char;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SysLogDump(mut Filename: *const libc::c_char) -> int32 {
    let mut fd: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut WritePos: size_t = 0;
    let mut TotalSize: size_t = 0;
    let mut LastReqSize: size_t = 0;
    let mut Buffer: C2RustUnnamed_23 = C2RustUnnamed_23 {
        LogData: CFE_ES_SysLogReadBuffer_t {
            SizeLeft: 0,
            BlockSize: 0,
            EndIdx: 0,
            LastOffset: 0,
            Data: [0; 444],
        },
    };
    OsStatus = OS_OpenCreate(
        &mut fd,
        Filename,
        OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
        1 as libc::c_int,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            55 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Error creating file %s, RC = %ld\0" as *const u8 as *const libc::c_char,
            Filename,
            OsStatus as libc::c_long,
        );
        return 0xc4000014 as libc::c_uint as CFE_Status_t;
    }
    CFE_FS_InitHeader(
        &mut Buffer.FileHdr,
        b"ES system log data file\0" as *const u8 as *const libc::c_char,
        CFE_FS_SubType_ES_SYSLOG as libc::c_int as uint32,
    );
    TotalSize = 0 as libc::c_int as size_t;
    LastReqSize = ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong;
    Status = CFE_FS_WriteHeader(fd, &mut Buffer.FileHdr);
    if Status >= 0 as libc::c_int {
        TotalSize =
            (TotalSize as libc::c_ulong).wrapping_add(Status as libc::c_ulong) as size_t as size_t;
        CFE_ES_LockSharedData(
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_SysLogDump\0"))
                .as_ptr(),
            471 as libc::c_int,
        );
        CFE_ES_SysLogReadStart_Unsync(&mut Buffer.LogData);
        CFE_ES_SysLogReadData(&mut Buffer.LogData);
        CFE_ES_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_ES_SysLogDump\0"))
                .as_ptr(),
            474 as libc::c_int,
        );
        while Buffer.LogData.BlockSize > 0 as libc::c_int as libc::c_ulong {
            WritePos = 0 as libc::c_int as size_t;
            while WritePos < Buffer.LogData.BlockSize {
                LastReqSize = (Buffer.LogData.BlockSize).wrapping_sub(WritePos);
                OsStatus = OS_write(
                    fd,
                    &mut *(Buffer.LogData.Data).as_mut_ptr().offset(WritePos as isize)
                        as *mut libc::c_char as *const libc::c_void,
                    LastReqSize,
                );
                if OsStatus <= 0 as libc::c_int {
                    break;
                }
                WritePos = (WritePos as libc::c_ulong)
                    .wrapping_add(OsStatus as libc::c_long as libc::c_ulong)
                    as size_t as size_t;
                TotalSize = (TotalSize as libc::c_ulong)
                    .wrapping_add(OsStatus as libc::c_long as libc::c_ulong)
                    as size_t as size_t;
            }
            if OsStatus <= 0 as libc::c_int {
                Status = OsStatus as libc::c_long as int32;
                break;
            } else {
                CFE_ES_SysLogReadData(&mut Buffer.LogData);
            }
        }
    }
    OS_close(fd);
    if Status <= 0 as libc::c_int {
        CFE_ES_FileWriteByteCntErr(Filename, LastReqSize, Status);
        Status = 0xc4000014 as libc::c_uint as CFE_Status_t;
    } else {
        CFE_EVS_SendEvent(
            18 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"%s written:Size=%lu,Entries=%u\0" as *const u8 as *const libc::c_char,
            Filename,
            TotalSize,
            CFE_ES_Global.TaskData.HkPacket.Payload.SysLogEntries,
        );
        Status = 0 as libc::c_int;
    }
    return Status;
}
#[no_mangle]
pub static mut CFE_ES_TaskData: CFE_ES_TaskData_t = CFE_ES_TaskData_t {
    CommandCounter: 0,
    CommandErrorCounter: 0,
    HkPacket: CFE_ES_HousekeepingTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_ES_HousekeepingTlm_Payload_t {
            CommandCounter: 0,
            CommandErrorCounter: 0,
            CFECoreChecksum: 0,
            CFEMajorVersion: 0,
            CFEMinorVersion: 0,
            CFERevision: 0,
            CFEMissionRevision: 0,
            OSALMajorVersion: 0,
            OSALMinorVersion: 0,
            OSALRevision: 0,
            OSALMissionRevision: 0,
            PSPMajorVersion: 0,
            PSPMinorVersion: 0,
            PSPRevision: 0,
            PSPMissionRevision: 0,
            SysLogBytesUsed: 0,
            SysLogSize: 0,
            SysLogEntries: 0,
            SysLogMode: 0,
            ERLogIndex: 0,
            ERLogEntries: 0,
            RegisteredCoreApps: 0,
            RegisteredExternalApps: 0,
            RegisteredTasks: 0,
            RegisteredLibs: 0,
            ResetType: 0,
            ResetSubtype: 0,
            ProcessorResets: 0,
            MaxProcessorResets: 0,
            BootSource: 0,
            PerfState: 0,
            PerfMode: 0,
            PerfTriggerCount: 0,
            PerfFilterMask: [0; 4],
            PerfTriggerMask: [0; 4],
            PerfDataStart: 0,
            PerfDataEnd: 0,
            PerfDataCount: 0,
            PerfDataToWrite: 0,
            HeapBytesFree: 0,
            HeapBlocksFree: 0,
            HeapMaxBlockSize: 0,
        },
    },
    OneAppPacket: CFE_ES_OneAppTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_ES_OneAppTlm_Payload_t {
            AppInfo: CFE_ES_AppInfo_t {
                ResourceId: 0,
                Type: 0,
                Name: [0; 20],
                EntryPoint: [0; 20],
                FileName: [0; 64],
                StackSize: 0,
                AddressesAreValid: 0,
                CodeAddress: 0,
                CodeSize: 0,
                DataAddress: 0,
                DataSize: 0,
                BSSAddress: 0,
                BSSSize: 0,
                StartAddress: 0,
                ExceptionAction: 0,
                Priority: 0,
                MainTaskId: 0,
                ExecutionCounter: 0,
                MainTaskName: [0; 20],
                NumOfChildTasks: 0,
            },
        },
    },
    MemStatsPacket: CFE_ES_MemStatsTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_ES_PoolStatsTlm_Payload_t {
            PoolHandle: 0,
            PoolStats: CFE_ES_MemPoolStats_t {
                PoolSize: 0,
                NumBlocksRequested: 0,
                CheckErrCtr: 0,
                NumFreeBytes: 0,
                BlockStats: [CFE_ES_BlockStats_t {
                    BlockSize: 0,
                    NumCreated: 0,
                    NumFree: 0,
                }; 17],
            },
        },
    },
    CmdPipe: 0,
};
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_TaskMain() {
    let mut Status: int32 = 0;
    let mut AppRunStatus: uint32 = CFE_ES_RunStatus_APP_RUN as libc::c_int as uint32;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(1 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    Status = CFE_ES_TaskInit();
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Application Init Failed,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskMain\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        AppRunStatus = CFE_ES_RunStatus_CORE_APP_INIT_ERROR as libc::c_int as uint32;
    }
    CFE_ES_WaitForSystemState(
        CFE_ES_SystemState_CORE_READY as libc::c_int as uint32,
        30000 as libc::c_int as uint32,
    );
    while AppRunStatus == CFE_ES_RunStatus_APP_RUN as libc::c_int as libc::c_uint {
        CFE_ES_IncrementTaskCounter();
        CFE_ES_PerfLogAdd(1 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        Status = CFE_SB_ReceiveBuffer(
            &mut SBBufPtr,
            CFE_ES_Global.TaskData.CmdPipe,
            -(1 as libc::c_int),
        );
        CFE_ES_PerfLogAdd(1 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if Status == 0 as libc::c_int {
            CFE_ES_TaskPipe(SBBufPtr);
            CFE_ES_BackgroundWakeup();
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Error reading cmd pipe,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskMain\0"))
                    .as_ptr(),
                Status as libc::c_uint,
            );
            AppRunStatus = CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR as libc::c_int as uint32;
        }
    }
    CFE_ES_PerfLogAdd(1 as libc::c_int as uint32, 1 as libc::c_int as uint32);
    CFE_ES_ExitApp(AppRunStatus);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenerateSingleVersionEvent(
    mut ModuleType: *const libc::c_char,
    mut ModuleName: *const libc::c_char,
    mut Id: CFE_ConfigId_t,
) -> int32 {
    let mut Status: int32 = 0;
    Status = CFE_EVS_SendEvent(
        91 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Version Info: %s %s, version %s\0" as *const u8 as *const libc::c_char,
        ModuleType,
        ModuleName,
        CFE_Config_GetString(Id),
    );
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ModSrcVerCallback(
    mut Arg: *mut libc::c_void,
    mut Id: CFE_ConfigId_t,
    mut Name: *const libc::c_char,
) {
    static mut IDNAME_PREFIX: [libc::c_char; 12] =
        unsafe { *::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"MOD_SRCVER_\0") };
    if strncmp(
        Name,
        IDNAME_PREFIX.as_ptr(),
        (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    ) == 0 as libc::c_int
    {
        CFE_ES_GenerateSingleVersionEvent(
            b"Module\0" as *const u8 as *const libc::c_char,
            &*Name.offset(
                (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
            ),
            Id,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenerateVersionEvents() {
    let mut Status: int32 = 0;
    Status = CFE_ES_GenerateSingleVersionEvent(
        b"Mission\0" as *const u8 as *const libc::c_char,
        GLOBAL_CONFIGDATA.MissionName,
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_MISSION_SRCVER as libc::c_int)
                as libc::c_ulong,
        ),
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error sending mission version event:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_ES_GenerateVersionEvents\0",
            ))
            .as_ptr(),
            Status as libc::c_uint,
        );
    }
    CFE_Config_IterateAll(
        0 as *mut libc::c_void,
        Some(
            CFE_ES_ModSrcVerCallback
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    CFE_ConfigId_t,
                    *const libc::c_char,
                ) -> (),
        ),
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_GenerateBuildInfoEvents() {
    let mut Status: int32 = 0;
    let mut BuildDate: *const libc::c_char = 0 as *const libc::c_char;
    let mut BuildUser: *const libc::c_char = 0 as *const libc::c_char;
    let mut BuildHost: *const libc::c_char = 0 as *const libc::c_char;
    BuildDate = CFE_Config_GetString(CFE_ResourceId_FromInteger(
        (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_CORE_BUILDINFO_DATE as libc::c_int)
            as libc::c_ulong,
    ));
    BuildUser = CFE_Config_GetString(CFE_ResourceId_FromInteger(
        (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_CORE_BUILDINFO_USER as libc::c_int)
            as libc::c_ulong,
    ));
    BuildHost = CFE_Config_GetString(CFE_ResourceId_FromInteger(
        (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_CORE_BUILDINFO_HOST as libc::c_int)
            as libc::c_ulong,
    ));
    Status = CFE_EVS_SendEvent(
        92 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Build %s by %s@%s, config %s\0" as *const u8 as *const libc::c_char,
        BuildDate,
        BuildUser,
        BuildHost,
        GLOBAL_CONFIGDATA.Config,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error sending build info event:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 31], &[libc::c_char; 31]>(
                b"CFE_ES_GenerateBuildInfoEvents\0",
            ))
            .as_ptr(),
            Status as libc::c_uint,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_TaskInit() -> int32 {
    let mut Status: int32 = 0;
    let mut PspStatus: int32 = 0;
    let mut SizeofCfeSegment: uint32 = 0;
    let mut CfeSegmentAddr: cpuaddr = 0;
    let mut VersionNumber: [uint8; 4] = [0; 4];
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_ES_Global.TaskData.CommandCounter = 0 as libc::c_int as uint8;
    CFE_ES_Global.TaskData.CommandErrorCounter = 0 as libc::c_int as uint8;
    if CFE_ES_GetResetType(0 as *mut uint32) == 2 as libc::c_int {
        (*CFE_ES_Global.ResetDataPtr).SystemLogMode = 0 as libc::c_int as uint32;
    } else {
        (*CFE_ES_Global.ResetDataPtr).SystemLogMode = 1 as libc::c_int as uint32;
    }
    Status = CFE_EVS_Register(
        0 as *const libc::c_void,
        0 as libc::c_int as uint16,
        CFE_EVS_EventFilter_BINARY as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_EVS_Register Failed, RC = 0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    CFE_MSG_Init(
        &mut CFE_ES_Global.TaskData.HkPacket.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 0 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_ES_HousekeepingTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_ES_Global.TaskData.OneAppPacket.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 11 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_ES_OneAppTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_ES_Global.TaskData.MemStatsPacket.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 16 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_ES_MemStatsTlm_t>() as libc::c_ulong,
    );
    Status = CFE_SB_CreatePipe(
        &mut CFE_ES_Global.TaskData.CmdPipe,
        12 as libc::c_int as uint16,
        b"ES_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Cannot Create SB Pipe, RC = 0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 8 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_ES_Global.TaskData.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Cannot Subscribe to HK packet, RC = 0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 6 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_ES_Global.TaskData.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Cannot Subscribe to ES ground commands, RC = 0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    PspStatus = CFE_PSP_GetCFETextSegmentInfo(&mut CfeSegmentAddr, &mut SizeofCfeSegment);
    if PspStatus == 0 as libc::c_int {
        CFE_ES_Global.TaskData.HkPacket.Payload.CFECoreChecksum = CFE_ES_CalculateCRC(
            CfeSegmentAddr as *mut libc::c_void,
            SizeofCfeSegment as size_t,
            0 as libc::c_int as uint32,
            CFE_ES_CrcType_16_ARC,
        ) as uint16;
    } else {
        CFE_ES_Global.TaskData.HkPacket.Payload.CFECoreChecksum = 0xffff as libc::c_int as uint16;
    }
    CFE_ES_Global.TaskData.HkPacket.Payload.CFEMajorVersion = 6 as libc::c_int as uint8;
    CFE_ES_Global.TaskData.HkPacket.Payload.CFEMinorVersion = 7 as libc::c_int as uint8;
    CFE_ES_Global.TaskData.HkPacket.Payload.CFERevision = 0 as libc::c_int as uint8;
    CFE_ES_Global.TaskData.HkPacket.Payload.CFEMissionRevision = 0xff as libc::c_int as uint8;
    OS_GetVersionNumber(VersionNumber.as_mut_ptr());
    CFE_ES_Global.TaskData.HkPacket.Payload.OSALMajorVersion =
        VersionNumber[0 as libc::c_int as usize];
    CFE_ES_Global.TaskData.HkPacket.Payload.OSALMinorVersion =
        VersionNumber[1 as libc::c_int as usize];
    CFE_ES_Global.TaskData.HkPacket.Payload.OSALRevision = VersionNumber[2 as libc::c_int as usize];
    CFE_ES_Global.TaskData.HkPacket.Payload.OSALMissionRevision =
        VersionNumber[3 as libc::c_int as usize];
    CFE_PSP_GetVersionNumber(VersionNumber.as_mut_ptr());
    CFE_ES_Global.TaskData.HkPacket.Payload.PSPMajorVersion =
        VersionNumber[0 as libc::c_int as usize];
    CFE_ES_Global.TaskData.HkPacket.Payload.PSPMinorVersion =
        VersionNumber[1 as libc::c_int as usize];
    CFE_ES_Global.TaskData.HkPacket.Payload.PSPRevision = VersionNumber[2 as libc::c_int as usize];
    CFE_ES_Global.TaskData.HkPacket.Payload.PSPMissionRevision =
        VersionNumber[3 as libc::c_int as usize];
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    Status = CFE_EVS_SendEvent(
        1 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"cFE ES Initialized: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error sending init event:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_EVS_SendEvent(
        2 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"cFS Versions: cfe %s, osal %s, psp %s. cFE chksm %d\0" as *const u8
            as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        OS_GetVersionString(),
        CFE_PSP_GetVersionString(),
        CFE_ES_Global.TaskData.HkPacket.Payload.CFECoreChecksum as libc::c_int,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error sending init stats event:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    CFE_ES_GenerateVersionEvents();
    CFE_ES_GenerateBuildInfoEvents();
    Status = CFE_ES_BackgroundInit();
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error initializing background task:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_ES_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_HousekeepingCmd(mut data: *const CFE_ES_SendHkCmd_t) -> int32 {
    let mut HeapProp: OS_heap_prop_t = OS_heap_prop_t {
        free_bytes: 0,
        free_blocks: 0,
        largest_free_block: 0,
    };
    let mut OsStatus: int32 = 0;
    let mut PerfIdx: uint32 = 0;
    memset(
        &mut HeapProp as *mut OS_heap_prop_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_heap_prop_t>() as libc::c_ulong,
    );
    CFE_ES_Global.TaskData.HkPacket.Payload.CommandCounter = CFE_ES_Global.TaskData.CommandCounter;
    CFE_ES_Global.TaskData.HkPacket.Payload.CommandErrorCounter =
        CFE_ES_Global.TaskData.CommandErrorCounter;
    CFE_ES_Global.TaskData.HkPacket.Payload.SysLogBytesUsed =
        (*CFE_ES_Global.ResetDataPtr).SystemLogEndIdx as CFE_ES_MemOffset_t;
    CFE_ES_Global.TaskData.HkPacket.Payload.SysLogSize = 3072 as libc::c_int as CFE_ES_MemOffset_t;
    CFE_ES_Global.TaskData.HkPacket.Payload.SysLogEntries =
        (*CFE_ES_Global.ResetDataPtr).SystemLogEntryNum;
    CFE_ES_Global.TaskData.HkPacket.Payload.SysLogMode =
        (*CFE_ES_Global.ResetDataPtr).SystemLogMode;
    CFE_ES_Global.TaskData.HkPacket.Payload.ERLogIndex = (*CFE_ES_Global.ResetDataPtr).ERLogIndex;
    CFE_ES_Global.TaskData.HkPacket.Payload.ERLogEntries =
        (*CFE_ES_Global.ResetDataPtr).ERLogEntries;
    CFE_ES_Global.TaskData.HkPacket.Payload.RegisteredCoreApps = CFE_ES_Global.RegisteredCoreApps;
    CFE_ES_Global
        .TaskData
        .HkPacket
        .Payload
        .RegisteredExternalApps = CFE_ES_Global.RegisteredExternalApps;
    CFE_ES_Global.TaskData.HkPacket.Payload.RegisteredTasks = CFE_ES_Global.RegisteredTasks;
    CFE_ES_Global.TaskData.HkPacket.Payload.RegisteredLibs = CFE_ES_Global.RegisteredLibs;
    CFE_ES_Global.TaskData.HkPacket.Payload.ResetType =
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetType;
    CFE_ES_Global.TaskData.HkPacket.Payload.ResetSubtype =
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ResetSubtype;
    CFE_ES_Global.TaskData.HkPacket.Payload.ProcessorResets =
        (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount;
    CFE_ES_Global.TaskData.HkPacket.Payload.MaxProcessorResets = (*CFE_ES_Global.ResetDataPtr)
        .ResetVars
        .MaxProcessorResetCount;
    CFE_ES_Global.TaskData.HkPacket.Payload.BootSource =
        (*CFE_ES_Global.ResetDataPtr).ResetVars.BootSource;
    CFE_ES_Global.TaskData.HkPacket.Payload.PerfState =
        (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.State;
    CFE_ES_Global.TaskData.HkPacket.Payload.PerfMode =
        (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.Mode;
    CFE_ES_Global.TaskData.HkPacket.Payload.PerfTriggerCount =
        (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.TriggerCount;
    CFE_ES_Global.TaskData.HkPacket.Payload.PerfDataStart =
        (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.DataStart;
    CFE_ES_Global.TaskData.HkPacket.Payload.PerfDataEnd =
        (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.DataEnd;
    CFE_ES_Global.TaskData.HkPacket.Payload.PerfDataCount =
        (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.DataCount;
    CFE_ES_Global.TaskData.HkPacket.Payload.PerfDataToWrite = CFE_ES_GetPerfLogDumpRemaining();
    PerfIdx = 0 as libc::c_int as uint32;
    while (PerfIdx as libc::c_ulong)
        < (::core::mem::size_of::<[uint32; 4]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<uint32>() as libc::c_ulong)
    {
        if (PerfIdx as libc::c_ulong)
            < (::core::mem::size_of::<[uint32; 4]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<uint32>() as libc::c_ulong)
        {
            CFE_ES_Global.TaskData.HkPacket.Payload.PerfTriggerMask[PerfIdx as usize] =
                (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.TriggerMask[PerfIdx as usize];
        } else {
            CFE_ES_Global.TaskData.HkPacket.Payload.PerfTriggerMask[PerfIdx as usize] =
                0 as libc::c_int as uint32;
        }
        PerfIdx = PerfIdx.wrapping_add(1);
        PerfIdx;
    }
    PerfIdx = 0 as libc::c_int as uint32;
    while (PerfIdx as libc::c_ulong)
        < (::core::mem::size_of::<[uint32; 4]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<uint32>() as libc::c_ulong)
    {
        if (PerfIdx as libc::c_ulong)
            < (::core::mem::size_of::<[uint32; 4]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<uint32>() as libc::c_ulong)
        {
            CFE_ES_Global.TaskData.HkPacket.Payload.PerfFilterMask[PerfIdx as usize] =
                (*CFE_ES_Global.ResetDataPtr).Perf.MetaData.FilterMask[PerfIdx as usize];
        } else {
            CFE_ES_Global.TaskData.HkPacket.Payload.PerfFilterMask[PerfIdx as usize] =
                0 as libc::c_int as uint32;
        }
        PerfIdx = PerfIdx.wrapping_add(1);
        PerfIdx;
    }
    OsStatus = OS_HeapGetInfo(&mut HeapProp);
    if OsStatus == 0 as libc::c_int {
        CFE_ES_Global.TaskData.HkPacket.Payload.HeapBytesFree =
            HeapProp.free_bytes as CFE_ES_MemOffset_t;
        CFE_ES_Global.TaskData.HkPacket.Payload.HeapBlocksFree =
            HeapProp.free_blocks as CFE_ES_MemOffset_t;
        CFE_ES_Global.TaskData.HkPacket.Payload.HeapMaxBlockSize =
            HeapProp.largest_free_block as CFE_ES_MemOffset_t;
    } else {
        CFE_ES_Global.TaskData.HkPacket.Payload.HeapBytesFree =
            0 as libc::c_int as CFE_ES_MemOffset_t;
        CFE_ES_Global.TaskData.HkPacket.Payload.HeapBlocksFree =
            0 as libc::c_int as CFE_ES_MemOffset_t;
        CFE_ES_Global.TaskData.HkPacket.Payload.HeapMaxBlockSize =
            0 as libc::c_int as CFE_ES_MemOffset_t;
    }
    CFE_SB_TimeStampMsg(&mut CFE_ES_Global.TaskData.HkPacket.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut CFE_ES_Global.TaskData.HkPacket.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_NoopCmd(mut Cmd: *const CFE_ES_NoopCmd_t) -> int32 {
    CFE_ES_GenerateBuildInfoEvents();
    CFE_ES_Global.TaskData.CommandCounter = (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
    CFE_ES_Global.TaskData.CommandCounter;
    CFE_EVS_SendEvent(
        3 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"No-op command:\n cFS Versions: cfe %s, osal %s, psp %s\0" as *const u8
            as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        OS_GetVersionString(),
        CFE_PSP_GetVersionString(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ResetCountersCmd(
    mut data: *const CFE_ES_ResetCountersCmd_t,
) -> int32 {
    CFE_ES_Global.TaskData.CommandCounter = 0 as libc::c_int as uint8;
    CFE_ES_Global.TaskData.CommandErrorCounter = 0 as libc::c_int as uint8;
    CFE_EVS_SendEvent(
        4 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Reset Counters command\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RestartCmd(mut data: *const CFE_ES_RestartCmd_t) -> int32 {
    let mut cmd: *const CFE_ES_RestartCmd_Payload_t = &(*data).Payload;
    if (*cmd).RestartType as libc::c_int != 1 as libc::c_int
        && (*cmd).RestartType as libc::c_int != 2 as libc::c_int
    {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            24 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid cFE restart type: %d\0" as *const u8 as *const libc::c_char,
            (*cmd).RestartType as libc::c_int,
        );
    } else {
        CFE_ES_ResetCFE((*cmd).RestartType as uint32);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_StartAppCmd(mut data: *const CFE_ES_StartAppCmd_t) -> int32 {
    let mut cmd: *const CFE_ES_StartAppCmd_Payload_t = &(*data).Payload;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut Result: int32 = 0;
    let mut AppEntryLen: int32 = 0;
    let mut AppNameLen: int32 = 0;
    let mut LocalAppName: [libc::c_char; 20] = [0; 20];
    let mut StartParams: CFE_ES_AppStartParams_t = CFE_ES_AppStartParams_t {
        BasicInfo: CFE_ES_ModuleLoadParams_t {
            InitSymbolName: [0; 20],
            FileName: [0; 64],
        },
        MainTaskInfo: CFE_ES_TaskStartParams_t {
            StackSize: 0,
            Priority: 0,
        },
        ExceptionAction: 0,
    };
    Result = CFE_FS_ParseInputFileNameEx(
        (StartParams.BasicInfo.FileName).as_mut_ptr(),
        ((*cmd).AppFileName).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        0 as *const libc::c_char,
        CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_DYNAMIC_MODULE),
        CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_DYNAMIC_MODULE),
    );
    AppEntryLen = CFE_SB_MessageStringGet(
        (StartParams.BasicInfo.InitSymbolName).as_mut_ptr(),
        ((*cmd).AppEntryPoint).as_ptr(),
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    AppNameLen = CFE_SB_MessageStringGet(
        LocalAppName.as_mut_ptr(),
        ((*cmd).Application).as_ptr(),
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    if Result != 0 as libc::c_int {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            27 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CFE_ES_StartAppCmd: invalid filename, status=%lx\0" as *const u8
                as *const libc::c_char,
            Result as libc::c_ulong,
        );
    } else if AppEntryLen <= 0 as libc::c_int {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            28 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CFE_ES_StartAppCmd: App Entry Point is empty.\0" as *const u8 as *const libc::c_char,
        );
    } else if AppNameLen <= 0 as libc::c_int {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            29 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CFE_ES_StartAppCmd: App Name is empty.\0" as *const u8 as *const libc::c_char,
        );
    } else if (*cmd).Priority as libc::c_int > 255 as libc::c_int {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            31 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CFE_ES_StartAppCmd: Priority is too large: %d.\0" as *const u8 as *const libc::c_char,
            (*cmd).Priority as libc::c_int,
        );
    } else if (*cmd).ExceptionAction as libc::c_int
        != CFE_ES_ExceptionAction_RESTART_APP as libc::c_int
        && (*cmd).ExceptionAction as libc::c_int
            != CFE_ES_ExceptionAction_PROC_RESTART as libc::c_int
    {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            32 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CFE_ES_StartAppCmd: Invalid Exception Action: %d.\0" as *const u8
                as *const libc::c_char,
            (*cmd).ExceptionAction as libc::c_int,
        );
    } else {
        StartParams.MainTaskInfo.StackSize = (*cmd).StackSize as size_t;
        if StartParams.MainTaskInfo.StackSize == 0 as libc::c_int as libc::c_ulong {
            StartParams.MainTaskInfo.StackSize = 8192 as libc::c_int as size_t;
        }
        StartParams.MainTaskInfo.Priority = (*cmd).Priority;
        StartParams.ExceptionAction = (*cmd).ExceptionAction;
        Result = CFE_ES_AppCreate(&mut AppID, LocalAppName.as_mut_ptr(), &mut StartParams);
        if Result == 0 as libc::c_int {
            CFE_ES_Global.TaskData.CommandCounter =
                (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandCounter;
            CFE_EVS_SendEvent(
                6 as libc::c_int as uint16,
                CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                b"Started %s from %s, AppID = %lu\0" as *const u8 as *const libc::c_char,
                LocalAppName.as_mut_ptr(),
                (StartParams.BasicInfo.FileName).as_mut_ptr(),
                CFE_ResourceId_ToInteger(AppID),
            );
        } else {
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                26 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Failed to start %s from %s, RC = 0x%08X\0" as *const u8 as *const libc::c_char,
                LocalAppName.as_mut_ptr(),
                (StartParams.BasicInfo.FileName).as_mut_ptr(),
                Result as libc::c_uint,
            );
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_StopAppCmd(mut data: *const CFE_ES_StopAppCmd_t) -> int32 {
    let mut cmd: *const CFE_ES_AppNameCmd_Payload_t = &(*data).Payload;
    let mut LocalApp: [libc::c_char; 20] = [0; 20];
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut Result: int32 = 0;
    CFE_SB_MessageStringGet(
        LocalApp.as_mut_ptr(),
        ((*cmd).Application).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Result = CFE_ES_GetAppIDByName(&mut AppID, LocalApp.as_mut_ptr());
    if Result == 0 as libc::c_int {
        Result = CFE_ES_DeleteApp(AppID);
        if Result == 0 as libc::c_int {
            CFE_ES_Global.TaskData.CommandCounter =
                (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandCounter;
            CFE_EVS_SendEvent(
                7 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Stop Application %s Initiated.\0" as *const u8 as *const libc::c_char,
                LocalApp.as_mut_ptr(),
            );
        } else {
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                35 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Stop Application %s Failed, RC = 0x%08X\0" as *const u8 as *const libc::c_char,
                LocalApp.as_mut_ptr(),
                Result as libc::c_uint,
            );
        }
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            36 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Stop Application %s, GetAppIDByName failed. RC = 0x%08X.\0" as *const u8
                as *const libc::c_char,
            LocalApp.as_mut_ptr(),
            Result as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_RestartAppCmd(mut data: *const CFE_ES_RestartAppCmd_t) -> int32 {
    let mut cmd: *const CFE_ES_AppNameCmd_Payload_t = &(*data).Payload;
    let mut LocalApp: [libc::c_char; 20] = [0; 20];
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut Result: int32 = 0;
    CFE_SB_MessageStringGet(
        LocalApp.as_mut_ptr(),
        ((*cmd).Application).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Result = CFE_ES_GetAppIDByName(&mut AppID, LocalApp.as_mut_ptr());
    if Result == 0 as libc::c_int {
        Result = CFE_ES_RestartApp(AppID);
        if Result == 0 as libc::c_int {
            CFE_ES_Global.TaskData.CommandCounter =
                (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandCounter;
            CFE_EVS_SendEvent(
                9 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Restart Application %s Initiated.\0" as *const u8 as *const libc::c_char,
                LocalApp.as_mut_ptr(),
            );
        } else {
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                38 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Restart Application %s Failed, RC = 0x%08X\0" as *const u8 as *const libc::c_char,
                LocalApp.as_mut_ptr(),
                Result as libc::c_uint,
            );
        }
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            39 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Restart Application %s, GetAppIDByName failed. RC = 0x%08X.\0" as *const u8
                as *const libc::c_char,
            LocalApp.as_mut_ptr(),
            Result as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ReloadAppCmd(mut data: *const CFE_ES_ReloadAppCmd_t) -> int32 {
    let mut cmd: *const CFE_ES_AppReloadCmd_Payload_t = &(*data).Payload;
    let mut LocalApp: [libc::c_char; 20] = [0; 20];
    let mut LocalFileName: [libc::c_char; 64] = [0; 64];
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut Result: int32 = 0;
    CFE_SB_MessageStringGet(
        LocalApp.as_mut_ptr(),
        ((*cmd).Application).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Result = CFE_ES_GetAppIDByName(&mut AppID, LocalApp.as_mut_ptr());
    if Result == 0 as libc::c_int {
        Result = CFE_FS_ParseInputFileNameEx(
            LocalFileName.as_mut_ptr(),
            ((*cmd).AppFileName).as_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            0 as *const libc::c_char,
            CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_DYNAMIC_MODULE),
            CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_DYNAMIC_MODULE),
        );
        if Result == 0 as libc::c_int {
            Result = CFE_ES_ReloadApp(AppID, LocalFileName.as_mut_ptr());
        }
        if Result == 0 as libc::c_int {
            CFE_ES_Global.TaskData.CommandCounter =
                (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandCounter;
            CFE_EVS_SendEvent(
                11 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Reload Application %s Initiated.\0" as *const u8 as *const libc::c_char,
                LocalApp.as_mut_ptr(),
            );
        } else {
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                42 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Reload Application %s Failed, RC = 0x%08X\0" as *const u8 as *const libc::c_char,
                LocalApp.as_mut_ptr(),
                Result as libc::c_uint,
            );
        }
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            43 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Reload Application %s, GetAppIDByName failed. RC = 0x%08X.\0" as *const u8
                as *const libc::c_char,
            LocalApp.as_mut_ptr(),
            Result as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_QueryOneCmd(mut data: *const CFE_ES_QueryOneCmd_t) -> int32 {
    let mut cmd: *const CFE_ES_AppNameCmd_Payload_t = &(*data).Payload;
    let mut LocalApp: [libc::c_char; 20] = [0; 20];
    let mut IdBuf: C2RustUnnamed_24 = C2RustUnnamed_24 { AppId: 0 };
    let mut Result: int32 = 0;
    CFE_SB_MessageStringGet(
        LocalApp.as_mut_ptr(),
        ((*cmd).Application).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Result = CFE_ES_GetAppIDByName(&mut IdBuf.AppId, LocalApp.as_mut_ptr());
    if Result == 0xc4000002 as libc::c_uint as CFE_Status_t {
        Result = CFE_ES_GetLibIDByName(&mut IdBuf.LibId, LocalApp.as_mut_ptr());
    }
    if Result == 0 as libc::c_int {
        Result = CFE_ES_GetModuleInfo(
            &mut CFE_ES_Global.TaskData.OneAppPacket.Payload.AppInfo,
            IdBuf.ResourceID,
        );
    }
    if Result == 0 as libc::c_int {
        CFE_SB_TimeStampMsg(&mut CFE_ES_Global.TaskData.OneAppPacket.TelemetryHeader.Msg);
        Result = CFE_SB_TransmitMsg(
            &mut CFE_ES_Global.TaskData.OneAppPacket.TelemetryHeader.Msg,
            1 as libc::c_int != 0,
        );
        if Result == 0 as libc::c_int {
            CFE_ES_Global.TaskData.CommandCounter =
                (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandCounter;
            CFE_EVS_SendEvent(
                15 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Sent %s application data\0" as *const u8 as *const libc::c_char,
                LocalApp.as_mut_ptr(),
            );
        } else {
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                49 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Failed to send %s application data, RC = 0x%08X\0" as *const u8
                    as *const libc::c_char,
                LocalApp.as_mut_ptr(),
                Result as libc::c_uint,
            );
        }
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            50 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Failed to send %s application data: GetAppIDByName Failed, RC = 0x%08X\0" as *const u8
                as *const libc::c_char,
            LocalApp.as_mut_ptr(),
            Result as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_QueryAllCmd(mut data: *const CFE_ES_QueryAllCmd_t) -> int32 {
    let mut FileHeader: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut FileDescriptor: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut i: uint32 = 0;
    let mut EntryCount: uint32 = 0 as libc::c_int as uint32;
    let mut FileSize: uint32 = 0 as libc::c_int as uint32;
    let mut OsStatus: int32 = 0;
    let mut Result: int32 = 0;
    let mut AppInfo: CFE_ES_AppInfo_t = CFE_ES_AppInfo_t {
        ResourceId: 0,
        Type: 0,
        Name: [0; 20],
        EntryPoint: [0; 20],
        FileName: [0; 64],
        StackSize: 0,
        AddressesAreValid: 0,
        CodeAddress: 0,
        CodeSize: 0,
        DataAddress: 0,
        DataSize: 0,
        BSSAddress: 0,
        BSSSize: 0,
        StartAddress: 0,
        ExceptionAction: 0,
        Priority: 0,
        MainTaskId: 0,
        ExecutionCounter: 0,
        MainTaskName: [0; 20],
        NumOfChildTasks: 0,
    };
    let mut CmdPtr: *const CFE_ES_FileNameCmd_Payload_t = &(*data).Payload;
    let mut QueryAllFilename: [libc::c_char; 64] = [0; 64];
    let mut ResourceList: [CFE_ResourceId_t; 42] = [0; 42];
    let mut NumResources: uint32 = 0;
    let mut AppRecPtr: *mut CFE_ES_AppRecord_t = 0 as *mut CFE_ES_AppRecord_t;
    let mut LibRecPtr: *mut CFE_ES_LibRecord_t = 0 as *mut CFE_ES_LibRecord_t;
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_QueryAllCmd\0"))
            .as_ptr(),
        974 as libc::c_int,
    );
    NumResources = 0 as libc::c_int as uint32;
    AppRecPtr = (CFE_ES_Global.AppTable).as_mut_ptr();
    i = 0 as libc::c_int as uint32;
    while i < 32 as libc::c_int as libc::c_uint
        && NumResources < (32 as libc::c_int + 10 as libc::c_int) as libc::c_uint
    {
        if CFE_ES_AppRecordIsUsed(AppRecPtr) {
            ResourceList[NumResources as usize] = CFE_ES_AppRecordGetID(AppRecPtr);
            NumResources = NumResources.wrapping_add(1);
            NumResources;
        }
        AppRecPtr = AppRecPtr.offset(1);
        AppRecPtr;
        i = i.wrapping_add(1);
        i;
    }
    LibRecPtr = (CFE_ES_Global.LibTable).as_mut_ptr();
    i = 0 as libc::c_int as uint32;
    while i < 10 as libc::c_int as libc::c_uint
        && NumResources < (32 as libc::c_int + 10 as libc::c_int) as libc::c_uint
    {
        if CFE_ES_LibRecordIsUsed(LibRecPtr) {
            ResourceList[NumResources as usize] = CFE_ES_LibRecordGetID(LibRecPtr);
            NumResources = NumResources.wrapping_add(1);
            NumResources;
        }
        LibRecPtr = LibRecPtr.offset(1);
        LibRecPtr;
        i = i.wrapping_add(1);
        i;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_ES_QueryAllCmd\0"))
            .as_ptr(),
        996 as libc::c_int,
    );
    Result = CFE_FS_ParseInputFileNameEx(
        QueryAllFilename.as_mut_ptr(),
        ((*CmdPtr).FileName).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"/ram/cfe_es_app_info.log\0" as *const u8 as *const libc::c_char,
        CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
    );
    if Result == 0 as libc::c_int {
        OsStatus = OS_OpenCreate(
            &mut FileDescriptor,
            QueryAllFilename.as_mut_ptr(),
            OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
            1 as libc::c_int,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                51 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Failed to write App Info file, OS_OpenCreate RC = %ld\0" as *const u8
                    as *const libc::c_char,
                OsStatus as libc::c_long,
            );
            Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    } else {
        CFE_EVS_SendEvent(
            51 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Failed to write App Info file, CFE_FS_ParseInputFileNameEx RC = %08x\0" as *const u8
                as *const libc::c_char,
            Result as libc::c_uint,
        );
    }
    if Result >= 0 as libc::c_int {
        CFE_FS_InitHeader(
            &mut FileHeader,
            b"ES Application Info file\0" as *const u8 as *const libc::c_char,
            CFE_FS_SubType_ES_QUERYALL as libc::c_int as uint32,
        );
        Result = CFE_FS_WriteHeader(FileDescriptor, &mut FileHeader);
        if Result as libc::c_ulong != ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong {
            OS_close(FileDescriptor);
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                52 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Failed to write App Info file, WriteHdr RC = 0x%08X, exp %d\0" as *const u8
                    as *const libc::c_char,
                Result as libc::c_uint,
                ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong as libc::c_int,
            );
            return 0 as libc::c_int;
        }
        FileSize = (FileSize as libc::c_ulong)
            .wrapping_add(::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong)
            as uint32 as uint32;
        i = 0 as libc::c_int as uint32;
        while i < NumResources {
            Result = CFE_ES_GetModuleInfo(&mut AppInfo, ResourceList[i as usize]);
            if Result == 0 as libc::c_int {
                OsStatus = OS_write(
                    FileDescriptor,
                    &mut AppInfo as *mut CFE_ES_AppInfo_t as *const libc::c_void,
                    ::core::mem::size_of::<CFE_ES_AppInfo_t>() as libc::c_ulong,
                );
                if OsStatus as libc::c_ulong
                    != ::core::mem::size_of::<CFE_ES_AppInfo_t>() as libc::c_ulong
                {
                    OS_close(FileDescriptor);
                    CFE_ES_Global.TaskData.CommandErrorCounter =
                        (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
                    CFE_ES_Global.TaskData.CommandErrorCounter;
                    CFE_EVS_SendEvent(
                        53 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Failed to write App Info file, Task write RC = %ld, exp %d\0" as *const u8
                            as *const libc::c_char,
                        OsStatus as libc::c_long,
                        ::core::mem::size_of::<CFE_ES_AppInfo_t>() as libc::c_ulong as libc::c_int,
                    );
                    return 0 as libc::c_int;
                }
                FileSize = (FileSize as libc::c_ulong)
                    .wrapping_add(::core::mem::size_of::<CFE_ES_AppInfo_t>() as libc::c_ulong)
                    as uint32 as uint32;
                EntryCount = EntryCount.wrapping_add(1);
                EntryCount;
            }
            i = i.wrapping_add(1);
            i;
        }
        OS_close(FileDescriptor);
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
        CFE_EVS_SendEvent(
            16 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"App Info file written to %s, Entries=%d, FileSize=%d\0" as *const u8
                as *const libc::c_char,
            QueryAllFilename.as_mut_ptr(),
            EntryCount as libc::c_int,
            FileSize as libc::c_int,
        );
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_QueryAllTasksCmd(
    mut data: *const CFE_ES_QueryAllTasksCmd_t,
) -> int32 {
    let mut FileHeader: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut FileDescriptor: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut i: uint32 = 0;
    let mut EntryCount: uint32 = 0 as libc::c_int as uint32;
    let mut FileSize: uint32 = 0 as libc::c_int as uint32;
    let mut OsStatus: int32 = 0;
    let mut Result: int32 = 0;
    let mut TaskInfo: CFE_ES_TaskInfo_t = CFE_ES_TaskInfo_t {
        TaskId: 0,
        ExecutionCounter: 0,
        TaskName: [0; 20],
        AppId: 0,
        AppName: [0; 20],
        StackSize: 0,
        Priority: 0,
        Spare: [0; 2],
    };
    let mut CmdPtr: *const CFE_ES_FileNameCmd_Payload_t = &(*data).Payload;
    let mut QueryAllFilename: [libc::c_char; 64] = [0; 64];
    let mut TaskList: [CFE_ES_TaskId_t; 64] = [0; 64];
    let mut NumTasks: uint32 = 0;
    let mut TaskRecPtr: *mut CFE_ES_TaskRecord_t = 0 as *mut CFE_ES_TaskRecord_t;
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"CFE_ES_QueryAllTasksCmd\0"))
            .as_ptr(),
        1133 as libc::c_int,
    );
    NumTasks = 0 as libc::c_int as uint32;
    TaskRecPtr = (CFE_ES_Global.TaskTable).as_mut_ptr();
    i = 0 as libc::c_int as uint32;
    while i < 64 as libc::c_int as libc::c_uint {
        if CFE_ES_TaskRecordIsUsed(TaskRecPtr) {
            TaskList[NumTasks as usize] = CFE_ES_TaskRecordGetID(TaskRecPtr);
            NumTasks = NumTasks.wrapping_add(1);
            NumTasks;
        }
        TaskRecPtr = TaskRecPtr.offset(1);
        TaskRecPtr;
        i = i.wrapping_add(1);
        i;
    }
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(b"CFE_ES_QueryAllTasksCmd\0"))
            .as_ptr(),
        1145 as libc::c_int,
    );
    Result = CFE_FS_ParseInputFileNameEx(
        QueryAllFilename.as_mut_ptr(),
        ((*CmdPtr).FileName).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"/ram/cfe_es_taskinfo.log\0" as *const u8 as *const libc::c_char,
        CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
    );
    if Result == 0 as libc::c_int {
        OsStatus = OS_OpenCreate(
            &mut FileDescriptor,
            QueryAllFilename.as_mut_ptr(),
            OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
            1 as libc::c_int,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                88 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Failed to write Task Info file, OS_OpenCreate RC = %ld\0" as *const u8
                    as *const libc::c_char,
                OsStatus as libc::c_long,
            );
            Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    } else {
        CFE_EVS_SendEvent(
            88 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Failed to write Task Info file, CFE_FS_ParseInputFileNameEx RC = %08x\0" as *const u8
                as *const libc::c_char,
            Result as libc::c_uint,
        );
    }
    if Result >= 0 as libc::c_int {
        CFE_FS_InitHeader(
            &mut FileHeader,
            b"ES Task Info file\0" as *const u8 as *const libc::c_char,
            CFE_FS_SubType_ES_QUERYALLTASKS as libc::c_int as uint32,
        );
        Result = CFE_FS_WriteHeader(FileDescriptor, &mut FileHeader);
        if Result as libc::c_ulong != ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong {
            OS_close(FileDescriptor);
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
            CFE_EVS_SendEvent(
                89 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Failed to write Task Info file, WriteHdr RC = 0x%08X, exp %d\0" as *const u8
                    as *const libc::c_char,
                Result as libc::c_uint,
                ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong as libc::c_int,
            );
            return 0 as libc::c_int;
        }
        FileSize = (FileSize as libc::c_ulong)
            .wrapping_add(::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong)
            as uint32 as uint32;
        i = 0 as libc::c_int as uint32;
        while i < NumTasks {
            Result = CFE_ES_GetTaskInfo(&mut TaskInfo, TaskList[i as usize]);
            if Result == 0 as libc::c_int {
                OsStatus = OS_write(
                    FileDescriptor,
                    &mut TaskInfo as *mut CFE_ES_TaskInfo_t as *const libc::c_void,
                    ::core::mem::size_of::<CFE_ES_TaskInfo_t>() as libc::c_ulong,
                );
                if OsStatus as libc::c_ulong
                    != ::core::mem::size_of::<CFE_ES_TaskInfo_t>() as libc::c_ulong
                {
                    OS_close(FileDescriptor);
                    CFE_ES_Global.TaskData.CommandErrorCounter =
                        (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
                    CFE_ES_Global.TaskData.CommandErrorCounter;
                    CFE_EVS_SendEvent(
                        90 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Failed to write Task Info file, Task write RC = %ld, exp %d\0"
                            as *const u8 as *const libc::c_char,
                        OsStatus as libc::c_long,
                        ::core::mem::size_of::<CFE_ES_TaskInfo_t>() as libc::c_ulong as libc::c_int,
                    );
                    return 0 as libc::c_int;
                }
                FileSize = (FileSize as libc::c_ulong)
                    .wrapping_add(::core::mem::size_of::<CFE_ES_TaskInfo_t>() as libc::c_ulong)
                    as uint32 as uint32;
                EntryCount = EntryCount.wrapping_add(1);
                EntryCount;
            }
            i = i.wrapping_add(1);
            i;
        }
        OS_close(FileDescriptor);
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
        CFE_EVS_SendEvent(
            87 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Task Info file written to %s, Entries=%d, FileSize=%d\0" as *const u8
                as *const libc::c_char,
            QueryAllFilename.as_mut_ptr(),
            EntryCount as libc::c_int,
            FileSize as libc::c_int,
        );
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ClearSysLogCmd(mut data: *const CFE_ES_ClearSysLogCmd_t) -> int32 {
    CFE_ES_LockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_ClearSysLogCmd\0"))
            .as_ptr(),
        1269 as libc::c_int,
    );
    CFE_ES_SysLogClear_Unsync();
    CFE_ES_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_ES_ClearSysLogCmd\0"))
            .as_ptr(),
        1271 as libc::c_int,
    );
    CFE_ES_Global.TaskData.CommandCounter = (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
    CFE_ES_Global.TaskData.CommandCounter;
    CFE_EVS_SendEvent(
        17 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Cleared Executive Services log data\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_OverWriteSysLogCmd(
    mut data: *const CFE_ES_OverWriteSysLogCmd_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut CmdPtr: *const CFE_ES_OverWriteSysLogCmd_Payload_t = &(*data).Payload;
    Status = CFE_ES_SysLogSetMode((*CmdPtr).Mode as CFE_ES_LogMode_Enum_t);
    if Status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            71 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Set OverWriteSysLog Command: Invalid Mode setting = %d\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).Mode as libc::c_int,
        );
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    } else {
        CFE_EVS_SendEvent(
            70 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Set OverWriteSysLog Command Received with Mode setting = %d\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).Mode as libc::c_int,
        );
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_WriteSysLogCmd(mut data: *const CFE_ES_WriteSysLogCmd_t) -> int32 {
    let mut CmdPtr: *const CFE_ES_FileNameCmd_Payload_t = &(*data).Payload;
    let mut Stat: int32 = 0;
    let mut LogFilename: [libc::c_char; 64] = [0; 64];
    Stat = CFE_FS_ParseInputFileNameEx(
        LogFilename.as_mut_ptr(),
        ((*CmdPtr).FileName).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"/ram/cfe_es_syslog.log\0" as *const u8 as *const libc::c_char,
        CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
    );
    if Stat != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            55 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Error parsing file name RC = 0x%08X\0" as *const u8 as *const libc::c_char,
            Stat as libc::c_uint,
        );
    } else {
        Stat = CFE_ES_SysLogDump(LogFilename.as_mut_ptr());
    }
    if Stat == 0 as libc::c_int {
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ClearERLogCmd(mut data: *const CFE_ES_ClearERLogCmd_t) -> int32 {
    memset(
        ((*CFE_ES_Global.ResetDataPtr).ERLog).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[CFE_ES_ERLog_MetaData_t; 20]>() as libc::c_ulong,
    );
    (*CFE_ES_Global.ResetDataPtr).ERLogIndex = 0 as libc::c_int as uint32;
    (*CFE_ES_Global.ResetDataPtr).ERLogEntries = 0 as libc::c_int as uint32;
    CFE_ES_Global.TaskData.CommandCounter = (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
    CFE_ES_Global.TaskData.CommandCounter;
    CFE_EVS_SendEvent(
        19 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Cleared ES Exception and Reset Log data\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_WriteERLogCmd(mut data: *const CFE_ES_WriteERLogCmd_t) -> int32 {
    let mut CmdPtr: *const CFE_ES_FileNameCmd_Payload_t = &(*data).Payload;
    let mut StatePtr: *mut CFE_ES_BackgroundLogDumpGlobal_t =
        0 as *mut CFE_ES_BackgroundLogDumpGlobal_t;
    let mut Status: int32 = 0;
    StatePtr = &mut CFE_ES_Global.BackgroundERLogDumpState;
    if CFE_FS_BackgroundFileDumpIsPending(&mut (*StatePtr).FileWrite) {
        Status = 0xc8000006 as libc::c_uint as int32;
    } else {
        memset(
            StatePtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_ES_BackgroundLogDumpGlobal_t>() as libc::c_ulong,
        );
        (*StatePtr).FileWrite.FileSubType = CFE_FS_SubType_ES_ERLOG as libc::c_int as uint32;
        snprintf(
            ((*StatePtr).FileWrite.Description).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            b"ES ERlog data file\0" as *const u8 as *const libc::c_char,
        );
        (*StatePtr).FileWrite.GetData = Some(
            CFE_ES_BackgroundERLogFileDataGetter
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    uint32,
                    *mut *mut libc::c_void,
                    *mut size_t,
                ) -> bool,
        );
        (*StatePtr).FileWrite.OnEvent = Some(
            CFE_ES_BackgroundERLogFileEventHandler
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    CFE_FS_FileWriteEvent_t,
                    int32,
                    uint32,
                    size_t,
                    size_t,
                ) -> (),
        );
        Status = CFE_FS_ParseInputFileNameEx(
            ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
            ((*CmdPtr).FileName).as_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"/ram/cfe_erlog.log\0" as *const u8 as *const libc::c_char,
            CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
            CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        );
        if Status == 0 as libc::c_int {
            Status = CFE_FS_BackgroundFileDumpRequest(&mut (*StatePtr).FileWrite);
        }
    }
    if Status != 0 as libc::c_int {
        if Status == 0xc8000006 as libc::c_uint as int32 {
            CFE_EVS_SendEvent(
                93 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error log write already in progress\0" as *const u8 as *const libc::c_char,
            );
        } else {
            CFE_EVS_SendEvent(
                56 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error creating file, RC = %d\0" as *const u8 as *const libc::c_char,
                Status,
            );
        }
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    } else {
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_ResetPRCountCmd(
    mut data: *const CFE_ES_ResetPRCountCmd_t,
) -> int32 {
    (*CFE_ES_Global.ResetDataPtr).ResetVars.ProcessorResetCount = 0 as libc::c_int as uint32;
    CFE_EVS_SendEvent(
        72 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Set Processor Reset Count to Zero\0" as *const u8 as *const libc::c_char,
    );
    CFE_ES_Global.TaskData.CommandCounter = (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
    CFE_ES_Global.TaskData.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SetMaxPRCountCmd(
    mut data: *const CFE_ES_SetMaxPRCountCmd_t,
) -> int32 {
    let mut cmd: *const CFE_ES_SetMaxPRCountCmd_Payload_t = &(*data).Payload;
    (*CFE_ES_Global.ResetDataPtr)
        .ResetVars
        .MaxProcessorResetCount = (*cmd).MaxPRCount as uint32;
    CFE_EVS_SendEvent(
        73 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Maximum Processor Reset Count set to: %d\0" as *const u8 as *const libc::c_char,
        (*cmd).MaxPRCount as libc::c_int,
    );
    CFE_ES_Global.TaskData.CommandCounter = (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
    CFE_ES_Global.TaskData.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_DeleteCDSCmd(mut data: *const CFE_ES_DeleteCDSCmd_t) -> int32 {
    let mut Status: int32 = 0;
    let mut cmd: *const CFE_ES_DeleteCDSCmd_Payload_t = &(*data).Payload;
    let mut LocalCdsName: [libc::c_char; 40] = [0; 40];
    CFE_SB_MessageStringGet(
        LocalCdsName.as_mut_ptr(),
        ((*cmd).CdsName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    Status = CFE_ES_DeleteCDS(LocalCdsName.as_mut_ptr(), 0 as libc::c_int != 0);
    if Status == 0xc4000020 as libc::c_uint as CFE_Status_t {
        CFE_EVS_SendEvent(
            79 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CDS '%s' is a Critical Table CDS. Must be deleted via TBL Command\0" as *const u8
                as *const libc::c_char,
            LocalCdsName.as_mut_ptr(),
        );
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    } else if Status == 0xc4000022 as libc::c_uint as CFE_Status_t {
        CFE_EVS_SendEvent(
            80 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CDS '%s' not deleted because owning app is active\0" as *const u8
                as *const libc::c_char,
            LocalCdsName.as_mut_ptr(),
        );
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    } else if Status == 0xc4000002 as libc::c_uint as CFE_Status_t {
        CFE_EVS_SendEvent(
            77 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to locate '%s' in CDS Registry\0" as *const u8 as *const libc::c_char,
            LocalCdsName.as_mut_ptr(),
        );
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    } else if Status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            76 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Error while deleting '%s' from CDS, See SysLog.(Err=0x%08X)\0" as *const u8
                as *const libc::c_char,
            LocalCdsName.as_mut_ptr(),
            Status as libc::c_uint,
        );
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    } else {
        CFE_EVS_SendEvent(
            78 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"Successfully removed '%s' from CDS\0" as *const u8 as *const libc::c_char,
            LocalCdsName.as_mut_ptr(),
        );
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_SendMemPoolStatsCmd(
    mut data: *const CFE_ES_SendMemPoolStatsCmd_t,
) -> int32 {
    let mut Cmd: *const CFE_ES_SendMemPoolStatsCmd_Payload_t =
        0 as *const CFE_ES_SendMemPoolStatsCmd_Payload_t;
    let mut MemHandle: CFE_ES_MemHandle_t = 0;
    let mut ValidHandle: bool = false;
    Cmd = &(*data).Payload;
    MemHandle = (*Cmd).PoolHandle;
    ValidHandle = CFE_ES_ValidateHandle(MemHandle);
    if ValidHandle {
        CFE_ES_GetMemPoolStats(
            &mut CFE_ES_Global.TaskData.MemStatsPacket.Payload.PoolStats,
            MemHandle,
        );
        CFE_ES_Global.TaskData.MemStatsPacket.Payload.PoolHandle = MemHandle;
        CFE_SB_TimeStampMsg(&mut CFE_ES_Global.TaskData.MemStatsPacket.TelemetryHeader.Msg);
        CFE_SB_TransmitMsg(
            &mut CFE_ES_Global.TaskData.MemStatsPacket.TelemetryHeader.Msg,
            1 as libc::c_int != 0,
        );
        CFE_ES_Global.TaskData.CommandCounter =
            (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandCounter;
        CFE_EVS_SendEvent(
            81 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Successfully telemetered memory pool stats for 0x%08lX\0" as *const u8
                as *const libc::c_char,
            CFE_ResourceId_ToInteger((*Cmd).PoolHandle),
        );
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
        CFE_EVS_SendEvent(
            82 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Cannot telemeter memory pool stats. Illegal Handle (0x%08lX)\0" as *const u8
                as *const libc::c_char,
            CFE_ResourceId_ToInteger((*Cmd).PoolHandle),
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_DumpCDSRegistryCmd(
    mut data: *const CFE_ES_DumpCDSRegistryCmd_t,
) -> int32 {
    let mut StdFileHeader: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut FileDescriptor: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut RegIndex: int16 = 0 as libc::c_int as int16;
    let mut CmdPtr: *const CFE_ES_DumpCDSRegistryCmd_Payload_t = &(*data).Payload;
    let mut DumpFilename: [libc::c_char; 64] = [0; 64];
    let mut RegRecPtr: *mut CFE_ES_CDS_RegRec_t = 0 as *mut CFE_ES_CDS_RegRec_t;
    let mut DumpRecord: CFE_ES_CDSRegDumpRec_t = CFE_ES_CDSRegDumpRec_t {
        Handle: 0,
        Size: 0,
        Table: false,
        Name: [0; 40],
        ByteAlignSpare: [0; 3],
    };
    let mut FileSize: int32 = 0 as libc::c_int;
    let mut NumEntries: int32 = 0 as libc::c_int;
    Status = CFE_FS_ParseInputFileNameEx(
        DumpFilename.as_mut_ptr(),
        ((*CmdPtr).DumpFilename).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"/ram/cfe_cds_reg.log\0" as *const u8 as *const libc::c_char,
        CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
    );
    if Status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            86 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Error parsing CDS dump filename, Status=0x%08X\0" as *const u8 as *const libc::c_char,
            Status as libc::c_uint,
        );
    } else {
        OsStatus = OS_OpenCreate(
            &mut FileDescriptor,
            DumpFilename.as_mut_ptr(),
            OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
            1 as libc::c_int,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                86 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error creating CDS dump file '%s', Status=%ld\0" as *const u8
                    as *const libc::c_char,
                DumpFilename.as_mut_ptr(),
                OsStatus as libc::c_long,
            );
            Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    }
    if Status == 0 as libc::c_int {
        CFE_FS_InitHeader(
            &mut StdFileHeader,
            b"CDS_Registry\0" as *const u8 as *const libc::c_char,
            CFE_FS_SubType_ES_CDS_REG as libc::c_int as uint32,
        );
        Status = CFE_FS_WriteHeader(FileDescriptor, &mut StdFileHeader);
        FileSize += Status;
        if Status as libc::c_ulong == ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong {
            OsStatus = ::core::mem::size_of::<CFE_ES_CDSRegDumpRec_t>() as libc::c_ulong as int32;
            RegRecPtr = (CFE_ES_Global.CDSVars.Registry).as_mut_ptr();
            while (RegIndex as libc::c_int) < 512 as libc::c_int
                && OsStatus as libc::c_ulong
                    == ::core::mem::size_of::<CFE_ES_CDSRegDumpRec_t>() as libc::c_ulong
            {
                if CFE_ES_CDSBlockRecordIsUsed(RegRecPtr) {
                    memset(
                        &mut DumpRecord as *mut CFE_ES_CDSRegDumpRec_t as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<CFE_ES_CDSRegDumpRec_t>() as libc::c_ulong,
                    );
                    DumpRecord.Size =
                        CFE_ES_CDSBlockRecordGetUserSize(RegRecPtr) as CFE_ES_MemOffset_t;
                    DumpRecord.Handle = CFE_ES_CDSBlockRecordGetID(RegRecPtr);
                    DumpRecord.Table = (*RegRecPtr).Table;
                    strncpy(
                        (DumpRecord.Name).as_mut_ptr(),
                        ((*RegRecPtr).Name).as_mut_ptr(),
                        (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    );
                    OsStatus = OS_write(
                        FileDescriptor,
                        &mut DumpRecord as *mut CFE_ES_CDSRegDumpRec_t as *const libc::c_void,
                        ::core::mem::size_of::<CFE_ES_CDSRegDumpRec_t>() as libc::c_ulong,
                    );
                    FileSize = (FileSize as libc::c_long + OsStatus as libc::c_long) as int32;
                    NumEntries += 1;
                    NumEntries;
                }
                RegIndex += 1;
                RegIndex;
                RegRecPtr = RegRecPtr.offset(1);
                RegRecPtr;
            }
            if OsStatus as libc::c_ulong
                == ::core::mem::size_of::<CFE_ES_CDSRegDumpRec_t>() as libc::c_ulong
            {
                CFE_EVS_SendEvent(
                    83 as libc::c_int as uint16,
                    CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                    b"Successfully dumped CDS Registry to '%s':Size=%d,Entries=%d\0" as *const u8
                        as *const libc::c_char,
                    DumpFilename.as_mut_ptr(),
                    FileSize,
                    NumEntries,
                );
                CFE_ES_Global.TaskData.CommandCounter =
                    (CFE_ES_Global.TaskData.CommandCounter).wrapping_add(1);
                CFE_ES_Global.TaskData.CommandCounter;
            } else {
                CFE_EVS_SendEvent(
                    84 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Error writing CDS Registry to '%s', Status=%ld\0" as *const u8
                        as *const libc::c_char,
                    DumpFilename.as_mut_ptr(),
                    OsStatus as libc::c_long,
                );
                CFE_ES_Global.TaskData.CommandErrorCounter =
                    (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
                CFE_ES_Global.TaskData.CommandErrorCounter;
            }
        } else {
            CFE_EVS_SendEvent(
                85 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error writing cFE File Header to '%s', Status=0x%08X\0" as *const u8
                    as *const libc::c_char,
                DumpFilename.as_mut_ptr(),
                Status as libc::c_uint,
            );
            CFE_ES_Global.TaskData.CommandErrorCounter =
                (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
            CFE_ES_Global.TaskData.CommandErrorCounter;
        }
        OS_close(FileDescriptor);
    } else {
        CFE_ES_Global.TaskData.CommandErrorCounter =
            (CFE_ES_Global.TaskData.CommandErrorCounter).wrapping_add(1);
        CFE_ES_Global.TaskData.CommandErrorCounter;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ES_FileWriteByteCntErr(
    mut Filename: *const libc::c_char,
    mut Requested: size_t,
    mut Status: int32,
) {
    CFE_EVS_SendEvent(
        74 as libc::c_int as uint16,
        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
        b"File write,byte cnt err,file %s,request=%u,status=0x%08x\0" as *const u8
            as *const libc::c_char,
        Filename,
        Requested as libc::c_uint,
        Status as libc::c_uint,
    );
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_eventids_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_fcncodes_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_interface_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_internal_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_mission_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_msgdefs_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_msg_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_msgids_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_msgstruct_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_platform_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_es_src_check_cfe_es_topicids_h_c__CheckHeader() {
}
#[inline]
unsafe extern "C" fn EVS_AppDataGetID(mut AppDataPtr: *mut EVS_AppData_t) -> CFE_ES_AppId_t {
    return (*AppDataPtr).AppID;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_SendEventWithAppID(
    mut EventID: uint16,
    mut EventType: uint16,
    mut AppID: CFE_ES_AppId_t,
    mut Spec: *const libc::c_char,
    mut args: ...
) -> CFE_Status_t {
    let mut Status: int32 = 0 as libc::c_int;
    let mut Time: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut Ptr: ::core::ffi::VaListImpl;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    if Spec.is_null() {
        return 0xc2000008 as libc::c_uint as CFE_Status_t;
    }
    AppDataPtr = EVS_GetAppDataByID(AppID);
    if AppDataPtr.is_null() {
        Status = 0xc2000003 as libc::c_uint as CFE_Status_t;
    } else if !EVS_AppDataIsMatch(AppDataPtr, AppID) {
        Status = EVS_NotRegistered(AppDataPtr, AppID);
    } else if EVS_IsFiltered(AppDataPtr, EventID, EventType) as libc::c_int == 0 as libc::c_int {
        if EVS_CheckAndIncrementSquelchTokens(AppDataPtr) as libc::c_int == 1 as libc::c_int {
            Time = CFE_TIME_GetTime();
            Ptr = args.clone();
            EVS_GenerateEventTelemetry(
                AppDataPtr,
                EventID,
                EventType,
                &mut Time,
                Spec,
                Ptr.as_va_list(),
            );
        } else {
            Status = 0xc2000009 as libc::c_uint as CFE_Status_t;
        }
    }
    return Status;
}
#[inline]
unsafe extern "C" fn EVS_AppDataSetFree(mut AppDataPtr: *mut EVS_AppData_t) {
    (*AppDataPtr).AppID = 0 as libc::c_int as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn EVS_AppDataIsMatch(
    mut AppDataPtr: *mut EVS_AppData_t,
    mut AppID: CFE_ES_AppId_t,
) -> bool {
    return !AppDataPtr.is_null()
        && CFE_ResourceId_Equal((*AppDataPtr).AppID, AppID) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ResetFilter(mut EventID: uint16) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut FilterPtr: *mut EVS_BinFilter_t = 0 as *mut EVS_BinFilter_t;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    Status = EVS_GetCurrentContext(&mut AppDataPtr, &mut AppID);
    if Status == 0 as libc::c_int {
        if !EVS_AppDataIsMatch(AppDataPtr, AppID) {
            Status = 0xc2000002 as libc::c_uint as CFE_Status_t;
        } else {
            FilterPtr = EVS_FindEventID(EventID, ((*AppDataPtr).BinFilters).as_mut_ptr());
            if !FilterPtr.is_null() {
                (*FilterPtr).Count = 0 as libc::c_int as uint16;
            } else {
                Status = 0xc2000006 as libc::c_uint as CFE_Status_t;
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_SendTimedEvent(
    mut Time: CFE_TIME_SysTime_t,
    mut EventID: uint16,
    mut EventType: uint16,
    mut Spec: *const libc::c_char,
    mut args: ...
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut Ptr: ::core::ffi::VaListImpl;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    if Spec.is_null() {
        return 0xc2000008 as libc::c_uint as CFE_Status_t;
    }
    Status = EVS_GetCurrentContext(&mut AppDataPtr, &mut AppID);
    if Status == 0 as libc::c_int {
        if !EVS_AppDataIsMatch(AppDataPtr, AppID) {
            Status = EVS_NotRegistered(AppDataPtr, AppID);
        } else if EVS_IsFiltered(AppDataPtr, EventID, EventType) as libc::c_int == 0 as libc::c_int
        {
            if EVS_CheckAndIncrementSquelchTokens(AppDataPtr) as libc::c_int == 1 as libc::c_int {
                Ptr = args.clone();
                EVS_GenerateEventTelemetry(
                    AppDataPtr,
                    EventID,
                    EventType,
                    &mut Time,
                    Spec,
                    Ptr.as_va_list(),
                );
            } else {
                Status = 0xc2000009 as libc::c_uint as CFE_Status_t;
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ResetAllFilters() -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut i: uint32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    Status = EVS_GetCurrentContext(&mut AppDataPtr, &mut AppID);
    if Status == 0 as libc::c_int {
        if !EVS_AppDataIsMatch(AppDataPtr, AppID) {
            Status = 0xc2000002 as libc::c_uint as CFE_Status_t;
        } else {
            i = 0 as libc::c_int as uint32;
            while i < 8 as libc::c_int as libc::c_uint {
                (*AppDataPtr).BinFilters[i as usize].Count = 0 as libc::c_int as uint16;
                i = i.wrapping_add(1);
                i;
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_SendEvent(
    mut EventID: uint16,
    mut EventType: uint16,
    mut Spec: *const libc::c_char,
    mut args: ...
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut Time: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut Ptr: ::core::ffi::VaListImpl;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    if Spec.is_null() {
        return 0xc2000008 as libc::c_uint as CFE_Status_t;
    }
    Status = EVS_GetCurrentContext(&mut AppDataPtr, &mut AppID);
    if Status == 0 as libc::c_int {
        if !EVS_AppDataIsMatch(AppDataPtr, AppID) {
            Status = EVS_NotRegistered(AppDataPtr, AppID);
        } else if EVS_IsFiltered(AppDataPtr, EventID, EventType) as libc::c_int == 0 as libc::c_int
        {
            if EVS_CheckAndIncrementSquelchTokens(AppDataPtr) as libc::c_int == 1 as libc::c_int {
                Time = CFE_TIME_GetTime();
                Ptr = args.clone();
                EVS_GenerateEventTelemetry(
                    AppDataPtr,
                    EventID,
                    EventType,
                    &mut Time,
                    Spec,
                    Ptr.as_va_list(),
                );
            } else {
                Status = 0xc2000009 as libc::c_uint as CFE_Status_t;
            }
        }
    }
    return Status;
}
#[inline]
unsafe extern "C" fn EVS_AppDataIsUsed(mut AppDataPtr: *mut EVS_AppData_t) -> bool {
    return CFE_ResourceId_IsDefined((*AppDataPtr).AppID);
}
#[inline]
unsafe extern "C" fn EVS_AppDataSetUsed(
    mut AppDataPtr: *mut EVS_AppData_t,
    mut AppID: CFE_ES_AppId_t,
) {
    (*AppDataPtr).AppID = AppID;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_Register(
    mut Filters: *const libc::c_void,
    mut NumEventFilters: uint16,
    mut FilterScheme: uint16,
) -> CFE_Status_t {
    let mut FilterLimit: uint16 = 0;
    let mut i: uint16 = 0;
    let mut Status: int32 = 0;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut AppFilters: *mut CFE_EVS_BinFilter_t = 0 as *mut CFE_EVS_BinFilter_t;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    Status = EVS_GetCurrentContext(&mut AppDataPtr, &mut AppID);
    if Status == 0 as libc::c_int {
        memset(
            AppDataPtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<EVS_AppData_t>() as libc::c_ulong,
        );
        if FilterScheme as libc::c_int != CFE_EVS_EventFilter_BINARY as libc::c_int {
            Status = 0xc2000001 as libc::c_uint as CFE_Status_t;
        } else if NumEventFilters as libc::c_int != 0 as libc::c_int && Filters.is_null() {
            Status = 0xc400000a as libc::c_uint as CFE_Status_t;
        } else {
            (*AppDataPtr).ActiveFlag = 1 as libc::c_int as uint8;
            (*AppDataPtr).EventTypesActiveFlag = 0xe as libc::c_int as uint8;
            (*AppDataPtr).SquelchTokens = 32 as libc::c_int * 1000 as libc::c_int;
            if (NumEventFilters as libc::c_int) < 8 as libc::c_int {
                FilterLimit = NumEventFilters;
            } else {
                FilterLimit = 8 as libc::c_int as uint16;
                CFE_ES_WriteToSysLog(
                    b"%s: Filter limit truncated to %d\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                        b"CFE_EVS_Register\0",
                    ))
                    .as_ptr(),
                    FilterLimit as libc::c_int,
                );
            }
            if !Filters.is_null() {
                AppFilters = Filters as *mut CFE_EVS_BinFilter_t;
                i = 0 as libc::c_int as uint16;
                while (i as libc::c_int) < FilterLimit as libc::c_int {
                    (*AppDataPtr).BinFilters[i as usize].EventID =
                        (*AppFilters.offset(i as isize)).EventID;
                    (*AppDataPtr).BinFilters[i as usize].Mask =
                        (*AppFilters.offset(i as isize)).Mask;
                    (*AppDataPtr).BinFilters[i as usize].Count = 0 as libc::c_int as uint16;
                    i = i.wrapping_add(1);
                    i;
                }
            }
            i = FilterLimit;
            while (i as libc::c_int) < 8 as libc::c_int {
                (*AppDataPtr).BinFilters[i as usize].EventID = -(1 as libc::c_int) as uint16;
                (*AppDataPtr).BinFilters[i as usize].Mask = 0 as libc::c_int as uint16;
                (*AppDataPtr).BinFilters[i as usize].Count = 0 as libc::c_int as uint16;
                i = i.wrapping_add(1);
                i;
            }
            EVS_AppDataSetUsed(AppDataPtr, AppID);
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_AddLog(mut EVS_PktPtr: *mut CFE_EVS_LongEventTlm_t) {
    OS_MutSemTake(CFE_EVS_Global.EVS_SharedDataMutexID);
    if (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag as libc::c_int == 1 as libc::c_int
        && (*CFE_EVS_Global.EVS_LogPtr).LogMode as libc::c_int
            == CFE_EVS_LogMode_DISCARD as libc::c_int
    {
        (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter =
            ((*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter).wrapping_add(1);
        (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter;
    } else {
        if (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag as libc::c_int == 1 as libc::c_int {
            (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter =
                ((*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter).wrapping_add(1);
            (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter;
        }
        memcpy(
            &mut *((*CFE_EVS_Global.EVS_LogPtr).LogEntry)
                .as_mut_ptr()
                .offset((*CFE_EVS_Global.EVS_LogPtr).Next as isize)
                as *mut CFE_EVS_LongEventTlm_t as *mut libc::c_void,
            EVS_PktPtr as *const libc::c_void,
            ::core::mem::size_of::<CFE_EVS_LongEventTlm_t>() as libc::c_ulong,
        );
        (*CFE_EVS_Global.EVS_LogPtr).Next = ((*CFE_EVS_Global.EVS_LogPtr).Next).wrapping_add(1);
        (*CFE_EVS_Global.EVS_LogPtr).Next;
        if (*CFE_EVS_Global.EVS_LogPtr).Next as libc::c_int >= 20 as libc::c_int {
            (*CFE_EVS_Global.EVS_LogPtr).Next = 0 as libc::c_int as uint16;
        }
        if ((*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_int) < 20 as libc::c_int {
            (*CFE_EVS_Global.EVS_LogPtr).LogCount =
                ((*CFE_EVS_Global.EVS_LogPtr).LogCount).wrapping_add(1);
            (*CFE_EVS_Global.EVS_LogPtr).LogCount;
            if (*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_int == 20 as libc::c_int {
                (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag = 1 as libc::c_int as uint8;
            }
        }
    }
    OS_MutSemGive(CFE_EVS_Global.EVS_SharedDataMutexID);
}
#[no_mangle]
pub unsafe extern "C" fn EVS_ClearLog() {
    OS_MutSemTake(CFE_EVS_Global.EVS_SharedDataMutexID);
    (*CFE_EVS_Global.EVS_LogPtr).Next = 0 as libc::c_int as uint16;
    (*CFE_EVS_Global.EVS_LogPtr).LogCount = 0 as libc::c_int as uint16;
    (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag = 0 as libc::c_int as uint8;
    (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter = 0 as libc::c_int as uint16;
    memset(
        ((*CFE_EVS_Global.EVS_LogPtr).LogEntry).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[CFE_EVS_LongEventTlm_t; 20]>() as libc::c_ulong,
    );
    OS_MutSemGive(CFE_EVS_Global.EVS_SharedDataMutexID);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_WriteLogDataFileCmd(
    mut data: *const CFE_EVS_WriteLogDataFileCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_LogFileCmd_Payload_t = &(*data).Payload;
    let mut Result: int32 = 0;
    let mut LogIndex: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut BytesWritten: int32 = 0;
    let mut LogFileHandle: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut i: uint32 = 0;
    let mut LogFileHdr: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut LogFilename: [libc::c_char; 64] = [0; 64];
    Result = CFE_FS_ParseInputFileNameEx(
        LogFilename.as_mut_ptr(),
        ((*CmdPtr).LogFilename).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"/ram/cfe_evs.log\0" as *const u8 as *const libc::c_char,
        CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
    );
    if Result != 0 as libc::c_int {
        EVS_SendEvent(
            3 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Write Log File Command Error: CFE_FS_ParseInputFileNameEx() = 0x%08X\0" as *const u8
                as *const libc::c_char,
            Result as libc::c_uint,
        );
    } else {
        OsStatus = OS_OpenCreate(
            &mut LogFileHandle,
            LogFilename.as_mut_ptr(),
            OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
            1 as libc::c_int,
        );
        if OsStatus != 0 as libc::c_int {
            EVS_SendEvent(
                3 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Write Log File Command Error: OS_OpenCreate = %ld, filename = %s\0" as *const u8
                    as *const libc::c_char,
                OsStatus as libc::c_long,
                LogFilename.as_mut_ptr(),
            );
            Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    }
    if Result == 0 as libc::c_int {
        Result = 0xc2000007 as libc::c_uint as CFE_Status_t;
        CFE_FS_InitHeader(
            &mut LogFileHdr,
            b"cFE EVS Log File\0" as *const u8 as *const libc::c_char,
            CFE_FS_SubType_EVS_EVENTLOG as libc::c_int as uint32,
        );
        BytesWritten = CFE_FS_WriteHeader(LogFileHandle, &mut LogFileHdr);
        if BytesWritten as libc::c_ulong
            == ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong
        {
            OS_MutSemTake(CFE_EVS_Global.EVS_SharedDataMutexID);
            if (*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_int == 20 as libc::c_int {
                LogIndex = (*CFE_EVS_Global.EVS_LogPtr).Next as int32;
            } else {
                LogIndex = 0 as libc::c_int;
            }
            i = 0 as libc::c_int as uint32;
            while i < (*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_uint {
                OsStatus = OS_write(
                    LogFileHandle,
                    &mut *((*CFE_EVS_Global.EVS_LogPtr).LogEntry)
                        .as_mut_ptr()
                        .offset(LogIndex as isize)
                        as *mut CFE_EVS_LongEventTlm_t as *const libc::c_void,
                    ::core::mem::size_of::<CFE_EVS_LongEventTlm_t>() as libc::c_ulong,
                );
                if !(OsStatus as libc::c_ulong
                    == ::core::mem::size_of::<CFE_EVS_LongEventTlm_t>() as libc::c_ulong)
                {
                    break;
                }
                LogIndex += 1;
                LogIndex;
                if LogIndex >= 20 as libc::c_int {
                    LogIndex = 0 as libc::c_int;
                }
                i = i.wrapping_add(1);
                i;
            }
            OS_MutSemGive(CFE_EVS_Global.EVS_SharedDataMutexID);
            if i == (*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_uint {
                EVS_SendEvent(
                    33 as libc::c_int as uint16,
                    CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                    b"Write Log File Command: %d event log entries written to %s\0" as *const u8
                        as *const libc::c_char,
                    (*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_int,
                    LogFilename.as_mut_ptr(),
                );
                Result = 0 as libc::c_int;
            } else {
                EVS_SendEvent(
                    2 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Write Log File Command Error: OS_write = %ld, filename = %s\0" as *const u8
                        as *const libc::c_char,
                    OsStatus as libc::c_long,
                    LogFilename.as_mut_ptr(),
                );
            }
        } else {
            EVS_SendEvent(
                14 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Write File Header to Log File Error: WriteHdr RC: %d, Expected: %d, filename = %s\0"
                    as *const u8 as *const libc::c_char,
                BytesWritten,
                ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong
                    as libc::c_int,
                LogFilename.as_mut_ptr(),
            );
        }
        OS_close(LogFileHandle);
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_SetLogModeCmd(mut data: *const CFE_EVS_SetLogModeCmd_t) -> int32 {
    let mut CmdPtr: *const CFE_EVS_SetLogMode_Payload_t = &(*data).Payload;
    let mut Status: int32 = 0;
    if (*CmdPtr).LogMode as libc::c_int == CFE_EVS_LogMode_OVERWRITE as libc::c_int
        || (*CmdPtr).LogMode as libc::c_int == CFE_EVS_LogMode_DISCARD as libc::c_int
    {
        OS_MutSemTake(CFE_EVS_Global.EVS_SharedDataMutexID);
        (*CFE_EVS_Global.EVS_LogPtr).LogMode = (*CmdPtr).LogMode;
        OS_MutSemGive(CFE_EVS_Global.EVS_SharedDataMutexID);
        EVS_SendEvent(
            38 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Set Log Mode Command: Log Mode = %d\0" as *const u8 as *const libc::c_char,
            (*CmdPtr).LogMode as libc::c_int,
        );
        Status = 0 as libc::c_int;
    } else {
        Status = 0xc2000008 as libc::c_uint as CFE_Status_t;
        EVS_SendEvent(
            39 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Set Log Mode Command Error: Log Mode = %d\0" as *const u8 as *const libc::c_char,
            (*CmdPtr).LogMode as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub static mut CFE_EVS_Global: CFE_EVS_Global_t = CFE_EVS_Global_t {
    AppData: [EVS_AppData_t {
        AppID: 0,
        UnregAppID: 0,
        BinFilters: [EVS_BinFilter_t {
            EventID: 0,
            Mask: 0,
            Count: 0,
            Padding: 0,
        }; 8],
        ActiveFlag: 0,
        EventTypesActiveFlag: 0,
        EventCount: 0,
        LastSquelchCreditableTime: OS_time_t { ticks: 0 },
        SquelchTokens: 0,
        SquelchedCount: 0,
    }; 32],
    EVS_LogPtr: 0 as *const CFE_EVS_Log_t as *mut CFE_EVS_Log_t,
    EVS_TlmPkt: CFE_EVS_HousekeepingTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_EVS_HousekeepingTlm_Payload_t {
            CommandCounter: 0,
            CommandErrorCounter: 0,
            MessageFormatMode: 0,
            MessageTruncCounter: 0,
            UnregisteredAppCounter: 0,
            OutputPort: 0,
            LogFullFlag: 0,
            LogMode: 0,
            MessageSendCounter: 0,
            LogOverflowCounter: 0,
            LogEnabled: 0,
            Spare1: 0,
            Spare2: 0,
            Spare3: 0,
            AppData: [CFE_EVS_AppTlmData_t {
                AppID: 0,
                AppMessageSentCounter: 0,
                AppEnableStatus: 0,
                AppMessageSquelchedCounter: 0,
            }; 16],
        },
    },
    EVS_CommandPipe: 0,
    EVS_SharedDataMutexID: 0,
    EVS_AppID: 0,
    EVS_EventBurstMax: 0,
};
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_EarlyInit() -> int32 {
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut PspStatus: int32 = 0;
    let mut resetAreaSize: uint32 = 0 as libc::c_int as uint32;
    let mut resetAreaAddr: cpuaddr = 0;
    let mut CFE_EVS_ResetDataPtr: *mut CFE_ES_ResetData_t =
        0 as *mut libc::c_void as *mut CFE_ES_ResetData_t;
    memset(
        &mut CFE_EVS_Global as *mut CFE_EVS_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_EVS_Global_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_EVS_Global.EVS_TlmPkt.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 1 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_EVS_HousekeepingTlm_t>() as libc::c_ulong,
    );
    CFE_EVS_Global.EVS_TlmPkt.Payload.MessageFormatMode =
        CFE_EVS_MsgFormat_LONG as libc::c_int as uint8;
    CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort = 0x1 as libc::c_int as uint8;
    CFE_EVS_Global.EVS_TlmPkt.Payload.LogMode = 1 as libc::c_int as uint8;
    CFE_EVS_Global.EVS_EventBurstMax = 32 as libc::c_int as uint32;
    PspStatus = CFE_PSP_GetResetArea(&mut resetAreaAddr, &mut resetAreaSize);
    if PspStatus != 0 as libc::c_int {
        Status = 0xc2000005 as libc::c_uint as CFE_Status_t;
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_PSP_GetResetArea failed, RC=0x%08x\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_EVS_EarlyInit\0"))
                .as_ptr(),
            PspStatus as libc::c_uint,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(3 as libc::c_int);
    } else if (resetAreaSize as libc::c_ulong)
        < ::core::mem::size_of::<CFE_ES_ResetData_t>() as libc::c_ulong
    {
        Status = 0xc2000005 as libc::c_uint as CFE_Status_t;
        CFE_ES_WriteToSysLog(
            b"%s: Unexpected size from CFE_PSP_GetResetArea: expected = 0x%08lX, actual = 0x%08lX\n\0"
                as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"CFE_EVS_EarlyInit\0"))
                .as_ptr(),
            ::core::mem::size_of::<CFE_ES_ResetData_t>() as libc::c_ulong,
            resetAreaSize as libc::c_ulong,
        );
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_PSP_Panic(3 as libc::c_int);
    } else {
        CFE_EVS_ResetDataPtr = resetAreaAddr as *mut CFE_ES_ResetData_t;
        CFE_EVS_Global.EVS_LogPtr = &mut (*CFE_EVS_ResetDataPtr).EVS_Log;
        OsStatus = OS_MutSemCreate(
            &mut CFE_EVS_Global.EVS_SharedDataMutexID,
            b"CFE_EVS_DataMutex\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as uint32,
        );
        if OsStatus != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: OS_MutSemCreate failed, RC=%ld\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_EVS_EarlyInit\0"))
                    .as_ptr(),
                OsStatus as libc::c_long,
            );
            OS_TaskDelay(500 as libc::c_int as uint32);
            CFE_PSP_Panic(5 as libc::c_int);
            Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
        } else {
            Status = 0 as libc::c_int;
        }
        CFE_EVS_Global.EVS_TlmPkt.Payload.LogEnabled = 1 as libc::c_int as uint8;
        if CFE_ES_GetResetType(0 as *mut uint32) == 2 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Event Log cleared following power-on reset\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_EVS_EarlyInit\0"))
                    .as_ptr(),
            );
            EVS_ClearLog();
            (*CFE_EVS_Global.EVS_LogPtr).LogMode = 1 as libc::c_int as uint8;
        } else if (*CFE_EVS_Global.EVS_LogPtr).LogMode as libc::c_int
            != CFE_EVS_LogMode_OVERWRITE as libc::c_int
            && (*CFE_EVS_Global.EVS_LogPtr).LogMode as libc::c_int
                != CFE_EVS_LogMode_DISCARD as libc::c_int
            || (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag as libc::c_int != 0 as libc::c_int
                && (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag as libc::c_int != 1 as libc::c_int
            || (*CFE_EVS_Global.EVS_LogPtr).Next as libc::c_int >= 20 as libc::c_int
        {
            CFE_ES_WriteToSysLog(
                b"%s: Event Log cleared, n=%d, c=%d, f=%d, m=%d, o=%d\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_EVS_EarlyInit\0"))
                    .as_ptr(),
                (*CFE_EVS_Global.EVS_LogPtr).Next as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogMode as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter as libc::c_int,
            );
            EVS_ClearLog();
            (*CFE_EVS_Global.EVS_LogPtr).LogMode = 1 as libc::c_int as uint8;
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Event Log restored, n=%d, c=%d, f=%d, m=%d, o=%d\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_EVS_EarlyInit\0"))
                    .as_ptr(),
                (*CFE_EVS_Global.EVS_LogPtr).Next as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogCount as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogMode as libc::c_int,
                (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter as libc::c_int,
            );
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_CleanUpApp(mut AppID: CFE_ES_AppId_t) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    AppDataPtr = EVS_GetAppDataByID(AppID);
    if AppDataPtr.is_null() {
        Status = 0xc2000003 as libc::c_uint as CFE_Status_t;
    } else if EVS_AppDataIsMatch(AppDataPtr, AppID) {
        EVS_AppDataSetFree(AppDataPtr);
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_TaskMain() {
    let mut Status: int32 = 0;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(2 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    Status = CFE_EVS_TaskInit();
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Application Init Failed,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_EVS_TaskMain\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        CFE_ES_PerfLogAdd(2 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_INIT_ERROR as libc::c_int as uint32);
    }
    CFE_ES_WaitForSystemState(
        CFE_ES_SystemState_CORE_READY as libc::c_int as uint32,
        30000 as libc::c_int as uint32,
    );
    while Status == 0 as libc::c_int {
        CFE_ES_IncrementTaskCounter();
        CFE_ES_PerfLogAdd(2 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        Status = CFE_SB_ReceiveBuffer(
            &mut SBBufPtr,
            CFE_EVS_Global.EVS_CommandPipe,
            -(1 as libc::c_int),
        );
        CFE_ES_PerfLogAdd(2 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if Status == 0 as libc::c_int {
            CFE_EVS_ProcessCommandPacket(SBBufPtr);
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Error reading cmd pipe,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_EVS_TaskMain\0"))
                    .as_ptr(),
                Status as libc::c_uint,
            );
        }
    }
    CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR as libc::c_int as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_TaskInit() -> int32 {
    let mut Status: int32 = 0;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    Status = CFE_ES_GetAppID(&mut AppID);
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_ES_GetAppID Failed:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_EVS_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_EVS_Register(
        0 as *const libc::c_void,
        0 as libc::c_int as uint16,
        CFE_EVS_EventFilter_BINARY as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_EVS_Register Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_EVS_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_CreatePipe(
        &mut CFE_EVS_Global.EVS_CommandPipe,
        32 as libc::c_int as uint16,
        b"EVS_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_SB_CreatePipe Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_EVS_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 1 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_EVS_Global.EVS_CommandPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Subscribing to Cmds Failed:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_EVS_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 9 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_EVS_Global.EVS_CommandPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Subscribing to HK Request Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_EVS_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    CFE_EVS_Global.EVS_AppID = AppID;
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    EVS_SendEvent(
        1 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"cFE EVS Initialized: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_NoopCmd(mut data: *const CFE_EVS_NoopCmd_t) -> int32 {
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    EVS_SendEvent(
        0 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"No-op Cmd Rcvd: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ClearLogCmd(mut data: *const CFE_EVS_ClearLogCmd_t) -> int32 {
    EVS_ClearLog();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ReportHousekeepingCmd(
    mut data: *const CFE_EVS_SendHkCmd_t,
) -> int32 {
    let mut i: uint32 = 0;
    let mut j: uint32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut AppTlmDataPtr: *mut CFE_EVS_AppTlmData_t = 0 as *mut CFE_EVS_AppTlmData_t;
    CFE_EVS_Global.EVS_TlmPkt.Payload.LogFullFlag = (*CFE_EVS_Global.EVS_LogPtr).LogFullFlag;
    CFE_EVS_Global.EVS_TlmPkt.Payload.LogMode = (*CFE_EVS_Global.EVS_LogPtr).LogMode;
    CFE_EVS_Global.EVS_TlmPkt.Payload.LogOverflowCounter =
        (*CFE_EVS_Global.EVS_LogPtr).LogOverflowCounter;
    AppDataPtr = (CFE_EVS_Global.AppData).as_mut_ptr();
    AppTlmDataPtr = (CFE_EVS_Global.EVS_TlmPkt.Payload.AppData).as_mut_ptr();
    i = 0 as libc::c_int as uint32;
    j = 0 as libc::c_int as uint32;
    while j < 16 as libc::c_int as libc::c_uint && i < 32 as libc::c_int as libc::c_uint {
        if EVS_AppDataIsUsed(AppDataPtr) {
            (*AppTlmDataPtr).AppID = EVS_AppDataGetID(AppDataPtr);
            (*AppTlmDataPtr).AppEnableStatus = (*AppDataPtr).ActiveFlag;
            (*AppTlmDataPtr).AppMessageSentCounter = (*AppDataPtr).EventCount;
            (*AppTlmDataPtr).AppMessageSquelchedCounter = (*AppDataPtr).SquelchedCount;
            j = j.wrapping_add(1);
            j;
            AppTlmDataPtr = AppTlmDataPtr.offset(1);
            AppTlmDataPtr;
        }
        AppDataPtr = AppDataPtr.offset(1);
        AppDataPtr;
        i = i.wrapping_add(1);
        i;
    }
    i = j;
    while i < 16 as libc::c_int as libc::c_uint {
        (*AppTlmDataPtr).AppID = 0 as libc::c_int as CFE_ResourceId_t;
        (*AppTlmDataPtr).AppEnableStatus = 0 as libc::c_int as uint8;
        (*AppTlmDataPtr).AppMessageSentCounter = 0 as libc::c_int as uint16;
        (*AppTlmDataPtr).AppMessageSquelchedCounter = 0 as libc::c_int as uint8;
        i = i.wrapping_add(1);
        i;
    }
    CFE_SB_TimeStampMsg(&mut CFE_EVS_Global.EVS_TlmPkt.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut CFE_EVS_Global.EVS_TlmPkt.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    return 0x48000001 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ResetCountersCmd(
    mut data: *const CFE_EVS_ResetCountersCmd_t,
) -> int32 {
    CFE_EVS_Global.EVS_TlmPkt.Payload.CommandCounter = 0 as libc::c_int as uint8;
    CFE_EVS_Global.EVS_TlmPkt.Payload.CommandErrorCounter = 0 as libc::c_int as uint8;
    CFE_EVS_Global.EVS_TlmPkt.Payload.MessageSendCounter = 0 as libc::c_int as uint16;
    CFE_EVS_Global.EVS_TlmPkt.Payload.MessageTruncCounter = 0 as libc::c_int as uint8;
    CFE_EVS_Global.EVS_TlmPkt.Payload.UnregisteredAppCounter = 0 as libc::c_int as uint8;
    EVS_SendEvent(
        16 as libc::c_int as uint16,
        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
        b"Reset Counters Command Received\0" as *const u8 as *const libc::c_char,
    );
    return 0x48000001 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_SetFilterCmd(mut data: *const CFE_EVS_SetFilterCmd_t) -> int32 {
    let mut CmdPtr: *const CFE_EVS_AppNameEventIDMaskCmd_Payload_t = &(*data).Payload;
    let mut FilterPtr: *mut EVS_BinFilter_t = 0 as *mut EVS_BinFilter_t;
    let mut Status: int32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        FilterPtr = EVS_FindEventID((*CmdPtr).EventID, ((*AppDataPtr).BinFilters).as_mut_ptr());
        if !FilterPtr.is_null() {
            (*FilterPtr).Mask = (*CmdPtr).Mask;
            EVS_SendEvent(
                17 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Set Filter Mask Command Received with AppName=%s, EventID=0x%08x, Mask=0x%04x\0"
                    as *const u8 as *const libc::c_char,
                LocalName.as_mut_ptr(),
                (*CmdPtr).EventID as libc::c_uint,
                (*CmdPtr).Mask as libc::c_uint,
            );
        } else {
            EVS_SendEvent(
                6 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"%s Event ID %d not registered for filtering: CC = %lu \0" as *const u8
                    as *const libc::c_char,
                LocalName.as_mut_ptr(),
                (*CmdPtr).EventID as libc::c_int,
                10 as libc::c_int as libc::c_ulong,
            );
            Status = 0xc2000006 as libc::c_uint as CFE_Status_t;
        }
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            10 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            10 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            10 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_EnablePortsCmd(
    mut data: *const CFE_EVS_EnablePortsCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_BitMaskCmd_Payload_t = &(*data).Payload;
    let mut ReturnCode: int32 = 0;
    if (*CmdPtr).BitMask as libc::c_int == 0 as libc::c_int
        || (*CmdPtr).BitMask as libc::c_int > 0xf as libc::c_int
    {
        EVS_SendEvent(
            40 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Bit Mask = 0x%08x out of range: CC = %lu\0" as *const u8 as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
            11 as libc::c_int as libc::c_ulong,
        );
        ReturnCode = 0xc2000008 as libc::c_uint as CFE_Status_t;
    } else {
        CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort =
            (CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort as libc::c_int
                | (*CmdPtr).BitMask as libc::c_int) as uint8;
        EVS_SendEvent(
            18 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Enable Ports Command Received with Port Bit Mask = 0x%02x\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
        );
        ReturnCode = 0 as libc::c_int;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_DisablePortsCmd(
    mut data: *const CFE_EVS_DisablePortsCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_BitMaskCmd_Payload_t = &(*data).Payload;
    let mut ReturnCode: int32 = 0;
    if (*CmdPtr).BitMask as libc::c_int == 0 as libc::c_int
        || (*CmdPtr).BitMask as libc::c_int > 0xf as libc::c_int
    {
        EVS_SendEvent(
            40 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Bit Mask = 0x%08x out of range: CC = %lu\0" as *const u8 as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
            12 as libc::c_int as libc::c_ulong,
        );
        ReturnCode = 0xc2000008 as libc::c_uint as CFE_Status_t;
    } else {
        CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort =
            (CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort as libc::c_int
                & !((*CmdPtr).BitMask as libc::c_int)) as uint8;
        EVS_SendEvent(
            19 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Disable Ports Command Received with Port Bit Mask = 0x%02x\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
        );
        ReturnCode = 0 as libc::c_int;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_EnableEventTypeCmd(
    mut data: *const CFE_EVS_EnableEventTypeCmd_t,
) -> int32 {
    let mut i: uint32 = 0;
    let mut CmdPtr: *const CFE_EVS_BitMaskCmd_Payload_t = &(*data).Payload;
    let mut ReturnCode: int32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    if (*CmdPtr).BitMask as libc::c_int == 0 as libc::c_int
        || (*CmdPtr).BitMask as libc::c_int > 0xf as libc::c_int
    {
        EVS_SendEvent(
            40 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Bit Mask = 0x%08x out of range: CC = %lu\0" as *const u8 as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
            2 as libc::c_int as libc::c_ulong,
        );
        ReturnCode = 0xc2000008 as libc::c_uint as CFE_Status_t;
    } else {
        AppDataPtr = (CFE_EVS_Global.AppData).as_mut_ptr();
        i = 0 as libc::c_int as uint32;
        while i < 32 as libc::c_int as libc::c_uint {
            if EVS_AppDataIsUsed(AppDataPtr) {
                EVS_EnableTypes(AppDataPtr, (*CmdPtr).BitMask);
            }
            AppDataPtr = AppDataPtr.offset(1);
            AppDataPtr;
            i = i.wrapping_add(1);
            i;
        }
        EVS_SendEvent(
            20 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Enable Event Type Command Received with Event Type Bit Mask = 0x%02x\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
        );
        ReturnCode = 0 as libc::c_int;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_DisableEventTypeCmd(
    mut data: *const CFE_EVS_DisableEventTypeCmd_t,
) -> int32 {
    let mut i: uint32 = 0;
    let mut CmdPtr: *const CFE_EVS_BitMaskCmd_Payload_t = &(*data).Payload;
    let mut ReturnCode: int32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    if (*CmdPtr).BitMask as libc::c_int == 0 as libc::c_int
        || (*CmdPtr).BitMask as libc::c_int > 0xf as libc::c_int
    {
        EVS_SendEvent(
            40 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Bit Mask = 0x%08x out of range: CC = %lu\0" as *const u8 as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
            3 as libc::c_int as libc::c_ulong,
        );
        ReturnCode = 0xc2000008 as libc::c_uint as CFE_Status_t;
    } else {
        AppDataPtr = (CFE_EVS_Global.AppData).as_mut_ptr();
        i = 0 as libc::c_int as uint32;
        while i < 32 as libc::c_int as libc::c_uint {
            if EVS_AppDataIsUsed(AppDataPtr) {
                EVS_DisableTypes(AppDataPtr, (*CmdPtr).BitMask);
            }
            AppDataPtr = AppDataPtr.offset(1);
            AppDataPtr;
            i = i.wrapping_add(1);
            i;
        }
        EVS_SendEvent(
            21 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Disable Event Type Command Received with Event Type Bit Mask = 0x%02x\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).BitMask as libc::c_uint,
        );
        ReturnCode = 0 as libc::c_int;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_SetEventFormatModeCmd(
    mut data: *const CFE_EVS_SetEventFormatModeCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_SetEventFormatMode_Payload_t = &(*data).Payload;
    let mut Status: int32 = 0;
    if (*CmdPtr).MsgFormat as libc::c_int == CFE_EVS_MsgFormat_SHORT as libc::c_int
        || (*CmdPtr).MsgFormat as libc::c_int == CFE_EVS_MsgFormat_LONG as libc::c_int
    {
        CFE_EVS_Global.EVS_TlmPkt.Payload.MessageFormatMode = (*CmdPtr).MsgFormat;
        EVS_SendEvent(
            22 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Set Event Format Mode Command Received with Mode = 0x%02x\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).MsgFormat as libc::c_uint,
        );
        Status = 0 as libc::c_int;
    } else {
        EVS_SendEvent(
            10 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Set Event Format Mode Command: Invalid Event Format Mode = 0x%02x\0" as *const u8
                as *const libc::c_char,
            (*CmdPtr).MsgFormat as libc::c_uint,
        );
        Status = 0xc2000008 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_EnableAppEventTypeCmd(
    mut data: *const CFE_EVS_EnableAppEventTypeCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_AppNameBitMaskCmd_Payload_t = &(*data).Payload;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut Status: int32 = 0;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        if (*CmdPtr).BitMask as libc::c_int == 0 as libc::c_int
            || (*CmdPtr).BitMask as libc::c_int > 0xf as libc::c_int
        {
            EVS_SendEvent(
                40 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Bit Mask = 0x%08x out of range: CC = %lu\0" as *const u8 as *const libc::c_char,
                (*CmdPtr).BitMask as libc::c_uint,
                5 as libc::c_int as libc::c_ulong,
            );
            Status = 0xc2000008 as libc::c_uint as CFE_Status_t;
        } else {
            EVS_EnableTypes(AppDataPtr, (*CmdPtr).BitMask);
        }
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            5 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            5 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            5 as libc::c_int as libc::c_ulong,
        );
    }
    if Status == 0 as libc::c_int {
        EVS_SendEvent(
            23 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Enable App Event Type Command Received with AppName = %s, EventType Bit Mask = 0x%02x\0"
                as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            (*CmdPtr).BitMask as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_DisableAppEventTypeCmd(
    mut data: *const CFE_EVS_DisableAppEventTypeCmd_t,
) -> int32 {
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut CmdPtr: *const CFE_EVS_AppNameBitMaskCmd_Payload_t = &(*data).Payload;
    let mut Status: int32 = 0;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        if (*CmdPtr).BitMask as libc::c_int == 0 as libc::c_int
            || (*CmdPtr).BitMask as libc::c_int > 0xf as libc::c_int
        {
            EVS_SendEvent(
                40 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Bit Mask = 0x%08x out of range: CC = %lu\0" as *const u8 as *const libc::c_char,
                (*CmdPtr).BitMask as libc::c_uint,
                6 as libc::c_int as libc::c_ulong,
            );
            Status = 0xc2000008 as libc::c_uint as CFE_Status_t;
        } else {
            EVS_DisableTypes(AppDataPtr, (*CmdPtr).BitMask);
        }
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS,: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            6 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            6 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            6 as libc::c_int as libc::c_ulong,
        );
    }
    if Status == 0 as libc::c_int {
        EVS_SendEvent(
            24 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Disable App Event Type Command Received with AppName = %s, EventType Bit Mask = 0x%02x\0"
                as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            (*CmdPtr).BitMask as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_EnableAppEventsCmd(
    mut data: *const CFE_EVS_EnableAppEventsCmd_t,
) -> int32 {
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut CmdPtr: *const CFE_EVS_AppNameCmd_Payload_t = &(*data).Payload;
    let mut Status: int32 = 0;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        (*AppDataPtr).ActiveFlag = 1 as libc::c_int as uint8;
        EVS_SendEvent(
            25 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Enable App Events Command Received with AppName = %s\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
        );
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            7 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            7 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            7 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_DisableAppEventsCmd(
    mut data: *const CFE_EVS_DisableAppEventsCmd_t,
) -> int32 {
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut CmdPtr: *const CFE_EVS_AppNameCmd_Payload_t = &(*data).Payload;
    let mut Status: int32 = 0;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        (*AppDataPtr).ActiveFlag = 0 as libc::c_int as uint8;
        EVS_SendEvent(
            26 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Disable App Events Command Received with AppName = %s\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
        );
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            8 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            8 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Disable App Events Command: Unable to retrieve application ID for %s: CC = %lu\0"
                as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            8 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ResetAppCounterCmd(
    mut data: *const CFE_EVS_ResetAppCounterCmd_t,
) -> int32 {
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut CmdPtr: *const CFE_EVS_AppNameCmd_Payload_t = &(*data).Payload;
    let mut Status: int32 = 0;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        (*AppDataPtr).EventCount = 0 as libc::c_int as uint16;
        (*AppDataPtr).SquelchedCount = 0 as libc::c_int as uint8;
        EVS_SendEvent(
            27 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Reset Event Counter Command Received with AppName = %s\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
        );
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            9 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            9 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Reset Event Counter Command: Unable to retrieve application ID for %s: CC = %lu\0"
                as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            9 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ResetFilterCmd(
    mut data: *const CFE_EVS_ResetFilterCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_AppNameEventIDCmd_Payload_t = &(*data).Payload;
    let mut FilterPtr: *mut EVS_BinFilter_t = 0 as *mut EVS_BinFilter_t;
    let mut Status: int32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        FilterPtr = EVS_FindEventID((*CmdPtr).EventID, ((*AppDataPtr).BinFilters).as_mut_ptr());
        if !FilterPtr.is_null() {
            (*FilterPtr).Count = 0 as libc::c_int as uint16;
            EVS_SendEvent(
                28 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Reset Filter Command Received with AppName = %s, EventID = 0x%08x\0" as *const u8
                    as *const libc::c_char,
                LocalName.as_mut_ptr(),
                (*CmdPtr).EventID as libc::c_uint,
            );
        } else {
            EVS_SendEvent(
                6 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"%s Event ID %d not registered for filtering: CC = %lu\0" as *const u8
                    as *const libc::c_char,
                LocalName.as_mut_ptr(),
                (*CmdPtr).EventID as libc::c_int,
                13 as libc::c_int as libc::c_ulong,
            );
            Status = 0xc2000006 as libc::c_uint as CFE_Status_t;
        }
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            13 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            13 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            13 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ResetAllFiltersCmd(
    mut data: *const CFE_EVS_ResetAllFiltersCmd_t,
) -> int32 {
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut CmdPtr: *const CFE_EVS_AppNameCmd_Payload_t = &(*data).Payload;
    let mut Status: int32 = 0;
    let mut i: uint32 = 0;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        i = 0 as libc::c_int as uint32;
        while i < 8 as libc::c_int as libc::c_uint {
            (*AppDataPtr).BinFilters[i as usize].Count = 0 as libc::c_int as uint16;
            i = i.wrapping_add(1);
            i;
        }
        EVS_SendEvent(
            29 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Reset All Filters Command Received with AppName = %s\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
        );
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            14 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            14 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            14 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_AddEventFilterCmd(
    mut data: *const CFE_EVS_AddEventFilterCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_AppNameEventIDMaskCmd_Payload_t = &(*data).Payload;
    let mut FilterPtr: *mut EVS_BinFilter_t = 0 as *mut EVS_BinFilter_t;
    let mut Status: int32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        FilterPtr = EVS_FindEventID((*CmdPtr).EventID, ((*AppDataPtr).BinFilters).as_mut_ptr());
        if !FilterPtr.is_null() {
            EVS_SendEvent(
                37 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Add Filter Command:AppName = %s, EventID = 0x%08x is already registered for filtering\0"
                    as *const u8 as *const libc::c_char,
                LocalName.as_mut_ptr(),
                (*CmdPtr).EventID as libc::c_uint,
            );
            Status = 0xc2000006 as libc::c_uint as CFE_Status_t;
        } else {
            FilterPtr = EVS_FindEventID(
                -(1 as libc::c_int) as uint16,
                ((*AppDataPtr).BinFilters).as_mut_ptr(),
            );
            if !FilterPtr.is_null() {
                (*FilterPtr).EventID = (*CmdPtr).EventID;
                (*FilterPtr).Mask = (*CmdPtr).Mask;
                (*FilterPtr).Count = 0 as libc::c_int as uint16;
                EVS_SendEvent(
                    30 as libc::c_int as uint16,
                    CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                    b"Add Filter Command Received with AppName = %s, EventID = 0x%08x, Mask = 0x%04x\0"
                        as *const u8 as *const libc::c_char,
                    LocalName.as_mut_ptr(),
                    (*CmdPtr).EventID as libc::c_uint,
                    (*CmdPtr).Mask as libc::c_uint,
                );
            } else {
                EVS_SendEvent(
                    11 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Add Filter Command: number of registered filters has reached max = %d\0"
                        as *const u8 as *const libc::c_char,
                    8 as libc::c_int,
                );
                Status = 0xc2000004 as libc::c_uint as CFE_Status_t;
            }
        }
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            15 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            15 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            15 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_DeleteEventFilterCmd(
    mut data: *const CFE_EVS_DeleteEventFilterCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_EVS_AppNameEventIDCmd_Payload_t = &(*data).Payload;
    let mut FilterPtr: *mut EVS_BinFilter_t = 0 as *mut EVS_BinFilter_t;
    let mut Status: int32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut LocalName: [libc::c_char; 20] = [0; 20];
    CFE_SB_MessageStringGet(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    Status = EVS_GetApplicationInfo(&mut AppDataPtr, LocalName.as_mut_ptr());
    if Status == 0 as libc::c_int {
        FilterPtr = EVS_FindEventID((*CmdPtr).EventID, ((*AppDataPtr).BinFilters).as_mut_ptr());
        if !FilterPtr.is_null() {
            (*FilterPtr).EventID = -(1 as libc::c_int) as uint16;
            (*FilterPtr).Mask = 0 as libc::c_int as uint16;
            (*FilterPtr).Count = 0 as libc::c_int as uint16;
            EVS_SendEvent(
                31 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Delete Filter Command Received with AppName = %s, EventID = 0x%08x\0" as *const u8
                    as *const libc::c_char,
                LocalName.as_mut_ptr(),
                (*CmdPtr).EventID as libc::c_uint,
            );
        } else {
            EVS_SendEvent(
                6 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"%s Event ID %d not registered for filtering: CC = %lu\0" as *const u8
                    as *const libc::c_char,
                LocalName.as_mut_ptr(),
                (*CmdPtr).EventID as libc::c_int,
                16 as libc::c_int as libc::c_ulong,
            );
            Status = 0xc2000006 as libc::c_uint as CFE_Status_t;
        }
    } else if Status == 0xc2000002 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"%s not registered with EVS: CC = %lu\0" as *const u8 as *const libc::c_char,
            LocalName.as_mut_ptr(),
            16 as libc::c_int as libc::c_ulong,
        );
    } else if Status == 0xc2000003 as libc::c_uint as CFE_Status_t {
        EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Illegal application ID retrieved for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            16 as libc::c_int as libc::c_ulong,
        );
    } else {
        EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to retrieve application ID for %s: CC = %lu\0" as *const u8
                as *const libc::c_char,
            LocalName.as_mut_ptr(),
            16 as libc::c_int as libc::c_ulong,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_WriteAppDataFileCmd(
    mut data: *const CFE_EVS_WriteAppDataFileCmd_t,
) -> int32 {
    let mut Result: int32 = 0;
    let mut FileHandle: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut OsStatus: int32 = 0;
    let mut BytesWritten: int32 = 0;
    let mut EntryCount: uint32 = 0 as libc::c_int as uint32;
    let mut i: uint32 = 0;
    static mut AppDataFile: CFE_EVS_AppDataFile_t = CFE_EVS_AppDataFile_t {
        AppName: [0; 20],
        ActiveFlag: 0,
        EventTypesActiveFlag: 0,
        EventCount: 0,
        SquelchedCount: 0,
        Spare: [0; 3],
        Filters: [EVS_BinFilter_t {
            EventID: 0,
            Mask: 0,
            Count: 0,
            Padding: 0,
        }; 8],
    };
    let mut FileHdr: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut CmdPtr: *const CFE_EVS_AppDataCmd_Payload_t = &(*data).Payload;
    let mut LocalName: [libc::c_char; 64] = [0; 64];
    Result = CFE_FS_ParseInputFileNameEx(
        LocalName.as_mut_ptr(),
        ((*CmdPtr).AppDataFilename).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"/ram/cfe_evs_app.dat\0" as *const u8 as *const libc::c_char,
        CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
    );
    if Result != 0 as libc::c_int {
        EVS_SendEvent(
            13 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Write App Data Command Error: CFE_FS_ParseInputFileNameEx() = 0x%08X\0" as *const u8
                as *const libc::c_char,
            Result as libc::c_uint,
        );
    } else {
        OsStatus = OS_OpenCreate(
            &mut FileHandle,
            LocalName.as_mut_ptr(),
            OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
            1 as libc::c_int,
        );
        if OsStatus != 0 as libc::c_int {
            EVS_SendEvent(
                13 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Write App Data Command Error: OS_OpenCreate = %ld, filename = %s\0" as *const u8
                    as *const libc::c_char,
                OsStatus as libc::c_long,
                LocalName.as_mut_ptr(),
            );
            Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    }
    if Result == 0 as libc::c_int {
        Result = 0xc2000007 as libc::c_uint as CFE_Status_t;
        CFE_FS_InitHeader(
            &mut FileHdr,
            b"EVS Application Data File\0" as *const u8 as *const libc::c_char,
            CFE_FS_SubType_EVS_APPDATA as libc::c_int as uint32,
        );
        BytesWritten = CFE_FS_WriteHeader(FileHandle, &mut FileHdr);
        if BytesWritten as libc::c_ulong
            == ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong
        {
            AppDataPtr = (CFE_EVS_Global.AppData).as_mut_ptr();
            i = 0 as libc::c_int as uint32;
            while i < 32 as libc::c_int as libc::c_uint {
                if EVS_AppDataIsUsed(AppDataPtr) {
                    memset(
                        &mut AppDataFile as *mut CFE_EVS_AppDataFile_t as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<CFE_EVS_AppDataFile_t>() as libc::c_ulong,
                    );
                    CFE_ES_GetAppName(
                        (AppDataFile.AppName).as_mut_ptr(),
                        EVS_AppDataGetID(AppDataPtr),
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
                    );
                    AppDataFile.ActiveFlag = (*AppDataPtr).ActiveFlag;
                    AppDataFile.EventCount = (*AppDataPtr).EventCount;
                    AppDataFile.EventTypesActiveFlag = (*AppDataPtr).EventTypesActiveFlag;
                    AppDataFile.SquelchedCount = (*AppDataPtr).SquelchedCount;
                    memcpy(
                        (AppDataFile.Filters).as_mut_ptr() as *mut libc::c_void,
                        ((*AppDataPtr).BinFilters).as_mut_ptr() as *const libc::c_void,
                        (8 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<EVS_BinFilter_t>() as libc::c_ulong
                            ),
                    );
                    OsStatus = OS_write(
                        FileHandle,
                        &mut AppDataFile as *mut CFE_EVS_AppDataFile_t as *const libc::c_void,
                        ::core::mem::size_of::<CFE_EVS_AppDataFile_t>() as libc::c_ulong,
                    );
                    if OsStatus as libc::c_ulong
                        == ::core::mem::size_of::<CFE_EVS_AppDataFile_t>() as libc::c_ulong
                    {
                        EntryCount = EntryCount.wrapping_add(1);
                        EntryCount;
                    } else {
                        EVS_SendEvent(
                            12 as libc::c_int as uint16,
                            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                            b"Write App Data Command Error: OS_write = %ld, filename = %s\0"
                                as *const u8 as *const libc::c_char,
                            OsStatus as libc::c_long,
                            LocalName.as_mut_ptr(),
                        );
                        break;
                    }
                }
                AppDataPtr = AppDataPtr.offset(1);
                AppDataPtr;
                i = i.wrapping_add(1);
                i;
            }
            if i == 32 as libc::c_int as libc::c_uint {
                EVS_SendEvent(
                    32 as libc::c_int as uint16,
                    CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                    b"Write App Data Command: %d application data entries written to %s\0"
                        as *const u8 as *const libc::c_char,
                    EntryCount as libc::c_int,
                    LocalName.as_mut_ptr(),
                );
                Result = 0 as libc::c_int;
            }
        }
        OS_close(FileHandle);
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_GetAppDataByID(mut AppID: CFE_ES_AppId_t) -> *mut EVS_AppData_t {
    let mut AppIndex: uint32 = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    if CFE_ES_AppID_ToIndex(AppID, &mut AppIndex) == 0 as libc::c_int
        && AppIndex < 32 as libc::c_int as libc::c_uint
    {
        AppDataPtr = &mut *(CFE_EVS_Global.AppData)
            .as_mut_ptr()
            .offset(AppIndex as isize) as *mut EVS_AppData_t;
    } else {
        AppDataPtr = 0 as *mut EVS_AppData_t;
    }
    return AppDataPtr;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_GetCurrentContext(
    mut AppDataOut: *mut *mut EVS_AppData_t,
    mut AppIDOut: *mut CFE_ES_AppId_t,
) -> int32 {
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    let mut Status: int32 = 0;
    Status = CFE_ES_GetAppID(&mut AppID);
    if Status == 0 as libc::c_int {
        AppDataPtr = EVS_GetAppDataByID(AppID);
    } else {
        AppDataPtr = 0 as *mut EVS_AppData_t;
    }
    if AppDataPtr.is_null() {
        Status = 0xc2000003 as libc::c_uint as CFE_Status_t;
    }
    if !AppIDOut.is_null() {
        *AppIDOut = AppID;
    }
    if !AppDataOut.is_null() {
        *AppDataOut = AppDataPtr;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_GetApplicationInfo(
    mut AppDataOut: *mut *mut EVS_AppData_t,
    mut pAppName: *const libc::c_char,
) -> int32 {
    let mut Status: int32 = 0;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    Status = CFE_ES_GetAppIDByName(&mut AppID, pAppName);
    if Status != 0 as libc::c_int {
        AppDataPtr = 0 as *mut EVS_AppData_t;
    } else {
        AppDataPtr = EVS_GetAppDataByID(AppID);
        if AppDataPtr.is_null() {
            Status = 0xc2000003 as libc::c_uint as CFE_Status_t;
        } else if !EVS_AppDataIsMatch(AppDataPtr, AppID) {
            AppDataPtr = 0 as *mut EVS_AppData_t;
            Status = 0xc2000002 as libc::c_uint as CFE_Status_t;
        }
    }
    *AppDataOut = AppDataPtr;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_NotRegistered(
    mut AppDataPtr: *mut EVS_AppData_t,
    mut CallerID: CFE_ES_AppId_t,
) -> int32 {
    let mut AppName: [libc::c_char; 20] = [0; 20];
    if !CFE_ResourceId_Equal((*AppDataPtr).UnregAppID, CallerID) {
        CFE_EVS_Global.EVS_TlmPkt.Payload.UnregisteredAppCounter =
            (CFE_EVS_Global.EVS_TlmPkt.Payload.UnregisteredAppCounter).wrapping_add(1);
        CFE_EVS_Global.EVS_TlmPkt.Payload.UnregisteredAppCounter;
        (*AppDataPtr).UnregAppID = CallerID;
        CFE_ES_GetAppName(
            AppName.as_mut_ptr(),
            CallerID,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        EVS_SendEvent(
            41 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"App %s not registered with Event Services. Unable to send event.\0" as *const u8
                as *const libc::c_char,
            AppName.as_mut_ptr(),
        );
        CFE_ES_WriteToSysLog(
            b"%s: App %s not registered with Event Services. Unable to send event.\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"EVS_NotRegistered\0"))
                .as_ptr(),
            AppName.as_mut_ptr(),
        );
    }
    return 0xc2000002 as libc::c_uint as CFE_Status_t;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_IsFiltered(
    mut AppDataPtr: *mut EVS_AppData_t,
    mut EventID: uint16,
    mut EventType: uint16,
) -> bool {
    let mut FilterPtr: *mut EVS_BinFilter_t = 0 as *mut EVS_BinFilter_t;
    let mut Filtered: bool = 0 as libc::c_int != 0;
    let mut AppName: [libc::c_char; 20] = [0; 20];
    if (*AppDataPtr).ActiveFlag as libc::c_int == 0 as libc::c_int {
        Filtered = 1 as libc::c_int != 0;
    } else {
        match EventType as libc::c_int {
            1 => {
                if (*AppDataPtr).EventTypesActiveFlag as libc::c_int & 0x1 as libc::c_int
                    == 0 as libc::c_int
                {
                    Filtered = 1 as libc::c_int != 0;
                }
            }
            2 => {
                if (*AppDataPtr).EventTypesActiveFlag as libc::c_int & 0x2 as libc::c_int
                    == 0 as libc::c_int
                {
                    Filtered = 1 as libc::c_int != 0;
                }
            }
            3 => {
                if (*AppDataPtr).EventTypesActiveFlag as libc::c_int & 0x4 as libc::c_int
                    == 0 as libc::c_int
                {
                    Filtered = 1 as libc::c_int != 0;
                }
            }
            4 => {
                if (*AppDataPtr).EventTypesActiveFlag as libc::c_int & 0x8 as libc::c_int
                    == 0 as libc::c_int
                {
                    Filtered = 1 as libc::c_int != 0;
                }
            }
            _ => {
                Filtered = 1 as libc::c_int != 0;
            }
        }
    }
    if Filtered as libc::c_int == 0 as libc::c_int {
        FilterPtr = EVS_FindEventID(EventID, ((*AppDataPtr).BinFilters).as_mut_ptr());
        if !FilterPtr.is_null() {
            if (*FilterPtr).Mask as libc::c_int & (*FilterPtr).Count as libc::c_int
                != 0 as libc::c_int
            {
                Filtered = 1 as libc::c_int != 0;
            }
            if ((*FilterPtr).Count as libc::c_int) < 65535 as libc::c_int {
                (*FilterPtr).Count = ((*FilterPtr).Count).wrapping_add(1);
                (*FilterPtr).Count;
                if (*FilterPtr).Count as libc::c_int == 65535 as libc::c_int {
                    CFE_ES_GetAppName(
                        AppName.as_mut_ptr(),
                        EVS_AppDataGetID(AppDataPtr),
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
                    );
                    EVS_SendEvent(
                        42 as libc::c_int as uint16,
                        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                        b"Max filter count reached, AppName = %s, EventID = 0x%08x: Filter locked until reset\0"
                            as *const u8 as *const libc::c_char,
                        AppName.as_mut_ptr(),
                        EventID as libc::c_uint,
                    );
                }
            }
        }
    }
    return Filtered;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_CheckAndIncrementSquelchTokens(
    mut AppDataPtr: *mut EVS_AppData_t,
) -> bool {
    let mut NotSquelched: bool = 1 as libc::c_int != 0;
    let mut SendSquelchEvent: bool = 0 as libc::c_int != 0;
    let mut CurrentTime: OS_time_t = {
        let mut init = OS_time_t {
            ticks: 0 as libc::c_int as int64,
        };
        init
    };
    let mut DeltaTimeMs: int64 = 0;
    let mut CreditCount: int64 = 0;
    let mut AppName: [libc::c_char; 20] = [0; 20];
    let UPPER_THRESHOLD: int32 = (CFE_EVS_Global.EVS_EventBurstMax)
        .wrapping_mul(1000 as libc::c_int as libc::c_uint)
        as int32;
    let LOWER_THRESHOLD: int32 = -(CFE_EVS_Global.EVS_EventBurstMax as int32) * 1000 as libc::c_int;
    let EVENT_COST: int32 = 1000 as libc::c_int;
    if CFE_EVS_Global.EVS_EventBurstMax != 0 as libc::c_int as libc::c_uint {
        OS_MutSemTake(CFE_EVS_Global.EVS_SharedDataMutexID);
        CFE_PSP_GetTime(&mut CurrentTime);
        DeltaTimeMs = OS_TimeGetTotalMilliseconds(OS_TimeSubtract(
            CurrentTime,
            (*AppDataPtr).LastSquelchCreditableTime,
        ));
        CreditCount = DeltaTimeMs * 15 as libc::c_int as libc::c_long;
        if CreditCount >= EVENT_COST as libc::c_long {
            (*AppDataPtr).LastSquelchCreditableTime = CurrentTime;
            if (*AppDataPtr).SquelchTokens as libc::c_long + CreditCount
                > UPPER_THRESHOLD as libc::c_long
            {
                (*AppDataPtr).SquelchTokens = UPPER_THRESHOLD;
            } else {
                (*AppDataPtr).SquelchTokens += CreditCount as int32;
            }
        }
        if (*AppDataPtr).SquelchTokens <= 0 as libc::c_int {
            if ((*AppDataPtr).SquelchedCount as libc::c_int) < 255 as libc::c_int {
                (*AppDataPtr).SquelchedCount = ((*AppDataPtr).SquelchedCount).wrapping_add(1);
                (*AppDataPtr).SquelchedCount;
            }
            NotSquelched = 0 as libc::c_int != 0;
            if (*AppDataPtr).SquelchTokens > -EVENT_COST && CreditCount < EVENT_COST as libc::c_long
            {
                SendSquelchEvent = 1 as libc::c_int != 0;
            }
        }
        if (*AppDataPtr).SquelchTokens - EVENT_COST < LOWER_THRESHOLD {
            (*AppDataPtr).SquelchTokens = LOWER_THRESHOLD;
        } else {
            (*AppDataPtr).SquelchTokens -= EVENT_COST;
        }
        OS_MutSemGive(CFE_EVS_Global.EVS_SharedDataMutexID);
        if SendSquelchEvent {
            CFE_ES_GetAppName(
                AppName.as_mut_ptr(),
                EVS_AppDataGetID(AppDataPtr),
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
            );
            EVS_SendEvent(
                44 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Events squelched, AppName = %s\0" as *const u8 as *const libc::c_char,
                AppName.as_mut_ptr(),
            );
        }
    }
    return NotSquelched;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_FindEventID(
    mut EventID: uint16,
    mut FilterArray: *mut EVS_BinFilter_t,
) -> *mut EVS_BinFilter_t {
    let mut i: uint32 = 0;
    i = 0 as libc::c_int as uint32;
    while i < 8 as libc::c_int as libc::c_uint {
        if (*FilterArray.offset(i as isize)).EventID as libc::c_int == EventID as libc::c_int {
            return &mut *FilterArray.offset(i as isize) as *mut EVS_BinFilter_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as *mut libc::c_void as *mut EVS_BinFilter_t;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_EnableTypes(mut AppDataPtr: *mut EVS_AppData_t, mut BitMask: uint8) {
    let mut EventTypeBits: uint8 =
        (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int | 0x8 as libc::c_int)
            as uint8;
    (*AppDataPtr).EventTypesActiveFlag = ((*AppDataPtr).EventTypesActiveFlag as libc::c_int
        | BitMask as libc::c_int & EventTypeBits as libc::c_int)
        as uint8;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_DisableTypes(mut AppDataPtr: *mut EVS_AppData_t, mut BitMask: uint8) {
    let mut EventTypeBits: uint8 =
        (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int | 0x8 as libc::c_int)
            as uint8;
    (*AppDataPtr).EventTypesActiveFlag = ((*AppDataPtr).EventTypesActiveFlag as libc::c_int
        & !(BitMask as libc::c_int & EventTypeBits as libc::c_int))
        as uint8;
}
#[no_mangle]
pub unsafe extern "C" fn EVS_GenerateEventTelemetry(
    mut AppDataPtr: *mut EVS_AppData_t,
    mut EventID: uint16,
    mut EventType: uint16,
    mut TimeStamp: *const CFE_TIME_SysTime_t,
    mut MsgSpec: *const libc::c_char,
    mut ArgPtr: ::core::ffi::VaList,
) {
    let mut LongEventTlm: CFE_EVS_LongEventTlm_t = CFE_EVS_LongEventTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_EVS_LongEventTlm_Payload_t {
            PacketID: CFE_EVS_PacketID_t {
                AppName: [0; 20],
                EventID: 0,
                EventType: 0,
                SpacecraftID: 0,
                ProcessorID: 0,
            },
            Message: [0; 122],
            Spare1: 0,
            Spare2: 0,
        },
    };
    let mut ShortEventTlm: CFE_EVS_ShortEventTlm_t = CFE_EVS_ShortEventTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_EVS_ShortEventTlm_Payload_t {
            PacketID: CFE_EVS_PacketID_t {
                AppName: [0; 20],
                EventID: 0,
                EventType: 0,
                SpacecraftID: 0,
                ProcessorID: 0,
            },
        },
    };
    let mut ExpandedLength: libc::c_int = 0;
    memset(
        &mut LongEventTlm as *mut CFE_EVS_LongEventTlm_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_EVS_LongEventTlm_t>() as libc::c_ulong,
    );
    memset(
        &mut ShortEventTlm as *mut CFE_EVS_ShortEventTlm_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_EVS_ShortEventTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut LongEventTlm.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 8 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_EVS_LongEventTlm_t>() as libc::c_ulong,
    );
    LongEventTlm.Payload.PacketID.EventID = EventID;
    LongEventTlm.Payload.PacketID.EventType = EventType;
    ExpandedLength = vsnprintf(
        (LongEventTlm.Payload.Message).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 122]>() as libc::c_ulong,
        MsgSpec,
        ArgPtr.as_va_list(),
    );
    if ExpandedLength
        >= ::core::mem::size_of::<[libc::c_char; 122]>() as libc::c_ulong as libc::c_int
    {
        LongEventTlm.Payload.Message[(::core::mem::size_of::<[libc::c_char; 122]>()
            as libc::c_ulong)
            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
            as usize] = '$' as i32 as libc::c_char;
        CFE_EVS_Global.EVS_TlmPkt.Payload.MessageTruncCounter =
            (CFE_EVS_Global.EVS_TlmPkt.Payload.MessageTruncCounter).wrapping_add(1);
        CFE_EVS_Global.EVS_TlmPkt.Payload.MessageTruncCounter;
    }
    CFE_ES_GetAppName(
        (LongEventTlm.Payload.PacketID.AppName).as_mut_ptr(),
        EVS_AppDataGetID(AppDataPtr),
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    LongEventTlm.Payload.PacketID.SpacecraftID = CFE_PSP_GetSpacecraftId();
    LongEventTlm.Payload.PacketID.ProcessorID = CFE_PSP_GetProcessorId();
    CFE_MSG_SetMsgTime(&mut LongEventTlm.TelemetryHeader.Msg, *TimeStamp);
    EVS_AddLog(&mut LongEventTlm);
    EVS_SendViaPorts(&mut LongEventTlm);
    if CFE_EVS_Global.EVS_TlmPkt.Payload.MessageFormatMode as libc::c_int
        == CFE_EVS_MsgFormat_LONG as libc::c_int
    {
        CFE_SB_TransmitMsg(&mut LongEventTlm.TelemetryHeader.Msg, 1 as libc::c_int != 0);
    } else if CFE_EVS_Global.EVS_TlmPkt.Payload.MessageFormatMode as libc::c_int
        == CFE_EVS_MsgFormat_SHORT as libc::c_int
    {
        CFE_MSG_Init(
            &mut ShortEventTlm.TelemetryHeader.Msg,
            CFE_SB_ValueToMsgId((0x800 as libc::c_int | 9 as libc::c_int) as CFE_SB_MsgId_Atom_t),
            ::core::mem::size_of::<CFE_EVS_ShortEventTlm_t>() as libc::c_ulong,
        );
        CFE_MSG_SetMsgTime(&mut ShortEventTlm.TelemetryHeader.Msg, *TimeStamp);
        ShortEventTlm.Payload.PacketID = LongEventTlm.Payload.PacketID;
        CFE_SB_TransmitMsg(
            &mut ShortEventTlm.TelemetryHeader.Msg,
            1 as libc::c_int != 0,
        );
    }
    if (CFE_EVS_Global.EVS_TlmPkt.Payload.MessageSendCounter as libc::c_int) < 65535 as libc::c_int
    {
        CFE_EVS_Global.EVS_TlmPkt.Payload.MessageSendCounter =
            (CFE_EVS_Global.EVS_TlmPkt.Payload.MessageSendCounter).wrapping_add(1);
        CFE_EVS_Global.EVS_TlmPkt.Payload.MessageSendCounter;
    }
    if ((*AppDataPtr).EventCount as libc::c_int) < 65535 as libc::c_int {
        (*AppDataPtr).EventCount = ((*AppDataPtr).EventCount).wrapping_add(1);
        (*AppDataPtr).EventCount;
    }
}
#[no_mangle]
pub unsafe extern "C" fn EVS_SendViaPorts(mut EVS_PktPtr: *mut CFE_EVS_LongEventTlm_t) {
    let mut PortMessage: [libc::c_char; 172] = [0; 172];
    let mut TimeBuffer: [libc::c_char; 24] = [0; 24];
    let mut PktTime: CFE_TIME_SysTime_t = {
        let mut init = CFE_TIME_SysTime {
            Seconds: 0 as libc::c_int as uint32,
            Subseconds: 0,
        };
        init
    };
    CFE_MSG_GetMsgTime(&mut (*EVS_PktPtr).TelemetryHeader.Msg, &mut PktTime);
    CFE_TIME_Print(TimeBuffer.as_mut_ptr(), PktTime);
    snprintf(
        PortMessage.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 172]>() as libc::c_ulong,
        b"%s %u/%u/%s %u: %s\0" as *const u8 as *const libc::c_char,
        TimeBuffer.as_mut_ptr(),
        (*EVS_PktPtr).Payload.PacketID.SpacecraftID,
        (*EVS_PktPtr).Payload.PacketID.ProcessorID,
        ((*EVS_PktPtr).Payload.PacketID.AppName).as_mut_ptr(),
        (*EVS_PktPtr).Payload.PacketID.EventID as libc::c_uint,
        ((*EVS_PktPtr).Payload.Message).as_mut_ptr(),
    );
    if CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort as libc::c_int & 0x1 as libc::c_int != 0 {
        EVS_OutputPort(1 as libc::c_int as uint8, PortMessage.as_mut_ptr());
    }
    if CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort as libc::c_int & 0x2 as libc::c_int != 0 {
        EVS_OutputPort(2 as libc::c_int as uint8, PortMessage.as_mut_ptr());
    }
    if CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort as libc::c_int & 0x4 as libc::c_int != 0 {
        EVS_OutputPort(3 as libc::c_int as uint8, PortMessage.as_mut_ptr());
    }
    if CFE_EVS_Global.EVS_TlmPkt.Payload.OutputPort as libc::c_int & 0x8 as libc::c_int != 0 {
        EVS_OutputPort(4 as libc::c_int as uint8, PortMessage.as_mut_ptr());
    }
}
#[no_mangle]
pub unsafe extern "C" fn EVS_OutputPort(mut PortNum: uint8, mut Message: *mut libc::c_char) {
    OS_printf(
        b"EVS Port%u %s\n\0" as *const u8 as *const libc::c_char,
        PortNum as libc::c_int,
        Message,
    );
}
#[no_mangle]
pub unsafe extern "C" fn EVS_SendEvent(
    mut EventID: uint16,
    mut EventType: uint16,
    mut Spec: *const libc::c_char,
    mut args: ...
) -> int32 {
    let mut Time: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut Ptr: ::core::ffi::VaListImpl;
    let mut AppDataPtr: *mut EVS_AppData_t = 0 as *mut EVS_AppData_t;
    AppDataPtr = EVS_GetAppDataByID(CFE_EVS_Global.EVS_AppID);
    if EVS_AppDataIsMatch(AppDataPtr, CFE_EVS_Global.EVS_AppID) as libc::c_int != 0
        && EVS_IsFiltered(AppDataPtr, EventID, EventType) as libc::c_int == 0 as libc::c_int
    {
        Time = CFE_TIME_GetTime();
        Ptr = args.clone();
        EVS_GenerateEventTelemetry(
            AppDataPtr,
            EventID,
            EventType,
            &mut Time,
            Spec,
            Ptr.as_va_list(),
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ProcessCommandPacket(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MessageID: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MessageID);
    match CFE_SB_MsgIdToValue(MessageID) {
        6145 => {
            CFE_EVS_ProcessGroundCommand(SBBufPtr, MessageID);
        }
        6153 => {
            CFE_EVS_ReportHousekeepingCmd(SBBufPtr as *const CFE_EVS_SendHkCmd_t);
        }
        _ => {
            CFE_EVS_Global.EVS_TlmPkt.Payload.CommandErrorCounter =
                (CFE_EVS_Global.EVS_TlmPkt.Payload.CommandErrorCounter).wrapping_add(1);
            CFE_EVS_Global.EVS_TlmPkt.Payload.CommandErrorCounter;
            EVS_SendEvent(
                5 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Invalid command packet, Message ID = 0x%08X\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MessageID),
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_ProcessGroundCommand(
    mut SBBufPtr: *const CFE_SB_Buffer_t,
    mut MsgId: CFE_SB_MsgId_t,
) {
    let mut Status: int32 = 0xc8000002 as libc::c_uint as CFE_Status_t;
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut FcnCode);
    match FcnCode as libc::c_int {
        0 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_NoopCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_NoopCmd(SBBufPtr as *const CFE_EVS_NoopCmd_t);
            }
        }
        1 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_ResetCountersCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_ResetCountersCmd(SBBufPtr as *const CFE_EVS_ResetCountersCmd_t);
            }
        }
        2 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_EnableEventTypeCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_EnableEventTypeCmd(SBBufPtr as *const CFE_EVS_EnableEventTypeCmd_t);
            }
        }
        3 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_DisableEventTypeCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_DisableEventTypeCmd(SBBufPtr as *const CFE_EVS_DisableEventTypeCmd_t);
            }
        }
        4 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_SetEventFormatModeCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_SetEventFormatModeCmd(
                    SBBufPtr as *const CFE_EVS_SetEventFormatModeCmd_t,
                );
            }
        }
        5 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_EnableAppEventTypeCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_EnableAppEventTypeCmd(
                    SBBufPtr as *const CFE_EVS_EnableAppEventTypeCmd_t,
                );
            }
        }
        6 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_DisableAppEventTypeCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_DisableAppEventTypeCmd(
                    SBBufPtr as *const CFE_EVS_DisableAppEventTypeCmd_t,
                );
            }
        }
        7 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_EnableAppEventsCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_EnableAppEventsCmd(SBBufPtr as *const CFE_EVS_EnableAppEventsCmd_t);
            }
        }
        8 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_DisableAppEventsCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_DisableAppEventsCmd(SBBufPtr as *const CFE_EVS_DisableAppEventsCmd_t);
            }
        }
        9 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_ResetAppCounterCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_ResetAppCounterCmd(SBBufPtr as *const CFE_EVS_ResetAppCounterCmd_t);
            }
        }
        10 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_SetFilterCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_SetFilterCmd(SBBufPtr as *const CFE_EVS_SetFilterCmd_t);
            }
        }
        11 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_EnablePortsCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_EnablePortsCmd(SBBufPtr as *const CFE_EVS_EnablePortsCmd_t);
            }
        }
        12 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_DisablePortsCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_DisablePortsCmd(SBBufPtr as *const CFE_EVS_DisablePortsCmd_t);
            }
        }
        13 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_ResetFilterCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_ResetFilterCmd(SBBufPtr as *const CFE_EVS_ResetFilterCmd_t);
            }
        }
        14 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_ResetAllFiltersCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_ResetAllFiltersCmd(SBBufPtr as *const CFE_EVS_ResetAllFiltersCmd_t);
            }
        }
        15 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_AddEventFilterCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_AddEventFilterCmd(SBBufPtr as *const CFE_EVS_AddEventFilterCmd_t);
            }
        }
        16 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_DeleteEventFilterCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_DeleteEventFilterCmd(SBBufPtr as *const CFE_EVS_DeleteEventFilterCmd_t);
            }
        }
        17 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_WriteAppDataFileCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_WriteAppDataFileCmd(SBBufPtr as *const CFE_EVS_WriteAppDataFileCmd_t);
            }
        }
        19 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_SetLogModeCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_SetLogModeCmd(SBBufPtr as *const CFE_EVS_SetLogModeCmd_t);
            }
        }
        20 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_ClearLogCmd_t>() as libc::c_ulong,
            ) {
                Status = CFE_EVS_ClearLogCmd(SBBufPtr as *const CFE_EVS_ClearLogCmd_t);
            }
        }
        18 => {
            if CFE_EVS_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CFE_EVS_WriteLogDataFileCmd_t>() as libc::c_ulong,
            ) {
                Status =
                    CFE_EVS_WriteLogDataFileCmd(SBBufPtr as *const CFE_EVS_WriteLogDataFileCmd_t);
            }
        }
        _ => {
            EVS_SendEvent(
                15 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Invalid command code -- ID = 0x%08x, CC = %u\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                FcnCode as libc::c_uint,
            );
            Status = 0xc8000004 as libc::c_uint as CFE_Status_t;
        }
    }
    if Status == 0 as libc::c_int {
        CFE_EVS_Global.EVS_TlmPkt.Payload.CommandCounter =
            (CFE_EVS_Global.EVS_TlmPkt.Payload.CommandCounter).wrapping_add(1);
        CFE_EVS_Global.EVS_TlmPkt.Payload.CommandCounter;
    } else if Status < 0 as libc::c_int {
        CFE_EVS_Global.EVS_TlmPkt.Payload.CommandErrorCounter =
            (CFE_EVS_Global.EVS_TlmPkt.Payload.CommandErrorCounter).wrapping_add(1);
        CFE_EVS_Global.EVS_TlmPkt.Payload.CommandErrorCounter;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_EVS_VerifyCmdLength(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut ExpectedLength: size_t,
) -> bool {
    let mut result: bool = 1 as libc::c_int != 0;
    let mut ActualLength: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetSize(MsgPtr, &mut ActualLength);
    if ExpectedLength != ActualLength {
        CFE_MSG_GetMsgId(MsgPtr, &mut MsgId);
        CFE_MSG_GetFcnCode(MsgPtr, &mut FcnCode);
        EVS_SendEvent(
            43 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid msg length: ID = 0x%X,  CC = %u, Len = %u, Expected = %u\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            FcnCode as libc::c_uint,
            ActualLength as libc::c_uint,
            ExpectedLength as libc::c_uint,
        );
        result = 0 as libc::c_int != 0;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_eventids_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_fcncodes_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_interface_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_internal_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_mission_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_msgdefs_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_msg_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_msgids_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_msgstruct_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_platform_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_evs_src_check_cfe_evs_topicids_h_c__CheckHeader()
{
}
#[no_mangle]
pub static mut CFE_FS_DEFAULT_SCRIPT_EXTENSION: [libc::c_char; 5] =
    unsafe { *::core::mem::transmute::<&[u8; 5], &[libc::c_char; 5]>(b".scr\0") };
#[no_mangle]
pub static mut CFE_FS_DEFAULT_TEMP_FILE_EXTENSION: [libc::c_char; 5] =
    unsafe { *::core::mem::transmute::<&[u8; 5], &[libc::c_char; 5]>(b".tmp\0") };
#[no_mangle]
pub static mut CFE_FS_DEFAULT_LOG_FILE_EXTENSION: [libc::c_char; 5] =
    unsafe { *::core::mem::transmute::<&[u8; 5], &[libc::c_char; 5]>(b".log\0") };
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_GetDefaultMountPoint(
    mut FileCategory: CFE_FS_FileCategory_t,
) -> *const libc::c_char {
    let mut Result: *const libc::c_char = 0 as *const libc::c_char;
    match FileCategory as libc::c_uint {
        4 | 1 => {
            Result = GLOBAL_CFE_CONFIGDATA.NonvolMountPoint;
        }
        5 | 2 | 3 => {
            Result = GLOBAL_CFE_CONFIGDATA.RamdiskMountPoint;
        }
        _ => {
            Result = 0 as *const libc::c_char;
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_GetDefaultExtension(
    mut FileCategory: CFE_FS_FileCategory_t,
) -> *const libc::c_char {
    let mut Result: *const libc::c_char = 0 as *const libc::c_char;
    match FileCategory as libc::c_uint {
        4 => {
            Result = CFE_FS_DEFAULT_SCRIPT_EXTENSION.as_ptr();
        }
        1 => {
            Result = GLOBAL_CONFIGDATA.Default_ModuleExtension;
        }
        5 => {
            Result = CFE_FS_DEFAULT_TEMP_FILE_EXTENSION.as_ptr();
        }
        3 => {
            Result = CFE_FS_DEFAULT_LOG_FILE_EXTENSION.as_ptr();
        }
        _ => {
            Result = 0 as *const libc::c_char;
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_ReadHeader(
    mut Hdr: *mut CFE_FS_Header_t,
    mut FileDes: osal_id_t,
) -> CFE_Status_t {
    let mut OsStatus: int32 = 0;
    let mut Result: int32 = 0;
    let mut EndianCheck: int32 = 0x1020304 as libc::c_int;
    if Hdr.is_null() {
        return 0xc6000001 as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_lseek(FileDes, 0 as libc::c_int, 0 as libc::c_int as uint32);
    if OsStatus >= 0 as libc::c_int {
        OsStatus = OS_read(
            FileDes,
            Hdr as *mut libc::c_void,
            ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong,
        );
        if *(&mut EndianCheck as *mut int32 as *mut libc::c_char) as libc::c_int
            == 0x4 as libc::c_int
        {
            CFE_FS_ByteSwapCFEHeader(Hdr);
        }
    }
    if OsStatus >= 0 as libc::c_int {
        Result = OsStatus as libc::c_long as int32;
    } else {
        Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_InitHeader(
    mut Hdr: *mut CFE_FS_Header_t,
    mut Description: *const libc::c_char,
    mut SubType: uint32,
) {
    if Hdr.is_null() || Description.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Failed invalid arguments\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_FS_InitHeader\0"))
                .as_ptr(),
        );
    } else {
        memset(
            Hdr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong,
        );
        strncpy(
            ((*Hdr).Description).as_mut_ptr(),
            Description,
            (::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*Hdr).SubType = SubType;
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_WriteHeader(
    mut FileDes: osal_id_t,
    mut Hdr: *mut CFE_FS_Header_t,
) -> CFE_Status_t {
    let mut Time: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut OsStatus: int32 = 0;
    let mut Result: int32 = 0;
    let mut EndianCheck: int32 = 0x1020304 as libc::c_int;
    let mut AppID: CFE_ES_AppId_t = 0;
    if Hdr.is_null() {
        return 0xc6000001 as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_lseek(FileDes, 0 as libc::c_int, 0 as libc::c_int as uint32);
    if OsStatus >= 0 as libc::c_int {
        (*Hdr).SpacecraftID = CFE_PSP_GetSpacecraftId();
        (*Hdr).ProcessorID = CFE_PSP_GetProcessorId();
        CFE_ES_GetAppID(&mut AppID);
        (*Hdr).ApplicationID = CFE_ResourceId_ToInteger(AppID) as uint32;
        (*Hdr).Length = ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong as uint32;
        (*Hdr).ContentType = 0x63464531 as libc::c_int as uint32;
        Time = CFE_TIME_GetTime();
        (*Hdr).TimeSeconds = Time.Seconds;
        (*Hdr).TimeSubSeconds = Time.Subseconds;
        if *(&mut EndianCheck as *mut int32 as *mut libc::c_char) as libc::c_int
            == 0x4 as libc::c_int
        {
            CFE_FS_ByteSwapCFEHeader(Hdr);
        }
        OsStatus = OS_write(
            FileDes,
            Hdr as *const libc::c_void,
            ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong,
        );
        if *(&mut EndianCheck as *mut int32 as *mut libc::c_char) as libc::c_int
            == 0x4 as libc::c_int
        {
            CFE_FS_ByteSwapCFEHeader(Hdr);
        }
    }
    if OsStatus >= 0 as libc::c_int {
        Result = OsStatus as libc::c_long as int32;
    } else {
        Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_SetTimestamp(
    mut FileDes: osal_id_t,
    mut NewTimestamp: CFE_TIME_SysTime_t,
) -> CFE_Status_t {
    let mut OsStatus: int32 = 0;
    let mut Result: int32 = 0;
    let mut TempHdr: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut EndianCheck: int32 = 0x1020304 as libc::c_int;
    let mut OutTimestamp: CFE_TIME_SysTime_t = NewTimestamp;
    let mut FileOffset: int32 = 0 as libc::c_int;
    FileOffset = (&mut TempHdr.TimeSeconds as *mut uint32 as *mut libc::c_char)
        .offset_from(&mut TempHdr.ContentType as *mut uint32 as *mut libc::c_char)
        as libc::c_long as int32;
    OsStatus = OS_lseek(FileDes, FileOffset, 0 as libc::c_int as uint32);
    if OsStatus == FileOffset {
        if *(&mut EndianCheck as *mut int32 as *mut libc::c_char) as libc::c_int
            == 0x4 as libc::c_int
        {
            CFE_FS_ByteSwapUint32(&mut OutTimestamp.Seconds);
            CFE_FS_ByteSwapUint32(&mut OutTimestamp.Subseconds);
        }
        OsStatus = OS_write(
            FileDes,
            &mut OutTimestamp as *mut CFE_TIME_SysTime_t as *const libc::c_void,
            ::core::mem::size_of::<CFE_TIME_SysTime_t>() as libc::c_ulong,
        );
        if OsStatus as libc::c_ulong
            == ::core::mem::size_of::<CFE_TIME_SysTime_t>() as libc::c_ulong
        {
            Result = 0 as libc::c_int;
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Failed to write timestamp (Status=%ld)\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                    b"CFE_FS_SetTimestamp\0",
                ))
                .as_ptr(),
                OsStatus as libc::c_long,
            );
            Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to lseek time fields (Status=%ld)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_FS_SetTimestamp\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        Result = 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_ByteSwapCFEHeader(mut Hdr: *mut CFE_FS_Header_t) {
    CFE_FS_ByteSwapUint32(&mut (*Hdr).ContentType);
    CFE_FS_ByteSwapUint32(&mut (*Hdr).SubType);
    CFE_FS_ByteSwapUint32(&mut (*Hdr).Length);
    CFE_FS_ByteSwapUint32(&mut (*Hdr).SpacecraftID);
    CFE_FS_ByteSwapUint32(&mut (*Hdr).ProcessorID);
    CFE_FS_ByteSwapUint32(&mut (*Hdr).ApplicationID);
    CFE_FS_ByteSwapUint32(&mut (*Hdr).TimeSeconds);
    CFE_FS_ByteSwapUint32(&mut (*Hdr).TimeSubSeconds);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_ByteSwapUint32(mut Uint32ToSwapPtr: *mut uint32) {
    let mut Temp: int32 = *Uint32ToSwapPtr as int32;
    let mut InPtr: *mut libc::c_char = &mut Temp as *mut int32 as *mut libc::c_char;
    let mut OutPtr: *mut libc::c_char = Uint32ToSwapPtr as *mut libc::c_char;
    *OutPtr.offset(0 as libc::c_int as isize) = *InPtr.offset(3 as libc::c_int as isize);
    *OutPtr.offset(1 as libc::c_int as isize) = *InPtr.offset(2 as libc::c_int as isize);
    *OutPtr.offset(2 as libc::c_int as isize) = *InPtr.offset(1 as libc::c_int as isize);
    *OutPtr.offset(3 as libc::c_int as isize) = *InPtr.offset(0 as libc::c_int as isize);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_ParseInputFileNameEx(
    mut OutputBuffer: *mut libc::c_char,
    mut InputBuffer: *const libc::c_char,
    mut OutputBufSize: size_t,
    mut InputBufSize: size_t,
    mut DefaultInput: *const libc::c_char,
    mut DefaultPath: *const libc::c_char,
    mut DefaultExtension: *const libc::c_char,
) -> int32 {
    let mut Status: int32 = 0;
    let mut InputPtr: *const libc::c_char = 0 as *const libc::c_char;
    let mut ComponentPtr: *const libc::c_char = 0 as *const libc::c_char;
    let mut ComponentLen: size_t = 0;
    let mut ComponentTerm: libc::c_char = 0;
    let mut OutputLen: size_t = 0;
    let mut InputLen: size_t = 0;
    let mut LastPathReached: bool = false;
    let mut Component: C2RustUnnamed_20 = PROCESS_INIT;
    if OutputBuffer.is_null() || OutputBufSize == 0 as libc::c_int as libc::c_ulong {
        return 0xc6000001 as libc::c_uint as CFE_Status_t;
    }
    Status = 0xc6000002 as libc::c_uint as CFE_Status_t;
    OutputLen = 0 as libc::c_int as size_t;
    ComponentTerm = 0 as libc::c_int as libc::c_char;
    LastPathReached = 0 as libc::c_int != 0;
    if !InputBuffer.is_null()
        && InputBufSize > 0 as libc::c_int as libc::c_ulong
        && *InputBuffer.offset(0 as libc::c_int as isize) as libc::c_int != 0 as libc::c_int
    {
        InputPtr = InputBuffer;
        InputLen = InputBufSize;
    } else if !DefaultInput.is_null() {
        InputPtr = DefaultInput;
        InputLen = strlen(DefaultInput);
    } else {
        InputPtr = 0 as *const libc::c_char;
        InputLen = 0 as libc::c_int as size_t;
    }
    Component = PROCESS_INIT;
    while !InputPtr.is_null()
        && (Component as libc::c_uint) < END_COMPONENT as libc::c_int as libc::c_uint
    {
        if Component as libc::c_uint == PATHNAME_SEPARATOR as libc::c_int as libc::c_uint
            && !LastPathReached
        {
            Component = PATHNAME_COMPONENT;
        } else {
            Component += 1;
            Component;
        }
        match Component as libc::c_uint {
            1 => {
                ComponentTerm = '/' as i32 as libc::c_char;
                ComponentPtr = memchr(
                    InputPtr as *const libc::c_void,
                    ComponentTerm as libc::c_int,
                    InputLen,
                ) as *const libc::c_char;
                if !ComponentPtr.is_null() {
                    ComponentLen = ComponentPtr.offset_from(InputPtr) as libc::c_long as size_t;
                    ComponentPtr = InputPtr;
                    InputPtr = InputPtr.offset(ComponentLen as isize);
                    InputLen =
                        (InputLen as libc::c_ulong).wrapping_sub(ComponentLen) as size_t as size_t;
                } else {
                    LastPathReached = 1 as libc::c_int != 0;
                    if !DefaultPath.is_null() && OutputLen == 0 as libc::c_int as libc::c_ulong {
                        ComponentLen = strlen(DefaultPath);
                        ComponentPtr = DefaultPath;
                    } else {
                        ComponentLen = 0 as libc::c_int as size_t;
                        ComponentPtr = 0 as *const libc::c_char;
                    }
                }
            }
            3 => {
                ComponentTerm = '.' as i32 as libc::c_char;
                ComponentPtr = memchr(
                    InputPtr as *const libc::c_void,
                    ComponentTerm as libc::c_int,
                    InputLen,
                ) as *const libc::c_char;
                if !ComponentPtr.is_null() {
                    ComponentLen = ComponentPtr.offset_from(InputPtr) as libc::c_long as size_t;
                    ComponentPtr = InputPtr;
                    InputPtr = InputPtr.offset(ComponentLen as isize);
                    InputLen =
                        (InputLen as libc::c_ulong).wrapping_sub(ComponentLen) as size_t as size_t;
                } else {
                    ComponentLen = InputLen;
                    ComponentPtr = InputPtr;
                    if !DefaultExtension.is_null() {
                        InputPtr = DefaultExtension;
                        InputLen = strlen(DefaultExtension);
                    } else {
                        InputPtr = 0 as *const libc::c_char;
                        InputLen = 0 as libc::c_int as size_t;
                    }
                }
                if ComponentLen > 0 as libc::c_int as libc::c_ulong
                    && *ComponentPtr as libc::c_int != 0 as libc::c_int
                {
                    Status = 0 as libc::c_int;
                }
            }
            2 | 4 => {
                while OutputLen > 0 as libc::c_int as libc::c_ulong
                    && *OutputBuffer
                        .offset(OutputLen.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
                        as libc::c_int
                        == ComponentTerm as libc::c_int
                {
                    OutputLen = OutputLen.wrapping_sub(1);
                    OutputLen;
                }
                ComponentLen = 1 as libc::c_int as size_t;
                ComponentPtr = &mut ComponentTerm;
                while *InputPtr as libc::c_int == ComponentTerm as libc::c_int
                    && InputLen > 0 as libc::c_int as libc::c_ulong
                {
                    InputPtr = InputPtr.offset(1);
                    InputPtr;
                    InputLen = InputLen.wrapping_sub(1);
                    InputLen;
                }
            }
            5 | _ => {
                ComponentTerm = 0 as libc::c_int as libc::c_char;
                ComponentLen = InputLen;
                ComponentPtr = InputPtr;
                InputPtr = 0 as *const libc::c_char;
                InputLen = 0 as libc::c_int as size_t;
            }
        }
        while ComponentLen > 0 as libc::c_int as libc::c_ulong
            && *ComponentPtr as libc::c_int != 0 as libc::c_int
        {
            *OutputBuffer.offset(OutputLen as isize) = *ComponentPtr;
            ComponentPtr = ComponentPtr.offset(1);
            ComponentPtr;
            OutputLen = OutputLen.wrapping_add(1);
            OutputLen;
            ComponentLen = ComponentLen.wrapping_sub(1);
            ComponentLen;
            if !(OutputLen >= OutputBufSize) {
                continue;
            }
            Status = 0xc6000003 as libc::c_uint as CFE_Status_t;
            InputPtr = 0 as *const libc::c_char;
            InputLen = 0 as libc::c_int as size_t;
            OutputLen = OutputLen.wrapping_sub(1);
            OutputLen;
            break;
        }
    }
    *OutputBuffer.offset(OutputLen as isize) = 0 as libc::c_int as libc::c_char;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_ParseInputFileName(
    mut OutputBuffer: *mut libc::c_char,
    mut InputName: *const libc::c_char,
    mut OutputBufSize: size_t,
    mut FileCategory: CFE_FS_FileCategory_t,
) -> int32 {
    return CFE_FS_ParseInputFileNameEx(
        OutputBuffer,
        0 as *const libc::c_char,
        OutputBufSize,
        0 as libc::c_int as size_t,
        InputName,
        CFE_FS_GetDefaultMountPoint(FileCategory),
        CFE_FS_GetDefaultExtension(FileCategory),
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_ExtractFilenameFromPath(
    mut OriginalPath: *const libc::c_char,
    mut FileNameOnly: *mut libc::c_char,
) -> CFE_Status_t {
    let mut i: uint32 = 0;
    let mut j: uint32 = 0;
    let mut StringLength: libc::c_int = 0;
    let mut DirMarkIdx: libc::c_int = 0;
    let mut ReturnCode: int32 = 0;
    if OriginalPath.is_null() || FileNameOnly.is_null() {
        ReturnCode = 0xc6000001 as libc::c_uint as CFE_Status_t;
    } else {
        StringLength = strlen(OriginalPath) as libc::c_int;
        DirMarkIdx = -(1 as libc::c_int);
        i = 0 as libc::c_int as uint32;
        while i < StringLength as libc::c_uint {
            if *OriginalPath.offset(i as isize) as libc::c_int == '/' as i32 {
                DirMarkIdx = i as libc::c_int;
            }
            i = i.wrapping_add(1);
            i;
        }
        if StringLength - (DirMarkIdx + 1 as libc::c_int) < 64 as libc::c_int {
            if DirMarkIdx > 0 as libc::c_int {
                j = 0 as libc::c_int as uint32;
                i = (DirMarkIdx + 1 as libc::c_int) as uint32;
                while i < StringLength as libc::c_uint {
                    *FileNameOnly.offset(j as isize) = *OriginalPath.offset(i as isize);
                    j = j.wrapping_add(1);
                    j;
                    i = i.wrapping_add(1);
                    i;
                }
                *FileNameOnly.offset(j as isize) = '\0' as i32 as libc::c_char;
                ReturnCode = 0 as libc::c_int;
            } else {
                ReturnCode = 0xc6000002 as libc::c_uint as CFE_Status_t;
            }
        } else {
            ReturnCode = 0xc6000003 as libc::c_uint as CFE_Status_t;
        }
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_RunBackgroundFileDump(
    mut ElapsedTime: uint32,
    mut Arg: *mut libc::c_void,
) -> bool {
    let mut State: *mut CFE_FS_CurrentFileState_t = 0 as *mut CFE_FS_CurrentFileState_t;
    let mut Curr: *mut CFE_FS_BackgroundFileDumpEntry_t =
        0 as *mut CFE_FS_BackgroundFileDumpEntry_t;
    let mut Meta: *mut CFE_FS_FileWriteMetaData_t = 0 as *mut CFE_FS_FileWriteMetaData_t;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut FileHdr: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut RecordPtr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut RecordSize: size_t = 0;
    let mut IsEOF: bool = false;
    State = &mut CFE_FS_Global.FileDump.Current;
    Curr = 0 as *mut CFE_FS_BackgroundFileDumpEntry_t;
    IsEOF = 0 as libc::c_int != 0;
    RecordPtr = 0 as *mut libc::c_void;
    RecordSize = 0 as libc::c_int as size_t;
    (*State).Credit = ((*State).Credit as libc::c_uint).wrapping_add(
        ElapsedTime
            .wrapping_mul(10000 as libc::c_int as libc::c_uint)
            .wrapping_div(1000 as libc::c_int as libc::c_uint),
    ) as int32 as int32;
    if (*State).Credit > 10000 as libc::c_int {
        (*State).Credit = 10000 as libc::c_int;
    }
    CFE_FS_LockSharedData(
        (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"CFE_FS_RunBackgroundFileDump\0",
        ))
        .as_ptr(),
    );
    if CFE_FS_Global.FileDump.CompleteCount != CFE_FS_Global.FileDump.RequestCount {
        Curr = &mut *(CFE_FS_Global.FileDump.Entries).as_mut_ptr().offset(
            (CFE_FS_Global.FileDump.CompleteCount
                & (4 as libc::c_int - 1 as libc::c_int) as libc::c_uint) as isize,
        ) as *mut CFE_FS_BackgroundFileDumpEntry_t;
    }
    CFE_FS_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
            b"CFE_FS_RunBackgroundFileDump\0",
        ))
        .as_ptr(),
    );
    if Curr.is_null() {
        return 0 as libc::c_int != 0;
    }
    Meta = (*Curr).Meta;
    if !OS_ObjectIdDefined((*State).Fd) && (*Meta).IsPending as libc::c_int != 0 {
        OsStatus = OS_OpenCreate(
            &mut (*State).Fd,
            ((*Meta).FileName).as_mut_ptr(),
            OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
            1 as libc::c_int,
        );
        if OsStatus != 0 as libc::c_int {
            (*State).Fd = 0 as libc::c_int as osal_id_t;
            ((*Meta).OnEvent).expect("non-null function pointer")(
                Meta as *mut libc::c_void,
                CFE_FS_FileWriteEvent_CREATE_ERROR,
                OsStatus as libc::c_long as int32,
                0 as libc::c_int as uint32,
                0 as libc::c_int as size_t,
                0 as libc::c_int as size_t,
            );
        } else {
            CFE_FS_InitHeader(
                &mut FileHdr,
                ((*Meta).Description).as_mut_ptr(),
                (*Meta).FileSubType,
            );
            Status = CFE_FS_WriteHeader((*State).Fd, &mut FileHdr);
            if Status as libc::c_ulong != ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong
            {
                OS_close((*State).Fd);
                (*State).Fd = 0 as libc::c_int as osal_id_t;
                ((*Meta).OnEvent).expect("non-null function pointer")(
                    Meta as *mut libc::c_void,
                    CFE_FS_FileWriteEvent_HEADER_WRITE_ERROR,
                    Status,
                    (*State).RecordNum,
                    ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong,
                    (*State).FileSize,
                );
            } else {
                (*State).FileSize = ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong;
                (*State).Credit = ((*State).Credit as libc::c_ulong)
                    .wrapping_sub(::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong)
                    as int32 as int32;
                (*State).RecordNum = 0 as libc::c_int as uint32;
            }
        }
    }
    while OS_ObjectIdDefined((*State).Fd) as libc::c_int != 0
        && (*State).Credit > 0 as libc::c_int
        && !IsEOF
    {
        IsEOF = ((*Meta).GetData).expect("non-null function pointer")(
            Meta as *mut libc::c_void,
            (*State).RecordNum,
            &mut RecordPtr,
            &mut RecordSize,
        );
        if RecordSize > 0 as libc::c_int as libc::c_ulong {
            (*State).Credit =
                ((*State).Credit as libc::c_ulong).wrapping_sub(RecordSize) as int32 as int32;
            OsStatus = OS_write((*State).Fd, RecordPtr, RecordSize);
            if OsStatus as libc::c_ulong != RecordSize {
                OS_close((*State).Fd);
                (*State).Fd = 0 as libc::c_int as osal_id_t;
                ((*Meta).OnEvent).expect("non-null function pointer")(
                    Meta as *mut libc::c_void,
                    CFE_FS_FileWriteEvent_RECORD_WRITE_ERROR,
                    OsStatus as libc::c_long as int32,
                    (*State).RecordNum,
                    RecordSize,
                    (*State).FileSize,
                );
                break;
            } else {
                (*State).FileSize = ((*State).FileSize as libc::c_ulong).wrapping_add(RecordSize)
                    as size_t as size_t;
            }
        }
        (*State).RecordNum = ((*State).RecordNum).wrapping_add(1);
        (*State).RecordNum;
    }
    if IsEOF {
        OS_close((*State).Fd);
        (*State).Fd = 0 as libc::c_int as osal_id_t;
        ((*Meta).OnEvent).expect("non-null function pointer")(
            Meta as *mut libc::c_void,
            CFE_FS_FileWriteEvent_COMPLETE,
            0 as libc::c_int,
            (*State).RecordNum,
            0 as libc::c_int as size_t,
            (*State).FileSize,
        );
    }
    if !OS_ObjectIdDefined((*State).Fd) {
        CFE_FS_LockSharedData(
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_FS_RunBackgroundFileDump\0",
            ))
            .as_ptr(),
        );
        memset(
            Curr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_FS_BackgroundFileDumpEntry_t>() as libc::c_ulong,
        );
        CFE_FS_Global.FileDump.CompleteCount =
            (CFE_FS_Global.FileDump.CompleteCount).wrapping_add(1);
        CFE_FS_Global.FileDump.CompleteCount;
        ::core::ptr::write_volatile(&mut (*Meta).IsPending as *mut bool, 0 as libc::c_int != 0);
        CFE_FS_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_FS_RunBackgroundFileDump\0",
            ))
            .as_ptr(),
        );
    }
    return !IsEOF;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_BackgroundFileDumpRequest(
    mut Meta: *mut CFE_FS_FileWriteMetaData_t,
) -> int32 {
    let mut Curr: *mut CFE_FS_BackgroundFileDumpEntry_t =
        0 as *mut CFE_FS_BackgroundFileDumpEntry_t;
    let mut Status: int32 = 0;
    let mut PendingRequestCount: uint32 = 0;
    if Meta.is_null() {
        return 0xc6000001 as libc::c_uint as CFE_Status_t;
    }
    if ((*Meta).GetData).is_none() || ((*Meta).OnEvent).is_none() {
        return 0xc6000001 as libc::c_uint as CFE_Status_t;
    }
    if (*Meta).FileName[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
        return 0xc6000002 as libc::c_uint as CFE_Status_t;
    }
    if (*Meta).IsPending {
        return 0xc8000006 as libc::c_uint as int32;
    }
    CFE_FS_LockSharedData(
        (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"CFE_FS_BackgroundFileDumpRequest\0",
        ))
        .as_ptr(),
    );
    PendingRequestCount =
        (CFE_FS_Global.FileDump.RequestCount).wrapping_add(1 as libc::c_int as libc::c_uint);
    if PendingRequestCount
        == (CFE_FS_Global.FileDump.CompleteCount).wrapping_add(4 as libc::c_int as libc::c_uint)
    {
        Status = 0xc8000006 as libc::c_uint as int32;
    } else {
        Curr = &mut *(CFE_FS_Global.FileDump.Entries).as_mut_ptr().offset(
            (CFE_FS_Global.FileDump.RequestCount
                & (4 as libc::c_int - 1 as libc::c_int) as libc::c_uint) as isize,
        ) as *mut CFE_FS_BackgroundFileDumpEntry_t;
        (*Curr).Meta = Meta;
        ::core::ptr::write_volatile(&mut (*Meta).IsPending as *mut bool, 1 as libc::c_int != 0);
        CFE_FS_Global.FileDump.RequestCount = PendingRequestCount;
        Status = 0 as libc::c_int;
    }
    CFE_FS_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 33], &[libc::c_char; 33]>(
            b"CFE_FS_BackgroundFileDumpRequest\0",
        ))
        .as_ptr(),
    );
    if Status == 0 as libc::c_int {
        CFE_ES_BackgroundWakeup();
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_BackgroundFileDumpIsPending(
    mut Meta: *const CFE_FS_FileWriteMetaData_t,
) -> bool {
    if Meta.is_null() {
        return 0 as libc::c_int != 0;
    }
    return (*Meta).IsPending;
}
#[no_mangle]
pub static mut CFE_FS_Global: CFE_FS_Global_t = CFE_FS_Global_t {
    SharedDataMutexId: 0,
    FileDump: CFE_FS_BackgroundFileDumpState_t {
        RequestCount: 0,
        CompleteCount: 0,
        Entries: [CFE_FS_BackgroundFileDumpEntry_t {
            RequestorAppId: 0,
            Meta: 0 as *const CFE_FS_FileWriteMetaData_t as *mut CFE_FS_FileWriteMetaData_t,
        }; 4],
        Current: CFE_FS_CurrentFileState_t {
            Fd: 0,
            Credit: 0,
            RecordNum: 0,
            FileSize: 0,
        },
    },
};
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_EarlyInit() -> int32 {
    let mut OsStatus: int32 = 0;
    memset(
        &mut CFE_FS_Global as *mut CFE_FS_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_FS_Global_t>() as libc::c_ulong,
    );
    OsStatus = OS_MutSemCreate(
        &mut CFE_FS_Global.SharedDataMutexId,
        b"CFE_FS_SharedMutex\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Shared Data Mutex creation failed! RC=%ld\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_FS_EarlyInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_LockSharedData(mut FunctionName: *const libc::c_char) {
    let mut OsStatus: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    OsStatus = OS_MutSemTake(CFE_FS_Global.SharedDataMutexId);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_GetAppID(&mut AppId);
        CFE_ES_WriteToSysLog(
            b"%s: SharedData Mutex Take Err Stat=%ld,App=%lu,Function=%s\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_FS_LockSharedData\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
            CFE_ResourceId_ToInteger(AppId),
            FunctionName,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_FS_UnlockSharedData(mut FunctionName: *const libc::c_char) {
    let mut OsStatus: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    OsStatus = OS_MutSemGive(CFE_FS_Global.SharedDataMutexId);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_GetAppID(&mut AppId);
        CFE_ES_WriteToSysLog(
            b"%s: SharedData Mutex Give Err Stat=%ld,App=%lu,Function=%s\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_FS_UnlockSharedData\0",
            ))
            .as_ptr(),
            OsStatus as libc::c_long,
            CFE_ResourceId_ToInteger(AppId),
            FunctionName,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_UnsubscribeWithAppId(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
    mut AppId: CFE_ES_AppId_t,
) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, 1 as libc::c_int as uint8, AppId);
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_DeletePipe(mut PipeId: CFE_SB_PipeId_t) -> CFE_Status_t {
    let mut CallerId: CFE_ES_AppId_t = 0;
    let mut Status: int32 = 0 as libc::c_int;
    CFE_ES_GetAppID(&mut CallerId);
    Status = CFE_SB_DeletePipeFull(PipeId, CallerId);
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SetPipeOpts(
    mut PipeId: CFE_SB_PipeId_t,
    mut Opts: uint8,
) -> CFE_Status_t {
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut AppID: CFE_ES_AppId_t = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut PendingEventID: uint16 = 0;
    let mut Status: int32 = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    PendingEventID = 0 as libc::c_int as uint16;
    Status = CFE_ES_GetAppID(&mut AppID);
    if Status != 0 as libc::c_int {
        return Status;
    }
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_SetPipeOpts\0"))
            .as_ptr(),
        503 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID(PipeId);
    if !CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
        PendingEventID = 55 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if !CFE_ResourceId_Equal(AppID, (*PipeDscPtr).AppId) {
        PendingEventID = 56 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        (*PipeDscPtr).Opts = Opts;
    }
    if Status != 0 as libc::c_int {
        CFE_SB_Global.HKTlmMsg.Payload.PipeOptsErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.PipeOptsErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.PipeOptsErrorCounter;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_SetPipeOpts\0"))
            .as_ptr(),
        529 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_ES_GetAppName(
            FullName.as_mut_ptr(),
            AppID,
            ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        );
        CFE_EVS_SendEventWithAppID(
            57 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Pipe opts set:id %lu,owner %s, opts=0x%02x\0" as *const u8 as *const libc::c_char,
            CFE_ResourceId_ToInteger(PipeId),
            FullName.as_mut_ptr(),
            Opts as libc::c_uint,
        );
    } else {
        CFE_ES_GetTaskID(&mut TskId);
        match PendingEventID as libc::c_int {
            55 => {
                CFE_EVS_SendEventWithAppID(
                    55 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Opts Error:Bad Argument,PipedId %lu,Requestor %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            56 => {
                CFE_EVS_SendEventWithAppID(
                    56 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Opts Set Error: Caller(%s) is not the owner of pipe %lu\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    CFE_ResourceId_ToInteger(PipeId),
                );
            }
            _ => {}
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetPipeOpts(
    mut PipeId: CFE_SB_PipeId_t,
    mut OptsPtr: *mut uint8,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut PendingEventID: uint16 = 0;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    PendingEventID = 0 as libc::c_int as uint16;
    Status = 0 as libc::c_int;
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_GetPipeOpts\0"))
            .as_ptr(),
        583 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID(PipeId);
    if !CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
        PendingEventID = 58 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if OptsPtr.is_null() {
        PendingEventID = 59 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        *OptsPtr = (*PipeDscPtr).Opts;
    }
    if Status != 0 as libc::c_int {
        CFE_SB_Global.HKTlmMsg.Payload.PipeOptsErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.PipeOptsErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.PipeOptsErrorCounter;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_GetPipeOpts\0"))
            .as_ptr(),
        608 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            60 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Pipe opts get:id %lu, opts=0x%02x\0" as *const u8 as *const libc::c_char,
            CFE_ResourceId_ToInteger(PipeId),
            *OptsPtr as libc::c_uint,
        );
    } else {
        CFE_ES_GetTaskID(&mut TskId);
        match PendingEventID as libc::c_int {
            59 => {
                CFE_EVS_SendEventWithAppID(
                    59 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Opts Error:Bad Argument,Requestor %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            58 => {
                CFE_EVS_SendEventWithAppID(
                    58 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Opts Error:Bad Argument,PipedId %lu,Requestor %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            _ => {}
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetPipeIdByName(
    mut PipeIdPtr: *mut CFE_SB_PipeId_t,
    mut PipeName: *const libc::c_char,
) -> CFE_Status_t {
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut Idx: uint32 = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut PendingEventID: uint16 = 0;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut SysQueueId: osal_id_t = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    SysQueueId = 0 as libc::c_int as osal_id_t;
    if PipeName.is_null() || PipeIdPtr.is_null() {
        PendingEventID = 66 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        OsStatus = OS_QueueGetIdByName(&mut SysQueueId, PipeName);
        if OsStatus == 0 as libc::c_int {
            Status = 0 as libc::c_int;
        } else {
            PendingEventID = 67 as libc::c_int as uint16;
            Status = 0xca000003 as libc::c_uint as CFE_Status_t;
        }
    }
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_GetPipeIdByName\0"))
            .as_ptr(),
        773 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        Idx = 64 as libc::c_int as uint32;
        PipeDscPtr = (CFE_SB_Global.PipeTbl).as_mut_ptr();
        loop {
            if Idx == 0 as libc::c_int as libc::c_uint {
                PendingEventID = 67 as libc::c_int as uint16;
                Status = 0xca000003 as libc::c_uint as CFE_Status_t;
                break;
            } else if OS_ObjectIdEqual((*PipeDscPtr).SysQueueId, SysQueueId) {
                *PipeIdPtr = CFE_SB_PipeDescGetID(PipeDscPtr);
                break;
            } else {
                Idx = Idx.wrapping_sub(1);
                Idx;
                PipeDscPtr = PipeDscPtr.offset(1);
                PipeDscPtr;
            }
        }
    }
    if Status != 0 as libc::c_int {
        CFE_SB_Global.HKTlmMsg.Payload.GetPipeIdByNameErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.GetPipeIdByNameErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.GetPipeIdByNameErrorCounter;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_GetPipeIdByName\0"))
            .as_ptr(),
        805 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            65 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"PipeIdByName name=%s id=%lu\0" as *const u8 as *const libc::c_char,
            PipeName,
            CFE_ResourceId_ToInteger(*PipeIdPtr),
        );
    } else {
        CFE_ES_GetTaskID(&mut TskId);
        match PendingEventID as libc::c_int {
            66 => {
                CFE_EVS_SendEventWithAppID(
                    66 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe ID By Name Error:Bad Argument,Requestor %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            67 => {
                CFE_EVS_SendEventWithAppID(
                    67 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe ID By Name Error:Bad Argument,Requestor %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            _ => {}
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SubscribeEx(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
    mut Quality: CFE_SB_Qos_t,
    mut MsgLim: uint16,
) -> CFE_Status_t {
    return CFE_SB_SubscribeFull(MsgId, PipeId, Quality, MsgLim, 0 as libc::c_int as uint8);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_Unsubscribe(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
) -> CFE_Status_t {
    let mut CallerId: CFE_ES_AppId_t = 0;
    let mut Status: int32 = 0 as libc::c_int;
    CFE_ES_GetAppID(&mut CallerId);
    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, 0 as libc::c_int as uint8, CallerId);
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_UnsubscribeFull(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
    mut Scope: uint8,
    mut AppId: CFE_ES_AppId_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut RouteId: CFE_SBR_RouteId_t = CFE_SBR_RouteId_t { RouteId: 0 };
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut DestPtr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut PipeName: [libc::c_char; 20] = [0; 20];
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut PendingEventID: uint16 = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    Status = 0 as libc::c_int;
    DestPtr = 0 as *mut CFE_SB_DestinationD_t;
    CFE_ES_GetTaskID(&mut TskId);
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_UnsubscribeFull\0"))
            .as_ptr(),
        1188 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID(PipeId);
    if !CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
        PendingEventID = 52 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if !CFE_ResourceId_Equal((*PipeDscPtr).AppId, AppId) {
        PendingEventID = 53 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if !CFE_SB_IsValidMsgId(MsgId) || Scope as libc::c_int > 1 as libc::c_int {
        PendingEventID = 11 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        RouteId = CFE_SBR_GetRouteId(MsgId);
        if !CFE_SBR_IsValidRouteId(RouteId) {
            PendingEventID = 12 as libc::c_int as uint16;
        } else {
            DestPtr = CFE_SB_GetDestPtr(RouteId, PipeId);
            if !DestPtr.is_null() {
                CFE_SB_RemoveDest(RouteId, DestPtr);
            } else {
                PendingEventID = 12 as libc::c_int as uint16;
            }
        }
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_UnsubscribeFull\0"))
            .as_ptr(),
        1237 as libc::c_int,
    );
    if PendingEventID as libc::c_int != 0 as libc::c_int {
        match PendingEventID as libc::c_int {
            12 => {
                CFE_SB_GetPipeName(
                    PipeName.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
                    PipeId,
                );
                CFE_EVS_SendEventWithAppID(
                    12 as libc::c_int as uint16,
                    CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Unsubscribe Err:No subs for Msg 0x%x on %s,app %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue(MsgId),
                    PipeName.as_mut_ptr(),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            52 => {
                CFE_EVS_SendEventWithAppID(
                    52 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Unsubscribe Err:Invalid Pipe Id Msg=0x%x,Pipe=%lu,app=%s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue(MsgId),
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            53 => {
                CFE_EVS_SendEventWithAppID(
                    53 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Unsubscribe Err:Caller(%s) is not the owner of pipe %lu,Msg=0x%x\0"
                        as *const u8 as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_MsgIdToValue(MsgId),
                );
            }
            11 => {
                CFE_EVS_SendEventWithAppID(
                    11 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Unsubscribe Err:Bad Arg,MsgId 0x%x,PipeId %lu,app %s,scope %d\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue(MsgId),
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    Scope as libc::c_int,
                );
            }
            _ => {}
        }
    } else if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            48 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Subscription Removed:Msg 0x%x on pipe %lu,app %s\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            CFE_ResourceId_ToInteger(PipeId),
            CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_UnsubscribeLocal(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
) -> CFE_Status_t {
    let mut CallerId: CFE_ES_AppId_t = 0;
    let mut Status: int32 = 0 as libc::c_int;
    CFE_ES_GetAppID(&mut CallerId);
    Status = CFE_SB_UnsubscribeFull(MsgId, PipeId, 1 as libc::c_int as uint8, CallerId);
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_AllocateMessageBuffer(mut MsgSize: size_t) -> *mut CFE_SB_Buffer_t {
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut BufDscPtr: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    let mut BufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    AppId = 0 as libc::c_int as CFE_ResourceId_t;
    BufDscPtr = 0 as *mut CFE_SB_BufferD_t;
    BufPtr = 0 as *mut CFE_SB_Buffer_t;
    if MsgSize > 32768 as libc::c_int as libc::c_ulong {
        CFE_ES_WriteToSysLog(
            b"%s: ZeroCopyGetPtr-Failed, MsgSize is too large\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_SB_AllocateMessageBuffer\0",
            ))
            .as_ptr(),
        );
        return 0 as *mut CFE_SB_Buffer_t;
    }
    if CFE_ES_GetAppID(&mut AppId) == 0 as libc::c_int {
        CFE_SB_LockSharedData(
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_SB_AllocateMessageBuffer\0",
            ))
            .as_ptr(),
            2023 as libc::c_int,
        );
        BufDscPtr = CFE_SB_GetBufferFromPool(MsgSize);
        if !BufDscPtr.is_null() {
            (*BufDscPtr).AppId = AppId;
            BufPtr = &mut (*BufDscPtr).Content;
            CFE_SB_TrackingListAdd(&mut CFE_SB_Global.ZeroCopyList, &mut (*BufDscPtr).Link);
        }
        CFE_SB_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_SB_AllocateMessageBuffer\0",
            ))
            .as_ptr(),
            2040 as libc::c_int,
        );
    }
    if !BufPtr.is_null() {
        memset(BufPtr as *mut libc::c_void, 0 as libc::c_int, MsgSize);
    }
    return BufPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ReleaseMessageBuffer(
    mut BufPtr: *mut CFE_SB_Buffer_t,
) -> CFE_Status_t {
    let mut BufDscPtr: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    let mut Status: int32 = 0;
    Status = CFE_SB_ZeroCopyBufferValidate(BufPtr, &mut BufDscPtr);
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"CFE_SB_ReleaseMessageBuffer\0",
        ))
        .as_ptr(),
        2106 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        (*BufDscPtr).AppId = 0 as libc::c_int as CFE_ResourceId_t;
        CFE_SB_DecrBufUseCnt(BufDscPtr);
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
            b"CFE_SB_ReleaseMessageBuffer\0",
        ))
        .as_ptr(),
        2115 as libc::c_int,
    );
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TransmitMsg(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut IsOrigination: bool,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut Size: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut BufDscPtr: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    let mut RouteId: CFE_SBR_RouteId_t = CFE_SBR_RouteId_t { RouteId: 0 };
    let mut PendingEventID: uint16 = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    BufDscPtr = 0 as *mut CFE_SB_BufferD_t;
    RouteId = {
        let mut init = CFE_SBR_RouteId_t {
            RouteId: 0 as libc::c_int as CFE_SB_RouteId_Atom_t,
        };
        init
    };
    Status = CFE_SB_TransmitMsgValidate(MsgPtr, &mut MsgId, &mut Size, &mut RouteId);
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_TransmitMsg\0"))
            .as_ptr(),
        1308 as libc::c_int,
    );
    if Status == 0 as libc::c_int && CFE_SBR_IsValidRouteId(RouteId) as libc::c_int != 0 {
        BufDscPtr = CFE_SB_GetBufferFromPool(Size);
        if BufDscPtr.is_null() {
            PendingEventID = 16 as libc::c_int as uint16;
            Status = 0xca000008 as libc::c_uint as CFE_Status_t;
        }
    }
    if Status != 0 as libc::c_int {
        CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_TransmitMsg\0"))
            .as_ptr(),
        1333 as libc::c_int,
    );
    if !BufDscPtr.is_null() {
        memcpy(
            &mut (*BufDscPtr).Content as *mut CFE_SB_Buffer_t as *mut libc::c_void,
            MsgPtr as *const libc::c_void,
            Size,
        );
        (*BufDscPtr).MsgId = MsgId;
        (*BufDscPtr).ContentSize = Size;
        (*BufDscPtr).NeedsUpdate = IsOrigination;
        CFE_MSG_GetType(MsgPtr, &mut (*BufDscPtr).ContentType);
        CFE_SB_BroadcastBufferToRoute(BufDscPtr, RouteId);
        BufDscPtr = 0 as *mut CFE_SB_BufferD_t;
    }
    if PendingEventID as libc::c_int == 16 as libc::c_int {
        CFE_ES_GetTaskID(&mut TskId);
        if CFE_SB_RequestToSendEvent(TskId, 1 as libc::c_int as uint32)
            == 1 as libc::c_int as libc::c_uint
        {
            CFE_EVS_SendEventWithAppID(
                16 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_SB_Global.AppId,
                b"Send Err:Request for Buffer Failed. MsgId 0x%x,app %s,size %d\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                Size as libc::c_int,
            );
            CFE_SB_FinishSendEvent(TskId, 1 as libc::c_int as uint32);
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ZeroCopyBufferValidate(
    mut BufPtr: *mut CFE_SB_Buffer_t,
    mut BufDscPtr: *mut *mut CFE_SB_BufferD_t,
) -> int32 {
    let mut BufDscAddr: cpuaddr = 0;
    if BufPtr.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    BufDscAddr = (BufPtr as cpuaddr).wrapping_sub(48 as libc::c_ulong);
    *BufDscPtr = BufDscAddr as *mut CFE_SB_BufferD_t;
    if !CFE_ResourceId_IsDefined((**BufDscPtr).AppId) {
        return 0xca00000e as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TransmitBuffer(
    mut BufPtr: *mut CFE_SB_Buffer_t,
    mut IsOrigination: bool,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut BufDscPtr: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    let mut RouteId: CFE_SBR_RouteId_t = CFE_SBR_RouteId_t { RouteId: 0 };
    Status = CFE_SB_ZeroCopyBufferValidate(BufPtr, &mut BufDscPtr);
    if Status == 0 as libc::c_int {
        Status = CFE_SB_TransmitMsgValidate(
            &mut (*BufPtr).Msg,
            &mut (*BufDscPtr).MsgId,
            &mut (*BufDscPtr).ContentSize,
            &mut RouteId,
        );
        if Status == 0 as libc::c_int {
            (*BufDscPtr).NeedsUpdate = IsOrigination;
            CFE_MSG_GetType(&mut (*BufPtr).Msg, &mut (*BufDscPtr).ContentType);
            CFE_SB_BroadcastBufferToRoute(BufDscPtr, RouteId);
            BufDscPtr = 0 as *mut CFE_SB_BufferD_t;
        }
    }
    if Status != 0 as libc::c_int {
        CFE_SB_LockSharedData(
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_TransmitBuffer\0"))
                .as_ptr(),
            2168 as libc::c_int,
        );
        CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter;
        CFE_SB_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_TransmitBuffer\0"))
                .as_ptr(),
            2170 as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SubscribeLocal(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
    mut MsgLim: uint16,
) -> CFE_Status_t {
    return CFE_SB_SubscribeFull(
        MsgId,
        PipeId,
        {
            let mut init = CFE_SB_Qos_t {
                Priority: 0 as libc::c_int as uint8,
                Reliability: 0,
            };
            init
        },
        MsgLim,
        1 as libc::c_int as uint8,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TransmitMsgValidate(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut MsgIdPtr: *mut CFE_SB_MsgId_t,
    mut SizePtr: *mut CFE_MSG_Size_t,
    mut RouteIdPtr: *mut CFE_SBR_RouteId_t,
) -> int32 {
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut PendingEventID: uint16 = 0;
    let mut Status: int32 = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    Status = 0 as libc::c_int;
    if MsgPtr.is_null() {
        PendingEventID = 13 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    if Status == 0 as libc::c_int {
        CFE_MSG_GetMsgId(MsgPtr, MsgIdPtr);
        if !CFE_SB_IsValidMsgId(*MsgIdPtr) {
            PendingEventID = 21 as libc::c_int as uint16;
            Status = 0xca000003 as libc::c_uint as CFE_Status_t;
        }
    }
    if Status == 0 as libc::c_int {
        CFE_MSG_GetSize(MsgPtr, SizePtr);
        if *SizePtr > 32768 as libc::c_int as libc::c_ulong {
            PendingEventID = 15 as libc::c_int as uint16;
            Status = 0xca000007 as libc::c_uint as CFE_Status_t;
        }
    }
    if Status == 0 as libc::c_int {
        CFE_SB_LockSharedData(
            (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                b"CFE_SB_TransmitMsgValidate\0",
            ))
            .as_ptr(),
            1441 as libc::c_int,
        );
        *RouteIdPtr = CFE_SBR_GetRouteId(*MsgIdPtr);
        if !CFE_SBR_IsValidRouteId(*RouteIdPtr) {
            CFE_SB_Global.HKTlmMsg.Payload.NoSubscribersCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.NoSubscribersCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.NoSubscribersCounter;
            PendingEventID = 14 as libc::c_int as uint16;
        }
        CFE_SB_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                b"CFE_SB_TransmitMsgValidate\0",
            ))
            .as_ptr(),
            1454 as libc::c_int,
        );
    }
    if PendingEventID as libc::c_int != 0 as libc::c_int {
        CFE_ES_GetTaskID(&mut TskId);
        match PendingEventID as libc::c_int {
            13 => {
                if CFE_SB_RequestToSendEvent(TskId, 5 as libc::c_int as uint32)
                    == 1 as libc::c_int as libc::c_uint
                {
                    CFE_EVS_SendEventWithAppID(
                        13 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        CFE_SB_Global.AppId,
                        b"Send Err:Bad input argument,Arg 0x%lx,App %s\0" as *const u8
                            as *const libc::c_char,
                        MsgPtr as libc::c_ulong,
                        CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    );
                    CFE_SB_FinishSendEvent(TskId, 5 as libc::c_int as uint32);
                }
            }
            21 => {
                if CFE_SB_RequestToSendEvent(TskId, 6 as libc::c_int as uint32)
                    == 1 as libc::c_int as libc::c_uint
                {
                    CFE_EVS_SendEventWithAppID(
                        21 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        CFE_SB_Global.AppId,
                        b"Send Err:Invalid MsgId(0x%x)in msg,App %s\0" as *const u8
                            as *const libc::c_char,
                        CFE_SB_MsgIdToValue(*MsgIdPtr),
                        CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    );
                    CFE_SB_FinishSendEvent(TskId, 6 as libc::c_int as uint32);
                }
            }
            15 => {
                if CFE_SB_RequestToSendEvent(TskId, 7 as libc::c_int as uint32)
                    == 1 as libc::c_int as libc::c_uint
                {
                    CFE_EVS_SendEventWithAppID(
                        15 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        CFE_SB_Global.AppId,
                        b"Send Err:Msg Too Big MsgId=0x%x,app=%s,size=%d,MaxSz=%d\0" as *const u8
                            as *const libc::c_char,
                        CFE_SB_MsgIdToValue(*MsgIdPtr),
                        CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                        *SizePtr as libc::c_int,
                        32768 as libc::c_int,
                    );
                    CFE_SB_FinishSendEvent(TskId, 7 as libc::c_int as uint32);
                }
            }
            14 => {
                if CFE_SB_RequestToSendEvent(TskId, 0 as libc::c_int as uint32)
                    == 1 as libc::c_int as libc::c_uint
                {
                    CFE_EVS_SendEventWithAppID(
                        14 as libc::c_int as uint16,
                        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                        CFE_SB_Global.AppId,
                        b"No subscribers for MsgId 0x%x,sender %s\0" as *const u8
                            as *const libc::c_char,
                        CFE_SB_MsgIdToValue(*MsgIdPtr),
                        CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    );
                    CFE_SB_FinishSendEvent(TskId, 0 as libc::c_int as uint32);
                }
            }
            _ => {}
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_CreatePipe(
    mut PipeIdPtr: *mut CFE_SB_PipeId_t,
    mut Depth: uint16,
    mut PipeName: *const libc::c_char,
) -> CFE_Status_t {
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut SysQueueId: osal_id_t = 0;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut PendingPipeId: CFE_ResourceId_t = 0 as libc::c_int as CFE_ResourceId_t;
    let mut PendingEventId: uint16 = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    Status = 0 as libc::c_int;
    SysQueueId = 0 as libc::c_int as osal_id_t;
    PendingEventId = 0 as libc::c_int as uint16;
    PipeDscPtr = 0 as *mut CFE_SB_PipeD_t;
    OsStatus = 0 as libc::c_int;
    CFE_ES_GetAppID(&mut AppId);
    CFE_ES_GetTaskID(&mut TskId);
    if PipeIdPtr.is_null()
        || Depth as libc::c_int > 50 as libc::c_int
        || Depth as libc::c_int == 0 as libc::c_int
        || !PipeName.is_null()
            && *PipeName.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32
    {
        PendingEventId = 2 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        CFE_SB_LockSharedData(
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_SB_CreatePipe\0"))
                .as_ptr(),
            135 as libc::c_int,
        );
        PendingPipeId = CFE_ResourceId_FindNext(
            CFE_SB_Global.LastPipeId,
            64 as libc::c_int as uint32,
            Some(CFE_SB_CheckPipeDescSlotUsed as unsafe extern "C" fn(CFE_ResourceId_t) -> bool),
        );
        PipeDscPtr = CFE_SB_LocatePipeDescByID(PendingPipeId);
        if PipeDscPtr.is_null() {
            PendingEventId = 3 as libc::c_int as uint16;
            Status = 0xca000004 as libc::c_uint as CFE_Status_t;
        } else {
            memset(
                PipeDscPtr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<CFE_SB_PipeD_t>() as libc::c_ulong,
            );
            CFE_SB_PipeDescSetUsed(PipeDscPtr, 0xffffffff as libc::c_uint);
            CFE_SB_Global.LastPipeId = PendingPipeId;
        }
        CFE_SB_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_SB_CreatePipe\0"))
                .as_ptr(),
            157 as libc::c_int,
        );
    }
    if Status == 0 as libc::c_int {
        OsStatus = OS_QueueCreate(
            &mut SysQueueId,
            PipeName,
            Depth as osal_blockcount_t,
            ::core::mem::size_of::<*mut CFE_SB_BufferD_t>() as libc::c_ulong,
            0 as libc::c_int as uint32,
        );
        if OsStatus == 0 as libc::c_int {
            Status = 0 as libc::c_int;
        } else {
            if OsStatus == -(15 as libc::c_int) {
                PendingEventId = 69 as libc::c_int as uint16;
            } else if OsStatus == -(14 as libc::c_int) {
                PendingEventId = 70 as libc::c_int as uint16;
            } else {
                PendingEventId = 4 as libc::c_int as uint16;
            }
            Status = 0xca000005 as libc::c_uint as CFE_Status_t;
        }
    }
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_SB_CreatePipe\0"))
            .as_ptr(),
        190 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        (*PipeDscPtr).SysQueueId = SysQueueId;
        (*PipeDscPtr).MaxQueueDepth = Depth;
        (*PipeDscPtr).AppId = AppId;
        CFE_SB_PipeDescSetUsed(PipeDscPtr, PendingPipeId);
        CFE_SB_Global.StatTlmMsg.Payload.PipesInUse =
            (CFE_SB_Global.StatTlmMsg.Payload.PipesInUse).wrapping_add(1);
        CFE_SB_Global.StatTlmMsg.Payload.PipesInUse;
        if CFE_SB_Global.StatTlmMsg.Payload.PipesInUse
            > CFE_SB_Global.StatTlmMsg.Payload.PeakPipesInUse
        {
            CFE_SB_Global.StatTlmMsg.Payload.PeakPipesInUse =
                CFE_SB_Global.StatTlmMsg.Payload.PipesInUse;
        }
    } else {
        if !PipeDscPtr.is_null() {
            CFE_SB_PipeDescSetFree(PipeDscPtr);
            PipeDscPtr = 0 as *mut CFE_SB_PipeD_t;
        }
        PendingPipeId = 0 as libc::c_int as CFE_ResourceId_t;
        CFE_SB_Global.HKTlmMsg.Payload.CreatePipeErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.CreatePipeErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.CreatePipeErrorCounter;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_SB_CreatePipe\0"))
            .as_ptr(),
        225 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            5 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Pipe Created:name %s,id %d,app %s\0" as *const u8 as *const libc::c_char,
            PipeName,
            CFE_ResourceId_ToInteger(PendingPipeId) as libc::c_int,
            CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
        );
        *PipeIdPtr = PendingPipeId;
    } else {
        match PendingEventId as libc::c_int {
            2 => {
                CFE_EVS_SendEventWithAppID(
                    2 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"CreatePipeErr:Bad Input Arg:app=%s,ptr=0x%lx,depth=%d,maxdepth=%d\0"
                        as *const u8 as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    PipeIdPtr as libc::c_ulong,
                    Depth as libc::c_int,
                    50 as libc::c_int,
                );
            }
            3 => {
                CFE_EVS_SendEventWithAppID(
                    3 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"CreatePipeErr:Max Pipes(%d)In Use.app %s\0" as *const u8
                        as *const libc::c_char,
                    64 as libc::c_int,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            69 => {
                CFE_EVS_SendEventWithAppID(
                    69 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"CreatePipeErr:OS_QueueCreate failed, name taken (app=%s, name=%s)\0"
                        as *const u8 as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    PipeName,
                );
            }
            70 => {
                CFE_EVS_SendEventWithAppID(
                    70 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"CreatePipeErr:OS_QueueCreate failed, no free id's (app=%s)\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            4 => {
                CFE_EVS_SendEventWithAppID(
                    4 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"CreatePipeErr:OS_QueueCreate returned %ld,app %s\0" as *const u8
                        as *const libc::c_char,
                    OsStatus as libc::c_long,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            _ => {}
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_RemovePipeFromRoute(
    mut RouteId: CFE_SBR_RouteId_t,
    mut ArgPtr: *mut libc::c_void,
) {
    let mut destptr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut args: *mut CFE_SB_RemovePipeCallback_t = 0 as *mut CFE_SB_RemovePipeCallback_t;
    args = ArgPtr as *mut CFE_SB_RemovePipeCallback_t;
    destptr = CFE_SB_GetDestPtr(RouteId, (*args).PipeId);
    if !destptr.is_null() {
        CFE_SB_RemoveDest(RouteId, destptr);
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_Subscribe(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
) -> CFE_Status_t {
    return CFE_SB_SubscribeFull(
        MsgId,
        PipeId,
        {
            let mut init = CFE_SB_Qos_t {
                Priority: 0 as libc::c_int as uint8,
                Reliability: 0,
            };
            init
        },
        4 as libc::c_int as uint16,
        0 as libc::c_int as uint8,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_DeletePipeWithAppId(
    mut PipeId: CFE_SB_PipeId_t,
    mut AppId: CFE_ES_AppId_t,
) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    Status = CFE_SB_DeletePipeFull(PipeId, AppId);
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SubscribeFull(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
    mut Quality: CFE_SB_Qos_t,
    mut MsgLim: uint16,
    mut Scope: uint8,
) -> int32 {
    let mut RouteId: CFE_SBR_RouteId_t = CFE_SBR_RouteId_t { RouteId: 0 };
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut Status: int32 = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut DestPtr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut DestCount: uint32 = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut PipeName: [libc::c_char; 20] = [0; 20];
    let mut Collisions: uint32 = 0;
    let mut PendingEventID: uint16 = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    Status = 0 as libc::c_int;
    DestPtr = 0 as *mut CFE_SB_DestinationD_t;
    Collisions = 0 as libc::c_int as uint32;
    CFE_ES_GetAppID(&mut AppId);
    CFE_ES_GetTaskID(&mut TskId);
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_SB_SubscribeFull\0"))
            .as_ptr(),
        904 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID(PipeId);
    if !CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
        PendingEventID = 50 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if !CFE_ResourceId_Equal((*PipeDscPtr).AppId, AppId) {
        PendingEventID = 51 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if !CFE_SB_IsValidMsgId(MsgId) || Scope as libc::c_int > 1 as libc::c_int {
        PendingEventID = 6 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        RouteId = CFE_SBR_GetRouteId(MsgId);
        if !CFE_SBR_IsValidRouteId(RouteId) {
            RouteId = CFE_SBR_AddRoute(MsgId, &mut Collisions);
            if !CFE_SBR_IsValidRouteId(RouteId) {
                PendingEventID = 8 as libc::c_int as uint16;
                Status = 0xca000009 as libc::c_uint as CFE_Status_t;
            } else {
                CFE_SB_Global.StatTlmMsg.Payload.MsgIdsInUse =
                    (CFE_SB_Global.StatTlmMsg.Payload.MsgIdsInUse).wrapping_add(1);
                CFE_SB_Global.StatTlmMsg.Payload.MsgIdsInUse;
                if CFE_SB_Global.StatTlmMsg.Payload.MsgIdsInUse
                    > CFE_SB_Global.StatTlmMsg.Payload.PeakMsgIdsInUse
                {
                    CFE_SB_Global.StatTlmMsg.Payload.PeakMsgIdsInUse =
                        CFE_SB_Global.StatTlmMsg.Payload.MsgIdsInUse;
                }
            }
        }
    }
    if Status == 0 as libc::c_int {
        DestCount = 0 as libc::c_int as uint32;
        DestPtr = CFE_SBR_GetDestListHeadPtr(RouteId);
        while !DestPtr.is_null() {
            DestCount = DestCount.wrapping_add(1);
            DestCount;
            if CFE_ResourceId_Equal((*DestPtr).PipeId, PipeId) {
                PendingEventID = 7 as libc::c_int as uint16;
                break;
            } else if DestCount >= 16 as libc::c_int as libc::c_uint {
                PendingEventID = 9 as libc::c_int as uint16;
                Status = 0xca00000a as libc::c_uint as CFE_Status_t;
                break;
            } else {
                DestPtr = (*DestPtr).Next;
            }
        }
        if DestPtr.is_null() {
            DestPtr = CFE_SB_GetDestinationBlk();
            if DestPtr.is_null() {
                PendingEventID = 20 as libc::c_int as uint16;
                Status = 0xca000008 as libc::c_uint as CFE_Status_t;
            } else {
                (*DestPtr).PipeId = PipeId;
                (*DestPtr).MsgId2PipeLim = MsgLim;
                (*DestPtr).Active = 1 as libc::c_int as uint8;
                (*DestPtr).BuffCount = 0 as libc::c_int as uint16;
                (*DestPtr).DestCnt = 0 as libc::c_int as uint16;
                (*DestPtr).Scope = Scope;
                (*DestPtr).Prev = 0 as *mut CFE_SB_DestinationD;
                (*DestPtr).Next = 0 as *mut CFE_SB_DestinationD;
                CFE_SB_AddDestNode(RouteId, DestPtr);
                CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse =
                    (CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse).wrapping_add(1);
                CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse;
                if CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse
                    > CFE_SB_Global.StatTlmMsg.Payload.PeakSubscriptionsInUse
                {
                    CFE_SB_Global.StatTlmMsg.Payload.PeakSubscriptionsInUse =
                        CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse;
                }
            }
        }
    }
    match PendingEventID as libc::c_int {
        50 | 51 | 6 | 8 | 20 | 9 => {
            CFE_SB_Global.HKTlmMsg.Payload.SubscribeErrorCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.SubscribeErrorCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.SubscribeErrorCounter;
        }
        7 => {
            CFE_SB_Global.HKTlmMsg.Payload.DuplicateSubscriptionsCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.DuplicateSubscriptionsCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.DuplicateSubscriptionsCounter;
        }
        _ => {}
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_SB_SubscribeFull\0"))
            .as_ptr(),
        1028 as libc::c_int,
    );
    if PendingEventID as libc::c_int != 0 as libc::c_int {
        CFE_SB_GetPipeName(
            PipeName.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
            PipeId,
        );
        match PendingEventID as libc::c_int {
            7 => {
                CFE_EVS_SendEventWithAppID(
                    7 as libc::c_int as uint16,
                    CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Duplicate Subscription,MsgId 0x%x on %s pipe,app %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue(MsgId),
                    PipeName.as_mut_ptr(),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            51 => {
                CFE_EVS_SendEventWithAppID(
                    51 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Subscribe Err:Caller(%s) is not the owner of pipe %lu,Msg=0x%x\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_MsgIdToValue(MsgId),
                );
            }
            50 => {
                CFE_EVS_SendEventWithAppID(
                    50 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Subscribe Err:Invalid Pipe Id,Msg=0x%x,PipeId=%lu,App %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue(MsgId),
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            20 => {
                CFE_EVS_SendEventWithAppID(
                    20 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Subscribe Err:Request for Destination Blk failed for Msg 0x%x\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue(MsgId),
                );
            }
            9 => {
                CFE_EVS_SendEventWithAppID(
                    9 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Subscribe Err:Max Dests(%d)In Use For Msg 0x%x,pipe %s,app %s\0" as *const u8
                        as *const libc::c_char,
                    16 as libc::c_int,
                    CFE_SB_MsgIdToValue(MsgId),
                    PipeName.as_mut_ptr(),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            8 => {
                CFE_EVS_SendEventWithAppID(
                    8 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Subscribe Err:Max Msgs(%d)In Use,MsgId 0x%x,pipe %s,app %s\0" as *const u8
                        as *const libc::c_char,
                    256 as libc::c_int,
                    CFE_SB_MsgIdToValue(MsgId),
                    PipeName.as_mut_ptr(),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            6 => {
                CFE_EVS_SendEventWithAppID(
                    6 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Subscribe Err:Bad Arg,MsgId 0x%x,PipeId %lu,app %s,scope %d\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue(MsgId),
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    Scope as libc::c_int,
                );
            }
            _ => {}
        }
    } else if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            10 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Subscription Rcvd:MsgId 0x%x on PipeId %lu,app %s\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            CFE_ResourceId_ToInteger(PipeId),
            CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
        );
    }
    if Status == 0 as libc::c_int && Scope as libc::c_int == 0 as libc::c_int {
        CFE_SB_SendSubscriptionReport(MsgId, PipeId, Quality);
    }
    if Collisions != 0 as libc::c_int as libc::c_uint {
        CFE_EVS_SendEventWithAppID(
            23 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Msg hash collision: MsgId = 0x%x, collisions = %u\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            Collisions,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_PipeId_ToIndex(
    mut PipeID: CFE_SB_PipeId_t,
    mut Idx: *mut uint32,
) -> CFE_Status_t {
    return CFE_ResourceId_ToIndex(
        PipeID,
        CFE_SB_PIPEID_BASE as libc::c_int as uint32,
        64 as libc::c_int as uint32,
        Idx,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ReceiveBuffer(
    mut BufPtr: *mut *mut CFE_SB_Buffer_t,
    mut PipeId: CFE_SB_PipeId_t,
    mut TimeOut: int32,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut BufDscPtr: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    let mut BufDscSize: size_t = 0;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut DestPtr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut RouteId: CFE_SBR_RouteId_t = CFE_SBR_RouteId_t { RouteId: 0 };
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut PendingEventID: uint16 = 0;
    let mut SysQueueId: osal_id_t = 0;
    let mut SysTimeout: int32 = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    PendingEventID = 0 as libc::c_int as uint16;
    Status = 0 as libc::c_int;
    SysTimeout = -(1 as libc::c_int);
    SysQueueId = 0 as libc::c_int as osal_id_t;
    PipeDscPtr = 0 as *mut CFE_SB_PipeD_t;
    BufDscPtr = 0 as *mut CFE_SB_BufferD_t;
    DestPtr = 0 as *mut CFE_SB_DestinationD_t;
    BufDscSize = 0 as libc::c_int as size_t;
    OsStatus = 0 as libc::c_int;
    if BufPtr.is_null() {
        PendingEventID = 18 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if TimeOut > 0 as libc::c_int {
        SysTimeout = TimeOut;
    } else if TimeOut == 0 as libc::c_int {
        SysTimeout = 0 as libc::c_int;
    } else if TimeOut != -(1 as libc::c_int) {
        PendingEventID = 18 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    if Status == 0 as libc::c_int {
        CFE_SB_LockSharedData(
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_SB_ReceiveBuffer\0"))
                .as_ptr(),
            1809 as libc::c_int,
        );
        PipeDscPtr = CFE_SB_LocatePipeDescByID(PipeId);
        if !CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
            PendingEventID = 19 as libc::c_int as uint16;
            Status = 0xca000003 as libc::c_uint as CFE_Status_t;
        } else {
            SysQueueId = (*PipeDscPtr).SysQueueId;
            if !((*PipeDscPtr).LastBuffer).is_null() {
                CFE_SB_DecrBufUseCnt((*PipeDscPtr).LastBuffer);
                (*PipeDscPtr).LastBuffer = 0 as *mut CFE_SB_BufferD_t;
            }
        }
        CFE_SB_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_SB_ReceiveBuffer\0"))
                .as_ptr(),
            1847 as libc::c_int,
        );
    }
    if Status == 0 as libc::c_int {
        OsStatus = OS_QueueGet(
            SysQueueId,
            &mut BufDscPtr as *mut *mut CFE_SB_BufferD_t as *mut libc::c_void,
            ::core::mem::size_of::<*mut CFE_SB_BufferD_t>() as libc::c_ulong,
            &mut BufDscSize,
            SysTimeout,
        );
        if !(OsStatus == 0 as libc::c_int
            && !BufDscPtr.is_null()
            && BufDscSize == ::core::mem::size_of::<*mut CFE_SB_BufferD_t>() as libc::c_ulong)
        {
            if OsStatus == -(8 as libc::c_int) {
                Status = 0xca000002 as libc::c_uint as CFE_Status_t;
            } else if OsStatus == -(10 as libc::c_int) {
                Status = 0xca000001 as libc::c_uint as CFE_Status_t;
            } else {
                PendingEventID = 27 as libc::c_int as uint16;
                Status = 0xca000006 as libc::c_uint as CFE_Status_t;
            }
        }
    }
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_SB_ReceiveBuffer\0"))
            .as_ptr(),
        1888 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        if CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
            CFE_SB_IncrBufUseCnt(BufDscPtr);
            (*PipeDscPtr).LastBuffer = BufDscPtr;
            *BufPtr = &mut (*BufDscPtr).Content;
            RouteId = CFE_SBR_GetRouteId((*BufDscPtr).MsgId);
            DestPtr = CFE_SB_GetDestPtr(RouteId, PipeId);
            if !DestPtr.is_null() && (*DestPtr).BuffCount as libc::c_int > 0 as libc::c_int {
                (*DestPtr).BuffCount = ((*DestPtr).BuffCount).wrapping_sub(1);
                (*DestPtr).BuffCount;
            }
            if (*PipeDscPtr).CurrentQueueDepth as libc::c_int > 0 as libc::c_int {
                (*PipeDscPtr).CurrentQueueDepth = ((*PipeDscPtr).CurrentQueueDepth).wrapping_sub(1);
                (*PipeDscPtr).CurrentQueueDepth;
            }
        } else {
            PendingEventID = 19 as libc::c_int as uint16;
            Status = 0xca000006 as libc::c_uint as CFE_Status_t;
        }
        CFE_SB_DecrBufUseCnt(BufDscPtr);
    }
    if Status != 0 as libc::c_int
        && Status != 0xca000002 as libc::c_uint as CFE_Status_t
        && Status != 0xca000001 as libc::c_uint as CFE_Status_t
    {
        if PendingEventID as libc::c_int == 18 as libc::c_int
            || PendingEventID as libc::c_int == 19 as libc::c_int
        {
            CFE_SB_Global.HKTlmMsg.Payload.MsgReceiveErrorCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.MsgReceiveErrorCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.MsgReceiveErrorCounter;
        } else {
            CFE_SB_Global.HKTlmMsg.Payload.InternalErrorCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.InternalErrorCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.InternalErrorCounter;
        }
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_SB_ReceiveBuffer\0"))
            .as_ptr(),
        1960 as libc::c_int,
    );
    if PendingEventID as libc::c_int != 0 as libc::c_int {
        CFE_ES_GetTaskID(&mut TskId);
        match PendingEventID as libc::c_int {
            27 => {
                CFE_EVS_SendEventWithAppID(
                    27 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Read Err,pipe %lu,app %s,stat %ld\0" as *const u8 as *const libc::c_char,
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                    OsStatus as libc::c_long,
                );
            }
            18 => {
                CFE_EVS_SendEventWithAppID(
                    18 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Rcv Err:Bad Input Arg:BufPtr 0x%lx,pipe %lu,t/o %d,app %s\0" as *const u8
                        as *const libc::c_char,
                    BufPtr as libc::c_ulong,
                    CFE_ResourceId_ToInteger(PipeId),
                    TimeOut,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            19 => {
                CFE_EVS_SendEventWithAppID(
                    19 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Rcv Err:PipeId %lu does not exist,app %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            _ => {}
        }
    }
    if Status != 0 as libc::c_int && !BufPtr.is_null() {
        *BufPtr = 0 as *mut CFE_SB_Buffer_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetPipeName(
    mut PipeNameBuf: *mut libc::c_char,
    mut PipeNameSize: size_t,
    mut PipeId: CFE_SB_PipeId_t,
) -> CFE_Status_t {
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut PendingEventID: uint16 = 0;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut SysQueueId: osal_id_t = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    Status = 0 as libc::c_int;
    SysQueueId = 0 as libc::c_int as osal_id_t;
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_GetPipeName\0"))
            .as_ptr(),
        661 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID(PipeId);
    if !CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
        PendingEventID = 64 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        SysQueueId = (*PipeDscPtr).SysQueueId;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_GetPipeName\0"))
            .as_ptr(),
        675 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        if PipeNameBuf.is_null() || PipeNameSize == 0 as libc::c_int as libc::c_ulong {
            PendingEventID = 63 as libc::c_int as uint16;
            Status = 0xca000003 as libc::c_uint as CFE_Status_t;
        } else {
            OsStatus = OS_GetResourceName(SysQueueId, PipeNameBuf, PipeNameSize);
            if OsStatus == 0 as libc::c_int {
                Status = 0 as libc::c_int;
            } else {
                PendingEventID = 64 as libc::c_int as uint16;
                Status = 0xca000003 as libc::c_uint as CFE_Status_t;
            }
        }
    }
    if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            62 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"GetPipeName name=%s id=%lu\0" as *const u8 as *const libc::c_char,
            PipeNameBuf,
            CFE_ResourceId_ToInteger(PipeId),
        );
    } else {
        CFE_ES_GetTaskID(&mut TskId);
        match PendingEventID as libc::c_int {
            63 => {
                CFE_EVS_SendEventWithAppID(
                    63 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Name Error:NullPtr,Requestor %s\0" as *const u8 as *const libc::c_char,
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            64 => {
                CFE_EVS_SendEventWithAppID(
                    64 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Id Error:Bad Argument,Id=%lu,Requestor %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_ResourceId_ToInteger(PipeId),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
            }
            _ => {}
        }
        if !PipeNameBuf.is_null() && PipeNameSize > 0 as libc::c_int as libc::c_ulong {
            memset(
                PipeNameBuf as *mut libc::c_void,
                0 as libc::c_int,
                PipeNameSize,
            );
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_BroadcastBufferToRoute(
    mut BufDscPtr: *mut CFE_SB_BufferD_t,
    mut RouteId: CFE_SBR_RouteId_t,
) {
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut DestPtr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut SBSndErr: CFE_SB_EventBuf_t = CFE_SB_EventBuf_t {
        EvtsToSnd: 0,
        EvtBuf: [CFE_SB_SendErrEventBuf_t {
            EventId: 0,
            OsStatus: 0,
            PipeId: 0,
        }; 16],
    };
    let mut OsStatus: int32 = 0;
    let mut i: uint32 = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut PipeName: [libc::c_char; 20] = [0; 20];
    let mut IsAcceptable: bool = false;
    SBSndErr.EvtsToSnd = 0 as libc::c_int as uint32;
    IsAcceptable = 1 as libc::c_int != 0;
    CFE_ES_GetAppID(&mut AppId);
    CFE_ES_GetTaskID(&mut TskId);
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"CFE_SB_BroadcastBufferToRoute\0",
        ))
        .as_ptr(),
        1551 as libc::c_int,
    );
    if CFE_SBR_IsValidRouteId(RouteId) {
        if (*BufDscPtr).NeedsUpdate {
            CFE_SBR_IncrementSequenceCounter(RouteId);
            CFE_MSG_SetSequenceCount(
                &mut (*BufDscPtr).Content.Msg,
                CFE_SBR_GetSequenceCounter(RouteId),
            );
            CFE_MSG_OriginationAction(
                &mut (*BufDscPtr).Content.Msg,
                (*BufDscPtr).ContentSize,
                &mut IsAcceptable,
            );
            (*BufDscPtr).NeedsUpdate = 0 as libc::c_int != 0;
        }
        DestPtr = CFE_SBR_GetDestListHeadPtr(RouteId);
        while !DestPtr.is_null() {
            if (*DestPtr).Active as libc::c_int == 1 as libc::c_int {
                PipeDscPtr = CFE_SB_LocatePipeDescByID((*DestPtr).PipeId);
            } else {
                PipeDscPtr = 0 as *mut CFE_SB_PipeD_t;
            }
            if CFE_SB_PipeDescIsMatch(PipeDscPtr, (*DestPtr).PipeId) {
                if !((*PipeDscPtr).Opts as libc::c_int & 0x1 as libc::c_int != 0 as libc::c_int
                    && CFE_ResourceId_Equal((*PipeDscPtr).AppId, AppId) as libc::c_int != 0)
                {
                    if (*DestPtr).BuffCount as libc::c_int
                        >= (*DestPtr).MsgId2PipeLim as libc::c_int
                    {
                        SBSndErr.EvtBuf[SBSndErr.EvtsToSnd as usize].PipeId = (*DestPtr).PipeId;
                        SBSndErr.EvtBuf[SBSndErr.EvtsToSnd as usize].EventId =
                            17 as libc::c_int as uint32;
                        SBSndErr.EvtsToSnd = (SBSndErr.EvtsToSnd).wrapping_add(1);
                        SBSndErr.EvtsToSnd;
                        CFE_SB_Global.HKTlmMsg.Payload.MsgLimitErrorCounter =
                            (CFE_SB_Global.HKTlmMsg.Payload.MsgLimitErrorCounter).wrapping_add(1);
                        CFE_SB_Global.HKTlmMsg.Payload.MsgLimitErrorCounter;
                        (*PipeDscPtr).SendErrors = ((*PipeDscPtr).SendErrors).wrapping_add(1);
                        (*PipeDscPtr).SendErrors;
                    } else {
                        OsStatus = OS_QueuePut(
                            (*PipeDscPtr).SysQueueId,
                            &mut BufDscPtr as *mut *mut CFE_SB_BufferD_t as *const libc::c_void,
                            ::core::mem::size_of::<*mut CFE_SB_BufferD_t>() as libc::c_ulong,
                            0 as libc::c_int as uint32,
                        );
                        if OsStatus == 0 as libc::c_int {
                            CFE_SB_IncrBufUseCnt(BufDscPtr);
                            (*DestPtr).BuffCount = ((*DestPtr).BuffCount).wrapping_add(1);
                            (*DestPtr).BuffCount;
                            (*DestPtr).DestCnt = ((*DestPtr).DestCnt).wrapping_add(1);
                            (*DestPtr).DestCnt;
                            (*PipeDscPtr).CurrentQueueDepth =
                                ((*PipeDscPtr).CurrentQueueDepth).wrapping_add(1);
                            (*PipeDscPtr).CurrentQueueDepth;
                            if (*PipeDscPtr).CurrentQueueDepth as libc::c_int
                                >= (*PipeDscPtr).PeakQueueDepth as libc::c_int
                            {
                                (*PipeDscPtr).PeakQueueDepth = (*PipeDscPtr).CurrentQueueDepth;
                            }
                        } else {
                            SBSndErr.EvtBuf[SBSndErr.EvtsToSnd as usize].PipeId = (*DestPtr).PipeId;
                            if OsStatus == -(9 as libc::c_int) {
                                SBSndErr.EvtBuf[SBSndErr.EvtsToSnd as usize].EventId =
                                    25 as libc::c_int as uint32;
                                CFE_SB_Global.HKTlmMsg.Payload.PipeOverflowErrorCounter =
                                    (CFE_SB_Global.HKTlmMsg.Payload.PipeOverflowErrorCounter)
                                        .wrapping_add(1);
                                CFE_SB_Global.HKTlmMsg.Payload.PipeOverflowErrorCounter;
                            } else {
                                SBSndErr.EvtBuf[SBSndErr.EvtsToSnd as usize].EventId =
                                    26 as libc::c_int as uint32;
                                SBSndErr.EvtBuf[SBSndErr.EvtsToSnd as usize].OsStatus = OsStatus;
                                CFE_SB_Global.HKTlmMsg.Payload.InternalErrorCounter =
                                    (CFE_SB_Global.HKTlmMsg.Payload.InternalErrorCounter)
                                        .wrapping_add(1);
                                CFE_SB_Global.HKTlmMsg.Payload.InternalErrorCounter;
                            }
                            SBSndErr.EvtsToSnd = (SBSndErr.EvtsToSnd).wrapping_add(1);
                            SBSndErr.EvtsToSnd;
                            (*PipeDscPtr).SendErrors = ((*PipeDscPtr).SendErrors).wrapping_add(1);
                            (*PipeDscPtr).SendErrors;
                        }
                    }
                }
            }
            DestPtr = (*DestPtr).Next;
        }
    }
    if SBSndErr.EvtsToSnd > 0 as libc::c_int as libc::c_uint {
        CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter;
    }
    CFE_SB_TrackingListRemove(&mut (*BufDscPtr).Link);
    (*BufDscPtr).AppId = 0 as libc::c_int as CFE_ResourceId_t;
    CFE_SB_TrackingListAdd(&mut CFE_SB_Global.InTransitList, &mut (*BufDscPtr).Link);
    CFE_SB_DecrBufUseCnt(BufDscPtr);
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 30], &[libc::c_char; 30]>(
            b"CFE_SB_BroadcastBufferToRoute\0",
        ))
        .as_ptr(),
        1681 as libc::c_int,
    );
    i = 0 as libc::c_int as uint32;
    while i < SBSndErr.EvtsToSnd {
        if SBSndErr.EvtBuf[i as usize].EventId == 17 as libc::c_int as libc::c_uint {
            if CFE_SB_RequestToSendEvent(TskId, 2 as libc::c_int as uint32)
                == 1 as libc::c_int as libc::c_uint
            {
                CFE_SB_GetPipeName(
                    PipeName.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
                    SBSndErr.EvtBuf[i as usize].PipeId,
                );
                CFE_ES_PerfLogAdd(5 as libc::c_int as uint32, 0 as libc::c_int as uint32);
                CFE_ES_PerfLogAdd(5 as libc::c_int as uint32, 1 as libc::c_int as uint32);
                CFE_EVS_SendEventWithAppID(
                    17 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Msg Limit Err,MsgId 0x%x,pipe %s,sender %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue((*BufDscPtr).MsgId),
                    PipeName.as_mut_ptr(),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
                CFE_SB_FinishSendEvent(TskId, 2 as libc::c_int as uint32);
            }
        } else if SBSndErr.EvtBuf[i as usize].EventId == 25 as libc::c_int as libc::c_uint {
            if CFE_SB_RequestToSendEvent(TskId, 3 as libc::c_int as uint32)
                == 1 as libc::c_int as libc::c_uint
            {
                CFE_SB_GetPipeName(
                    PipeName.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
                    SBSndErr.EvtBuf[i as usize].PipeId,
                );
                CFE_ES_PerfLogAdd(27 as libc::c_int as uint32, 0 as libc::c_int as uint32);
                CFE_ES_PerfLogAdd(27 as libc::c_int as uint32, 1 as libc::c_int as uint32);
                CFE_EVS_SendEventWithAppID(
                    25 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Overflow,MsgId 0x%x,pipe %s,sender %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_MsgIdToValue((*BufDscPtr).MsgId),
                    PipeName.as_mut_ptr(),
                    CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                );
                CFE_SB_FinishSendEvent(TskId, 3 as libc::c_int as uint32);
            }
        } else if CFE_SB_RequestToSendEvent(TskId, 4 as libc::c_int as uint32)
            == 1 as libc::c_int as libc::c_uint
        {
            CFE_SB_GetPipeName(
                PipeName.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
                SBSndErr.EvtBuf[i as usize].PipeId,
            );
            CFE_EVS_SendEventWithAppID(
                26 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_SB_Global.AppId,
                b"Pipe Write Err,MsgId 0x%x,pipe %s,sender %s,stat %ld\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue((*BufDscPtr).MsgId),
                PipeName.as_mut_ptr(),
                CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr()),
                SBSndErr.EvtBuf[i as usize].OsStatus as libc::c_long,
            );
            CFE_SB_FinishSendEvent(TskId, 4 as libc::c_int as uint32);
        }
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_DeletePipeFull(
    mut PipeId: CFE_SB_PipeId_t,
    mut AppId: CFE_ES_AppId_t,
) -> int32 {
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut Status: int32 = 0;
    let mut TskId: CFE_ES_TaskId_t = 0;
    let mut BufDscPtr: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    let mut SysQueueId: osal_id_t = 0;
    let mut FullName: [libc::c_char; 40] = [0; 40];
    let mut BufDscSize: size_t = 0;
    let mut Args: CFE_SB_RemovePipeCallback_t = CFE_SB_RemovePipeCallback_t {
        FullName: 0 as *const libc::c_char,
        PipeId: 0,
    };
    let mut PendingEventID: uint16 = 0;
    Status = 0 as libc::c_int;
    PendingEventID = 0 as libc::c_int as uint16;
    SysQueueId = 0 as libc::c_int as osal_id_t;
    BufDscPtr = 0 as *mut CFE_SB_BufferD_t;
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_DeletePipeFull\0"))
            .as_ptr(),
        355 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID(PipeId);
    if !CFE_SB_PipeDescIsMatch(PipeDscPtr, PipeId) {
        PendingEventID = 46 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else if !CFE_ResourceId_Equal(AppId, (*PipeDscPtr).AppId) {
        PendingEventID = 54 as libc::c_int as uint16;
        Status = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        Args.PipeId = PipeId;
        Args.FullName = FullName.as_mut_ptr();
        CFE_SBR_ForEachRouteId(
            Some(
                CFE_SB_RemovePipeFromRoute
                    as unsafe extern "C" fn(CFE_SBR_RouteId_t, *mut libc::c_void) -> (),
            ),
            &mut Args as *mut CFE_SB_RemovePipeCallback_t as *mut libc::c_void,
            0 as *mut CFE_SBR_Throttle_t,
        );
        SysQueueId = (*PipeDscPtr).SysQueueId;
        BufDscPtr = (*PipeDscPtr).LastBuffer;
        CFE_SB_PipeDescSetUsed(PipeDscPtr, 0xffffffff as libc::c_uint);
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_DeletePipeFull\0"))
            .as_ptr(),
        397 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        loop {
            if !BufDscPtr.is_null() {
                CFE_SB_LockSharedData(
                    (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(
                        b"CFE_SB_DeletePipeFull\0",
                    ))
                    .as_ptr(),
                    407 as libc::c_int,
                );
                CFE_SB_DecrBufUseCnt(BufDscPtr);
                CFE_SB_UnlockSharedData(
                    (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(
                        b"CFE_SB_DeletePipeFull\0",
                    ))
                    .as_ptr(),
                    409 as libc::c_int,
                );
                BufDscPtr = 0 as *mut CFE_SB_BufferD_t;
            }
            if OS_QueueGet(
                SysQueueId,
                &mut BufDscPtr as *mut *mut CFE_SB_BufferD_t as *mut libc::c_void,
                ::core::mem::size_of::<*mut CFE_SB_BufferD_t>() as libc::c_ulong,
                &mut BufDscSize,
                0 as libc::c_int,
            ) != 0 as libc::c_int
            {
                break;
            }
        }
        OS_QueueDelete(SysQueueId);
    }
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_DeletePipeFull\0"))
            .as_ptr(),
        427 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_SB_PipeDescSetFree(PipeDscPtr);
        CFE_SB_Global.StatTlmMsg.Payload.PipesInUse =
            (CFE_SB_Global.StatTlmMsg.Payload.PipesInUse).wrapping_sub(1);
        CFE_SB_Global.StatTlmMsg.Payload.PipesInUse;
    } else if PendingEventID as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.HKTlmMsg.Payload.CreatePipeErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.CreatePipeErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.CreatePipeErrorCounter;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_DeletePipeFull\0"))
            .as_ptr(),
        439 as libc::c_int,
    );
    if Status == 0 as libc::c_int {
        CFE_ES_GetAppName(
            FullName.as_mut_ptr(),
            AppId,
            ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        );
        CFE_EVS_SendEventWithAppID(
            47 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Pipe Deleted:id %d,owner %s\0" as *const u8 as *const libc::c_char,
            CFE_ResourceId_ToInteger(PipeId) as libc::c_int,
            FullName.as_mut_ptr(),
        );
    } else {
        CFE_ES_GetTaskID(&mut TskId);
        CFE_SB_GetAppTskName(TskId, FullName.as_mut_ptr());
        match PendingEventID as libc::c_int {
            46 => {
                CFE_EVS_SendEventWithAppID(
                    46 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Delete Error:Bad Argument,PipedId %ld,Requestor %s\0" as *const u8
                        as *const libc::c_char,
                    CFE_ResourceId_ToInteger(PipeId),
                    FullName.as_mut_ptr(),
                );
            }
            54 => {
                CFE_EVS_SendEventWithAppID(
                    54 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_SB_Global.AppId,
                    b"Pipe Delete Error:Caller(%s) is not the owner of pipe %ld\0" as *const u8
                        as *const libc::c_char,
                    FullName.as_mut_ptr(),
                    CFE_ResourceId_ToInteger(PipeId),
                );
            }
            _ => {}
        }
    }
    return Status;
}
#[inline]
unsafe extern "C" fn CFE_SB_TrackingListGetNext(
    mut Node: *mut CFE_SB_BufferLink_t,
) -> *mut CFE_SB_BufferLink_t {
    return (*Node).Next;
}
#[inline]
unsafe extern "C" fn CFE_SB_TrackingListIsEnd(
    mut List: *const CFE_SB_BufferLink_t,
    mut Node: *const CFE_SB_BufferLink_t,
) -> bool {
    return Node.is_null() || Node == List;
}
#[inline]
unsafe extern "C" fn CFE_SB_PipeDescSetUsed(
    mut PipeDscPtr: *mut CFE_SB_PipeD_t,
    mut PendingID: CFE_ResourceId_t,
) {
    (*PipeDscPtr).PipeId = PendingID;
}
#[inline]
unsafe extern "C" fn CFE_SB_PipeDescGetID(
    mut PipeDscPtr: *const CFE_SB_PipeD_t,
) -> CFE_SB_PipeId_t {
    return (*PipeDscPtr).PipeId;
}
#[inline]
unsafe extern "C" fn CFE_SB_PipeDescIsUsed(mut PipeDscPtr: *const CFE_SB_PipeD_t) -> bool {
    return CFE_ResourceId_IsDefined((*PipeDscPtr).PipeId);
}
#[inline]
unsafe extern "C" fn CFE_SB_PipeDescSetFree(mut PipeDscPtr: *mut CFE_SB_PipeD_t) {
    (*PipeDscPtr).PipeId = 0 as libc::c_int as CFE_ResourceId_t;
}
#[inline]
unsafe extern "C" fn CFE_SB_PipeDescIsMatch(
    mut PipeDscPtr: *const CFE_SB_PipeD_t,
    mut PipeID: CFE_SB_PipeId_t,
) -> bool {
    return !PipeDscPtr.is_null()
        && CFE_ResourceId_Equal((*PipeDscPtr).PipeId, PipeID) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TrackingListReset(mut Link: *mut CFE_SB_BufferLink_t) {
    (*Link).Prev = Link;
    (*Link).Next = Link;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TrackingListRemove(mut Node: *mut CFE_SB_BufferLink_t) {
    (*(*Node).Prev).Next = (*Node).Next;
    (*(*Node).Next).Prev = (*Node).Prev;
    CFE_SB_TrackingListReset(Node);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TrackingListAdd(
    mut List: *mut CFE_SB_BufferLink_t,
    mut Node: *mut CFE_SB_BufferLink_t,
) {
    (*Node).Prev = (*List).Prev;
    (*Node).Next = List;
    (*(*Node).Prev).Next = Node;
    (*(*Node).Next).Prev = Node;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetBufferFromPool(mut MaxMsgSize: size_t) -> *mut CFE_SB_BufferD_t {
    let mut stat1: int32 = 0;
    let mut AllocSize: size_t = 0;
    let mut addr: CFE_ES_MemPoolBuf_t = 0 as *mut libc::c_void;
    let mut bd: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    AllocSize = MaxMsgSize.wrapping_add(48 as libc::c_ulong);
    stat1 = CFE_ES_GetPoolBuf(&mut addr, CFE_SB_Global.Mem.PoolHdl, AllocSize);
    if stat1 < 0 as libc::c_int {
        return 0 as *mut CFE_SB_BufferD_t;
    }
    CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse =
        (CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse).wrapping_add(1);
    CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse;
    if CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse
        > CFE_SB_Global.StatTlmMsg.Payload.PeakSBBuffersInUse
    {
        CFE_SB_Global.StatTlmMsg.Payload.PeakSBBuffersInUse =
            CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse;
    }
    CFE_SB_Global.StatTlmMsg.Payload.MemInUse =
        (CFE_SB_Global.StatTlmMsg.Payload.MemInUse as libc::c_ulong).wrapping_add(AllocSize)
            as uint32 as uint32;
    if CFE_SB_Global.StatTlmMsg.Payload.MemInUse > CFE_SB_Global.StatTlmMsg.Payload.PeakMemInUse {
        CFE_SB_Global.StatTlmMsg.Payload.PeakMemInUse = CFE_SB_Global.StatTlmMsg.Payload.MemInUse;
    }
    bd = addr as *mut CFE_SB_BufferD_t;
    memset(
        bd as *mut libc::c_void,
        0 as libc::c_int,
        48 as libc::c_ulong,
    );
    (*bd).MsgId = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    (*bd).UseCount = 1 as libc::c_int as uint16;
    (*bd).AllocatedSize = AllocSize;
    CFE_SB_TrackingListReset(&mut (*bd).Link);
    return bd;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ReturnBufferToPool(mut bd: *mut CFE_SB_BufferD_t) {
    CFE_SB_TrackingListRemove(&mut (*bd).Link);
    CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse =
        (CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse).wrapping_sub(1);
    CFE_SB_Global.StatTlmMsg.Payload.SBBuffersInUse;
    CFE_SB_Global.StatTlmMsg.Payload.MemInUse =
        (CFE_SB_Global.StatTlmMsg.Payload.MemInUse as libc::c_ulong)
            .wrapping_sub((*bd).AllocatedSize) as uint32 as uint32;
    CFE_ES_PutPoolBuf(CFE_SB_Global.Mem.PoolHdl, bd as CFE_ES_MemPoolBuf_t);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_IncrBufUseCnt(mut bd: *mut CFE_SB_BufferD_t) {
    if ((*bd).UseCount as libc::c_int) < 0x7fff as libc::c_int {
        (*bd).UseCount = ((*bd).UseCount).wrapping_add(1);
        (*bd).UseCount;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_DecrBufUseCnt(mut bd: *mut CFE_SB_BufferD_t) {
    if (*bd).UseCount as libc::c_int > 0 as libc::c_int {
        (*bd).UseCount = ((*bd).UseCount).wrapping_sub(1);
        (*bd).UseCount;
        if (*bd).UseCount as libc::c_int == 0 as libc::c_int {
            CFE_SB_ReturnBufferToPool(bd);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetDestinationBlk() -> *mut CFE_SB_DestinationD_t {
    let mut Stat: int32 = 0;
    let mut addr: CFE_ES_MemPoolBuf_t = 0 as *mut libc::c_void;
    Stat = CFE_ES_GetPoolBuf(
        &mut addr,
        CFE_SB_Global.Mem.PoolHdl,
        ::core::mem::size_of::<CFE_SB_DestinationD_t>() as libc::c_ulong,
    );
    if Stat < 0 as libc::c_int {
        return 0 as *mut CFE_SB_DestinationD_t;
    }
    CFE_SB_Global.StatTlmMsg.Payload.MemInUse =
        (CFE_SB_Global.StatTlmMsg.Payload.MemInUse as libc::c_uint)
            .wrapping_add(Stat as libc::c_uint) as uint32 as uint32;
    if CFE_SB_Global.StatTlmMsg.Payload.MemInUse > CFE_SB_Global.StatTlmMsg.Payload.PeakMemInUse {
        CFE_SB_Global.StatTlmMsg.Payload.PeakMemInUse = CFE_SB_Global.StatTlmMsg.Payload.MemInUse;
    }
    return addr as *mut CFE_SB_DestinationD_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_PutDestinationBlk(mut Dest: *mut CFE_SB_DestinationD_t) -> int32 {
    let mut Stat: int32 = 0;
    if Dest.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    Stat = CFE_ES_PutPoolBuf(CFE_SB_Global.Mem.PoolHdl, Dest as CFE_ES_MemPoolBuf_t);
    if Stat > 0 as libc::c_int {
        CFE_SB_Global.StatTlmMsg.Payload.MemInUse =
            (CFE_SB_Global.StatTlmMsg.Payload.MemInUse as libc::c_uint)
                .wrapping_sub(Stat as libc::c_uint) as uint32 as uint32;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut CFE_SB_MemPoolDefSize: [size_t; 17] = [
    (32768 as libc::c_int + 128 as libc::c_int) as size_t,
    32768 as libc::c_int as size_t,
    16384 as libc::c_int as size_t,
    8192 as libc::c_int as size_t,
    4096 as libc::c_int as size_t,
    2048 as libc::c_int as size_t,
    1024 as libc::c_int as size_t,
    512 as libc::c_int as size_t,
    256 as libc::c_int as size_t,
    160 as libc::c_int as size_t,
    128 as libc::c_int as size_t,
    96 as libc::c_int as size_t,
    64 as libc::c_int as size_t,
    36 as libc::c_int as size_t,
    20 as libc::c_int as size_t,
    16 as libc::c_int as size_t,
    8 as libc::c_int as size_t,
];
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_EarlyInit() -> int32 {
    let mut OsStatus: int32 = 0;
    let mut Stat: int32 = 0;
    memset(
        &mut CFE_SB_Global as *mut CFE_SB_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_SB_Global_t>() as libc::c_ulong,
    );
    OsStatus = OS_MutSemCreate(
        &mut CFE_SB_Global.SharedDataMutexId,
        b"CFE_SB_DataMutex\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Shared data mutex creation failed! RC=%ld\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_SB_EarlyInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    CFE_SB_Global.SubscriptionReporting = 0 as libc::c_int as uint32;
    Stat = CFE_SB_InitBuffers();
    if Stat != 0 as libc::c_int {
        return Stat;
    }
    CFE_SB_InitPipeTbl();
    CFE_SBR_Init();
    CFE_MSG_Init(
        &mut CFE_SB_Global.StatTlmMsg.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 10 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_SB_StatsTlm_t>() as libc::c_ulong,
    );
    return Stat;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_InitBuffers() -> int32 {
    let mut Stat: int32 = 0 as libc::c_int;
    Stat = CFE_ES_PoolCreateEx(
        &mut CFE_SB_Global.Mem.PoolHdl,
        (CFE_SB_Global.Mem.Partition.Data).as_mut_ptr() as *mut libc::c_void,
        524288 as libc::c_int as size_t,
        17 as libc::c_int as uint16,
        &*CFE_SB_MemPoolDefSize
            .as_ptr()
            .offset(0 as libc::c_int as isize),
        0 as libc::c_int != 0,
    );
    if Stat != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: PoolCreate failed for SB Buffers, gave adr 0x%lx,size %d,stat=0x%x\n\0"
                as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_InitBuffers\0"))
                .as_ptr(),
            (CFE_SB_Global.Mem.Partition.Data).as_mut_ptr() as libc::c_ulong,
            524288 as libc::c_int,
            Stat as libc::c_uint,
        );
        return Stat;
    }
    CFE_SB_TrackingListReset(&mut CFE_SB_Global.InTransitList);
    CFE_SB_TrackingListReset(&mut CFE_SB_Global.ZeroCopyList);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_InitPipeTbl() {
    CFE_SB_Global.LastPipeId =
        CFE_ResourceId_FromInteger(CFE_SB_PIPEID_BASE as libc::c_int as libc::c_ulong);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_IsValidMsgId(mut MsgId: CFE_SB_MsgId_t) -> bool {
    return !CFE_SB_MsgId_Equal(MsgId, {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    }) && CFE_SB_MsgIdToValue(MsgId) <= 0x1fff as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_CleanUpApp(mut AppId: CFE_ES_AppId_t) -> int32 {
    let mut i: uint32 = 0;
    let mut DelCount: uint32 = 0;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut DelList: [CFE_SB_PipeId_t; 64] = [0; 64];
    PipeDscPtr = (CFE_SB_Global.PipeTbl).as_mut_ptr();
    DelCount = 0 as libc::c_int as uint32;
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_SB_CleanUpApp\0"))
            .as_ptr(),
        97 as libc::c_int,
    );
    i = 0 as libc::c_int as uint32;
    while i < 64 as libc::c_int as libc::c_uint {
        if CFE_SB_PipeDescIsUsed(PipeDscPtr) as libc::c_int != 0
            && CFE_ResourceId_Equal((*PipeDscPtr).AppId, AppId) as libc::c_int != 0
        {
            DelList[DelCount as usize] = CFE_SB_PipeDescGetID(PipeDscPtr);
            DelCount = DelCount.wrapping_add(1);
            DelCount;
        }
        PipeDscPtr = PipeDscPtr.offset(1);
        PipeDscPtr;
        i = i.wrapping_add(1);
        i;
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_SB_CleanUpApp\0"))
            .as_ptr(),
        110 as libc::c_int,
    );
    i = 0 as libc::c_int as uint32;
    while i < DelCount {
        CFE_SB_DeletePipeWithAppId(DelList[i as usize], AppId);
        i = i.wrapping_add(1);
        i;
    }
    CFE_SB_ZeroCopyReleaseAppId(AppId);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_LockSharedData(
    mut FuncName: *const libc::c_char,
    mut LineNumber: int32,
) {
    let mut OsStatus: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    OsStatus = OS_MutSemTake(CFE_SB_Global.SharedDataMutexId);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_GetAppID(&mut AppId);
        CFE_ES_WriteToSysLog(
            b"%s: SharedData Mutex Take Err Stat=%ld,App=%lu,Func=%s,Line=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_LockSharedData\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
            CFE_ResourceId_ToInteger(AppId),
            FuncName,
            LineNumber,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_UnlockSharedData(
    mut FuncName: *const libc::c_char,
    mut LineNumber: int32,
) {
    let mut OsStatus: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    OsStatus = OS_MutSemGive(CFE_SB_Global.SharedDataMutexId);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_GetAppID(&mut AppId);
        CFE_ES_WriteToSysLog(
            b"%s: SharedData Mutex Give Err Stat=%ld,App=%lu,Func=%s,Line=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_SB_UnlockSharedData\0",
            ))
            .as_ptr(),
            OsStatus as libc::c_long,
            CFE_ResourceId_ToInteger(AppId),
            FuncName,
            LineNumber,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetDestPtr(
    mut RouteId: CFE_SBR_RouteId_t,
    mut PipeId: CFE_SB_PipeId_t,
) -> *mut CFE_SB_DestinationD_t {
    let mut destptr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    destptr = CFE_SBR_GetDestListHeadPtr(RouteId);
    while !destptr.is_null() {
        if CFE_ResourceId_Equal((*destptr).PipeId, PipeId) {
            break;
        }
        destptr = (*destptr).Next;
    }
    return destptr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ValidateMsgId(mut MsgId: CFE_SB_MsgId_t) -> int32 {
    if !CFE_SB_IsValidMsgId(MsgId) {
        return 1 as libc::c_int;
    } else {
        return 0 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_LocatePipeDescByID(
    mut PipeId: CFE_SB_PipeId_t,
) -> *mut CFE_SB_PipeD_t {
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut Idx: uint32 = 0;
    if CFE_SB_PipeId_ToIndex(PipeId, &mut Idx) == 0 as libc::c_int {
        PipeDscPtr =
            &mut *(CFE_SB_Global.PipeTbl).as_mut_ptr().offset(Idx as isize) as *mut CFE_SB_PipeD_t;
    } else {
        PipeDscPtr = 0 as *mut CFE_SB_PipeD_t;
    }
    return PipeDscPtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_CheckPipeDescSlotUsed(mut CheckId: CFE_ResourceId_t) -> bool {
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    PipeDscPtr = CFE_SB_LocatePipeDescByID(CheckId);
    return PipeDscPtr.is_null() || CFE_SB_PipeDescIsUsed(PipeDscPtr) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetAppTskName(
    mut TaskId: CFE_ES_TaskId_t,
    mut FullName: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut TaskInfo: CFE_ES_TaskInfo_t = CFE_ES_TaskInfo_t {
        TaskId: 0,
        ExecutionCounter: 0,
        TaskName: [0; 20],
        AppId: 0,
        AppName: [0; 20],
        StackSize: 0,
        Priority: 0,
        Spare: [0; 2],
    };
    let mut ptr: *mut CFE_ES_TaskInfo_t = &mut TaskInfo;
    let mut AppName: [libc::c_char; 20] = [0; 20];
    let mut TskName: [libc::c_char; 20] = [0; 20];
    if CFE_ES_GetTaskInfo(ptr, TaskId) != 0 as libc::c_int {
        strncpy(
            FullName,
            b"Unknown\0" as *const u8 as *const libc::c_char,
            (20 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
        );
        *FullName.offset((20 as libc::c_int - 1 as libc::c_int) as isize) =
            '\0' as i32 as libc::c_char;
    } else if strncmp(
        ((*ptr).AppName).as_mut_ptr(),
        ((*ptr).TaskName).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    ) == 0 as libc::c_int
    {
        strncpy(
            FullName,
            ((*ptr).AppName).as_mut_ptr(),
            (20 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
        );
        *FullName.offset((20 as libc::c_int - 1 as libc::c_int) as isize) =
            '\0' as i32 as libc::c_char;
    } else {
        strncpy(
            AppName.as_mut_ptr(),
            ((*ptr).AppName).as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        AppName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
            '\0' as i32 as libc::c_char;
        strncpy(
            TskName.as_mut_ptr(),
            ((*ptr).TaskName).as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        TskName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
            '\0' as i32 as libc::c_char;
        sprintf(
            FullName,
            b"%s.%s\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            TskName.as_mut_ptr(),
        );
    }
    return FullName;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_RequestToSendEvent(
    mut TaskId: CFE_ES_TaskId_t,
    mut Bit: uint32,
) -> uint32 {
    let mut Indx: uint32 = 0;
    if CFE_ES_TaskID_ToIndex(TaskId, &mut Indx) != 0 as libc::c_int {
        return 0 as libc::c_int as uint32;
    }
    if CFE_SB_Global.StopRecurseFlags[Indx as usize] & ((1 as libc::c_int) << Bit) as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int as uint32;
    } else {
        CFE_SB_Global.StopRecurseFlags[Indx as usize] |=
            ((1 as libc::c_int) << Bit) as libc::c_uint;
        return 1 as libc::c_int as uint32;
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_FinishSendEvent(mut TaskId: CFE_ES_TaskId_t, mut Bit: uint32) {
    let mut Indx: uint32 = 0;
    if CFE_ES_TaskID_ToIndex(TaskId, &mut Indx) != 0 as libc::c_int {
        return;
    }
    CFE_SB_Global.StopRecurseFlags[Indx as usize] &= !((1 as libc::c_int) << Bit) as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_AddDestNode(
    mut RouteId: CFE_SBR_RouteId_t,
    mut NewNode: *mut CFE_SB_DestinationD_t,
) -> int32 {
    let mut WBS: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut listheadptr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    listheadptr = CFE_SBR_GetDestListHeadPtr(RouteId);
    if listheadptr.is_null() {
        (*NewNode).Next = 0 as *mut CFE_SB_DestinationD;
        (*NewNode).Prev = 0 as *mut CFE_SB_DestinationD;
    } else {
        WBS = listheadptr;
        (*NewNode).Next = WBS;
        (*NewNode).Prev = 0 as *mut CFE_SB_DestinationD;
        (*WBS).Prev = NewNode;
    }
    CFE_SBR_SetDestListHeadPtr(RouteId, NewNode);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_RemoveDest(
    mut RouteId: CFE_SBR_RouteId_t,
    mut DestPtr: *mut CFE_SB_DestinationD_t,
) {
    CFE_SB_RemoveDestNode(RouteId, DestPtr);
    CFE_SB_PutDestinationBlk(DestPtr);
    CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse =
        (CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse).wrapping_sub(1);
    CFE_SB_Global.StatTlmMsg.Payload.SubscriptionsInUse;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_RemoveDestNode(
    mut RouteId: CFE_SBR_RouteId_t,
    mut NodeToRemove: *mut CFE_SB_DestinationD_t,
) {
    let mut PrevNode: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut NextNode: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    if ((*NodeToRemove).Prev).is_null() && ((*NodeToRemove).Next).is_null() {
        CFE_SBR_SetDestListHeadPtr(RouteId, 0 as *mut CFE_SB_DestinationD_t);
    } else if ((*NodeToRemove).Prev).is_null() {
        NextNode = (*NodeToRemove).Next;
        (*NextNode).Prev = 0 as *mut CFE_SB_DestinationD;
        CFE_SBR_SetDestListHeadPtr(RouteId, NextNode);
    } else if ((*NodeToRemove).Next).is_null() {
        PrevNode = (*NodeToRemove).Prev;
        (*PrevNode).Next = 0 as *mut CFE_SB_DestinationD;
    } else {
        PrevNode = (*NodeToRemove).Prev;
        NextNode = (*NodeToRemove).Next;
        (*PrevNode).Next = NextNode;
        (*NextNode).Prev = PrevNode;
    }
    (*NodeToRemove).Next = 0 as *mut CFE_SB_DestinationD;
    (*NodeToRemove).Prev = 0 as *mut CFE_SB_DestinationD;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ZeroCopyReleaseAppId(mut AppId: CFE_ES_AppId_t) -> int32 {
    let mut NextLink: *mut CFE_SB_BufferLink_t = 0 as *mut CFE_SB_BufferLink_t;
    let mut DscPtr: *mut CFE_SB_BufferD_t = 0 as *mut CFE_SB_BufferD_t;
    if CFE_ResourceId_IsDefined(AppId) {
        CFE_SB_LockSharedData(
            (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                b"CFE_SB_ZeroCopyReleaseAppId\0",
            ))
            .as_ptr(),
            446 as libc::c_int,
        );
        NextLink = CFE_SB_TrackingListGetNext(&mut CFE_SB_Global.ZeroCopyList);
        while !CFE_SB_TrackingListIsEnd(&mut CFE_SB_Global.ZeroCopyList, NextLink) {
            DscPtr = NextLink as *mut libc::c_void as *mut CFE_SB_BufferD_t;
            NextLink = CFE_SB_TrackingListGetNext(NextLink);
            if CFE_ResourceId_Equal((*DscPtr).AppId, AppId) {
                CFE_SB_DecrBufUseCnt(DscPtr);
            }
        }
        CFE_SB_UnlockSharedData(
            (*::core::mem::transmute::<&[u8; 28], &[libc::c_char; 28]>(
                b"CFE_SB_ZeroCopyReleaseAppId\0",
            ))
            .as_ptr(),
            468 as libc::c_int,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_VerifyCmdLength(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut ExpectedLength: size_t,
) -> bool {
    let mut result: bool = 1 as libc::c_int != 0;
    let mut ActualLength: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetSize(MsgPtr, &mut ActualLength);
    if ExpectedLength != ActualLength {
        CFE_MSG_GetMsgId(MsgPtr, &mut MsgId);
        CFE_MSG_GetFcnCode(MsgPtr, &mut FcnCode);
        CFE_EVS_SendEvent(
            68 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid msg length: ID = 0x%X,  CC = %u, Len = %u, Expected = %u\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            FcnCode as libc::c_uint,
            ActualLength as libc::c_uint,
            ExpectedLength as libc::c_uint,
        );
        result = 0 as libc::c_int != 0;
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ProcessCmdPipePkt(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MessageID: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MessageID);
    match CFE_SB_MsgIdToValue(MessageID) {
        6155 => {
            CFE_SB_SendHKTlmCmd(SBBufPtr as *const CFE_SB_SendHkCmd_t);
        }
        6158 => {
            CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut FcnCode);
            match FcnCode as libc::c_int {
                11 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_SendPrevSubsCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_SendPrevSubsCmd(SBBufPtr as *const CFE_SB_SendPrevSubsCmd_t);
                    }
                }
                9 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_EnableSubReportingCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_EnableSubReportingCmd(
                            SBBufPtr as *const CFE_SB_EnableSubReportingCmd_t,
                        );
                    }
                }
                10 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_DisableSubReportingCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_DisableSubReportingCmd(
                            SBBufPtr as *const CFE_SB_DisableSubReportingCmd_t,
                        );
                    }
                }
                _ => {
                    CFE_EVS_SendEvent(
                        42 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Invalid Cmd, Unexpected Command Code %u\0" as *const u8
                            as *const libc::c_char,
                        FcnCode as libc::c_uint,
                    );
                    CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
                        (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
                    CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
                }
            }
        }
        6147 => {
            CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut FcnCode);
            match FcnCode as libc::c_int {
                0 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_NoopCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_NoopCmd(SBBufPtr as *const CFE_SB_NoopCmd_t);
                    }
                }
                1 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_ResetCountersCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_ResetCountersCmd(SBBufPtr as *const CFE_SB_ResetCountersCmd_t);
                    }
                }
                2 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_SendSbStatsCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_SendStatsCmd(SBBufPtr as *const CFE_SB_SendSbStatsCmd_t);
                    }
                }
                3 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_WriteRoutingInfoCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_WriteRoutingInfoCmd(SBBufPtr as *const CFE_SB_WriteRoutingInfoCmd_t);
                    }
                }
                4 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_EnableRouteCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_EnableRouteCmd(SBBufPtr as *const CFE_SB_EnableRouteCmd_t);
                    }
                }
                5 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_DisableRouteCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_DisableRouteCmd(SBBufPtr as *const CFE_SB_DisableRouteCmd_t);
                    }
                }
                7 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_WritePipeInfoCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_WritePipeInfoCmd(SBBufPtr as *const CFE_SB_WritePipeInfoCmd_t);
                    }
                }
                8 => {
                    if CFE_SB_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_SB_WriteMapInfoCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_SB_WriteMapInfoCmd(SBBufPtr as *const CFE_SB_WriteMapInfoCmd_t);
                    }
                }
                _ => {
                    CFE_EVS_SendEvent(
                        42 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Invalid Cmd, Unexpected Command Code %u\0" as *const u8
                            as *const libc::c_char,
                        FcnCode as libc::c_int,
                    );
                    CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
                        (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
                    CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
                }
            }
        }
        _ => {
            CFE_EVS_SendEvent(
                43 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Invalid Cmd, Unexpected Msg Id: 0x%x\0" as *const u8 as *const libc::c_char,
                CFE_SB_MsgIdToValue(MessageID),
            );
            CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
        }
    };
}
#[no_mangle]
pub static mut CFE_SB_Global: CFE_SB_Global_t = CFE_SB_Global_t {
    SharedDataMutexId: 0,
    SubscriptionReporting: 0,
    AppId: 0,
    StopRecurseFlags: [0; 64],
    PipeTbl: [CFE_SB_PipeD_t {
        PipeId: 0,
        Opts: 0,
        Spare: 0,
        AppId: 0,
        SysQueueId: 0,
        SendErrors: 0,
        MaxQueueDepth: 0,
        CurrentQueueDepth: 0,
        PeakQueueDepth: 0,
        LastBuffer: 0 as *const CFE_SB_BufferD_t as *mut CFE_SB_BufferD_t,
    }; 64],
    HKTlmMsg: CFE_SB_HousekeepingTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_SB_HousekeepingTlm_Payload_t {
            CommandCounter: 0,
            CommandErrorCounter: 0,
            NoSubscribersCounter: 0,
            MsgSendErrorCounter: 0,
            MsgReceiveErrorCounter: 0,
            InternalErrorCounter: 0,
            CreatePipeErrorCounter: 0,
            SubscribeErrorCounter: 0,
            PipeOptsErrorCounter: 0,
            DuplicateSubscriptionsCounter: 0,
            GetPipeIdByNameErrorCounter: 0,
            Spare2Align: [0; 1],
            PipeOverflowErrorCounter: 0,
            MsgLimitErrorCounter: 0,
            MemPoolHandle: 0,
            MemInUse: 0,
            UnmarkedMem: 0,
        },
    },
    StatTlmMsg: CFE_SB_StatsTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_SB_StatsTlm_Payload_t {
            MsgIdsInUse: 0,
            PeakMsgIdsInUse: 0,
            MaxMsgIdsAllowed: 0,
            PipesInUse: 0,
            PeakPipesInUse: 0,
            MaxPipesAllowed: 0,
            MemInUse: 0,
            PeakMemInUse: 0,
            MaxMemAllowed: 0,
            SubscriptionsInUse: 0,
            PeakSubscriptionsInUse: 0,
            MaxSubscriptionsAllowed: 0,
            SBBuffersInUse: 0,
            PeakSBBuffersInUse: 0,
            MaxPipeDepthAllowed: 0,
            PipeDepthStats: [CFE_SB_PipeDepthStats_t {
                PipeId: 0,
                MaxQueueDepth: 0,
                CurrentQueueDepth: 0,
                PeakQueueDepth: 0,
                Spare: 0,
            }; 64],
        },
    },
    CmdPipe: 0,
    Mem: CFE_SB_MemParams_t {
        PoolHdl: 0,
        Partition: C2RustUnnamed_21 {
            Align: CFE_ES_PoolAlign {
                Ptr: 0 as *const libc::c_void as *mut libc::c_void,
            },
        },
    },
    PrevSubMsg: CFE_SB_AllSubscriptionsTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_SB_AllSubscriptionsTlm_Payload_t {
            PktSegment: 0,
            TotalSegments: 0,
            Entries: 0,
            Entry: [CFE_SB_SubEntries_t {
                MsgId: CFE_SB_MsgId_t { Value: 0 },
                Qos: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                Pipe: 0,
            }; 20],
        },
    },
    EventFilters: [CFE_EVS_BinFilter_t {
        EventID: 0,
        Mask: 0,
    }; 8],
    Default_Qos: CFE_SB_Qos_t {
        Priority: 0,
        Reliability: 0,
    },
    LastPipeId: 0,
    BackgroundFile: CFE_SB_BackgroundFileStateInfo_t {
        FileWrite: CFE_FS_FileWriteMetaData_t {
            IsPending: false,
            FileName: [0; 64],
            FileSubType: 0,
            Description: [0; 32],
            GetData: None,
            OnEvent: None,
        },
        Buffer: CFE_SB_BackgroundFileBuffer_t {
            RouteInfo: CFE_SB_BackgroundRouteInfoBuffer_t {
                NumDestinations: 0,
                DestEntries: [CFE_SB_RoutingFileEntry_t {
                    MsgId: CFE_SB_MsgId_t { Value: 0 },
                    PipeId: 0,
                    State: 0,
                    MsgCnt: 0,
                    AppName: [0; 20],
                    PipeName: [0; 20],
                }; 16],
            },
        },
    },
    InTransitList: CFE_SB_BufferLink_t {
        Next: 0 as *const CFE_SB_BufferLink as *mut CFE_SB_BufferLink,
        Prev: 0 as *const CFE_SB_BufferLink as *mut CFE_SB_BufferLink,
    },
    ZeroCopyList: CFE_SB_BufferLink_t {
        Next: 0 as *const CFE_SB_BufferLink as *mut CFE_SB_BufferLink,
        Prev: 0 as *const CFE_SB_BufferLink as *mut CFE_SB_BufferLink,
    },
};
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TaskMain() {
    let mut Status: int32 = 0;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(4 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    Status = CFE_SB_AppInit();
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Application Init Failed,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_SB_TaskMain\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        CFE_ES_PerfLogAdd(4 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_INIT_ERROR as libc::c_int as uint32);
    }
    CFE_ES_WaitForSystemState(
        CFE_ES_SystemState_CORE_READY as libc::c_int as uint32,
        30000 as libc::c_int as uint32,
    );
    while Status == 0 as libc::c_int {
        CFE_ES_IncrementTaskCounter();
        CFE_ES_PerfLogAdd(4 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        Status = CFE_SB_ReceiveBuffer(&mut SBBufPtr, CFE_SB_Global.CmdPipe, -(1 as libc::c_int));
        CFE_ES_PerfLogAdd(4 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if Status == 0 as libc::c_int {
            CFE_SB_ProcessCmdPipePkt(SBBufPtr);
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Error reading cmd pipe,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"CFE_SB_TaskMain\0"))
                    .as_ptr(),
                Status as libc::c_uint,
            );
        }
    }
    CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR as libc::c_int as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_AppInit() -> int32 {
    let mut CfgFileEventsToFilter: uint32 = 0 as libc::c_int as uint32;
    let mut TmpPtr: CFE_ES_MemPoolBuf_t = 0 as *mut libc::c_void;
    let mut Status: int32 = 0;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_ES_GetAppID(&mut CFE_SB_Global.AppId);
    if 14 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            14 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0xfffc as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if 7 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            7 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0xfffc as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if 17 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            17 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0xfff0 as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if 25 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            25 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0xfff0 as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if 0 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            0 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0 as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if 0 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            0 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0 as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if 0 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            0 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0 as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if 0 as libc::c_int != 0 as libc::c_int {
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].EventID =
            0 as libc::c_int as uint16;
        CFE_SB_Global.EventFilters[CfgFileEventsToFilter as usize].Mask =
            0 as libc::c_int as uint16;
        CfgFileEventsToFilter = CfgFileEventsToFilter.wrapping_add(1);
        CfgFileEventsToFilter;
    }
    if (8 as libc::c_int as libc::c_uint) < CfgFileEventsToFilter {
        CfgFileEventsToFilter = 8 as libc::c_int as uint32;
    }
    Status = CFE_EVS_Register(
        (CFE_SB_Global.EventFilters).as_mut_ptr() as *const libc::c_void,
        CfgFileEventsToFilter as uint16,
        CFE_EVS_EventFilter_BINARY as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_EVS_Register Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    CFE_ES_WriteToSysLog(
        b"%s: Registered %d events for filtering\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0")).as_ptr(),
        CfgFileEventsToFilter as libc::c_int,
    );
    CFE_MSG_Init(
        &mut CFE_SB_Global.HKTlmMsg.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 3 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_SB_HousekeepingTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_SB_Global.PrevSubMsg.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 13 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_SB_AllSubscriptionsTlm_t>() as libc::c_ulong,
    );
    CFE_SB_Global.HKTlmMsg.Payload.MemPoolHandle = CFE_SB_Global.Mem.PoolHdl;
    CFE_SB_Global.StatTlmMsg.Payload.MaxMsgIdsAllowed = 256 as libc::c_int as uint32;
    CFE_SB_Global.StatTlmMsg.Payload.MaxPipesAllowed = 64 as libc::c_int as uint32;
    CFE_SB_Global.StatTlmMsg.Payload.MaxMemAllowed = 524288 as libc::c_int as uint32;
    CFE_SB_Global.StatTlmMsg.Payload.MaxPipeDepthAllowed = 50 as libc::c_int as uint32;
    CFE_SB_Global.StatTlmMsg.Payload.MaxSubscriptionsAllowed =
        (256 as libc::c_int * 16 as libc::c_int) as uint32;
    Status = CFE_SB_CreatePipe(
        &mut CFE_SB_Global.CmdPipe,
        32 as libc::c_int as uint16,
        b"SB_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_SB_CreatePipe Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 3 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_SB_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Subscribe to Cmds Failed:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 11 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_SB_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Subscribe to HK Request Failed:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 14 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_SB_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Subscribe to Subscription Report Request Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_ES_GetPoolBuf(
        &mut TmpPtr,
        CFE_SB_Global.Mem.PoolHdl,
        ::core::mem::size_of::<CFE_ES_RestartCmd_t>() as libc::c_ulong,
    );
    if Status < 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Init error, GetPool Failed:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_ES_PutPoolBuf(CFE_SB_Global.Mem.PoolHdl, TmpPtr);
    if Status < 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Init error, PutPool Failed:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    Status = CFE_EVS_SendEvent(
        1 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"cFE SB Initialized: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error sending init event:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_SB_AppInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_NoopCmd(mut data: *const CFE_SB_NoopCmd_t) -> int32 {
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    CFE_EVS_SendEvent(
        28 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"No-op Cmd Rcvd: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    CFE_SB_Global.HKTlmMsg.Payload.CommandCounter =
        (CFE_SB_Global.HKTlmMsg.Payload.CommandCounter).wrapping_add(1);
    CFE_SB_Global.HKTlmMsg.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ResetCountersCmd(
    mut data: *const CFE_SB_ResetCountersCmd_t,
) -> int32 {
    CFE_EVS_SendEvent(
        29 as libc::c_int as uint16,
        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
        b"Reset Counters Cmd Rcvd\0" as *const u8 as *const libc::c_char,
    );
    CFE_SB_ResetCounters();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_EnableSubReportingCmd(
    mut data: *const CFE_SB_EnableSubReportingCmd_t,
) -> int32 {
    CFE_SB_SetSubscriptionReporting(1 as libc::c_int as uint32);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_DisableSubReportingCmd(
    mut data: *const CFE_SB_DisableSubReportingCmd_t,
) -> int32 {
    CFE_SB_SetSubscriptionReporting(0 as libc::c_int as uint32);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SendHKTlmCmd(mut data: *const CFE_SB_SendHkCmd_t) -> int32 {
    CFE_SB_LockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        348 as libc::c_int,
    );
    CFE_SB_Global.HKTlmMsg.Payload.MemInUse = CFE_SB_Global.StatTlmMsg.Payload.MemInUse;
    CFE_SB_Global.HKTlmMsg.Payload.UnmarkedMem = (524288 as libc::c_int as libc::c_uint)
        .wrapping_sub(CFE_SB_Global.StatTlmMsg.Payload.PeakMemInUse);
    CFE_SB_UnlockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        354 as libc::c_int,
    );
    CFE_SB_TimeStampMsg(&mut CFE_SB_Global.HKTlmMsg.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut CFE_SB_Global.HKTlmMsg.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_ResetCounters() {
    CFE_SB_Global.HKTlmMsg.Payload.CommandCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.NoSubscribersCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.DuplicateSubscriptionsCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.MsgSendErrorCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.MsgReceiveErrorCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.InternalErrorCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.CreatePipeErrorCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.SubscribeErrorCounter = 0 as libc::c_int as uint8;
    CFE_SB_Global.HKTlmMsg.Payload.PipeOverflowErrorCounter = 0 as libc::c_int as uint16;
    CFE_SB_Global.HKTlmMsg.Payload.MsgLimitErrorCounter = 0 as libc::c_int as uint16;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_EnableRouteCmd(mut data: *const CFE_SB_EnableRouteCmd_t) -> int32 {
    let mut MsgId: CFE_SB_MsgId_t = CFE_SB_MsgId_t { Value: 0 };
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut DestPtr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut CmdPtr: *const CFE_SB_RouteCmd_Payload_t = 0 as *const CFE_SB_RouteCmd_Payload_t;
    let mut PendingEventID: uint16 = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    CmdPtr = &(*data).Payload;
    MsgId = (*CmdPtr).MsgId;
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_EnableRouteCmd\0"))
            .as_ptr(),
        402 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID((*CmdPtr).Pipe);
    if !CFE_SB_IsValidMsgId(MsgId) || !CFE_SB_PipeDescIsMatch(PipeDscPtr, (*CmdPtr).Pipe) {
        PendingEventID = 35 as libc::c_int as uint16;
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
    } else {
        DestPtr = CFE_SB_GetDestPtr(CFE_SBR_GetRouteId(MsgId), (*CmdPtr).Pipe);
        if DestPtr.is_null() {
            PendingEventID = 33 as libc::c_int as uint16;
            CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
        } else {
            (*DestPtr).Active = 1 as libc::c_int as uint8;
            PendingEventID = 34 as libc::c_int as uint16;
            CFE_SB_Global.HKTlmMsg.Payload.CommandCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.CommandCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.CommandCounter;
        }
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 22], &[libc::c_char; 22]>(b"CFE_SB_EnableRouteCmd\0"))
            .as_ptr(),
        427 as libc::c_int,
    );
    match PendingEventID as libc::c_int {
        33 => {
            CFE_EVS_SendEvent(
                33 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Enbl Route Cmd:Route does not exist.Msg 0x%x,Pipe %lu\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                CFE_ResourceId_ToInteger((*CmdPtr).Pipe),
            );
        }
        35 => {
            CFE_EVS_SendEvent(
                35 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Enbl Route Cmd:Invalid Param.Msg 0x%x,Pipe %lu\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                CFE_ResourceId_ToInteger((*CmdPtr).Pipe),
            );
        }
        34 => {
            CFE_EVS_SendEvent(
                34 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Enabling Route,Msg 0x%x,Pipe %lu\0" as *const u8 as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                CFE_ResourceId_ToInteger((*CmdPtr).Pipe),
            );
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_DisableRouteCmd(
    mut data: *const CFE_SB_DisableRouteCmd_t,
) -> int32 {
    let mut MsgId: CFE_SB_MsgId_t = CFE_SB_MsgId_t { Value: 0 };
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut DestPtr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut CmdPtr: *const CFE_SB_RouteCmd_Payload_t = 0 as *const CFE_SB_RouteCmd_Payload_t;
    let mut PendingEventID: uint16 = 0;
    PendingEventID = 0 as libc::c_int as uint16;
    CmdPtr = &(*data).Payload;
    MsgId = (*CmdPtr).MsgId;
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_DisableRouteCmd\0"))
            .as_ptr(),
        469 as libc::c_int,
    );
    PipeDscPtr = CFE_SB_LocatePipeDescByID((*CmdPtr).Pipe);
    if !CFE_SB_IsValidMsgId(MsgId) || !CFE_SB_PipeDescIsMatch(PipeDscPtr, (*CmdPtr).Pipe) {
        PendingEventID = 38 as libc::c_int as uint16;
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
    } else {
        DestPtr = CFE_SB_GetDestPtr(CFE_SBR_GetRouteId(MsgId), (*CmdPtr).Pipe);
        if DestPtr.is_null() {
            PendingEventID = 36 as libc::c_int as uint16;
            CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
        } else {
            (*DestPtr).Active = 0 as libc::c_int as uint8;
            PendingEventID = 37 as libc::c_int as uint16;
            CFE_SB_Global.HKTlmMsg.Payload.CommandCounter =
                (CFE_SB_Global.HKTlmMsg.Payload.CommandCounter).wrapping_add(1);
            CFE_SB_Global.HKTlmMsg.Payload.CommandCounter;
        }
    }
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_DisableRouteCmd\0"))
            .as_ptr(),
        494 as libc::c_int,
    );
    match PendingEventID as libc::c_int {
        36 => {
            CFE_EVS_SendEvent(
                36 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Disable Route Cmd:Route does not exist,Msg 0x%x,Pipe %lu\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                CFE_ResourceId_ToInteger((*CmdPtr).Pipe),
            );
        }
        38 => {
            CFE_EVS_SendEvent(
                38 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Disable Route Cmd:Invalid Param.Msg 0x%x,Pipe %lu\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                CFE_ResourceId_ToInteger((*CmdPtr).Pipe),
            );
        }
        37 => {
            CFE_EVS_SendEvent(
                37 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                b"Route Disabled,Msg 0x%x,Pipe %lu\0" as *const u8 as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
                CFE_ResourceId_ToInteger((*CmdPtr).Pipe),
            );
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SendStatsCmd(mut data: *const CFE_SB_SendSbStatsCmd_t) -> int32 {
    let mut PipeDscCount: uint32 = 0;
    let mut PipeStatCount: uint32 = 0;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut PipeStatPtr: *mut CFE_SB_PipeDepthStats_t = 0 as *mut CFE_SB_PipeDepthStats_t;
    CFE_SB_LockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        530 as libc::c_int,
    );
    PipeDscCount = 64 as libc::c_int as uint32;
    PipeStatCount = 64 as libc::c_int as uint32;
    PipeDscPtr = (CFE_SB_Global.PipeTbl).as_mut_ptr();
    PipeStatPtr = (CFE_SB_Global.StatTlmMsg.Payload.PipeDepthStats).as_mut_ptr();
    while PipeDscCount > 0 as libc::c_int as libc::c_uint
        && PipeStatCount > 0 as libc::c_int as libc::c_uint
    {
        if CFE_SB_PipeDescIsUsed(PipeDscPtr) {
            (*PipeStatPtr).PipeId = (*PipeDscPtr).PipeId;
            (*PipeStatPtr).CurrentQueueDepth = (*PipeDscPtr).CurrentQueueDepth;
            (*PipeStatPtr).PeakQueueDepth = (*PipeDscPtr).PeakQueueDepth;
            (*PipeStatPtr).MaxQueueDepth = (*PipeDscPtr).MaxQueueDepth;
            PipeStatPtr = PipeStatPtr.offset(1);
            PipeStatPtr;
            PipeStatCount = PipeStatCount.wrapping_sub(1);
            PipeStatCount;
        }
        PipeDscCount = PipeDscCount.wrapping_sub(1);
        PipeDscCount;
        PipeDscPtr = PipeDscPtr.offset(1);
        PipeDscPtr;
    }
    CFE_SB_UnlockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        557 as libc::c_int,
    );
    while PipeStatCount > 0 as libc::c_int as libc::c_uint {
        memset(
            PipeStatPtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_SB_PipeDepthStats_t>() as libc::c_ulong,
        );
        PipeStatPtr = PipeStatPtr.offset(1);
        PipeStatPtr;
        PipeStatCount = PipeStatCount.wrapping_sub(1);
        PipeStatCount;
    }
    CFE_SB_TimeStampMsg(&mut CFE_SB_Global.StatTlmMsg.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut CFE_SB_Global.StatTlmMsg.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    CFE_EVS_SendEvent(
        32 as libc::c_int as uint16,
        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
        b"Software Bus Statistics packet sent\0" as *const u8 as *const libc::c_char,
    );
    CFE_SB_Global.HKTlmMsg.Payload.CommandCounter =
        (CFE_SB_Global.HKTlmMsg.Payload.CommandCounter).wrapping_add(1);
    CFE_SB_Global.HKTlmMsg.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_CollectRouteInfo(
    mut RouteId: CFE_SBR_RouteId_t,
    mut ArgPtr: *mut libc::c_void,
) {
    let mut DestPtr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut RouteMsgId: CFE_SB_MsgId_t = CFE_SB_MsgId_t { Value: 0 };
    let mut RouteBufferPtr: *mut CFE_SB_BackgroundRouteInfoBuffer_t =
        0 as *mut CFE_SB_BackgroundRouteInfoBuffer_t;
    let mut FileEntryPtr: *mut CFE_SB_RoutingFileEntry_t = 0 as *mut CFE_SB_RoutingFileEntry_t;
    let mut DestAppId: [CFE_ES_AppId_t; 16] = [0; 16];
    let mut i: uint32 = 0;
    RouteBufferPtr = ArgPtr as *mut CFE_SB_BackgroundRouteInfoBuffer_t;
    CFE_SB_LockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        598 as libc::c_int,
    );
    RouteMsgId = CFE_SBR_GetMsgId(RouteId);
    (*RouteBufferPtr).NumDestinations = 0 as libc::c_int as uint32;
    if CFE_SB_IsValidMsgId(RouteMsgId) {
        DestPtr = CFE_SBR_GetDestListHeadPtr(RouteId);
        while !DestPtr.is_null()
            && (*RouteBufferPtr).NumDestinations < 16 as libc::c_int as libc::c_uint
        {
            PipeDscPtr = CFE_SB_LocatePipeDescByID((*DestPtr).PipeId);
            if CFE_SB_PipeDescIsMatch(PipeDscPtr, (*DestPtr).PipeId) {
                FileEntryPtr = &mut *((*RouteBufferPtr).DestEntries)
                    .as_mut_ptr()
                    .offset((*RouteBufferPtr).NumDestinations as isize)
                    as *mut CFE_SB_RoutingFileEntry_t;
                memset(
                    FileEntryPtr as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<CFE_SB_RoutingFileEntry_t>() as libc::c_ulong,
                );
                (*FileEntryPtr).PipeId = (*DestPtr).PipeId;
                (*FileEntryPtr).State = (*DestPtr).Active;
                (*FileEntryPtr).MsgCnt = (*DestPtr).DestCnt;
                DestAppId[(*RouteBufferPtr).NumDestinations as usize] = (*PipeDscPtr).AppId;
                (*RouteBufferPtr).NumDestinations =
                    ((*RouteBufferPtr).NumDestinations).wrapping_add(1);
                (*RouteBufferPtr).NumDestinations;
            }
            DestPtr = (*DestPtr).Next;
        }
    }
    CFE_SB_UnlockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        635 as libc::c_int,
    );
    FileEntryPtr = ((*RouteBufferPtr).DestEntries).as_mut_ptr();
    i = 0 as libc::c_int as uint32;
    while i < (*RouteBufferPtr).NumDestinations {
        (*FileEntryPtr).MsgId = RouteMsgId;
        CFE_ES_GetAppName(
            ((*FileEntryPtr).AppName).as_mut_ptr(),
            DestAppId[i as usize],
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        CFE_SB_GetPipeName(
            ((*FileEntryPtr).PipeName).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
            (*FileEntryPtr).PipeId,
        );
        FileEntryPtr = FileEntryPtr.offset(1);
        FileEntryPtr;
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SendSubscriptionReport(
    mut MsgId: CFE_SB_MsgId_t,
    mut PipeId: CFE_SB_PipeId_t,
    mut Quality: CFE_SB_Qos_t,
) -> int32 {
    let mut SubRptMsg: CFE_SB_SingleSubscriptionTlm_t = CFE_SB_SingleSubscriptionTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_SB_SingleSubscriptionTlm_Payload_t {
            SubType: 0,
            MsgId: CFE_SB_MsgId_t { Value: 0 },
            Qos: CFE_SB_Qos_t {
                Priority: 0,
                Reliability: 0,
            },
            Pipe: 0,
        },
    };
    let mut Status: int32 = 0 as libc::c_int;
    memset(
        &mut SubRptMsg as *mut CFE_SB_SingleSubscriptionTlm_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_SB_SingleSubscriptionTlm_t>() as libc::c_ulong,
    );
    if CFE_SB_Global.SubscriptionReporting == 1 as libc::c_int as libc::c_uint {
        CFE_MSG_Init(
            &mut SubRptMsg.TelemetryHeader.Msg,
            CFE_SB_ValueToMsgId((0x800 as libc::c_int | 14 as libc::c_int) as CFE_SB_MsgId_Atom_t),
            ::core::mem::size_of::<CFE_SB_SingleSubscriptionTlm_t>() as libc::c_ulong,
        );
        SubRptMsg.Payload.MsgId = MsgId;
        SubRptMsg.Payload.Pipe = PipeId;
        SubRptMsg.Payload.Qos = Quality;
        SubRptMsg.Payload.SubType = 0 as libc::c_int as uint8;
        Status = CFE_SB_TransmitMsg(&mut SubRptMsg.TelemetryHeader.Msg, 1 as libc::c_int != 0);
        CFE_EVS_SendEventWithAppID(
            22 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_SB_Global.AppId,
            b"Sending Subscription Report Msg=0x%x,Pipe=%lu,Stat=0x%x\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            CFE_ResourceId_ToInteger(PipeId),
            Status as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_WriteRouteInfoDataGetter(
    mut Meta: *mut libc::c_void,
    mut RecordNum: uint32,
    mut Buffer: *mut *mut libc::c_void,
    mut BufSize: *mut size_t,
) -> bool {
    let mut BgFilePtr: *mut CFE_SB_BackgroundFileStateInfo_t =
        0 as *mut CFE_SB_BackgroundFileStateInfo_t;
    let mut Throttle: CFE_SBR_Throttle_t = CFE_SBR_Throttle_t {
        StartIndex: 0,
        MaxLoop: 0,
        NextIndex: 0,
    };
    BgFilePtr = Meta as *mut CFE_SB_BackgroundFileStateInfo_t;
    Throttle.StartIndex = RecordNum;
    Throttle.MaxLoop = 1 as libc::c_int as uint32;
    Throttle.NextIndex = 0 as libc::c_int as uint32;
    (*BgFilePtr).Buffer.RouteInfo.NumDestinations = 0 as libc::c_int as uint32;
    CFE_SBR_ForEachRouteId(
        Some(
            CFE_SB_CollectRouteInfo
                as unsafe extern "C" fn(CFE_SBR_RouteId_t, *mut libc::c_void) -> (),
        ),
        &mut (*BgFilePtr).Buffer.RouteInfo as *mut CFE_SB_BackgroundRouteInfoBuffer_t
            as *mut libc::c_void,
        &mut Throttle,
    );
    *Buffer = &mut (*BgFilePtr).Buffer.RouteInfo.DestEntries as *mut [CFE_SB_RoutingFileEntry_t; 16]
        as *mut libc::c_void;
    *BufSize = (::core::mem::size_of::<CFE_SB_RoutingFileEntry_t>() as libc::c_ulong)
        .wrapping_mul((*BgFilePtr).Buffer.RouteInfo.NumDestinations as libc::c_ulong);
    return Throttle.NextIndex == 0 as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_BackgroundFileEventHandler(
    mut Meta: *mut libc::c_void,
    mut Event: CFE_FS_FileWriteEvent_t,
    mut Status: int32,
    mut RecordNum: uint32,
    mut BlockSize: size_t,
    mut Position: size_t,
) {
    let mut BgFilePtr: *mut CFE_SB_BackgroundFileStateInfo_t =
        0 as *mut CFE_SB_BackgroundFileStateInfo_t;
    BgFilePtr = Meta as *mut CFE_SB_BackgroundFileStateInfo_t;
    match Event as libc::c_uint {
        1 => {
            CFE_EVS_SendEventWithAppID(
                39 as libc::c_int as uint16,
                CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                CFE_SB_Global.AppId,
                b"%s written:Size=%d,Entries=%d\0" as *const u8 as *const libc::c_char,
                ((*BgFilePtr).FileWrite.FileName).as_mut_ptr(),
                Position as libc::c_int,
                RecordNum as libc::c_int,
            );
        }
        3 | 4 => {
            CFE_EVS_SendEventWithAppID(
                49 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_SB_Global.AppId,
                b"File write,byte cnt err,file %s,request=%d,actual=%d\0" as *const u8
                    as *const libc::c_char,
                ((*BgFilePtr).FileWrite.FileName).as_mut_ptr(),
                BlockSize as libc::c_int,
                Status,
            );
        }
        2 => {
            CFE_EVS_SendEventWithAppID(
                40 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_SB_Global.AppId,
                b"Error creating file %s, stat=0x%x\0" as *const u8 as *const libc::c_char,
                ((*BgFilePtr).FileWrite.FileName).as_mut_ptr(),
                Status,
            );
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_WriteRoutingInfoCmd(
    mut data: *const CFE_SB_WriteRoutingInfoCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_SB_WriteFileInfoCmd_Payload_t =
        0 as *const CFE_SB_WriteFileInfoCmd_Payload_t;
    let mut StatePtr: *mut CFE_SB_BackgroundFileStateInfo_t =
        0 as *mut CFE_SB_BackgroundFileStateInfo_t;
    let mut Status: int32 = 0;
    StatePtr = &mut CFE_SB_Global.BackgroundFile;
    CmdPtr = &(*data).Payload;
    if !CFE_FS_BackgroundFileDumpIsPending(&mut (*StatePtr).FileWrite) {
        memset(
            StatePtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_SB_BackgroundFileStateInfo_t>() as libc::c_ulong,
        );
        (*StatePtr).FileWrite.FileSubType = CFE_FS_SubType_SB_ROUTEDATA as libc::c_int as uint32;
        snprintf(
            ((*StatePtr).FileWrite.Description).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            b"SB Routing Information\0" as *const u8 as *const libc::c_char,
        );
        (*StatePtr).FileWrite.GetData = Some(
            CFE_SB_WriteRouteInfoDataGetter
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    uint32,
                    *mut *mut libc::c_void,
                    *mut size_t,
                ) -> bool,
        );
        (*StatePtr).FileWrite.OnEvent = Some(
            CFE_SB_BackgroundFileEventHandler
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    CFE_FS_FileWriteEvent_t,
                    int32,
                    uint32,
                    size_t,
                    size_t,
                ) -> (),
        );
        Status = CFE_FS_ParseInputFileNameEx(
            ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
            ((*CmdPtr).Filename).as_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"/ram/cfe_sb_route.dat\0" as *const u8 as *const libc::c_char,
            CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
            CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        );
        if Status == 0 as libc::c_int {
            Status = CFE_FS_BackgroundFileDumpRequest(&mut (*StatePtr).FileWrite);
        }
    } else {
        Status = 0xc8000006 as libc::c_uint as int32;
    }
    if Status != 0 as libc::c_int {
        CFE_SB_BackgroundFileEventHandler(
            StatePtr as *mut libc::c_void,
            CFE_FS_FileWriteEvent_CREATE_ERROR,
            Status,
            0 as libc::c_int as uint32,
            0 as libc::c_int as size_t,
            0 as libc::c_int as size_t,
        );
    }
    CFE_SB_IncrCmdCtr(Status);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_WritePipeInfoDataGetter(
    mut Meta: *mut libc::c_void,
    mut RecordNum: uint32,
    mut Buffer: *mut *mut libc::c_void,
    mut BufSize: *mut size_t,
) -> bool {
    let mut BgFilePtr: *mut CFE_SB_BackgroundFileStateInfo_t =
        0 as *mut CFE_SB_BackgroundFileStateInfo_t;
    let mut PipeBufferPtr: *mut CFE_SB_PipeInfoEntry_t = 0 as *mut CFE_SB_PipeInfoEntry_t;
    let mut PipeDscPtr: *mut CFE_SB_PipeD_t = 0 as *mut CFE_SB_PipeD_t;
    let mut SysQueueId: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut PipeIsValid: bool = false;
    BgFilePtr = Meta as *mut CFE_SB_BackgroundFileStateInfo_t;
    PipeDscPtr = 0 as *mut CFE_SB_PipeD_t;
    PipeIsValid = 0 as libc::c_int != 0;
    PipeBufferPtr = &mut (*BgFilePtr).Buffer.PipeInfo;
    if RecordNum < 64 as libc::c_int as libc::c_uint {
        PipeDscPtr = &mut *(CFE_SB_Global.PipeTbl)
            .as_mut_ptr()
            .offset(RecordNum as isize) as *mut CFE_SB_PipeD_t;
        CFE_SB_LockSharedData(
            b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
                as *const libc::c_char,
            852 as libc::c_int,
        );
        PipeIsValid = CFE_SB_PipeDescIsUsed(PipeDscPtr);
        if PipeIsValid {
            memset(
                PipeBufferPtr as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<CFE_SB_PipeInfoEntry_t>() as libc::c_ulong,
            );
            (*PipeBufferPtr).PipeId = CFE_SB_PipeDescGetID(PipeDscPtr);
            (*PipeBufferPtr).AppId = (*PipeDscPtr).AppId;
            (*PipeBufferPtr).Opts = (*PipeDscPtr).Opts;
            (*PipeBufferPtr).SendErrors = (*PipeDscPtr).SendErrors;
            (*PipeBufferPtr).MaxQueueDepth = (*PipeDscPtr).MaxQueueDepth;
            (*PipeBufferPtr).CurrentQueueDepth = (*PipeDscPtr).CurrentQueueDepth;
            (*PipeBufferPtr).PeakQueueDepth = (*PipeDscPtr).PeakQueueDepth;
            SysQueueId = (*PipeDscPtr).SysQueueId;
        }
        CFE_SB_UnlockSharedData(
            b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
                as *const libc::c_char,
            879 as libc::c_int,
        );
    }
    if PipeIsValid {
        OS_GetResourceName(
            SysQueueId,
            ((*PipeBufferPtr).PipeName).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        CFE_ES_GetAppName(
            ((*PipeBufferPtr).AppName).as_mut_ptr(),
            (*PipeBufferPtr).AppId,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        *Buffer = PipeBufferPtr as *mut libc::c_void;
        *BufSize = ::core::mem::size_of::<CFE_SB_PipeInfoEntry_t>() as libc::c_ulong;
    } else {
        *Buffer = 0 as *mut libc::c_void;
        *BufSize = 0 as libc::c_int as size_t;
    }
    return RecordNum >= (64 as libc::c_int - 1 as libc::c_int) as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_WritePipeInfoCmd(
    mut data: *const CFE_SB_WritePipeInfoCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_SB_WriteFileInfoCmd_Payload_t =
        0 as *const CFE_SB_WriteFileInfoCmd_Payload_t;
    let mut StatePtr: *mut CFE_SB_BackgroundFileStateInfo_t =
        0 as *mut CFE_SB_BackgroundFileStateInfo_t;
    let mut Status: int32 = 0;
    StatePtr = &mut CFE_SB_Global.BackgroundFile;
    CmdPtr = &(*data).Payload;
    if !CFE_FS_BackgroundFileDumpIsPending(&mut (*StatePtr).FileWrite) {
        memset(
            StatePtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_SB_BackgroundFileStateInfo_t>() as libc::c_ulong,
        );
        (*StatePtr).FileWrite.FileSubType = CFE_FS_SubType_SB_PIPEDATA as libc::c_int as uint32;
        snprintf(
            ((*StatePtr).FileWrite.Description).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            b"SB Pipe Information\0" as *const u8 as *const libc::c_char,
        );
        (*StatePtr).FileWrite.GetData = Some(
            CFE_SB_WritePipeInfoDataGetter
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    uint32,
                    *mut *mut libc::c_void,
                    *mut size_t,
                ) -> bool,
        );
        (*StatePtr).FileWrite.OnEvent = Some(
            CFE_SB_BackgroundFileEventHandler
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    CFE_FS_FileWriteEvent_t,
                    int32,
                    uint32,
                    size_t,
                    size_t,
                ) -> (),
        );
        Status = CFE_FS_ParseInputFileNameEx(
            ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
            ((*CmdPtr).Filename).as_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"/ram/cfe_sb_pipe.dat\0" as *const u8 as *const libc::c_char,
            CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
            CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        );
        if Status == 0 as libc::c_int {
            Status = CFE_FS_BackgroundFileDumpRequest(&mut (*StatePtr).FileWrite);
        }
    } else {
        Status = 0xc8000006 as libc::c_uint as int32;
    }
    if Status != 0 as libc::c_int {
        CFE_SB_BackgroundFileEventHandler(
            StatePtr as *mut libc::c_void,
            CFE_FS_FileWriteEvent_CREATE_ERROR,
            Status,
            0 as libc::c_int as uint32,
            0 as libc::c_int as size_t,
            0 as libc::c_int as size_t,
        );
    }
    CFE_SB_IncrCmdCtr(Status);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_CollectMsgMapInfo(
    mut RouteId: CFE_SBR_RouteId_t,
    mut ArgPtr: *mut libc::c_void,
) {
    let mut BufferPtr: *mut CFE_SB_MsgMapFileEntry_t = 0 as *mut CFE_SB_MsgMapFileEntry_t;
    BufferPtr = ArgPtr as *mut CFE_SB_MsgMapFileEntry_t;
    CFE_SB_LockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        982 as libc::c_int,
    );
    (*BufferPtr).MsgId = CFE_SBR_GetMsgId(RouteId);
    (*BufferPtr).Index = CFE_SBR_RouteIdToValue(RouteId);
    CFE_SB_UnlockSharedData(
        b"/home/kkysen/work/rust/cFS/cfe/modules/sb/fsw/src/cfe_sb_task.c\0" as *const u8
            as *const libc::c_char,
        987 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_WriteMsgMapInfoDataGetter(
    mut Meta: *mut libc::c_void,
    mut RecordNum: uint32,
    mut Buffer: *mut *mut libc::c_void,
    mut BufSize: *mut size_t,
) -> bool {
    let mut BgFilePtr: *mut CFE_SB_BackgroundFileStateInfo_t =
        0 as *mut CFE_SB_BackgroundFileStateInfo_t;
    let mut Throttle: CFE_SBR_Throttle_t = CFE_SBR_Throttle_t {
        StartIndex: 0,
        MaxLoop: 0,
        NextIndex: 0,
    };
    BgFilePtr = Meta as *mut CFE_SB_BackgroundFileStateInfo_t;
    Throttle.StartIndex = RecordNum;
    Throttle.MaxLoop = 1 as libc::c_int as uint32;
    Throttle.NextIndex = 0 as libc::c_int as uint32;
    (*BgFilePtr).Buffer.MsgMapInfo.MsgId = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_SBR_ForEachRouteId(
        Some(
            CFE_SB_CollectMsgMapInfo
                as unsafe extern "C" fn(CFE_SBR_RouteId_t, *mut libc::c_void) -> (),
        ),
        &mut (*BgFilePtr).Buffer.MsgMapInfo as *mut CFE_SB_MsgMapFileEntry_t as *mut libc::c_void,
        &mut Throttle,
    );
    if CFE_SB_IsValidMsgId((*BgFilePtr).Buffer.MsgMapInfo.MsgId) {
        *Buffer = &mut (*BgFilePtr).Buffer.MsgMapInfo as *mut CFE_SB_MsgMapFileEntry_t
            as *mut libc::c_void;
        *BufSize = ::core::mem::size_of::<CFE_SB_MsgMapFileEntry_t>() as libc::c_ulong;
    } else {
        *Buffer = 0 as *mut libc::c_void;
        *BufSize = 0 as libc::c_int as size_t;
    }
    return Throttle.NextIndex == 0 as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_WriteMapInfoCmd(
    mut data: *const CFE_SB_WriteMapInfoCmd_t,
) -> int32 {
    let mut CmdPtr: *const CFE_SB_WriteFileInfoCmd_Payload_t =
        0 as *const CFE_SB_WriteFileInfoCmd_Payload_t;
    let mut StatePtr: *mut CFE_SB_BackgroundFileStateInfo_t =
        0 as *mut CFE_SB_BackgroundFileStateInfo_t;
    let mut Status: int32 = 0;
    StatePtr = &mut CFE_SB_Global.BackgroundFile;
    CmdPtr = &(*data).Payload;
    if !CFE_FS_BackgroundFileDumpIsPending(&mut (*StatePtr).FileWrite) {
        memset(
            StatePtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_SB_BackgroundFileStateInfo_t>() as libc::c_ulong,
        );
        (*StatePtr).FileWrite.FileSubType = CFE_FS_SubType_SB_MAPDATA as libc::c_int as uint32;
        snprintf(
            ((*StatePtr).FileWrite.Description).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            b"SB Map Information\0" as *const u8 as *const libc::c_char,
        );
        (*StatePtr).FileWrite.GetData = Some(
            CFE_SB_WriteMsgMapInfoDataGetter
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    uint32,
                    *mut *mut libc::c_void,
                    *mut size_t,
                ) -> bool,
        );
        (*StatePtr).FileWrite.OnEvent = Some(
            CFE_SB_BackgroundFileEventHandler
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    CFE_FS_FileWriteEvent_t,
                    int32,
                    uint32,
                    size_t,
                    size_t,
                ) -> (),
        );
        Status = CFE_FS_ParseInputFileNameEx(
            ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
            ((*CmdPtr).Filename).as_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"/ram/cfe_sb_msgmap.dat\0" as *const u8 as *const libc::c_char,
            CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
            CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        );
        if Status == 0 as libc::c_int {
            Status = CFE_FS_BackgroundFileDumpRequest(&mut (*StatePtr).FileWrite);
        }
    } else {
        Status = 0xc8000006 as libc::c_uint as int32;
    }
    if Status != 0 as libc::c_int {
        CFE_SB_BackgroundFileEventHandler(
            StatePtr as *mut libc::c_void,
            CFE_FS_FileWriteEvent_CREATE_ERROR,
            Status,
            0 as libc::c_int as uint32,
            0 as libc::c_int as size_t,
            0 as libc::c_int as size_t,
        );
    }
    CFE_SB_IncrCmdCtr(Status);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SendRouteSub(
    mut RouteId: CFE_SBR_RouteId_t,
    mut ArgPtr: *mut libc::c_void,
) {
    let mut destptr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    let mut status: int32 = 0;
    destptr = CFE_SBR_GetDestListHeadPtr(RouteId);
    while !destptr.is_null() {
        if (*destptr).Scope as libc::c_int == 0 as libc::c_int {
            CFE_SB_Global.PrevSubMsg.Payload.Entry
                [CFE_SB_Global.PrevSubMsg.Payload.Entries as usize]
                .MsgId = CFE_SBR_GetMsgId(RouteId);
            CFE_SB_Global.PrevSubMsg.Payload.Entry
                [CFE_SB_Global.PrevSubMsg.Payload.Entries as usize]
                .Qos
                .Priority = 0 as libc::c_int as uint8;
            CFE_SB_Global.PrevSubMsg.Payload.Entry
                [CFE_SB_Global.PrevSubMsg.Payload.Entries as usize]
                .Qos
                .Reliability = 0 as libc::c_int as uint8;
            CFE_SB_Global.PrevSubMsg.Payload.Entries =
                (CFE_SB_Global.PrevSubMsg.Payload.Entries).wrapping_add(1);
            CFE_SB_Global.PrevSubMsg.Payload.Entries;
            if CFE_SB_Global.PrevSubMsg.Payload.Entries >= 20 as libc::c_int as libc::c_uint {
                CFE_SB_UnlockSharedData(
                    (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                        b"CFE_SB_SendRouteSub\0",
                    ))
                    .as_ptr(),
                    1120 as libc::c_int,
                );
                status = CFE_SB_TransmitMsg(
                    &mut CFE_SB_Global.PrevSubMsg.TelemetryHeader.Msg,
                    1 as libc::c_int != 0,
                );
                CFE_EVS_SendEvent(
                    44 as libc::c_int as uint16,
                    CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                    b"Full Sub Pkt %d Sent,Entries=%d,Stat=0x%x\n\0" as *const u8
                        as *const libc::c_char,
                    CFE_SB_Global.PrevSubMsg.Payload.PktSegment as libc::c_int,
                    CFE_SB_Global.PrevSubMsg.Payload.Entries as libc::c_int,
                    status as libc::c_uint,
                );
                CFE_SB_LockSharedData(
                    (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(
                        b"CFE_SB_SendRouteSub\0",
                    ))
                    .as_ptr(),
                    1126 as libc::c_int,
                );
                CFE_SB_Global.PrevSubMsg.Payload.Entries = 0 as libc::c_int as uint32;
                CFE_SB_Global.PrevSubMsg.Payload.PktSegment =
                    (CFE_SB_Global.PrevSubMsg.Payload.PktSegment).wrapping_add(1);
                CFE_SB_Global.PrevSubMsg.Payload.PktSegment;
            }
            break;
        } else {
            destptr = (*destptr).Next;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SendPrevSubsCmd(
    mut data: *const CFE_SB_SendPrevSubsCmd_t,
) -> int32 {
    let mut status: int32 = 0;
    CFE_SB_LockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_SendPrevSubsCmd\0"))
            .as_ptr(),
        1156 as libc::c_int,
    );
    CFE_SB_Global.PrevSubMsg.Payload.PktSegment = 1 as libc::c_int as uint32;
    CFE_SB_Global.PrevSubMsg.Payload.Entries = 0 as libc::c_int as uint32;
    CFE_SBR_ForEachRouteId(
        Some(
            CFE_SB_SendRouteSub as unsafe extern "C" fn(CFE_SBR_RouteId_t, *mut libc::c_void) -> (),
        ),
        0 as *mut libc::c_void,
        0 as *mut CFE_SBR_Throttle_t,
    );
    CFE_SB_UnlockSharedData(
        (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(b"CFE_SB_SendPrevSubsCmd\0"))
            .as_ptr(),
        1165 as libc::c_int,
    );
    if CFE_SB_Global.PrevSubMsg.Payload.Entries > 0 as libc::c_int as libc::c_uint {
        status = CFE_SB_TransmitMsg(
            &mut CFE_SB_Global.PrevSubMsg.TelemetryHeader.Msg,
            1 as libc::c_int != 0,
        );
        CFE_EVS_SendEvent(
            45 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Partial Sub Pkt %d Sent,Entries=%d,Stat=0x%x\0" as *const u8 as *const libc::c_char,
            CFE_SB_Global.PrevSubMsg.Payload.PktSegment as libc::c_int,
            CFE_SB_Global.PrevSubMsg.Payload.Entries as libc::c_int,
            status as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_IncrCmdCtr(mut status: int32) {
    if status == 0 as libc::c_int {
        CFE_SB_Global.HKTlmMsg.Payload.CommandCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.CommandCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.CommandCounter;
    } else {
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter =
            (CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter).wrapping_add(1);
        CFE_SB_Global.HKTlmMsg.Payload.CommandErrorCounter;
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SetSubscriptionReporting(mut state: uint32) {
    CFE_SB_Global.SubscriptionReporting = state;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_MsgHdrSize(mut MsgPtr: *const CFE_MSG_Message_t) -> size_t {
    let mut size: size_t = 0 as libc::c_int as size_t;
    let mut hassechdr: bool = 0 as libc::c_int != 0;
    let mut type_0: CFE_MSG_Type_t = CFE_MSG_Type_Invalid;
    if MsgPtr.is_null() {
        return size;
    }
    CFE_MSG_GetHasSecondaryHeader(MsgPtr, &mut hassechdr);
    CFE_MSG_GetType(MsgPtr, &mut type_0);
    if !hassechdr {
        size = ::core::mem::size_of::<CFE_MSG_Message_t>() as libc::c_ulong;
    } else if type_0 as libc::c_uint == CFE_MSG_Type_Cmd as libc::c_int as libc::c_uint {
        size = ::core::mem::size_of::<CFE_MSG_CommandHeader_t>() as libc::c_ulong;
    } else if type_0 as libc::c_uint == CFE_MSG_Type_Tlm as libc::c_int as libc::c_uint {
        size = ::core::mem::size_of::<CFE_MSG_TelemetryHeader_t>() as libc::c_ulong;
    }
    return size;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetUserData(
    mut MsgPtr: *mut CFE_MSG_Message_t,
) -> *mut libc::c_void {
    let mut BytePtr: *mut uint8 = 0 as *mut uint8;
    let mut HdrSize: size_t = 0;
    if MsgPtr.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Failed invalid arguments\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_SB_GetUserData\0"))
                .as_ptr(),
        );
        return 0 as *mut libc::c_void;
    }
    BytePtr = MsgPtr as *mut uint8;
    HdrSize = CFE_SB_MsgHdrSize(MsgPtr);
    return BytePtr.offset(HdrSize as isize) as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_GetUserDataLength(mut MsgPtr: *const CFE_MSG_Message_t) -> size_t {
    let mut TotalMsgSize: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut HdrSize: size_t = 0;
    if MsgPtr.is_null() {
        return TotalMsgSize;
    }
    CFE_MSG_GetSize(MsgPtr, &mut TotalMsgSize);
    HdrSize = CFE_SB_MsgHdrSize(MsgPtr);
    return TotalMsgSize.wrapping_sub(HdrSize);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_SetUserDataLength(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut DataLength: size_t,
) {
    let mut TotalMsgSize: CFE_MSG_Size_t = 0;
    let mut HdrSize: size_t = 0;
    if MsgPtr.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Failed invalid arguments\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                b"CFE_SB_SetUserDataLength\0",
            ))
            .as_ptr(),
        );
    } else {
        HdrSize = CFE_SB_MsgHdrSize(MsgPtr);
        TotalMsgSize = HdrSize.wrapping_add(DataLength);
        if TotalMsgSize <= 32768 as libc::c_int as libc::c_ulong {
            CFE_MSG_SetSize(MsgPtr, TotalMsgSize);
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Failed TotalMsgSize too large\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                    b"CFE_SB_SetUserDataLength\0",
                ))
                .as_ptr(),
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_TimeStampMsg(mut MsgPtr: *mut CFE_MSG_Message_t) {
    CFE_MSG_SetMsgTime(MsgPtr, CFE_TIME_GetTime());
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_MessageStringGet(
    mut DestStringPtr: *mut libc::c_char,
    mut SourceStringPtr: *const libc::c_char,
    mut DefaultString: *const libc::c_char,
    mut DestMaxSize: size_t,
    mut SourceMaxSize: size_t,
) -> int32 {
    let mut Result: int32 = 0;
    if DestMaxSize == 0 as libc::c_int as libc::c_ulong || DestStringPtr.is_null() {
        Result = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        Result = 0 as libc::c_int;
        if !DefaultString.is_null()
            && (SourceMaxSize == 0 as libc::c_int as libc::c_ulong
                || *SourceStringPtr as libc::c_int == 0 as libc::c_int)
        {
            SourceStringPtr = DefaultString;
            SourceMaxSize = DestMaxSize;
        }
        DestMaxSize = DestMaxSize.wrapping_sub(1);
        DestMaxSize;
        while SourceMaxSize > 0 as libc::c_int as libc::c_ulong
            && *SourceStringPtr as libc::c_int != 0 as libc::c_int
            && DestMaxSize > 0 as libc::c_int as libc::c_ulong
        {
            *DestStringPtr = *SourceStringPtr;
            DestStringPtr = DestStringPtr.offset(1);
            DestStringPtr;
            SourceStringPtr = SourceStringPtr.offset(1);
            SourceStringPtr;
            SourceMaxSize = SourceMaxSize.wrapping_sub(1);
            SourceMaxSize;
            DestMaxSize = DestMaxSize.wrapping_sub(1);
            DestMaxSize;
            Result += 1;
            Result;
        }
        *DestStringPtr = 0 as libc::c_int as libc::c_char;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SB_MessageStringSet(
    mut DestStringPtr: *mut libc::c_char,
    mut SourceStringPtr: *const libc::c_char,
    mut DestMaxSize: size_t,
    mut SourceMaxSize: size_t,
) -> int32 {
    let mut Result: int32 = 0;
    if SourceStringPtr.is_null() || DestStringPtr.is_null() {
        Result = 0xca000003 as libc::c_uint as CFE_Status_t;
    } else {
        Result = 0 as libc::c_int;
        while SourceMaxSize > 0 as libc::c_int as libc::c_ulong
            && *SourceStringPtr as libc::c_int != 0 as libc::c_int
            && DestMaxSize > 0 as libc::c_int as libc::c_ulong
        {
            *DestStringPtr = *SourceStringPtr;
            DestStringPtr = DestStringPtr.offset(1);
            DestStringPtr;
            SourceStringPtr = SourceStringPtr.offset(1);
            SourceStringPtr;
            Result += 1;
            Result;
            DestMaxSize = DestMaxSize.wrapping_sub(1);
            DestMaxSize;
            SourceMaxSize = SourceMaxSize.wrapping_sub(1);
            SourceMaxSize;
        }
        while DestMaxSize > 0 as libc::c_int as libc::c_ulong {
            *DestStringPtr = 0 as libc::c_int as libc::c_char;
            DestStringPtr = DestStringPtr.offset(1);
            DestStringPtr;
            DestMaxSize = DestMaxSize.wrapping_sub(1);
            DestMaxSize;
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_eventids_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_fcncodes_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_interface_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_internal_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_mission_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_msgdefs_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_msg_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_msgids_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_msgstruct_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_platform_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_sb_src_check_cfe_sb_topicids_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Register(
    mut TblHandlePtr: *mut CFE_TBL_Handle_t,
    mut Name: *const libc::c_char,
    mut Size: size_t,
    mut TblOptionFlags: uint16,
    mut TblValidationFuncPtr: CFE_TBL_CallbackFuncPtr_t,
) -> CFE_Status_t {
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut WorkingBufferPtr: *mut CFE_TBL_LoadBuff_t = 0 as *mut CFE_TBL_LoadBuff_t;
    let mut CritRegRecPtr: *mut CFE_TBL_CritRegRec_t = 0 as *mut CFE_TBL_CritRegRec_t;
    let mut Status: int32 = 0;
    let mut NameLen: size_t = 0;
    let mut RegIndx: int16 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut AppName: [libc::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [libc::c_char; 20],
    >(b"UNKNOWN\0\0\0\0\0\0\0\0\0\0\0\0\0");
    let mut TblName: [libc::c_char; 40] =
        *::core::mem::transmute::<&[u8; 40], &mut [libc::c_char; 40]>(
            b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        );
    let mut AccessIndex: CFE_TBL_Handle_t = 0;
    if TblHandlePtr.is_null() || Name.is_null() {
        return 0xcc00002d as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_GetAppID(&mut ThisAppId);
    if Status == 0 as libc::c_int {
        *TblHandlePtr = 0xffff as libc::c_int as CFE_TBL_Handle_t;
        NameLen = strlen(Name);
        if NameLen > 16 as libc::c_int as libc::c_ulong
            || NameLen == 0 as libc::c_int as libc::c_ulong
        {
            Status = 0xcc000002 as libc::c_uint as CFE_Status_t;
            strncpy(
                TblName.as_mut_ptr(),
                Name,
                (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            TblName[(::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
                '\0' as i32 as libc::c_char;
            CFE_ES_WriteToSysLog(
                b"%s: Table Name (%s) is bad length (%d)\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_Register\0"))
                    .as_ptr(),
                TblName.as_mut_ptr(),
                NameLen as libc::c_int,
            );
        } else {
            CFE_TBL_FormTableName(TblName.as_mut_ptr(), Name, ThisAppId);
            if Size == 0 as libc::c_int as libc::c_ulong {
                Status = 0xcc000003 as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: Table %s has size of zero\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                        b"CFE_TBL_Register\0",
                    ))
                    .as_ptr(),
                    Name,
                );
            } else if Size > 16384 as libc::c_int as libc::c_ulong
                && TblOptionFlags as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int
            {
                Status = 0xcc000003 as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: Single Buffered Table '%s' has size %d > %d\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                        b"CFE_TBL_Register\0",
                    ))
                    .as_ptr(),
                    Name,
                    Size as libc::c_int,
                    16384 as libc::c_int,
                );
            } else if Size > 16384 as libc::c_int as libc::c_ulong
                && TblOptionFlags as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int
            {
                Status = 0xcc000003 as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: Dbl Buffered Table '%s' has size %d > %d\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                        b"CFE_TBL_Register\0",
                    ))
                    .as_ptr(),
                    Name,
                    Size as libc::c_int,
                    16384 as libc::c_int,
                );
            }
            if TblOptionFlags as libc::c_int & 0x4 as libc::c_int
                == 0x6 as libc::c_int & 0x4 as libc::c_int
            {
                if TblOptionFlags as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int
                    || TblOptionFlags as libc::c_int & 0x2 as libc::c_int == 0 as libc::c_int
                    || TblOptionFlags as libc::c_int & 0x8 as libc::c_int == 0x8 as libc::c_int
                {
                    Status = 0xcc000025 as libc::c_uint as CFE_Status_t;
                    CFE_ES_WriteToSysLog(
                        b"%s: User Def tbl '%s' cannot be dbl buff, load/dump or critical\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                            b"CFE_TBL_Register\0",
                        ))
                        .as_ptr(),
                        Name,
                    );
                }
            } else if TblOptionFlags as libc::c_int & 0x2 as libc::c_int == 0x2 as libc::c_int {
                if TblOptionFlags as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int
                    || TblOptionFlags as libc::c_int & 0x8 as libc::c_int == 0x8 as libc::c_int
                {
                    Status = 0xcc000025 as libc::c_uint as CFE_Status_t;
                    CFE_ES_WriteToSysLog(
                        b"%s: Dump Only tbl '%s' cannot be double buffered or critical\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                            b"CFE_TBL_Register\0",
                        ))
                        .as_ptr(),
                        Name,
                    );
                }
            }
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Bad AppId(%lu)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_Register\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
        );
    }
    if Status == 0 as libc::c_int {
        CFE_TBL_LockRegistry();
        RegIndx = CFE_TBL_FindTableInRegistry(TblName.as_mut_ptr());
        if RegIndx as libc::c_int != -(1 as libc::c_int) {
            RegRecPtr = &mut *(CFE_TBL_Global.Registry)
                .as_mut_ptr()
                .offset(RegIndx as isize) as *mut CFE_TBL_RegistryRec_t;
            if CFE_ResourceId_Equal((*RegRecPtr).OwnerAppId, ThisAppId) {
                if Size != (*RegRecPtr).Size {
                    Status = 0xcc00000c as libc::c_uint as CFE_Status_t;
                    CFE_ES_WriteToSysLog(
                        b"%s: Attempt to register existing table ('%s') with different size(%d!=%d)\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<
                            &[u8; 17],
                            &[libc::c_char; 17],
                        >(b"CFE_TBL_Register\0"))
                            .as_ptr(),
                        TblName.as_mut_ptr(),
                        Size as libc::c_int,
                        (*RegRecPtr).Size as libc::c_int,
                    );
                } else {
                    Status = 0x4c000007 as libc::c_int;
                    AccessIndex = (*RegRecPtr).HeadOfAccessList;
                    while AccessIndex as libc::c_int
                        != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
                        && *TblHandlePtr as libc::c_int
                            == 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
                    {
                        if CFE_TBL_Global.Handles[AccessIndex as usize].UsedFlag as libc::c_int
                            == 1 as libc::c_int
                            && CFE_ResourceId_Equal(
                                CFE_TBL_Global.Handles[AccessIndex as usize].AppId,
                                ThisAppId,
                            ) as libc::c_int
                                != 0
                            && CFE_TBL_Global.Handles[AccessIndex as usize].RegIndex as libc::c_int
                                == RegIndx as libc::c_int
                        {
                            *TblHandlePtr = AccessIndex;
                        } else {
                            AccessIndex = CFE_TBL_Global.Handles[AccessIndex as usize].NextLink;
                        }
                    }
                }
            } else {
                Status = 0xcc00000d as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: App(%lu) Registering Duplicate Table '%s' owned by App(%lu)\n\0"
                        as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                        b"CFE_TBL_Register\0",
                    ))
                    .as_ptr(),
                    CFE_ResourceId_ToInteger(ThisAppId),
                    TblName.as_mut_ptr(),
                    CFE_ResourceId_ToInteger((*RegRecPtr).OwnerAppId),
                );
            }
        } else {
            RegIndx = CFE_TBL_FindFreeRegistryEntry();
        }
        if RegIndx as libc::c_int == -(1 as libc::c_int) {
            Status = 0xcc000006 as libc::c_uint as CFE_Status_t;
            CFE_ES_WriteToSysLog(
                b"%s: Registry full\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_Register\0"))
                    .as_ptr(),
            );
        }
        if Status != 0x4c000007 as libc::c_int {
            *TblHandlePtr = CFE_TBL_FindFreeHandle();
            if *TblHandlePtr as libc::c_int
                == 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
            {
                Status = 0xcc00000b as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: No more free handles\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                        b"CFE_TBL_Register\0",
                    ))
                    .as_ptr(),
                );
            }
            if Status & 0xc0000000 as libc::c_uint as CFE_Status_t
                != 0xc0000000 as libc::c_uint as CFE_Status_t
            {
                RegRecPtr = &mut *(CFE_TBL_Global.Registry)
                    .as_mut_ptr()
                    .offset(RegIndx as isize)
                    as *mut CFE_TBL_RegistryRec_t;
                CFE_TBL_InitRegistryRecord(RegRecPtr);
                if TblOptionFlags as libc::c_int & 0x4 as libc::c_int
                    != 0x6 as libc::c_int & 0x4 as libc::c_int
                {
                    (*RegRecPtr).UserDefAddr = 0 as libc::c_int != 0;
                    Status = CFE_ES_GetPoolBuf(
                        &mut (*((*RegRecPtr).Buffers)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize))
                        .BufferPtr,
                        CFE_TBL_Global.Buf.PoolHdl,
                        Size,
                    );
                    if Status < 0 as libc::c_int {
                        CFE_ES_WriteToSysLog(
                            b"%s: 1st Buf Alloc GetPool fail Stat=0x%08X MemPoolHndl=0x%08lX\n\0"
                                as *const u8 as *const libc::c_char,
                            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                                b"CFE_TBL_Register\0",
                            ))
                            .as_ptr(),
                            Status as libc::c_uint,
                            CFE_ResourceId_ToInteger(CFE_TBL_Global.Buf.PoolHdl),
                        );
                    } else {
                        Status = 0 as libc::c_int;
                        memset(
                            (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr,
                            0 as libc::c_int,
                            Size,
                        );
                    }
                } else {
                    (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr =
                        0 as *mut libc::c_void;
                    (*RegRecPtr).UserDefAddr = 1 as libc::c_int != 0;
                }
                if TblOptionFlags as libc::c_int & 0x1 as libc::c_int == 0x1 as libc::c_int
                    && Status & 0xc0000000 as libc::c_uint as CFE_Status_t
                        != 0xc0000000 as libc::c_uint as CFE_Status_t
                {
                    Status = CFE_ES_GetPoolBuf(
                        &mut (*((*RegRecPtr).Buffers)
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize))
                        .BufferPtr,
                        CFE_TBL_Global.Buf.PoolHdl,
                        Size,
                    );
                    if Status < 0 as libc::c_int {
                        CFE_ES_WriteToSysLog(
                            b"%s: 2nd Buf Alloc GetPool fail Stat=0x%08X MemPoolHndl=0x%08lX\n\0"
                                as *const u8 as *const libc::c_char,
                            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                                b"CFE_TBL_Register\0",
                            ))
                            .as_ptr(),
                            Status as libc::c_uint,
                            CFE_ResourceId_ToInteger(CFE_TBL_Global.Buf.PoolHdl),
                        );
                    } else {
                        Status = 0 as libc::c_int;
                        memset(
                            (*RegRecPtr).Buffers[1 as libc::c_int as usize].BufferPtr,
                            0 as libc::c_int,
                            Size,
                        );
                    }
                    (*RegRecPtr).ActiveBufferIndex = 0 as libc::c_int as uint8;
                    (*RegRecPtr).DoubleBuffered = 1 as libc::c_int != 0;
                } else {
                    (*RegRecPtr).DoubleBuffered = 0 as libc::c_int != 0;
                    (*RegRecPtr).ActiveBufferIndex = 0 as libc::c_int as uint8;
                }
                if Status & 0xc0000000 as libc::c_uint as CFE_Status_t
                    != 0xc0000000 as libc::c_uint as CFE_Status_t
                {
                    (*RegRecPtr).Size = Size;
                    (*RegRecPtr).ValidationFuncPtr = TblValidationFuncPtr;
                    strncpy(
                        ((*RegRecPtr).Name).as_mut_ptr(),
                        TblName.as_mut_ptr(),
                        (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    );
                    (*RegRecPtr).Name[(::core::mem::size_of::<[libc::c_char; 40]>()
                        as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        as usize] = '\0' as i32 as libc::c_char;
                    if TblOptionFlags as libc::c_int & 0x2 as libc::c_int == 0x2 as libc::c_int {
                        (*RegRecPtr).DumpOnly = 1 as libc::c_int != 0;
                    } else {
                        (*RegRecPtr).DumpOnly = 0 as libc::c_int != 0;
                    }
                    AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
                        .as_mut_ptr()
                        .offset(*TblHandlePtr as isize)
                        as *mut CFE_TBL_AccessDescriptor_t;
                    (*AccessDescPtr).AppId = ThisAppId;
                    (*AccessDescPtr).LockFlag = 0 as libc::c_int != 0;
                    (*AccessDescPtr).Updated = 0 as libc::c_int != 0;
                    if (*RegRecPtr).DumpOnly as libc::c_int != 0 && !(*RegRecPtr).UserDefAddr {
                        (*RegRecPtr).TableLoadedOnce = 1 as libc::c_int != 0;
                    }
                    (*AccessDescPtr).RegIndex = RegIndx;
                    (*AccessDescPtr).PrevLink = 0xffff as libc::c_int as CFE_TBL_Handle_t;
                    (*AccessDescPtr).NextLink = 0xffff as libc::c_int as CFE_TBL_Handle_t;
                    (*AccessDescPtr).UsedFlag = 1 as libc::c_int != 0;
                    (*RegRecPtr).HeadOfAccessList = *TblHandlePtr;
                    if TblOptionFlags as libc::c_int & 0x8 as libc::c_int == 0x8 as libc::c_int {
                        Status = CFE_ES_RegisterCDSEx(
                            &mut (*RegRecPtr).CDSHandle,
                            Size,
                            TblName.as_mut_ptr(),
                            1 as libc::c_int != 0,
                        );
                        if Status == 0x4400000d as libc::c_int {
                            Status = CFE_TBL_GetWorkingBuffer(
                                &mut WorkingBufferPtr,
                                RegRecPtr,
                                1 as libc::c_int != 0,
                            );
                            if Status != 0 as libc::c_int {
                                CFE_ES_GetAppName(
                                    AppName.as_mut_ptr(),
                                    ThisAppId,
                                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
                                );
                                CFE_ES_WriteToSysLog(
                                    b"%s: Failed to get work buffer for '%s.%s' (ErrCode=0x%08X)\n\0"
                                        as *const u8 as *const libc::c_char,
                                    (*::core::mem::transmute::<
                                        &[u8; 17],
                                        &[libc::c_char; 17],
                                    >(b"CFE_TBL_Register\0"))
                                        .as_ptr(),
                                    AppName.as_mut_ptr(),
                                    Name,
                                    Status as libc::c_uint,
                                );
                            } else {
                                Status = CFE_ES_RestoreFromCDS(
                                    (*WorkingBufferPtr).BufferPtr,
                                    (*RegRecPtr).CDSHandle,
                                );
                                if Status != 0 as libc::c_int {
                                    CFE_ES_GetAppName(
                                        AppName.as_mut_ptr(),
                                        ThisAppId,
                                        ::core::mem::size_of::<[libc::c_char; 20]>()
                                            as libc::c_ulong,
                                    );
                                    CFE_ES_WriteToSysLog(
                                        b"%s: Failed to recover '%s.%s' from CDS (ErrCode=0x%08X)\n\0"
                                            as *const u8 as *const libc::c_char,
                                        (*::core::mem::transmute::<
                                            &[u8; 17],
                                            &[libc::c_char; 17],
                                        >(b"CFE_TBL_Register\0"))
                                            .as_ptr(),
                                        AppName.as_mut_ptr(),
                                        Name,
                                        Status as libc::c_uint,
                                    );
                                }
                            }
                            if Status != 0 as libc::c_int {
                                Status = 0 as libc::c_int;
                            } else {
                                CFE_TBL_FindCriticalTblInfo(
                                    &mut CritRegRecPtr,
                                    (*RegRecPtr).CDSHandle,
                                );
                                if !CritRegRecPtr.is_null()
                                    && (*CritRegRecPtr).TableLoadedOnce as libc::c_int != 0
                                {
                                    strncpy(
                                        ((*WorkingBufferPtr).DataSource).as_mut_ptr(),
                                        ((*CritRegRecPtr).LastFileLoaded).as_mut_ptr(),
                                        (::core::mem::size_of::<[libc::c_char; 64]>()
                                            as libc::c_ulong)
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                    );
                                    (*WorkingBufferPtr).DataSource[(::core::mem::size_of::<
                                        [libc::c_char; 64],
                                    >(
                                    )
                                        as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        as usize] = '\0' as i32 as libc::c_char;
                                    (*WorkingBufferPtr).FileCreateTimeSecs =
                                        (*CritRegRecPtr).FileCreateTimeSecs;
                                    (*WorkingBufferPtr).FileCreateTimeSubSecs =
                                        (*CritRegRecPtr).FileCreateTimeSubSecs;
                                    strncpy(
                                        ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
                                        ((*CritRegRecPtr).LastFileLoaded).as_mut_ptr(),
                                        (::core::mem::size_of::<[libc::c_char; 64]>()
                                            as libc::c_ulong)
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                    );
                                    (*RegRecPtr).LastFileLoaded[(::core::mem::size_of::<
                                        [libc::c_char; 64],
                                    >(
                                    )
                                        as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        as usize] = '\0' as i32 as libc::c_char;
                                    (*RegRecPtr).TimeOfLastUpdate.Seconds =
                                        (*CritRegRecPtr).TimeOfLastUpdate.Seconds;
                                    (*RegRecPtr).TimeOfLastUpdate.Subseconds =
                                        (*CritRegRecPtr).TimeOfLastUpdate.Subseconds;
                                    (*RegRecPtr).TableLoadedOnce = (*CritRegRecPtr).TableLoadedOnce;
                                    (*WorkingBufferPtr).Crc = CFE_ES_CalculateCRC(
                                        (*WorkingBufferPtr).BufferPtr,
                                        (*RegRecPtr).Size,
                                        0 as libc::c_int as uint32,
                                        CFE_ES_CrcType_16_ARC,
                                    );
                                    CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
                                    Status = 0x4c000027 as libc::c_int;
                                } else {
                                    CFE_ES_GetAppName(
                                        AppName.as_mut_ptr(),
                                        ThisAppId,
                                        ::core::mem::size_of::<[libc::c_char; 20]>()
                                            as libc::c_ulong,
                                    );
                                    CFE_ES_WriteToSysLog(
                                        b"%s: Failed to recover '%s.%s' info from CDS TblReg\n\0"
                                            as *const u8
                                            as *const libc::c_char,
                                        (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                                            b"CFE_TBL_Register\0",
                                        ))
                                        .as_ptr(),
                                        AppName.as_mut_ptr(),
                                        Name,
                                    );
                                    Status = 0 as libc::c_int;
                                }
                            }
                            (*RegRecPtr).CriticalTable = 1 as libc::c_int != 0;
                        }
                        if Status == 0 as libc::c_int {
                            CFE_TBL_FindCriticalTblInfo(
                                &mut CritRegRecPtr,
                                0 as libc::c_int as CFE_ResourceId_t,
                            );
                            if !CritRegRecPtr.is_null() {
                                (*CritRegRecPtr).CDSHandle = (*RegRecPtr).CDSHandle;
                                strncpy(
                                    ((*CritRegRecPtr).Name).as_mut_ptr(),
                                    TblName.as_mut_ptr(),
                                    (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                );
                                (*CritRegRecPtr).Name[(::core::mem::size_of::<[libc::c_char; 40]>()
                                    as libc::c_ulong)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                    as usize] = '\0' as i32 as libc::c_char;
                                (*CritRegRecPtr).FileCreateTimeSecs = 0 as libc::c_int as uint32;
                                (*CritRegRecPtr).FileCreateTimeSubSecs = 0 as libc::c_int as uint32;
                                (*CritRegRecPtr).LastFileLoaded[0 as libc::c_int as usize] =
                                    '\0' as i32 as libc::c_char;
                                (*CritRegRecPtr).TimeOfLastUpdate.Seconds =
                                    0 as libc::c_int as uint32;
                                (*CritRegRecPtr).TimeOfLastUpdate.Subseconds =
                                    0 as libc::c_int as uint32;
                                (*CritRegRecPtr).TableLoadedOnce = 0 as libc::c_int != 0;
                                CFE_ES_CopyToCDS(
                                    CFE_TBL_Global.CritRegHandle,
                                    (CFE_TBL_Global.CritReg).as_mut_ptr() as *const libc::c_void,
                                );
                            } else {
                                CFE_ES_WriteToSysLog(
                                    b"%s: Failed to find a free Crit Tbl Reg Rec for '%s'\n\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                                        b"CFE_TBL_Register\0",
                                    ))
                                    .as_ptr(),
                                    ((*RegRecPtr).Name).as_mut_ptr(),
                                );
                            }
                            (*RegRecPtr).CriticalTable = 1 as libc::c_int != 0;
                        } else if Status != 0x4c000027 as libc::c_int {
                            CFE_ES_WriteToSysLog(
                                b"%s: Failed to register '%s.%s' as a CDS (ErrCode=0x%08X)\n\0"
                                    as *const u8
                                    as *const libc::c_char,
                                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(
                                    b"CFE_TBL_Register\0",
                                ))
                                .as_ptr(),
                                AppName.as_mut_ptr(),
                                Name,
                                Status as libc::c_uint,
                            );
                            Status = 0x4c000026 as libc::c_int;
                        }
                    }
                    (*RegRecPtr).OwnerAppId = ThisAppId;
                }
            }
        }
        CFE_TBL_UnlockRegistry();
    }
    if Status < 0 as libc::c_int {
        *TblHandlePtr = 0xffff as libc::c_int as CFE_TBL_Handle_t;
        CFE_ES_GetAppName(
            AppName.as_mut_ptr(),
            ThisAppId,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        CFE_EVS_SendEventWithAppID(
            90 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s Failed to Register '%s', Status=0x%08X\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            TblName.as_mut_ptr(),
            Status as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Share(
    mut TblHandlePtr: *mut CFE_TBL_Handle_t,
    mut TblName: *const libc::c_char,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut RegIndx: int16 = 0;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AppName: [libc::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [libc::c_char; 20],
    >(b"UNKNOWN\0\0\0\0\0\0\0\0\0\0\0\0\0");
    if TblHandlePtr.is_null() || TblName.is_null() {
        return 0xcc00002d as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_GetAppID(&mut ThisAppId);
    if Status == 0 as libc::c_int {
        CFE_TBL_LockRegistry();
        RegIndx = CFE_TBL_FindTableInRegistry(TblName);
        if RegIndx as libc::c_int != -(1 as libc::c_int) {
            RegRecPtr = &mut *(CFE_TBL_Global.Registry)
                .as_mut_ptr()
                .offset(RegIndx as isize) as *mut CFE_TBL_RegistryRec_t;
            *TblHandlePtr = CFE_TBL_FindFreeHandle();
            if *TblHandlePtr as libc::c_int
                == 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
            {
                Status = 0xcc00000b as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: No more free handles\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"CFE_TBL_Share\0"))
                        .as_ptr(),
                );
            } else {
                AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
                    .as_mut_ptr()
                    .offset(*TblHandlePtr as isize)
                    as *mut CFE_TBL_AccessDescriptor_t;
                (*AccessDescPtr).AppId = ThisAppId;
                (*AccessDescPtr).LockFlag = 0 as libc::c_int != 0;
                (*AccessDescPtr).Updated = 0 as libc::c_int != 0;
                if (*RegRecPtr).TableLoadedOnce {
                    (*AccessDescPtr).Updated = 1 as libc::c_int != 0;
                }
                (*AccessDescPtr).RegIndex = RegIndx;
                (*AccessDescPtr).UsedFlag = 1 as libc::c_int != 0;
                (*AccessDescPtr).PrevLink = 0xffff as libc::c_int as CFE_TBL_Handle_t;
                (*AccessDescPtr).NextLink = (*RegRecPtr).HeadOfAccessList;
                CFE_TBL_Global.Handles[(*RegRecPtr).HeadOfAccessList as usize].PrevLink =
                    *TblHandlePtr;
                (*RegRecPtr).HeadOfAccessList = *TblHandlePtr;
            }
        } else {
            Status = 0xcc000002 as libc::c_uint as CFE_Status_t;
            CFE_ES_WriteToSysLog(
                b"%s: Table '%s' not found in Registry\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"CFE_TBL_Share\0"))
                    .as_ptr(),
                TblName,
            );
        }
        CFE_TBL_UnlockRegistry();
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Bad AppId(%lu)\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"CFE_TBL_Share\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
        );
    }
    if Status < 0 as libc::c_int {
        CFE_ES_GetAppName(
            AppName.as_mut_ptr(),
            ThisAppId,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        CFE_EVS_SendEventWithAppID(
            91 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s Failed to Share '%s', Status=0x%08X\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            TblName,
            Status as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Unregister(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut AppName: [libc::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [libc::c_char; 20],
    >(b"UNKNOWN\0\0\0\0\0\0\0\0\0\0\0\0\0");
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status == 0 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset((*AccessDescPtr).RegIndex as isize)
            as *mut CFE_TBL_RegistryRec_t;
        if CFE_ResourceId_Equal((*RegRecPtr).OwnerAppId, ThisAppId) {
            (*RegRecPtr).OwnerAppId = 0 as libc::c_int as CFE_ResourceId_t;
            (*RegRecPtr).Name[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
        }
        CFE_TBL_RemoveAccessLink(TblHandle);
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: App(%lu) does not have access to Tbl Handle=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_TBL_Unregister\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
            TblHandle as libc::c_int,
        );
    }
    if Status < 0 as libc::c_int {
        CFE_ES_GetAppName(
            AppName.as_mut_ptr(),
            ThisAppId,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        CFE_EVS_SendEventWithAppID(
            92 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s Failed to Unregister '?', Status=0x%08X\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            Status as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Load(
    mut TblHandle: CFE_TBL_Handle_t,
    mut SrcType: CFE_TBL_SrcEnum_t,
    mut SrcDataPtr: *const libc::c_void,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut WorkingBufferPtr: *mut CFE_TBL_LoadBuff_t = 0 as *mut CFE_TBL_LoadBuff_t;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AppName: [libc::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [libc::c_char; 20],
    >(b"UNKNOWN\0\0\0\0\0\0\0\0\0\0\0\0\0");
    let mut FirstTime: bool = 0 as libc::c_int != 0;
    if SrcDataPtr.is_null() {
        return 0xcc00002d as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status != 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            103 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: No access to Tbl Handle=%d\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            TblHandle as libc::c_int,
        );
        return Status;
    }
    AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
        .as_mut_ptr()
        .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
    RegRecPtr = &mut *(CFE_TBL_Global.Registry)
        .as_mut_ptr()
        .offset((*AccessDescPtr).RegIndex as isize) as *mut CFE_TBL_RegistryRec_t;
    CFE_ES_GetAppName(
        AppName.as_mut_ptr(),
        ThisAppId,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    WorkingBufferPtr = 0 as *mut CFE_TBL_LoadBuff_t;
    if (*RegRecPtr).DumpOnly {
        if !(*RegRecPtr).UserDefAddr || (*RegRecPtr).TableLoadedOnce as libc::c_int != 0 {
            CFE_EVS_SendEventWithAppID(
                79 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"%s: Attempted to load Dump Only Tbl '%s'\0" as *const u8 as *const libc::c_char,
                AppName.as_mut_ptr(),
                ((*RegRecPtr).Name).as_mut_ptr(),
            );
            return 0xcc000010 as libc::c_uint as CFE_Status_t;
        }
        (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr = SrcDataPtr as *mut libc::c_void;
        (*RegRecPtr).TableLoadedOnce = 1 as libc::c_int != 0;
        snprintf(
            ((*RegRecPtr).Buffers[0 as libc::c_int as usize].DataSource).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"Addr 0x%08lX\0" as *const u8 as *const libc::c_char,
            SrcDataPtr as libc::c_ulong,
        );
        (*RegRecPtr).Buffers[0 as libc::c_int as usize].FileCreateTimeSecs =
            0 as libc::c_int as uint32;
        (*RegRecPtr).Buffers[0 as libc::c_int as usize].FileCreateTimeSubSecs =
            0 as libc::c_int as uint32;
        CFE_EVS_SendEventWithAppID(
            35 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"Successfully loaded '%s' from '%s'\0" as *const u8 as *const libc::c_char,
            ((*RegRecPtr).Name).as_mut_ptr(),
            ((*RegRecPtr).Buffers[0 as libc::c_int as usize].DataSource).as_mut_ptr(),
        );
        return 0 as libc::c_int;
    }
    if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int) {
        CFE_EVS_SendEventWithAppID(
            100 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: Load already in progress for '%s'\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            ((*RegRecPtr).Name).as_mut_ptr(),
        );
        return 0xcc000012 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_TBL_GetWorkingBuffer(&mut WorkingBufferPtr, RegRecPtr, 1 as libc::c_int != 0);
    if Status != 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            60 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: Failed to get Working Buffer (Stat=%u)\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    match SrcType as libc::c_uint {
        0 => {
            Status = CFE_TBL_LoadFromFile(
                AppName.as_mut_ptr(),
                WorkingBufferPtr,
                RegRecPtr,
                SrcDataPtr as *const libc::c_char,
            );
            if Status == 0x4c000022 as libc::c_int && !(*RegRecPtr).TableLoadedOnce {
                CFE_EVS_SendEventWithAppID(
                    74 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_TBL_Global.TableTaskAppId,
                    b"%s: Attempted to load from partial Tbl '%s' from '%s' (Stat=%u)\0"
                        as *const u8 as *const libc::c_char,
                    AppName.as_mut_ptr(),
                    ((*RegRecPtr).Name).as_mut_ptr(),
                    SrcDataPtr as *const libc::c_char,
                    Status as libc::c_uint,
                );
                Status = 0xcc000023 as libc::c_uint as CFE_Status_t;
            }
        }
        1 => {
            memcpy(
                (*WorkingBufferPtr).BufferPtr,
                SrcDataPtr as *mut uint8 as *const libc::c_void,
                (*RegRecPtr).Size,
            );
            snprintf(
                ((*WorkingBufferPtr).DataSource).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                b"Addr 0x%08lX\0" as *const u8 as *const libc::c_char,
                SrcDataPtr as libc::c_ulong,
            );
            (*WorkingBufferPtr).FileCreateTimeSecs = 0 as libc::c_int as uint32;
            (*WorkingBufferPtr).FileCreateTimeSubSecs = 0 as libc::c_int as uint32;
            (*WorkingBufferPtr).Crc = CFE_ES_CalculateCRC(
                (*WorkingBufferPtr).BufferPtr,
                (*RegRecPtr).Size,
                0 as libc::c_int as uint32,
                CFE_ES_CrcType_16_ARC,
            );
        }
        _ => {
            CFE_EVS_SendEventWithAppID(
                94 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"%s: Attempted to load from illegal source type=%d\0" as *const u8
                    as *const libc::c_char,
                AppName.as_mut_ptr(),
                SrcType as libc::c_int,
            );
            Status = 0xcc000011 as libc::c_uint as CFE_Status_t;
        }
    }
    if Status >= 0 as libc::c_int && ((*RegRecPtr).ValidationFuncPtr).is_some() {
        Status = ((*RegRecPtr).ValidationFuncPtr).expect("non-null function pointer")(
            (*WorkingBufferPtr).BufferPtr,
        );
        if Status > 0 as libc::c_int {
            CFE_EVS_SendEventWithAppID(
                93 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"%s: Validation func return code invalid (Stat=%u) for '%s'\0" as *const u8
                    as *const libc::c_char,
                AppName.as_mut_ptr(),
                Status as libc::c_uint,
                ((*RegRecPtr).Name).as_mut_ptr(),
            );
            Status = -(1 as libc::c_int);
        }
        if Status < 0 as libc::c_int {
            CFE_EVS_SendEventWithAppID(
                96 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"%s: Validation func reports table invalid (Stat=%u) for '%s'\0" as *const u8
                    as *const libc::c_char,
                AppName.as_mut_ptr(),
                Status as libc::c_uint,
                ((*RegRecPtr).Name).as_mut_ptr(),
            );
            memset(
                (*WorkingBufferPtr).BufferPtr,
                0 as libc::c_int,
                (*RegRecPtr).Size,
            );
        }
    }
    if Status < 0 as libc::c_int {
        if !(*RegRecPtr).DoubleBuffered
            && (*RegRecPtr).TableLoadedOnce as libc::c_int == 1 as libc::c_int
        {
            CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].Taken =
                0 as libc::c_int != 0;
        }
        (*RegRecPtr).LoadInProgress = -(1 as libc::c_int);
        return Status;
    }
    FirstTime = !(*RegRecPtr).TableLoadedOnce;
    if !FirstTime {
        (*RegRecPtr).LoadPending = 1 as libc::c_int != 0;
        Status = CFE_TBL_UpdateInternal(TblHandle, RegRecPtr, AccessDescPtr);
        if Status != 0 as libc::c_int {
            CFE_EVS_SendEventWithAppID(
                95 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"%s: Failed to update '%s' (Stat=%u)\0" as *const u8 as *const libc::c_char,
                AppName.as_mut_ptr(),
                ((*RegRecPtr).Name).as_mut_ptr(),
                Status as libc::c_uint,
            );
        }
    } else {
        strncpy(
            ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
            ((*WorkingBufferPtr).DataSource).as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*RegRecPtr).LastFileLoaded[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as usize] = '\0' as i32 as libc::c_char;
        CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        if (*RegRecPtr).CriticalTable as libc::c_int == 1 as libc::c_int {
            CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        }
        Status = 0 as libc::c_int;
    }
    if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            35 as libc::c_int as uint16,
            (if FirstTime as libc::c_int != 0 {
                CFE_EVS_EventType_DEBUG as libc::c_int
            } else {
                CFE_EVS_EventType_INFORMATION as libc::c_int
            }) as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"Successfully loaded '%s' from '%s'\0" as *const u8 as *const libc::c_char,
            ((*RegRecPtr).Name).as_mut_ptr(),
            ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
        );
        CFE_TBL_Global.LastTblUpdated = (*AccessDescPtr).RegIndex;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Update(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut AppName: [libc::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [libc::c_char; 20],
    >(b"UNKNOWN\0\0\0\0\0\0\0\0\0\0\0\0\0");
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status == 0 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset((*AccessDescPtr).RegIndex as isize)
            as *mut CFE_TBL_RegistryRec_t;
        Status = CFE_TBL_UpdateInternal(TblHandle, RegRecPtr, AccessDescPtr);
        if Status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: App(%lu) fail to update Tbl '%s' (Stat=0x%08X)\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_TBL_Update\0"))
                    .as_ptr(),
                CFE_ResourceId_ToInteger(ThisAppId),
                ((*RegRecPtr).Name).as_mut_ptr(),
                Status as libc::c_uint,
            );
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: App(%lu) does not have access to Tbl Handle=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_TBL_Update\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
            TblHandle as libc::c_int,
        );
    }
    if Status != 0xc4000001 as libc::c_uint as CFE_Status_t {
        CFE_ES_GetAppName(
            AppName.as_mut_ptr(),
            ThisAppId,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
    }
    if Status < 0 as libc::c_int {
        if !RegRecPtr.is_null() {
            CFE_EVS_SendEventWithAppID(
                95 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"%s Failed to Update '%s', Status=0x%08X\0" as *const u8 as *const libc::c_char,
                AppName.as_mut_ptr(),
                ((*RegRecPtr).Name).as_mut_ptr(),
                Status as libc::c_uint,
            );
        } else {
            CFE_EVS_SendEventWithAppID(
                95 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"%s Failed to Update '?', Status=0x%08X\0" as *const u8 as *const libc::c_char,
                AppName.as_mut_ptr(),
                Status as libc::c_uint,
            );
        }
    } else if Status == 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            37 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s Successfully Updated '%s'\0" as *const u8 as *const libc::c_char,
            AppName.as_mut_ptr(),
            ((*RegRecPtr).Name).as_mut_ptr(),
        );
        CFE_TBL_Global.LastTblUpdated = (*AccessDescPtr).RegIndex;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Validate(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut AppName: [libc::c_char; 20] = *::core::mem::transmute::<
        &[u8; 20],
        &mut [libc::c_char; 20],
    >(b"UNKNOWN\0\0\0\0\0\0\0\0\0\0\0\0\0");
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status == 0 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset((*AccessDescPtr).RegIndex as isize)
            as *mut CFE_TBL_RegistryRec_t;
        CFE_ES_GetAppName(
            AppName.as_mut_ptr(),
            ThisAppId,
            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
        );
        if (*RegRecPtr).ValidateInactiveIndex != -(1 as libc::c_int) {
            if (*RegRecPtr).DoubleBuffered {
                Status = ((*RegRecPtr).ValidationFuncPtr).expect("non-null function pointer")(
                    (*RegRecPtr).Buffers[(1 as libc::c_uint)
                        .wrapping_sub((*RegRecPtr).ActiveBufferIndex as libc::c_uint)
                        as usize]
                        .BufferPtr,
                );
                if Status == 0 as libc::c_int {
                    (*RegRecPtr).Buffers[(1 as libc::c_uint)
                        .wrapping_sub((*RegRecPtr).ActiveBufferIndex as libc::c_uint)
                        as usize]
                        .Validated = 1 as libc::c_int != 0;
                }
            } else {
                Status = ((*RegRecPtr).ValidationFuncPtr).expect("non-null function pointer")(
                    CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].BufferPtr,
                );
                if Status == 0 as libc::c_int {
                    CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].Validated =
                        1 as libc::c_int != 0;
                }
            }
            if Status == 0 as libc::c_int {
                CFE_EVS_SendEventWithAppID(
                    36 as libc::c_int as uint16,
                    CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                    CFE_TBL_Global.TableTaskAppId,
                    b"%s validation successful for Inactive '%s'\0" as *const u8
                        as *const libc::c_char,
                    AppName.as_mut_ptr(),
                    ((*RegRecPtr).Name).as_mut_ptr(),
                );
            } else {
                CFE_EVS_SendEventWithAppID(
                    96 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_TBL_Global.TableTaskAppId,
                    b"%s validation failed for Inactive '%s', Status=0x%08X\0" as *const u8
                        as *const libc::c_char,
                    AppName.as_mut_ptr(),
                    ((*RegRecPtr).Name).as_mut_ptr(),
                    Status as libc::c_uint,
                );
                if Status > 0 as libc::c_int {
                    CFE_ES_WriteToSysLog(
                        b"%s: App(%lu) Validation func return code invalid (Stat=0x%08X) for '%s'\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<
                            &[u8; 17],
                            &[libc::c_char; 17],
                        >(b"CFE_TBL_Validate\0"))
                            .as_ptr(),
                        CFE_ResourceId_ToInteger(CFE_TBL_Global.TableTaskAppId),
                        Status as libc::c_uint,
                        ((*RegRecPtr).Name).as_mut_ptr(),
                    );
                }
            }
            CFE_TBL_Global.ValidationResults[(*RegRecPtr).ValidateInactiveIndex as usize]
                .Result_0 = Status;
            CFE_TBL_Global.ValidationResults[(*RegRecPtr).ValidateInactiveIndex as usize].State =
                CFE_TBL_VALIDATION_PERFORMED;
            (*RegRecPtr).ValidateInactiveIndex = -(1 as libc::c_int);
            Status = 0 as libc::c_int;
        } else if (*RegRecPtr).ValidateActiveIndex != -(1 as libc::c_int) {
            if (*RegRecPtr).DoubleBuffered {
                Status = ((*RegRecPtr).ValidationFuncPtr).expect("non-null function pointer")(
                    (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr,
                );
            } else {
                Status = ((*RegRecPtr).ValidationFuncPtr).expect("non-null function pointer")(
                    (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr,
                );
            }
            if Status == 0 as libc::c_int {
                CFE_EVS_SendEventWithAppID(
                    36 as libc::c_int as uint16,
                    CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                    CFE_TBL_Global.TableTaskAppId,
                    b"%s validation successful for Active '%s'\0" as *const u8
                        as *const libc::c_char,
                    AppName.as_mut_ptr(),
                    ((*RegRecPtr).Name).as_mut_ptr(),
                );
            } else {
                CFE_EVS_SendEventWithAppID(
                    96 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    CFE_TBL_Global.TableTaskAppId,
                    b"%s validation failed for Active '%s', Status=0x%08X\0" as *const u8
                        as *const libc::c_char,
                    AppName.as_mut_ptr(),
                    ((*RegRecPtr).Name).as_mut_ptr(),
                    Status as libc::c_uint,
                );
                if Status > 0 as libc::c_int {
                    CFE_ES_WriteToSysLog(
                        b"%s: App(%lu) Validation func return code invalid (Stat=0x%08X) for '%s'\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<
                            &[u8; 17],
                            &[libc::c_char; 17],
                        >(b"CFE_TBL_Validate\0"))
                            .as_ptr(),
                        CFE_ResourceId_ToInteger(CFE_TBL_Global.TableTaskAppId),
                        Status as libc::c_uint,
                        ((*RegRecPtr).Name).as_mut_ptr(),
                    );
                }
            }
            CFE_TBL_Global.ValidationResults[(*RegRecPtr).ValidateActiveIndex as usize].Result_0 =
                Status;
            CFE_TBL_Global.ValidationResults[(*RegRecPtr).ValidateActiveIndex as usize].State =
                CFE_TBL_VALIDATION_PERFORMED;
            (*RegRecPtr).ValidateActiveIndex = -(1 as libc::c_int);
            Status = 0 as libc::c_int;
        } else {
            Status = 0x4c00001a as libc::c_int;
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: App(%lu) does not have access to Tbl Handle=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_Validate\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
            TblHandle as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Manage(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0 as libc::c_int;
    let mut FinishedManaging: bool = 0 as libc::c_int != 0;
    while !FinishedManaging {
        Status = CFE_TBL_GetStatus(TblHandle);
        if Status == 0x4c000019 as libc::c_int {
            Status = CFE_TBL_Validate(TblHandle);
            if Status != 0 as libc::c_int {
                FinishedManaging = 1 as libc::c_int != 0;
            }
        } else if Status == 0x4c000024 as libc::c_int {
            Status = CFE_TBL_DumpToBuffer(TblHandle);
            FinishedManaging = 1 as libc::c_int != 0;
        } else if Status == 0x4c000004 as libc::c_int {
            Status = CFE_TBL_Update(TblHandle);
            if Status == 0 as libc::c_int {
                Status = 0x4c00000e as libc::c_int;
            }
            FinishedManaging = 1 as libc::c_int != 0;
        } else {
            FinishedManaging = 1 as libc::c_int != 0;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_DumpToBuffer(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut DumpCtrlPtr: *mut CFE_TBL_DumpControl_t = 0 as *mut CFE_TBL_DumpControl_t;
    let mut DumpTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    Status = CFE_TBL_GetStatus(TblHandle);
    if Status == 0x4c000024 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset((*AccessDescPtr).RegIndex as isize)
            as *mut CFE_TBL_RegistryRec_t;
        DumpCtrlPtr = &mut *(CFE_TBL_Global.DumpControlBlocks)
            .as_mut_ptr()
            .offset((*RegRecPtr).DumpControlIndex as isize)
            as *mut CFE_TBL_DumpControl_t;
        memcpy(
            (*(*DumpCtrlPtr).DumpBufferPtr).BufferPtr,
            (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr,
            (*DumpCtrlPtr).Size,
        );
        DumpTime = CFE_TIME_GetTime();
        (*(*DumpCtrlPtr).DumpBufferPtr).FileCreateTimeSecs = DumpTime.Seconds;
        (*(*DumpCtrlPtr).DumpBufferPtr).FileCreateTimeSubSecs = DumpTime.Subseconds;
        (*RegRecPtr).DumpControlIndex = -(1 as libc::c_int);
        (*DumpCtrlPtr).State = CFE_TBL_DUMP_PERFORMED;
        Status = 0 as libc::c_int;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetStatus(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status == 0 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset((*AccessDescPtr).RegIndex as isize)
            as *mut CFE_TBL_RegistryRec_t;
        if (*RegRecPtr).LoadPending {
            Status = 0x4c000004 as libc::c_int;
        } else if (*RegRecPtr).ValidateActiveIndex != -(1 as libc::c_int)
            || (*RegRecPtr).ValidateInactiveIndex != -(1 as libc::c_int)
        {
            Status = 0x4c000019 as libc::c_int;
        } else if (*RegRecPtr).DumpControlIndex != -(1 as libc::c_int) {
            Status = 0x4c000024 as libc::c_int;
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: App(%lu) does not have access to Tbl Handle=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TBL_GetStatus\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
            TblHandle as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_Modified(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AccessIterator: CFE_TBL_Handle_t = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    let mut FilenameLen: size_t = 0;
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status == 0 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset((*AccessDescPtr).RegIndex as isize)
            as *mut CFE_TBL_RegistryRec_t;
        if (*RegRecPtr).CriticalTable as libc::c_int == 1 as libc::c_int {
            CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        }
        (*RegRecPtr).TimeOfLastUpdate = CFE_TIME_GetTime();
        (*RegRecPtr).LastFileLoaded[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as usize] = '\0' as i32 as libc::c_char;
        (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].Crc = CFE_ES_CalculateCRC(
            (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr,
            (*RegRecPtr).Size,
            0 as libc::c_int as uint32,
            CFE_ES_CrcType_16_ARC,
        );
        FilenameLen = strlen(((*RegRecPtr).LastFileLoaded).as_mut_ptr());
        if FilenameLen
            < (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                .wrapping_sub(4 as libc::c_int as libc::c_ulong)
        {
            strncpy(
                &mut *((*RegRecPtr).LastFileLoaded)
                    .as_mut_ptr()
                    .offset(FilenameLen as isize),
                b"(*)\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as libc::c_ulong,
            );
        } else {
            strncpy(
                &mut *((*RegRecPtr).LastFileLoaded).as_mut_ptr().offset(
                    (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                        .wrapping_sub(4 as libc::c_int as libc::c_ulong)
                        as isize,
                ),
                b"(*)\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as libc::c_ulong,
            );
        }
        AccessIterator = (*RegRecPtr).HeadOfAccessList;
        while AccessIterator as libc::c_int
            != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        {
            if !CFE_ResourceId_Equal(
                CFE_TBL_Global.Handles[AccessIterator as usize].AppId,
                ThisAppId,
            ) {
                CFE_TBL_Global.Handles[AccessIterator as usize].Updated = 1 as libc::c_int != 0;
            }
            AccessIterator = CFE_TBL_Global.Handles[AccessIterator as usize].NextLink;
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: App(%lu) does not have access to Tbl Handle=%d\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_Modified\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
            TblHandle as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetAddress(
    mut TblPtr: *mut *mut libc::c_void,
    mut TblHandle: CFE_TBL_Handle_t,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    if TblPtr.is_null() {
        return 0xcc00002d as libc::c_uint as CFE_Status_t;
    }
    *TblPtr = 0 as *mut libc::c_void;
    Status = CFE_ES_GetAppID(&mut ThisAppId);
    if Status == 0 as libc::c_int {
        Status = CFE_TBL_GetAddressInternal(TblPtr, TblHandle, ThisAppId);
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Bad AppId=%lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_TBL_GetAddress\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ReleaseAddress(mut TblHandle: CFE_TBL_Handle_t) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status == 0 as libc::c_int {
        CFE_TBL_Global.Handles[TblHandle as usize].LockFlag = 0 as libc::c_int != 0;
        Status = CFE_TBL_GetNextNotification(TblHandle);
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: App(%lu) does not have access to Tbl Handle=%u\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_TBL_ReleaseAddress\0",
            ))
            .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
            TblHandle as libc::c_uint,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetAddresses(
    mut TblPtrs: *mut *mut *mut libc::c_void,
    mut NumTables: uint16,
    mut TblHandles: *const CFE_TBL_Handle_t,
) -> CFE_Status_t {
    let mut i: uint16 = 0;
    let mut Status: int32 = 0;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    if TblPtrs.is_null() || TblHandles.is_null() {
        return 0xcc00002d as libc::c_uint as CFE_Status_t;
    }
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < NumTables as libc::c_int {
        let ref mut fresh18 = **TblPtrs.offset(i as isize);
        *fresh18 = 0 as *mut libc::c_void;
        i = i.wrapping_add(1);
        i;
    }
    Status = CFE_ES_GetAppID(&mut ThisAppId);
    if Status == 0 as libc::c_int {
        i = 0 as libc::c_int as uint16;
        while (i as libc::c_int) < NumTables as libc::c_int {
            if Status == 0 as libc::c_int {
                Status = CFE_TBL_GetAddressInternal(
                    *TblPtrs.offset(i as isize),
                    *TblHandles.offset(i as isize),
                    ThisAppId,
                );
            } else {
                CFE_TBL_GetAddressInternal(
                    *TblPtrs.offset(i as isize),
                    *TblHandles.offset(i as isize),
                    ThisAppId,
                );
            }
            i = i.wrapping_add(1);
            i;
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: Bad AppId=%lu\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"CFE_TBL_GetAddresses\0"))
                .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ReleaseAddresses(
    mut NumTables: uint16,
    mut TblHandles: *const CFE_TBL_Handle_t,
) -> CFE_Status_t {
    let mut Status: CFE_Status_t = 0 as libc::c_int;
    let mut i: uint16 = 0;
    if TblHandles.is_null() {
        return 0xcc00002d as libc::c_uint as CFE_Status_t;
    }
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < NumTables as libc::c_int {
        if Status == 0 as libc::c_int {
            Status = CFE_TBL_ReleaseAddress(*TblHandles.offset(i as isize));
        } else {
            CFE_TBL_ReleaseAddress(*TblHandles.offset(i as isize));
        }
        i = i.wrapping_add(1);
        i;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetInfo(
    mut TblInfoPtr: *mut CFE_TBL_Info_t,
    mut TblName: *const libc::c_char,
) -> CFE_Status_t {
    let mut Status: int32 = 0 as libc::c_int;
    let mut RegIndx: int16 = 0;
    let mut NumAccessDescriptors: int32 = 0 as libc::c_int;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut HandleIterator: CFE_TBL_Handle_t = 0;
    if TblInfoPtr.is_null() || TblName.is_null() {
        return 0xcc00002d as libc::c_uint as CFE_Status_t;
    }
    RegIndx = CFE_TBL_FindTableInRegistry(TblName);
    if RegIndx as libc::c_int != -(1 as libc::c_int) {
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset(RegIndx as isize) as *mut CFE_TBL_RegistryRec_t;
        (*TblInfoPtr).Size = (*RegRecPtr).Size;
        (*TblInfoPtr).DoubleBuffered = (*RegRecPtr).DoubleBuffered;
        (*TblInfoPtr).DumpOnly = (*RegRecPtr).DumpOnly;
        (*TblInfoPtr).UserDefAddr = (*RegRecPtr).UserDefAddr;
        (*TblInfoPtr).TableLoadedOnce = (*RegRecPtr).TableLoadedOnce;
        (*TblInfoPtr).TimeOfLastUpdate = (*RegRecPtr).TimeOfLastUpdate;
        (*TblInfoPtr).FileCreateTimeSecs =
            (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSecs;
        (*TblInfoPtr).FileCreateTimeSubSecs =
            (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSubSecs;
        (*TblInfoPtr).Crc = (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].Crc;
        strncpy(
            ((*TblInfoPtr).LastFileLoaded).as_mut_ptr(),
            ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*TblInfoPtr).LastFileLoaded[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as usize] = 0 as libc::c_int as libc::c_char;
        HandleIterator = (*RegRecPtr).HeadOfAccessList;
        while HandleIterator as libc::c_int
            != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        {
            NumAccessDescriptors += 1;
            NumAccessDescriptors;
            HandleIterator = CFE_TBL_Global.Handles[HandleIterator as usize].NextLink;
        }
        (*TblInfoPtr).NumUsers = NumAccessDescriptors as uint32;
        (*TblInfoPtr).Critical = (*RegRecPtr).CriticalTable;
    } else {
        Status = 0xcc000002 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_NotifyByMessage(
    mut TblHandle: CFE_TBL_Handle_t,
    mut MsgId: CFE_SB_MsgId_t,
    mut CommandCode: CFE_MSG_FcnCode_t,
    mut Parameter: uint32,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut ThisAppId: CFE_ES_AppId_t = 0;
    Status = CFE_TBL_ValidateAccess(TblHandle, &mut ThisAppId);
    if Status == 0 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset((*AccessDescPtr).RegIndex as isize)
            as *mut CFE_TBL_RegistryRec_t;
        if CFE_ResourceId_Equal((*RegRecPtr).OwnerAppId, ThisAppId) {
            (*RegRecPtr).NotificationMsgId = MsgId;
            (*RegRecPtr).NotificationCC = CommandCode;
            (*RegRecPtr).NotificationParam = Parameter;
            (*RegRecPtr).NotifyByMsg = 1 as libc::c_int != 0;
        } else {
            Status = 0xcc000008 as libc::c_uint as CFE_Status_t;
            CFE_ES_WriteToSysLog(
                b"%s: App(%lu) does not own Tbl Handle=%d\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                    b"CFE_TBL_NotifyByMessage\0",
                ))
                .as_ptr(),
                CFE_ResourceId_ToInteger(ThisAppId),
                TblHandle as libc::c_int,
            );
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_EarlyInit() -> int32 {
    let mut i: uint16 = 0;
    let mut j: uint32 = 0;
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    memset(
        &mut CFE_TBL_Global as *mut CFE_TBL_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TBL_Global_t>() as libc::c_ulong,
    );
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < 128 as libc::c_int {
        CFE_TBL_InitRegistryRecord(&mut *(CFE_TBL_Global.Registry).as_mut_ptr().offset(i as isize));
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < 256 as libc::c_int {
        CFE_TBL_Global.Handles[i as usize].AppId = 0 as libc::c_int as CFE_ResourceId_t;
        CFE_TBL_Global.Handles[i as usize].PrevLink = 0xffff as libc::c_int as CFE_TBL_Handle_t;
        CFE_TBL_Global.Handles[i as usize].NextLink = 0xffff as libc::c_int as CFE_TBL_Handle_t;
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < 10 as libc::c_int {
        CFE_TBL_Global.ValidationResults[i as usize].State = CFE_TBL_VALIDATION_FREE;
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < 4 as libc::c_int {
        CFE_TBL_Global.DumpControlBlocks[i as usize].State = CFE_TBL_DUMP_FREE;
        CFE_TBL_Global.LoadBuffs[i as usize].Taken = 1 as libc::c_int != 0;
        i = i.wrapping_add(1);
        i;
    }
    CFE_TBL_Global.HkTlmTblRegIndex = -(1 as libc::c_int) as int16;
    CFE_TBL_Global.LastTblUpdated = -(1 as libc::c_int) as int16;
    OsStatus = OS_MutSemCreate(
        &mut CFE_TBL_Global.RegistryMutex,
        b"TBL_REG_MUT\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_MutSemCreate(
        &mut CFE_TBL_Global.WorkBufMutex,
        b"TBL_WRK_MUT\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_PoolCreate(
        &mut CFE_TBL_Global.Buf.PoolHdl,
        (CFE_TBL_Global.Buf.Partition.Data).as_mut_ptr() as *mut libc::c_void,
        ::core::mem::size_of::<C2RustUnnamed_22>() as libc::c_ulong,
    );
    if Status < 0 as libc::c_int {
        return Status;
    } else {
        j = 0 as libc::c_int as uint32;
        loop {
            Status = CFE_ES_GetPoolBuf(
                &mut (*(CFE_TBL_Global.LoadBuffs).as_mut_ptr().offset(j as isize)).BufferPtr,
                CFE_TBL_Global.Buf.PoolHdl,
                16384 as libc::c_int as size_t,
            );
            if Status < 16384 as libc::c_int {
                return Status;
            } else {
                CFE_TBL_Global.LoadBuffs[j as usize].Taken = 0 as libc::c_int != 0;
            }
            j = j.wrapping_add(1);
            j;
            if !(j < 4 as libc::c_int as libc::c_uint) {
                break;
            }
        }
    }
    Status = CFE_ES_RegisterCDSEx(
        &mut CFE_TBL_Global.CritRegHandle,
        (::core::mem::size_of::<CFE_TBL_CritRegRec_t>() as libc::c_ulong)
            .wrapping_mul(32 as libc::c_int as libc::c_ulong),
        b"CFE_TBL.CritReg\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int != 0,
    );
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < 32 as libc::c_int {
        CFE_TBL_Global.CritReg[i as usize].CDSHandle = 0 as libc::c_int as CFE_ResourceId_t;
        i = i.wrapping_add(1);
        i;
    }
    if Status == 0x4400000d as libc::c_int {
        Status = CFE_ES_RestoreFromCDS(
            (CFE_TBL_Global.CritReg).as_mut_ptr() as *mut libc::c_void,
            CFE_TBL_Global.CritRegHandle,
        );
        if Status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Failed to recover Critical Table Registry (Err=0x%08X)\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TBL_EarlyInit\0"))
                    .as_ptr(),
                Status as libc::c_uint,
            );
        }
        Status = 0 as libc::c_int;
    } else if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to create Critical Table Registry (Err=0x%08X)\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TBL_EarlyInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        Status = 0 as libc::c_int;
    } else {
        Status = CFE_ES_CopyToCDS(
            CFE_TBL_Global.CritRegHandle,
            (CFE_TBL_Global.CritReg).as_mut_ptr() as *const libc::c_void,
        );
        if Status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"%s: Failed to save Critical Table Registry (Err=0x%08X)\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TBL_EarlyInit\0"))
                    .as_ptr(),
                Status as libc::c_uint,
            );
            Status = 0 as libc::c_int;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_InitRegistryRecord(mut RegRecPtr: *mut CFE_TBL_RegistryRec_t) {
    memset(
        RegRecPtr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TBL_RegistryRec_t>() as libc::c_ulong,
    );
    (*RegRecPtr).OwnerAppId = 0 as libc::c_int as CFE_ResourceId_t;
    (*RegRecPtr).NotificationMsgId = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    (*RegRecPtr).HeadOfAccessList = 0xffff as libc::c_int as CFE_TBL_Handle_t;
    (*RegRecPtr).LoadInProgress = -(1 as libc::c_int);
    (*RegRecPtr).ValidateActiveIndex = -(1 as libc::c_int);
    (*RegRecPtr).ValidateInactiveIndex = -(1 as libc::c_int);
    (*RegRecPtr).CDSHandle = 0 as libc::c_int as CFE_ResourceId_t;
    (*RegRecPtr).DumpControlIndex = -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ValidateHandle(mut TblHandle: CFE_TBL_Handle_t) -> int32 {
    if TblHandle as libc::c_int >= 256 as libc::c_int {
        return 0xcc000001 as libc::c_uint as CFE_Status_t;
    } else if CFE_TBL_Global.Handles[TblHandle as usize].UsedFlag as libc::c_int == 0 as libc::c_int
    {
        return 0xcc000001 as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ValidateAccess(
    mut TblHandle: CFE_TBL_Handle_t,
    mut AppIdPtr: *mut CFE_ES_AppId_t,
) -> int32 {
    let mut Status: int32 = 0;
    Status = CFE_ES_GetAppID(AppIdPtr);
    if Status != 0 as libc::c_int {
        return Status;
    }
    Status = CFE_TBL_ValidateHandle(TblHandle);
    if Status != 0 as libc::c_int {
        return Status;
    }
    Status = CFE_TBL_CheckAccessRights(TblHandle, *AppIdPtr);
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_CheckAccessRights(
    mut TblHandle: CFE_TBL_Handle_t,
    mut ThisAppId: CFE_ES_AppId_t,
) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    if !CFE_ResourceId_Equal(ThisAppId, CFE_TBL_Global.Handles[TblHandle as usize].AppId) {
        if !CFE_ResourceId_Equal(ThisAppId, CFE_TBL_Global.TableTaskAppId) {
            Status = 0xcc000008 as libc::c_uint as CFE_Status_t;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_RemoveAccessLink(mut TblHandle: CFE_TBL_Handle_t) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = &mut *(CFE_TBL_Global.Handles)
        .as_mut_ptr()
        .offset(TblHandle as isize)
        as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = &mut *(CFE_TBL_Global.Registry)
        .as_mut_ptr()
        .offset((*AccessDescPtr).RegIndex as isize)
        as *mut CFE_TBL_RegistryRec_t;
    CFE_TBL_LockRegistry();
    if (*AccessDescPtr).PrevLink as libc::c_int
        == 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
    {
        (*RegRecPtr).HeadOfAccessList = (*AccessDescPtr).NextLink;
        if (*AccessDescPtr).NextLink as libc::c_int
            != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        {
            CFE_TBL_Global.Handles[(*AccessDescPtr).NextLink as usize].PrevLink =
                0xffff as libc::c_int as CFE_TBL_Handle_t;
        }
    } else {
        CFE_TBL_Global.Handles[(*AccessDescPtr).PrevLink as usize].NextLink =
            (*AccessDescPtr).NextLink;
        if (*AccessDescPtr).NextLink as libc::c_int
            != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        {
            CFE_TBL_Global.Handles[(*AccessDescPtr).NextLink as usize].PrevLink =
                (*AccessDescPtr).PrevLink;
        }
    }
    (*AccessDescPtr).UsedFlag = 0 as libc::c_int != 0;
    if (*RegRecPtr).HeadOfAccessList as libc::c_int
        == 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
    {
        if (*RegRecPtr).UserDefAddr as libc::c_int == 0 as libc::c_int {
            Status = CFE_ES_PutPoolBuf(
                CFE_TBL_Global.Buf.PoolHdl,
                (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr,
            );
            (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr = 0 as *mut libc::c_void;
            if Status < 0 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: PutPoolBuf[0] Fail Stat=0x%08X, Hndl=0x%08lX, Buf=0x%08lX\n\0"
                        as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                        b"CFE_TBL_RemoveAccessLink\0",
                    ))
                    .as_ptr(),
                    Status as libc::c_uint,
                    CFE_ResourceId_ToInteger(CFE_TBL_Global.Buf.PoolHdl),
                    (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr as libc::c_ulong,
                );
            }
            if (*RegRecPtr).DoubleBuffered {
                Status = CFE_ES_PutPoolBuf(
                    CFE_TBL_Global.Buf.PoolHdl,
                    (*RegRecPtr).Buffers[1 as libc::c_int as usize].BufferPtr,
                );
                (*RegRecPtr).Buffers[1 as libc::c_int as usize].BufferPtr = 0 as *mut libc::c_void;
                if Status < 0 as libc::c_int {
                    CFE_ES_WriteToSysLog(
                        b"%s: PutPoolBuf[1] Fail Stat=0x%08X, Hndl=0x%08lX, Buf=0x%08lX\n\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                            b"CFE_TBL_RemoveAccessLink\0",
                        ))
                        .as_ptr(),
                        Status as libc::c_uint,
                        CFE_ResourceId_ToInteger(CFE_TBL_Global.Buf.PoolHdl),
                        (*RegRecPtr).Buffers[1 as libc::c_int as usize].BufferPtr as libc::c_ulong,
                    );
                }
            } else if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int) {
                CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].Taken =
                    0 as libc::c_int != 0;
                (*RegRecPtr).LoadInProgress = -(1 as libc::c_int);
            }
        }
    }
    CFE_TBL_UnlockRegistry();
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetAddressInternal(
    mut TblPtr: *mut *mut libc::c_void,
    mut TblHandle: CFE_TBL_Handle_t,
    mut ThisAppId: CFE_ES_AppId_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    Status = CFE_TBL_ValidateHandle(TblHandle);
    if Status == 0 as libc::c_int {
        AccessDescPtr = &mut *(CFE_TBL_Global.Handles)
            .as_mut_ptr()
            .offset(TblHandle as isize) as *mut CFE_TBL_AccessDescriptor_t;
        Status = CFE_TBL_CheckAccessRights(TblHandle, ThisAppId);
        if Status == 0 as libc::c_int {
            RegRecPtr = &mut *(CFE_TBL_Global.Registry)
                .as_mut_ptr()
                .offset((*AccessDescPtr).RegIndex as isize)
                as *mut CFE_TBL_RegistryRec_t;
            if CFE_ResourceId_Equal(
                (*RegRecPtr).OwnerAppId,
                0 as libc::c_int as CFE_ResourceId_t,
            ) {
                Status = 0xcc000009 as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: App(%lu) attempt to access unowned Tbl Handle=%d\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                        b"CFE_TBL_GetAddressInternal\0",
                    ))
                    .as_ptr(),
                    CFE_ResourceId_ToInteger(ThisAppId),
                    TblHandle as libc::c_int,
                );
            } else {
                (*AccessDescPtr).LockFlag = 1 as libc::c_int != 0;
                (*AccessDescPtr).BufferIndex = (*RegRecPtr).ActiveBufferIndex;
                *TblPtr = (*RegRecPtr).Buffers[(*AccessDescPtr).BufferIndex as usize].BufferPtr;
                Status = CFE_TBL_GetNextNotification(TblHandle);
                (*AccessDescPtr).Updated = 0 as libc::c_int != 0;
            }
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: App(%lu) does not have access to Tbl Handle=%d\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                    b"CFE_TBL_GetAddressInternal\0",
                ))
                .as_ptr(),
                CFE_ResourceId_ToInteger(ThisAppId),
                TblHandle as libc::c_int,
            );
        }
    } else {
        CFE_ES_WriteToSysLog(
            b"%s: App(%lu) using invalid Tbl Handle=%d\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 27], &[libc::c_char; 27]>(
                b"CFE_TBL_GetAddressInternal\0",
            ))
            .as_ptr(),
            CFE_ResourceId_ToInteger(ThisAppId),
            TblHandle as libc::c_int,
        );
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetNextNotification(mut TblHandle: CFE_TBL_Handle_t) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = &mut *(CFE_TBL_Global.Handles)
        .as_mut_ptr()
        .offset(TblHandle as isize)
        as *mut CFE_TBL_AccessDescriptor_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = &mut *(CFE_TBL_Global.Registry)
        .as_mut_ptr()
        .offset((*AccessDescPtr).RegIndex as isize)
        as *mut CFE_TBL_RegistryRec_t;
    if !(*RegRecPtr).TableLoadedOnce {
        Status = 0xcc000005 as libc::c_uint as CFE_Status_t;
    } else if (*AccessDescPtr).Updated {
        Status = 0x4c00000e as libc::c_int;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_FindTableInRegistry(mut TblName: *const libc::c_char) -> int16 {
    let mut RegIndx: int16 = -(1 as libc::c_int) as int16;
    let mut i: int16 = -(1 as libc::c_int) as int16;
    loop {
        i += 1;
        i;
        if !CFE_ResourceId_Equal(
            CFE_TBL_Global.Registry[i as usize].OwnerAppId,
            0 as libc::c_int as CFE_ResourceId_t,
        ) {
            if strcmp(
                TblName,
                (CFE_TBL_Global.Registry[i as usize].Name).as_mut_ptr(),
            ) == 0 as libc::c_int
            {
                RegIndx = i;
            }
        }
        if !(RegIndx as libc::c_int == -(1 as libc::c_int)
            && (i as libc::c_int) < 128 as libc::c_int - 1 as libc::c_int)
        {
            break;
        }
    }
    return RegIndx;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_FindFreeRegistryEntry() -> int16 {
    let mut RegIndx: int16 = -(1 as libc::c_int) as int16;
    let mut i: int16 = 0 as libc::c_int as int16;
    while RegIndx as libc::c_int == -(1 as libc::c_int) && (i as libc::c_int) < 128 as libc::c_int {
        if CFE_ResourceId_Equal(
            CFE_TBL_Global.Registry[i as usize].OwnerAppId,
            0 as libc::c_int as CFE_ResourceId_t,
        ) as libc::c_int
            != 0
            && CFE_TBL_Global.Registry[i as usize].HeadOfAccessList as libc::c_int
                == 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        {
            RegIndx = i;
        } else {
            i += 1;
            i;
        }
    }
    return RegIndx;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_FindFreeHandle() -> CFE_TBL_Handle_t {
    let mut HandleIndx: CFE_TBL_Handle_t = 0xffff as libc::c_int as CFE_TBL_Handle_t;
    let mut i: int16 = 0 as libc::c_int as int16;
    while HandleIndx as libc::c_int == 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        && (i as libc::c_int) < 256 as libc::c_int
    {
        if CFE_TBL_Global.Handles[i as usize].UsedFlag as libc::c_int == 0 as libc::c_int {
            HandleIndx = i;
        } else {
            i += 1;
            i;
        }
    }
    return HandleIndx;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_FormTableName(
    mut FullTblName: *mut libc::c_char,
    mut TblName: *const libc::c_char,
    mut ThisAppId: CFE_ES_AppId_t,
) {
    let mut AppName: [libc::c_char; 20] = [0; 20];
    CFE_ES_GetAppName(
        AppName.as_mut_ptr(),
        ThisAppId,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    AppName[(20 as libc::c_int - 1 as libc::c_int) as usize] = '\0' as i32 as libc::c_char;
    sprintf(
        FullTblName,
        b"%s.%s\0" as *const u8 as *const libc::c_char,
        AppName.as_mut_ptr(),
        TblName,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_LockRegistry() -> int32 {
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    OsStatus = OS_MutSemTake(CFE_TBL_Global.RegistryMutex);
    if OsStatus == 0 as libc::c_int {
        Status = 0 as libc::c_int;
    } else {
        Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_UnlockRegistry() -> int32 {
    let mut OsStatus: int32 = 0;
    let mut Status: int32 = 0;
    OsStatus = OS_MutSemGive(CFE_TBL_Global.RegistryMutex);
    if OsStatus == 0 as libc::c_int {
        Status = 0 as libc::c_int;
    } else {
        Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetWorkingBuffer(
    mut WorkingBufferPtr: *mut *mut CFE_TBL_LoadBuff_t,
    mut RegRecPtr: *mut CFE_TBL_RegistryRec_t,
    mut CalledByApp: bool,
) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    let mut OsStatus: int32 = 0;
    let mut i: int32 = 0;
    let mut InactiveBufferIndex: int32 = 0;
    let mut AccessIterator: CFE_TBL_Handle_t = 0;
    *WorkingBufferPtr = 0 as *mut CFE_TBL_LoadBuff_t;
    if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int) {
        if (*RegRecPtr).DoubleBuffered {
            *WorkingBufferPtr = &mut *((*RegRecPtr).Buffers).as_mut_ptr().offset(
                (1 as libc::c_uint).wrapping_sub((*RegRecPtr).ActiveBufferIndex as libc::c_uint)
                    as isize,
            ) as *mut CFE_TBL_LoadBuff_t;
        } else {
            *WorkingBufferPtr = &mut *(CFE_TBL_Global.LoadBuffs)
                .as_mut_ptr()
                .offset((*RegRecPtr).LoadInProgress as isize)
                as *mut CFE_TBL_LoadBuff_t;
        }
    } else if (*RegRecPtr).TableLoadedOnce as libc::c_int == 0 as libc::c_int
        && CalledByApp as libc::c_int == 1 as libc::c_int
    {
        if (*RegRecPtr).DoubleBuffered {
            *WorkingBufferPtr = &mut *((*RegRecPtr).Buffers)
                .as_mut_ptr()
                .offset((*RegRecPtr).ActiveBufferIndex as isize)
                as *mut CFE_TBL_LoadBuff_t;
        } else {
            *WorkingBufferPtr = &mut *((*RegRecPtr).Buffers)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize)
                as *mut CFE_TBL_LoadBuff_t;
        }
    } else {
        if (*RegRecPtr).DoubleBuffered {
            InactiveBufferIndex = 1 as libc::c_int - (*RegRecPtr).ActiveBufferIndex as libc::c_int;
            AccessIterator = (*RegRecPtr).HeadOfAccessList;
            while AccessIterator as libc::c_int
                != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
                && Status == 0 as libc::c_int
            {
                if CFE_TBL_Global.Handles[AccessIterator as usize].BufferIndex as libc::c_int
                    == InactiveBufferIndex
                    && CFE_TBL_Global.Handles[AccessIterator as usize].LockFlag as libc::c_int != 0
                {
                    Status = 0xcc00000f as libc::c_uint as CFE_Status_t;
                    CFE_ES_WriteToSysLog(
                        b"%s: Inactive Dbl Buff Locked for '%s' by AppId=%lu\n\0" as *const u8
                            as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                            b"CFE_TBL_GetWorkingBuffer\0",
                        ))
                        .as_ptr(),
                        ((*RegRecPtr).Name).as_mut_ptr(),
                        CFE_ResourceId_ToInteger(
                            CFE_TBL_Global.Handles[AccessIterator as usize].AppId,
                        ),
                    );
                }
                AccessIterator = CFE_TBL_Global.Handles[AccessIterator as usize].NextLink;
            }
            if Status == 0 as libc::c_int {
                *WorkingBufferPtr = &mut *((*RegRecPtr).Buffers)
                    .as_mut_ptr()
                    .offset(InactiveBufferIndex as isize)
                    as *mut CFE_TBL_LoadBuff_t;
                (*RegRecPtr).LoadInProgress = InactiveBufferIndex;
            }
        } else {
            OsStatus = OS_MutSemTake(CFE_TBL_Global.WorkBufMutex);
            if OsStatus != 0 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: Internal error taking WorkBuf Mutex (Status=%ld)\n\0" as *const u8
                        as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                        b"CFE_TBL_GetWorkingBuffer\0",
                    ))
                    .as_ptr(),
                    OsStatus as libc::c_long,
                );
            }
            i = 0 as libc::c_int;
            while i < 4 as libc::c_int
                && CFE_TBL_Global.LoadBuffs[i as usize].Taken as libc::c_int == 1 as libc::c_int
            {
                i += 1;
                i;
            }
            if i < 4 as libc::c_int {
                CFE_TBL_Global.LoadBuffs[i as usize].Taken = 1 as libc::c_int != 0;
                *WorkingBufferPtr = &mut *(CFE_TBL_Global.LoadBuffs).as_mut_ptr().offset(i as isize)
                    as *mut CFE_TBL_LoadBuff_t;
                (*RegRecPtr).LoadInProgress = i;
                Status = 0 as libc::c_int;
            } else {
                Status = 0xcc00000f as libc::c_uint as CFE_Status_t;
                CFE_ES_WriteToSysLog(
                    b"%s: All shared buffers are locked\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(
                        b"CFE_TBL_GetWorkingBuffer\0",
                    ))
                    .as_ptr(),
                );
            }
            OS_MutSemGive(CFE_TBL_Global.WorkBufMutex);
        }
        if !(*WorkingBufferPtr).is_null()
            && (**WorkingBufferPtr).BufferPtr
                != (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr
        {
            memcpy(
                (**WorkingBufferPtr).BufferPtr,
                (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr,
                (*RegRecPtr).Size,
            );
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_LoadFromFile(
    mut AppName: *const libc::c_char,
    mut WorkingBufferPtr: *mut CFE_TBL_LoadBuff_t,
    mut RegRecPtr: *mut CFE_TBL_RegistryRec_t,
    mut Filename: *const libc::c_char,
) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    let mut OsStatus: int32 = 0;
    let mut StdFileHeader: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut TblFileHeader: CFE_TBL_File_Hdr_t = CFE_TBL_File_Hdr_t {
        Reserved: 0,
        Offset: 0,
        NumBytes: 0,
        TableName: [0; 40],
    };
    let mut FileDescriptor: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut FilenameLen: size_t = strlen(Filename);
    let mut NumBytes: uint32 = 0;
    let mut ExtraByte: uint8 = 0;
    if FilenameLen > (64 as libc::c_int - 1 as libc::c_int) as libc::c_ulong {
        CFE_EVS_SendEventWithAppID(
            101 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: Filename is too long ('%s' (%lu) > %lu)\0" as *const u8 as *const libc::c_char,
            AppName,
            Filename,
            FilenameLen,
            (64 as libc::c_int as libc::c_ulong).wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        return 0xcc00001f as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_OpenCreate(
        &mut FileDescriptor,
        Filename,
        OS_FILE_FLAG_NONE as libc::c_int,
        0 as libc::c_int,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_EVS_SendEventWithAppID(
            53 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: Unable to open file (Status=%ld)\0" as *const u8 as *const libc::c_char,
            AppName,
            OsStatus as libc::c_long,
        );
        return 0xcc00002c as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_TBL_ReadHeaders(
        FileDescriptor,
        &mut StdFileHeader,
        &mut TblFileHeader,
        Filename,
    );
    if Status != 0 as libc::c_int {
        OS_close(FileDescriptor);
        return Status;
    }
    if strcmp(
        ((*RegRecPtr).Name).as_mut_ptr(),
        (TblFileHeader.TableName).as_mut_ptr(),
    ) != 0 as libc::c_int
    {
        CFE_EVS_SendEventWithAppID(
            102 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: Table name mismatch (exp=%s, tblfilhdr=%s)\0" as *const u8 as *const libc::c_char,
            AppName,
            ((*RegRecPtr).Name).as_mut_ptr(),
            (TblFileHeader.TableName).as_mut_ptr(),
        );
        OS_close(FileDescriptor);
        return 0xcc000020 as libc::c_uint as CFE_Status_t;
    }
    if (TblFileHeader.Offset).wrapping_add(TblFileHeader.NumBytes) as libc::c_ulong
        > (*RegRecPtr).Size
    {
        CFE_EVS_SendEventWithAppID(
            72 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: File reports size larger than expected (file=%lu, exp=%lu)\0" as *const u8
                as *const libc::c_char,
            AppName,
            (TblFileHeader.Offset).wrapping_add(TblFileHeader.NumBytes) as libc::c_ulong,
            (*RegRecPtr).Size,
        );
        OS_close(FileDescriptor);
        return 0xcc000014 as libc::c_uint as CFE_Status_t;
    }
    if TblFileHeader.Offset > 0 as libc::c_int as libc::c_uint {
        Status = 0x4c000022 as libc::c_int;
    } else if (TblFileHeader.NumBytes as libc::c_ulong) < (*RegRecPtr).Size {
        Status = 0x4c000015 as libc::c_int;
    }
    OsStatus = OS_read(
        FileDescriptor,
        ((*WorkingBufferPtr).BufferPtr as *mut uint8).offset(TblFileHeader.Offset as isize)
            as *mut libc::c_void,
        TblFileHeader.NumBytes as size_t,
    );
    if OsStatus >= 0 as libc::c_int {
        NumBytes = OsStatus as uint32;
    } else {
        NumBytes = 0 as libc::c_int as uint32;
    }
    if NumBytes != TblFileHeader.NumBytes {
        CFE_EVS_SendEventWithAppID(
            71 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: File load incomplete (exp=%lu, read=%lu)\0" as *const u8 as *const libc::c_char,
            AppName,
            TblFileHeader.NumBytes as libc::c_ulong,
            NumBytes as libc::c_ulong,
        );
        OS_close(FileDescriptor);
        return 0xcc000021 as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_read(
        FileDescriptor,
        &mut ExtraByte as *mut uint8 as *mut libc::c_void,
        1 as libc::c_int as size_t,
    );
    if OsStatus >= 0 as libc::c_int {
        NumBytes = OsStatus as uint32;
    } else {
        NumBytes = 0 as libc::c_int as uint32;
    }
    if NumBytes == 1 as libc::c_int as libc::c_uint {
        CFE_EVS_SendEventWithAppID(
            75 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"%s: File load too long (file length > %lu)\0" as *const u8 as *const libc::c_char,
            AppName,
            TblFileHeader.NumBytes as libc::c_ulong,
        );
        OS_close(FileDescriptor);
        return 0xcc000014 as libc::c_uint as CFE_Status_t;
    }
    strncpy(
        ((*WorkingBufferPtr).DataSource).as_mut_ptr(),
        Filename,
        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    (*WorkingBufferPtr).DataSource[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = '\0' as i32 as libc::c_char;
    (*WorkingBufferPtr).FileCreateTimeSecs = StdFileHeader.TimeSeconds;
    (*WorkingBufferPtr).FileCreateTimeSubSecs = StdFileHeader.TimeSubSeconds;
    (*WorkingBufferPtr).Crc = CFE_ES_CalculateCRC(
        (*WorkingBufferPtr).BufferPtr,
        (*RegRecPtr).Size,
        0 as libc::c_int as uint32,
        CFE_ES_CrcType_16_ARC,
    );
    OS_close(FileDescriptor);
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_UpdateInternal(
    mut TblHandle: CFE_TBL_Handle_t,
    mut RegRecPtr: *mut CFE_TBL_RegistryRec_t,
    mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t,
) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    let mut AccessIterator: CFE_TBL_Handle_t = 0;
    let mut LockStatus: bool = 0 as libc::c_int != 0;
    if !(*RegRecPtr).LoadPending || (*RegRecPtr).LoadInProgress == -(1 as libc::c_int) {
        Status = 0x4c000017 as libc::c_int;
    } else if (*RegRecPtr).DoubleBuffered {
        (*RegRecPtr).ActiveBufferIndex = (*RegRecPtr).LoadInProgress as uint8;
        strncpy(
            ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
            ((*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].DataSource).as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        (*RegRecPtr).LastFileLoaded[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as usize] = '\0' as i32 as libc::c_char;
        CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
        if (*RegRecPtr).CriticalTable as libc::c_int == 1 as libc::c_int {
            CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
        }
    } else {
        AccessIterator = (*RegRecPtr).HeadOfAccessList;
        while AccessIterator as libc::c_int
            != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        {
            LockStatus = LockStatus as libc::c_int != 0
                || CFE_TBL_Global.Handles[AccessIterator as usize].LockFlag as libc::c_int != 0;
            AccessIterator = CFE_TBL_Global.Handles[AccessIterator as usize].NextLink;
        }
        if LockStatus {
            Status = 0x4c000018 as libc::c_int;
            CFE_ES_WriteToSysLog(
                b"%s: Unable to update locked table Handle=%d\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                    b"CFE_TBL_UpdateInternal\0",
                ))
                .as_ptr(),
                TblHandle as libc::c_int,
            );
        } else {
            if (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr
                != CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].BufferPtr
            {
                memcpy(
                    (*RegRecPtr).Buffers[0 as libc::c_int as usize].BufferPtr,
                    CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].BufferPtr,
                    (*RegRecPtr).Size,
                );
            }
            strncpy(
                ((*RegRecPtr).Buffers[0 as libc::c_int as usize].DataSource).as_mut_ptr(),
                (CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].DataSource)
                    .as_mut_ptr(),
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*RegRecPtr).Buffers[0 as libc::c_int as usize].DataSource[(::core::mem::size_of::<
                [libc::c_char; 64],
            >()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
            strncpy(
                ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
                (CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].DataSource)
                    .as_mut_ptr(),
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*RegRecPtr).LastFileLoaded[(::core::mem::size_of::<[libc::c_char; 64]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
            (*RegRecPtr).Buffers[0 as libc::c_int as usize].FileCreateTimeSecs =
                CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].FileCreateTimeSecs;
            (*RegRecPtr).Buffers[0 as libc::c_int as usize].FileCreateTimeSubSecs = CFE_TBL_Global
                .LoadBuffs[(*RegRecPtr).LoadInProgress as usize]
                .FileCreateTimeSubSecs;
            (*RegRecPtr).Buffers[0 as libc::c_int as usize].Crc =
                CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].Crc;
            CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].Taken =
                0 as libc::c_int != 0;
            CFE_TBL_NotifyTblUsersOfUpdate(RegRecPtr);
            if (*RegRecPtr).CriticalTable as libc::c_int == 1 as libc::c_int {
                CFE_TBL_UpdateCriticalTblCDS(RegRecPtr);
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_NotifyTblUsersOfUpdate(mut RegRecPtr: *mut CFE_TBL_RegistryRec_t) {
    let mut AccessIterator: CFE_TBL_Handle_t = 0;
    (*RegRecPtr).LoadInProgress = -(1 as libc::c_int);
    (*RegRecPtr).TimeOfLastUpdate = CFE_TIME_GetTime();
    (*RegRecPtr).LoadPending = 0 as libc::c_int != 0;
    (*RegRecPtr).TableLoadedOnce = 1 as libc::c_int != 0;
    AccessIterator = (*RegRecPtr).HeadOfAccessList;
    while AccessIterator as libc::c_int != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
    {
        CFE_TBL_Global.Handles[AccessIterator as usize].Updated = 1 as libc::c_int != 0;
        AccessIterator = CFE_TBL_Global.Handles[AccessIterator as usize].NextLink;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ReadHeaders(
    mut FileDescriptor: osal_id_t,
    mut StdFileHeaderPtr: *mut CFE_FS_Header_t,
    mut TblFileHeaderPtr: *mut CFE_TBL_File_Hdr_t,
    mut LoadFilename: *const libc::c_char,
) -> int32 {
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut EndianCheck: int32 = 0x1020304 as libc::c_int;
    Status = CFE_FS_ReadHeader(StdFileHeaderPtr, FileDescriptor);
    if Status as libc::c_ulong != ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong {
        CFE_EVS_SendEventWithAppID(
            54 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"Unable to read std header for '%s', Status = 0x%08X\0" as *const u8
                as *const libc::c_char,
            LoadFilename,
            Status as libc::c_uint,
        );
        Status = 0xcc00001d as libc::c_uint as CFE_Status_t;
    } else if (*StdFileHeaderPtr).ContentType != 0x63464531 as libc::c_int as libc::c_uint {
        CFE_EVS_SendEventWithAppID(
            58 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"File '%s' is not a cFE file type, ContentType = 0x%08X\0" as *const u8
                as *const libc::c_char,
            LoadFilename,
            (*StdFileHeaderPtr).ContentType,
        );
        Status = 0xcc000016 as libc::c_uint as CFE_Status_t;
    } else if (*StdFileHeaderPtr).SubType != CFE_FS_SubType_TBL_IMG as libc::c_int as libc::c_uint {
        CFE_EVS_SendEventWithAppID(
            59 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            CFE_TBL_Global.TableTaskAppId,
            b"File subtype for '%s' is wrong. Subtype = 0x%08X\0" as *const u8
                as *const libc::c_char,
            LoadFilename,
            (*StdFileHeaderPtr).SubType,
        );
        Status = 0xcc00001b as libc::c_uint as CFE_Status_t;
    } else {
        OsStatus = OS_read(
            FileDescriptor,
            TblFileHeaderPtr as *mut libc::c_void,
            ::core::mem::size_of::<CFE_TBL_File_Hdr_t>() as libc::c_ulong,
        );
        if OsStatus as libc::c_ulong
            != ::core::mem::size_of::<CFE_TBL_File_Hdr_t>() as libc::c_ulong
        {
            CFE_EVS_SendEventWithAppID(
                55 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"Unable to read tbl header for '%s', Status = %ld\0" as *const u8
                    as *const libc::c_char,
                LoadFilename,
                OsStatus as libc::c_long,
            );
            Status = 0xcc00001e as libc::c_uint as CFE_Status_t;
        } else {
            Status = 0 as libc::c_int;
            if *(&mut EndianCheck as *mut int32 as *mut libc::c_char) as libc::c_int
                == 0x4 as libc::c_int
            {
                CFE_TBL_ByteSwapTblHeader(TblFileHeaderPtr);
            }
            (*TblFileHeaderPtr).TableName[(::core::mem::size_of::<[libc::c_char; 40]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = '\0' as i32 as libc::c_char;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ByteSwapTblHeader(mut HdrPtr: *mut CFE_TBL_File_Hdr_t) {
    CFE_TBL_ByteSwapUint32(&mut (*HdrPtr).Reserved);
    CFE_TBL_ByteSwapUint32(&mut (*HdrPtr).Offset);
    CFE_TBL_ByteSwapUint32(&mut (*HdrPtr).NumBytes);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ByteSwapUint32(mut Uint32ToSwapPtr: *mut uint32) {
    let mut Temp: int32 = *Uint32ToSwapPtr as int32;
    let mut InPtr: *mut libc::c_char = &mut Temp as *mut int32 as *mut libc::c_char;
    let mut OutPtr: *mut libc::c_char = Uint32ToSwapPtr as *mut libc::c_char;
    *OutPtr.offset(0 as libc::c_int as isize) = *InPtr.offset(3 as libc::c_int as isize);
    *OutPtr.offset(1 as libc::c_int as isize) = *InPtr.offset(2 as libc::c_int as isize);
    *OutPtr.offset(2 as libc::c_int as isize) = *InPtr.offset(1 as libc::c_int as isize);
    *OutPtr.offset(3 as libc::c_int as isize) = *InPtr.offset(0 as libc::c_int as isize);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_CleanUpApp(mut AppId: CFE_ES_AppId_t) -> int32 {
    let mut i: uint32 = 0;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut AccessDescPtr: *mut CFE_TBL_AccessDescriptor_t = 0 as *mut CFE_TBL_AccessDescriptor_t;
    i = 0 as libc::c_int as uint32;
    while i < 4 as libc::c_int as libc::c_uint {
        if CFE_TBL_Global.DumpControlBlocks[i as usize].State as libc::c_uint
            != CFE_TBL_DUMP_FREE as libc::c_int as libc::c_uint
            && CFE_ResourceId_Equal(
                (*CFE_TBL_Global.DumpControlBlocks[i as usize].RegRecPtr).OwnerAppId,
                AppId,
            ) as libc::c_int
                != 0
        {
            CFE_TBL_Global.DumpControlBlocks[i as usize].State = CFE_TBL_DUMP_FREE;
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint32;
    while i < 256 as libc::c_int as libc::c_uint {
        if CFE_ResourceId_Equal(CFE_TBL_Global.Handles[i as usize].AppId, AppId) as libc::c_int != 0
            && CFE_TBL_Global.Handles[i as usize].UsedFlag as libc::c_int == 1 as libc::c_int
        {
            AccessDescPtr = &mut *(CFE_TBL_Global.Handles).as_mut_ptr().offset(i as isize)
                as *mut CFE_TBL_AccessDescriptor_t;
            RegRecPtr = &mut *(CFE_TBL_Global.Registry)
                .as_mut_ptr()
                .offset((*AccessDescPtr).RegIndex as isize)
                as *mut CFE_TBL_RegistryRec_t;
            if CFE_ResourceId_Equal((*RegRecPtr).OwnerAppId, AppId) {
                (*RegRecPtr).OwnerAppId = 0 as libc::c_int as CFE_ResourceId_t;
                (*RegRecPtr).Name[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
            }
            CFE_TBL_RemoveAccessLink(i as CFE_TBL_Handle_t);
            CFE_TBL_Global.Handles[i as usize].AppId = 0 as libc::c_int as CFE_ResourceId_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_FindCriticalTblInfo(
    mut CritRegRecPtr: *mut *mut CFE_TBL_CritRegRec_t,
    mut CDSHandleToFind: CFE_ES_CDSHandle_t,
) {
    let mut i: uint32 = 0;
    *CritRegRecPtr = 0 as *mut CFE_TBL_CritRegRec_t;
    i = 0 as libc::c_int as uint32;
    while i < 32 as libc::c_int as libc::c_uint {
        if CFE_ResourceId_Equal(
            CFE_TBL_Global.CritReg[i as usize].CDSHandle,
            CDSHandleToFind,
        ) {
            *CritRegRecPtr = &mut *(CFE_TBL_Global.CritReg).as_mut_ptr().offset(i as isize)
                as *mut CFE_TBL_CritRegRec_t;
            break;
        } else {
            i = i.wrapping_add(1);
            i;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_UpdateCriticalTblCDS(mut RegRecPtr: *mut CFE_TBL_RegistryRec_t) {
    let mut CritRegRecPtr: *mut CFE_TBL_CritRegRec_t = 0 as *mut CFE_TBL_CritRegRec_t;
    let mut Status: int32 = 0;
    Status = CFE_ES_CopyToCDS(
        (*RegRecPtr).CDSHandle,
        (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Unable to update Critical Table '%s' in CDS (Err=0x%08X)\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                b"CFE_TBL_UpdateCriticalTblCDS\0",
            ))
            .as_ptr(),
            ((*RegRecPtr).Name).as_mut_ptr(),
            Status as libc::c_uint,
        );
    } else {
        CFE_TBL_FindCriticalTblInfo(&mut CritRegRecPtr, (*RegRecPtr).CDSHandle);
        if !CritRegRecPtr.is_null() {
            (*CritRegRecPtr).FileCreateTimeSecs =
                (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSecs;
            (*CritRegRecPtr).FileCreateTimeSubSecs =
                (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSubSecs;
            strncpy(
                ((*CritRegRecPtr).LastFileLoaded).as_mut_ptr(),
                ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*CritRegRecPtr).LastFileLoaded[(::core::mem::size_of::<[libc::c_char; 64]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = '\0' as i32 as libc::c_char;
            (*CritRegRecPtr).TimeOfLastUpdate = (*RegRecPtr).TimeOfLastUpdate;
            (*CritRegRecPtr).TableLoadedOnce = (*RegRecPtr).TableLoadedOnce;
            Status = CFE_ES_CopyToCDS(
                CFE_TBL_Global.CritRegHandle,
                (CFE_TBL_Global.CritReg).as_mut_ptr() as *const libc::c_void,
            );
            if Status != 0 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: Unable to update Critical Table Registry in CDS (Err=0x%08X)\n\0"
                        as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                        b"CFE_TBL_UpdateCriticalTblCDS\0",
                    ))
                    .as_ptr(),
                    Status as libc::c_uint,
                );
            }
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Error finding '%s' in Critical Table Registry\n\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 29], &[libc::c_char; 29]>(
                    b"CFE_TBL_UpdateCriticalTblCDS\0",
                ))
                .as_ptr(),
                ((*RegRecPtr).Name).as_mut_ptr(),
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_SendNotificationMsg(
    mut RegRecPtr: *mut CFE_TBL_RegistryRec_t,
) -> int32 {
    let mut Status: int32 = 0 as libc::c_int;
    if (*RegRecPtr).NotifyByMsg {
        CFE_MSG_SetMsgId(
            &mut CFE_TBL_Global.NotifyMsg.CommandHeader.Msg,
            (*RegRecPtr).NotificationMsgId,
        );
        CFE_MSG_SetFcnCode(
            &mut CFE_TBL_Global.NotifyMsg.CommandHeader.Msg,
            (*RegRecPtr).NotificationCC,
        );
        CFE_TBL_Global.NotifyMsg.Payload.Parameter = (*RegRecPtr).NotificationParam;
        CFE_SB_TimeStampMsg(&mut CFE_TBL_Global.NotifyMsg.CommandHeader.Msg);
        Status = CFE_SB_TransmitMsg(
            &mut CFE_TBL_Global.NotifyMsg.CommandHeader.Msg,
            1 as libc::c_int != 0,
        );
        if Status != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                89 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Manage Notification Pkt Error(Status=0x%08X)\0" as *const u8
                    as *const libc::c_char,
                Status as libc::c_uint,
            );
        }
    }
    return Status;
}
#[no_mangle]
pub static mut CFE_TBL_Global: CFE_TBL_Global_t = CFE_TBL_Global_t {
    CommandCounter: 0,
    CommandErrorCounter: 0,
    SuccessValCounter: 0,
    FailedValCounter: 0,
    NumValRequests: 0,
    LastTblUpdated: 0,
    HkPacket: CFE_TBL_HousekeepingTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_TBL_HousekeepingTlm_Payload_t {
            CommandCounter: 0,
            CommandErrorCounter: 0,
            NumTables: 0,
            NumLoadPending: 0,
            ValidationCounter: 0,
            LastValCrc: 0,
            LastValStatus: 0,
            ActiveBuffer: false,
            LastValTableName: [0; 40],
            SuccessValCounter: 0,
            FailedValCounter: 0,
            NumValRequests: 0,
            NumFreeSharedBufs: 0,
            ByteAlignPad1: 0,
            MemPoolHandle: 0,
            LastUpdateTime: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            LastUpdatedTable: [0; 40],
            LastFileLoaded: [0; 64],
            LastFileDumped: [0; 64],
            LastTableLoaded: [0; 40],
        },
    },
    TblRegPacket: CFE_TBL_TableRegistryTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_TBL_TblRegPacket_Payload_t {
            Size: 0,
            Crc: 0,
            ActiveBufferAddr: 0,
            InactiveBufferAddr: 0,
            ValidationFuncPtr: 0,
            TimeOfLastUpdate: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            FileCreateTimeSecs: 0,
            FileCreateTimeSubSecs: 0,
            TableLoadedOnce: false,
            LoadPending: false,
            DumpOnly: false,
            DoubleBuffered: false,
            Name: [0; 40],
            LastFileLoaded: [0; 64],
            OwnerAppName: [0; 20],
            Critical: false,
            ByteAlign4: 0,
        },
    },
    NotifyMsg: CFE_TBL_NotifyCmd_t {
        CommandHeader: CFE_MSG_CommandHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_CommandSecondaryHeader_t {
                FunctionCode: 0,
                Checksum: 0,
            },
        },
        Payload: CFE_TBL_NotifyCmd_Payload_t { Parameter: 0 },
    },
    CmdPipe: 0,
    TableTaskAppId: 0,
    HkTlmTblRegIndex: 0,
    ValidationCounter: 0,
    RegistryMutex: 0,
    WorkBufMutex: 0,
    CritRegHandle: 0,
    LoadBuffs: [CFE_TBL_LoadBuff_t {
        BufferPtr: 0 as *const libc::c_void as *mut libc::c_void,
        FileCreateTimeSecs: 0,
        FileCreateTimeSubSecs: 0,
        Crc: 0,
        Taken: false,
        Validated: false,
        DataSource: [0; 64],
    }; 4],
    Handles: [CFE_TBL_AccessDescriptor_t {
        AppId: 0,
        RegIndex: 0,
        PrevLink: 0,
        NextLink: 0,
        UsedFlag: false,
        LockFlag: false,
        Updated: false,
        BufferIndex: 0,
    }; 256],
    Registry: [CFE_TBL_RegistryRec_t {
        OwnerAppId: 0,
        Size: 0,
        NotificationMsgId: CFE_SB_MsgId_t { Value: 0 },
        NotificationParam: 0,
        Buffers: [CFE_TBL_LoadBuff_t {
            BufferPtr: 0 as *const libc::c_void as *mut libc::c_void,
            FileCreateTimeSecs: 0,
            FileCreateTimeSubSecs: 0,
            Crc: 0,
            Taken: false,
            Validated: false,
            DataSource: [0; 64],
        }; 2],
        ValidationFuncPtr: None,
        TimeOfLastUpdate: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        HeadOfAccessList: 0,
        LoadInProgress: 0,
        ValidateActiveIndex: 0,
        ValidateInactiveIndex: 0,
        DumpControlIndex: 0,
        CDSHandle: 0,
        NotificationCC: 0,
        CriticalTable: false,
        TableLoadedOnce: false,
        LoadPending: false,
        DumpOnly: false,
        DoubleBuffered: false,
        UserDefAddr: false,
        NotifyByMsg: false,
        ActiveBufferIndex: 0,
        Name: [0; 40],
        LastFileLoaded: [0; 64],
    }; 128],
    CritReg: [CFE_TBL_CritRegRec_t {
        CDSHandle: 0,
        FileCreateTimeSecs: 0,
        FileCreateTimeSubSecs: 0,
        TimeOfLastUpdate: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        LastFileLoaded: [0; 64],
        Name: [0; 40],
        TableLoadedOnce: false,
    }; 32],
    Buf: CFE_TBL_BufParams_t {
        PoolHdl: 0,
        Partition: C2RustUnnamed_22 {
            Align: CFE_ES_PoolAlign {
                Ptr: 0 as *const libc::c_void as *mut libc::c_void,
            },
        },
    },
    ValidationResults: [CFE_TBL_ValidationResult_t {
        State: CFE_TBL_VALIDATION_FREE,
        Result_0: 0,
        CrcOfTable: 0,
        ActiveBuffer: false,
        TableName: [0; 40],
    }; 10],
    DumpControlBlocks: [CFE_TBL_DumpControl_t {
        State: CFE_TBL_DUMP_FREE,
        Size: 0,
        DumpBufferPtr: 0 as *const CFE_TBL_LoadBuff_t as *mut CFE_TBL_LoadBuff_t,
        RegRecPtr: 0 as *const CFE_TBL_RegistryRec_t as *mut CFE_TBL_RegistryRec_t,
        TableName: [0; 40],
    }; 4],
    RegDumpState: CFE_TBL_RegDumpStateInfo_t {
        FileWrite: CFE_FS_FileWriteMetaData_t {
            IsPending: false,
            FileName: [0; 64],
            FileSubType: 0,
            Description: [0; 32],
            GetData: None,
            OnEvent: None,
        },
        FileExisted: false,
        DumpRecord: CFE_TBL_RegDumpRec_t {
            Size: 0,
            TimeOfLastUpdate: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            NumUsers: 0,
            LoadInProgress: 0,
            FileCreateTimeSecs: 0,
            FileCreateTimeSubSecs: 0,
            Crc: 0,
            ValidationFunc: false,
            TableLoadedOnce: false,
            LoadPending: false,
            DumpOnly: false,
            DoubleBuffered: false,
            Name: [0; 40],
            LastFileLoaded: [0; 64],
            OwnerAppName: [0; 20],
            CriticalTable: false,
        },
    },
};
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_TaskMain() {
    let mut Status: int32 = 0;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(3 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    Status = CFE_TBL_TaskInit();
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Application Init Failed,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_TaskMain\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        CFE_ES_PerfLogAdd(3 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_INIT_ERROR as libc::c_int as uint32);
    }
    CFE_ES_WaitForSystemState(
        CFE_ES_SystemState_CORE_READY as libc::c_int as uint32,
        30000 as libc::c_int as uint32,
    );
    while Status == 0 as libc::c_int {
        CFE_ES_IncrementTaskCounter();
        CFE_ES_PerfLogAdd(3 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        Status = CFE_SB_ReceiveBuffer(&mut SBBufPtr, CFE_TBL_Global.CmdPipe, -(1 as libc::c_int));
        CFE_ES_PerfLogAdd(3 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if Status == 0 as libc::c_int {
            CFE_TBL_TaskPipe(SBBufPtr);
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Error reading cmd pipe,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_TaskMain\0"))
                    .as_ptr(),
                Status as libc::c_uint,
            );
        }
    }
    CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR as libc::c_int as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_TaskInit() -> int32 {
    let mut Status: int32 = 0;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_TBL_InitData();
    Status = CFE_EVS_Register(
        0 as *const libc::c_void,
        0 as libc::c_int as uint16,
        0 as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_EVS_Register Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_CreatePipe(
        &mut CFE_TBL_Global.CmdPipe,
        12 as libc::c_int as uint16,
        b"TBL_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error creating cmd pipe:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 12 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TBL_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to HK Request:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TBL_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to gnd cmds:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    Status = CFE_EVS_SendEvent(
        1 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"cFE TBL Initialized: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error sending init event:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 17], &[libc::c_char; 17]>(b"CFE_TBL_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_InitData() {
    CFE_ES_GetAppID(&mut CFE_TBL_Global.TableTaskAppId);
    CFE_MSG_Init(
        &mut CFE_TBL_Global.HkPacket.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TBL_HousekeepingTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_TBL_Global.TblRegPacket.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 12 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TBL_TableRegistryTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_TBL_Global.NotifyMsg.CommandHeader.Msg,
        {
            let mut init = CFE_SB_MsgId_t {
                Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
            };
            init
        },
        ::core::mem::size_of::<CFE_TBL_NotifyCmd_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_HousekeepingCmd(
    mut data: *const CFE_MSG_CommandHeader_t,
) -> int32 {
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut i: uint32 = 0;
    let mut DumpCtrlPtr: *mut CFE_TBL_DumpControl_t = 0 as *mut CFE_TBL_DumpControl_t;
    let mut DumpTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut FileDescriptor: osal_id_t = 0;
    CFE_TBL_GetHkData();
    CFE_SB_TimeStampMsg(&mut CFE_TBL_Global.HkPacket.TelemetryHeader.Msg);
    Status = CFE_SB_TransmitMsg(
        &mut CFE_TBL_Global.HkPacket.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    if Status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            56 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to send Hk Packet (Status=0x%08X)\0" as *const u8 as *const libc::c_char,
            Status as libc::c_uint,
        );
    }
    if CFE_TBL_Global.HkTlmTblRegIndex as libc::c_int != -(1 as libc::c_int) {
        CFE_TBL_GetTblRegData();
        CFE_SB_TimeStampMsg(&mut CFE_TBL_Global.TblRegPacket.TelemetryHeader.Msg);
        CFE_SB_TransmitMsg(
            &mut CFE_TBL_Global.TblRegPacket.TelemetryHeader.Msg,
            1 as libc::c_int != 0,
        );
        CFE_TBL_Global.HkTlmTblRegIndex = -(1 as libc::c_int) as int16;
    }
    i = 0 as libc::c_int as uint32;
    while i < 4 as libc::c_int as libc::c_uint {
        if CFE_TBL_Global.DumpControlBlocks[i as usize].State as libc::c_uint
            == CFE_TBL_DUMP_PERFORMED as libc::c_int as libc::c_uint
        {
            DumpCtrlPtr = &mut *(CFE_TBL_Global.DumpControlBlocks)
                .as_mut_ptr()
                .offset(i as isize) as *mut CFE_TBL_DumpControl_t;
            Status = CFE_TBL_DumpToFile(
                ((*(*DumpCtrlPtr).DumpBufferPtr).DataSource).as_mut_ptr(),
                ((*DumpCtrlPtr).TableName).as_mut_ptr(),
                (*(*DumpCtrlPtr).DumpBufferPtr).BufferPtr,
                (*DumpCtrlPtr).Size,
            ) as int32;
            if Status == CFE_TBL_INC_CMD_CTR as libc::c_int {
                DumpTime.Seconds = (*(*DumpCtrlPtr).DumpBufferPtr).FileCreateTimeSecs;
                DumpTime.Subseconds = (*(*DumpCtrlPtr).DumpBufferPtr).FileCreateTimeSubSecs;
                OsStatus = OS_OpenCreate(
                    &mut FileDescriptor,
                    ((*(*DumpCtrlPtr).DumpBufferPtr).DataSource).as_mut_ptr(),
                    OS_FILE_FLAG_NONE as libc::c_int,
                    2 as libc::c_int,
                );
                if OsStatus == 0 as libc::c_int {
                    Status = CFE_FS_SetTimestamp(FileDescriptor, DumpTime);
                    if Status != 0 as libc::c_int {
                        CFE_ES_WriteToSysLog(
                            b"%s: Unable to update timestamp in dump file '%s'\n\0" as *const u8
                                as *const libc::c_char,
                            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                                b"CFE_TBL_HousekeepingCmd\0",
                            ))
                            .as_ptr(),
                            ((*(*DumpCtrlPtr).DumpBufferPtr).DataSource).as_mut_ptr(),
                        );
                    }
                    OS_close(FileDescriptor);
                } else {
                    CFE_ES_WriteToSysLog(
                        b"%s: Unable to open dump file '%s' to update timestamp\n\0" as *const u8
                            as *const libc::c_char,
                        (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                            b"CFE_TBL_HousekeepingCmd\0",
                        ))
                        .as_ptr(),
                        ((*(*DumpCtrlPtr).DumpBufferPtr).DataSource).as_mut_ptr(),
                    );
                }
            }
            CFE_TBL_Global.LoadBuffs[(*(*DumpCtrlPtr).RegRecPtr).LoadInProgress as usize].Taken =
                0 as libc::c_int != 0;
            (*(*DumpCtrlPtr).RegRecPtr).LoadInProgress = -(1 as libc::c_int);
            (*DumpCtrlPtr).State = CFE_TBL_DUMP_FREE;
        }
        i = i.wrapping_add(1);
        i;
    }
    return CFE_TBL_DONT_INC_CTR as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetHkData() {
    let mut i: uint32 = 0;
    let mut Count: uint16 = 0;
    let mut ValPtr: *mut CFE_TBL_ValidationResult_t = 0 as *mut CFE_TBL_ValidationResult_t;
    CFE_TBL_Global.HkPacket.Payload.CommandCounter = CFE_TBL_Global.CommandCounter;
    CFE_TBL_Global.HkPacket.Payload.CommandErrorCounter = CFE_TBL_Global.CommandErrorCounter;
    CFE_TBL_Global.HkPacket.Payload.FailedValCounter = CFE_TBL_Global.FailedValCounter;
    CFE_TBL_Global.HkPacket.Payload.NumLoadPending = 0 as libc::c_int as uint16;
    CFE_TBL_Global.HkPacket.Payload.MemPoolHandle = CFE_TBL_Global.Buf.PoolHdl;
    Count = 0 as libc::c_int as uint16;
    i = 0 as libc::c_int as uint32;
    while i < 128 as libc::c_int as libc::c_uint {
        if !CFE_ResourceId_Equal(
            CFE_TBL_Global.Registry[i as usize].OwnerAppId,
            0 as libc::c_int as CFE_ResourceId_t,
        ) {
            Count = Count.wrapping_add(1);
            Count;
            if CFE_TBL_Global.Registry[i as usize].LoadPending {
                CFE_TBL_Global.HkPacket.Payload.NumLoadPending =
                    (CFE_TBL_Global.HkPacket.Payload.NumLoadPending).wrapping_add(1);
                CFE_TBL_Global.HkPacket.Payload.NumLoadPending;
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    CFE_TBL_Global.HkPacket.Payload.NumTables = Count;
    CFE_TBL_Global.HkPacket.Payload.NumFreeSharedBufs = 4 as libc::c_int as uint8;
    i = 0 as libc::c_int as uint32;
    while i < 4 as libc::c_int as libc::c_uint {
        if CFE_TBL_Global.LoadBuffs[i as usize].Taken {
            CFE_TBL_Global.HkPacket.Payload.NumFreeSharedBufs =
                (CFE_TBL_Global.HkPacket.Payload.NumFreeSharedBufs).wrapping_sub(1);
            CFE_TBL_Global.HkPacket.Payload.NumFreeSharedBufs;
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint32;
    while i < 10 as libc::c_int as libc::c_uint && ValPtr.is_null() {
        if CFE_TBL_Global.ValidationResults[i as usize].State as libc::c_uint
            == CFE_TBL_VALIDATION_PERFORMED as libc::c_int as libc::c_uint
        {
            ValPtr = &mut *(CFE_TBL_Global.ValidationResults)
                .as_mut_ptr()
                .offset(i as isize) as *mut CFE_TBL_ValidationResult_t;
        } else {
            i = i.wrapping_add(1);
            i;
        }
    }
    if !ValPtr.is_null() {
        CFE_TBL_Global.HkPacket.Payload.LastValCrc = (*ValPtr).CrcOfTable;
        CFE_TBL_Global.HkPacket.Payload.LastValStatus = (*ValPtr).Result_0;
        CFE_TBL_Global.HkPacket.Payload.ActiveBuffer = (*ValPtr).ActiveBuffer;
        if (*ValPtr).Result_0 == 0 as libc::c_int {
            CFE_TBL_Global.SuccessValCounter = (CFE_TBL_Global.SuccessValCounter).wrapping_add(1);
            CFE_TBL_Global.SuccessValCounter;
        } else {
            CFE_TBL_Global.FailedValCounter = (CFE_TBL_Global.FailedValCounter).wrapping_add(1);
            CFE_TBL_Global.FailedValCounter;
        }
        CFE_SB_MessageStringSet(
            (CFE_TBL_Global.HkPacket.Payload.LastValTableName).as_mut_ptr(),
            ((*ValPtr).TableName).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        );
        CFE_TBL_Global.ValidationCounter = (CFE_TBL_Global.ValidationCounter).wrapping_add(1);
        CFE_TBL_Global.ValidationCounter;
        (*ValPtr).Result_0 = 0 as libc::c_int;
        (*ValPtr).CrcOfTable = 0 as libc::c_int as uint32;
        (*ValPtr).TableName[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
        (*ValPtr).ActiveBuffer = 0 as libc::c_int != 0;
        (*ValPtr).State = CFE_TBL_VALIDATION_FREE;
    }
    CFE_TBL_Global.HkPacket.Payload.ValidationCounter = CFE_TBL_Global.ValidationCounter;
    CFE_TBL_Global.HkPacket.Payload.SuccessValCounter = CFE_TBL_Global.SuccessValCounter;
    CFE_TBL_Global.HkPacket.Payload.FailedValCounter = CFE_TBL_Global.FailedValCounter;
    CFE_TBL_Global.HkPacket.Payload.NumValRequests = CFE_TBL_Global.NumValRequests;
    if CFE_TBL_Global.LastTblUpdated as libc::c_int >= 0 as libc::c_int
        && (CFE_TBL_Global.LastTblUpdated as libc::c_int) < 128 as libc::c_int
    {
        if !CFE_ResourceId_Equal(
            CFE_TBL_Global.Registry[CFE_TBL_Global.LastTblUpdated as usize].OwnerAppId,
            0 as libc::c_int as CFE_ResourceId_t,
        ) {
            CFE_TBL_Global.HkPacket.Payload.LastUpdateTime =
                CFE_TBL_Global.Registry[CFE_TBL_Global.LastTblUpdated as usize].TimeOfLastUpdate;
            CFE_SB_MessageStringSet(
                (CFE_TBL_Global.HkPacket.Payload.LastUpdatedTable).as_mut_ptr(),
                (CFE_TBL_Global.Registry[CFE_TBL_Global.LastTblUpdated as usize].Name).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
                ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_GetTblRegData() {
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    RegRecPtr = &mut *(CFE_TBL_Global.Registry)
        .as_mut_ptr()
        .offset(CFE_TBL_Global.HkTlmTblRegIndex as isize)
        as *mut CFE_TBL_RegistryRec_t;
    CFE_TBL_Global.TblRegPacket.Payload.Size = (*RegRecPtr).Size as CFE_ES_MemOffset_t;
    CFE_TBL_Global.TblRegPacket.Payload.ActiveBufferAddr =
        ((*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr as cpuaddr
            & 0xffffffff as libc::c_uint as libc::c_ulong) as CFE_ES_MemAddress_t;
    if (*RegRecPtr).DoubleBuffered {
        CFE_TBL_Global.TblRegPacket.Payload.InactiveBufferAddr =
            ((*RegRecPtr).Buffers[(1 as libc::c_uint)
                .wrapping_sub((*RegRecPtr).ActiveBufferIndex as libc::c_uint)
                as usize]
                .BufferPtr as cpuaddr
                & 0xffffffff as libc::c_uint as libc::c_ulong) as CFE_ES_MemAddress_t;
    } else if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int) {
        CFE_TBL_Global.TblRegPacket.Payload.InactiveBufferAddr =
            (CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].BufferPtr as cpuaddr
                & 0xffffffff as libc::c_uint as libc::c_ulong) as CFE_ES_MemAddress_t;
    } else {
        CFE_TBL_Global.TblRegPacket.Payload.InactiveBufferAddr = (0 as libc::c_int as cpuaddr
            & 0xffffffff as libc::c_uint as libc::c_ulong)
            as CFE_ES_MemAddress_t;
    }
    CFE_TBL_Global.TblRegPacket.Payload.ValidationFuncPtr =
        (::core::mem::transmute::<CFE_TBL_CallbackFuncPtr_t, cpuaddr>(
            (*RegRecPtr).ValidationFuncPtr,
        ) & 0xffffffff as libc::c_uint as libc::c_ulong) as CFE_ES_MemAddress_t;
    CFE_TBL_Global.TblRegPacket.Payload.TimeOfLastUpdate = (*RegRecPtr).TimeOfLastUpdate;
    CFE_TBL_Global.TblRegPacket.Payload.TableLoadedOnce = (*RegRecPtr).TableLoadedOnce;
    CFE_TBL_Global.TblRegPacket.Payload.LoadPending = (*RegRecPtr).LoadPending;
    CFE_TBL_Global.TblRegPacket.Payload.DumpOnly = (*RegRecPtr).DumpOnly;
    CFE_TBL_Global.TblRegPacket.Payload.DoubleBuffered = (*RegRecPtr).DoubleBuffered;
    CFE_TBL_Global.TblRegPacket.Payload.FileCreateTimeSecs =
        (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSecs;
    CFE_TBL_Global.TblRegPacket.Payload.FileCreateTimeSubSecs =
        (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSubSecs;
    CFE_TBL_Global.TblRegPacket.Payload.Crc =
        (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].Crc;
    CFE_TBL_Global.TblRegPacket.Payload.Critical = (*RegRecPtr).CriticalTable;
    CFE_SB_MessageStringSet(
        (CFE_TBL_Global.TblRegPacket.Payload.Name).as_mut_ptr(),
        ((*RegRecPtr).Name).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    CFE_SB_MessageStringSet(
        (CFE_TBL_Global.TblRegPacket.Payload.LastFileLoaded).as_mut_ptr(),
        ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
    );
    CFE_ES_GetAppName(
        (CFE_TBL_Global.TblRegPacket.Payload.OwnerAppName).as_mut_ptr(),
        (*RegRecPtr).OwnerAppId,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_NoopCmd(mut data: *const CFE_TBL_NoopCmd_t) -> int32 {
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    CFE_EVS_SendEvent(
        10 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"No-op Cmd Rcvd: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    return CFE_TBL_INC_CMD_CTR as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ResetCountersCmd(
    mut data: *const CFE_TBL_ResetCountersCmd_t,
) -> int32 {
    CFE_TBL_Global.CommandCounter = 0 as libc::c_int as uint8;
    CFE_TBL_Global.CommandErrorCounter = 0 as libc::c_int as uint8;
    CFE_TBL_Global.SuccessValCounter = 0 as libc::c_int as uint8;
    CFE_TBL_Global.FailedValCounter = 0 as libc::c_int as uint8;
    CFE_TBL_Global.NumValRequests = 0 as libc::c_int as uint8;
    CFE_TBL_Global.ValidationCounter = 0 as libc::c_int as uint16;
    CFE_EVS_SendEvent(
        11 as libc::c_int as uint16,
        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
        b"Reset Counters command\0" as *const u8 as *const libc::c_char,
    );
    return CFE_TBL_DONT_INC_CTR as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_LoadCmd(mut data: *const CFE_TBL_LoadCmd_t) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut CmdPtr: *const CFE_TBL_LoadCmd_Payload_t = &(*data).Payload;
    let mut StdFileHeader: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut TblFileHeader: CFE_TBL_File_Hdr_t = CFE_TBL_File_Hdr_t {
        Reserved: 0,
        Offset: 0,
        NumBytes: 0,
        TableName: [0; 40],
    };
    let mut FileDescriptor: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut RegIndex: int16 = 0;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut WorkingBufferPtr: *mut CFE_TBL_LoadBuff_t = 0 as *mut CFE_TBL_LoadBuff_t;
    let mut LoadFilename: [libc::c_char; 64] = [0; 64];
    let mut ExtraByte: uint8 = 0;
    CFE_SB_MessageStringGet(
        LoadFilename.as_mut_ptr(),
        ((*CmdPtr).LoadFilename).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
    );
    OsStatus = OS_OpenCreate(
        &mut FileDescriptor,
        LoadFilename.as_mut_ptr(),
        OS_FILE_FLAG_NONE as libc::c_int,
        0 as libc::c_int,
    );
    if OsStatus == 0 as libc::c_int {
        Status = CFE_TBL_ReadHeaders(
            FileDescriptor,
            &mut StdFileHeader,
            &mut TblFileHeader,
            &mut *LoadFilename.as_mut_ptr().offset(0 as libc::c_int as isize),
        );
        if Status == 0 as libc::c_int {
            RegIndex = CFE_TBL_FindTableInRegistry((TblFileHeader.TableName).as_mut_ptr());
            if RegIndex as libc::c_int == -(1 as libc::c_int) {
                CFE_EVS_SendEvent(
                    57 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Unable to locate '%s' in Table Registry\0" as *const u8
                        as *const libc::c_char,
                    (TblFileHeader.TableName).as_mut_ptr(),
                );
            } else {
                RegRecPtr = &mut *(CFE_TBL_Global.Registry)
                    .as_mut_ptr()
                    .offset(RegIndex as isize)
                    as *mut CFE_TBL_RegistryRec_t;
                if (*RegRecPtr).DumpOnly {
                    CFE_EVS_SendEvent(
                        79 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Attempted to load DUMP-ONLY table '%s' from '%s'\0" as *const u8
                            as *const libc::c_char,
                        (TblFileHeader.TableName).as_mut_ptr(),
                        LoadFilename.as_mut_ptr(),
                    );
                } else if (*RegRecPtr).LoadPending {
                    CFE_EVS_SendEvent(
                        88 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Attempted to load table '%s' while previous load is still pending\0"
                            as *const u8 as *const libc::c_char,
                        (TblFileHeader.TableName).as_mut_ptr(),
                    );
                } else if ((*RegRecPtr).TableLoadedOnce as libc::c_int != 0
                    || TblFileHeader.Offset == 0 as libc::c_int as libc::c_uint)
                    && TblFileHeader.NumBytes > 0 as libc::c_int as libc::c_uint
                    && (TblFileHeader.NumBytes).wrapping_add(TblFileHeader.Offset) as libc::c_ulong
                        <= (*RegRecPtr).Size
                {
                    Status = CFE_TBL_GetWorkingBuffer(
                        &mut WorkingBufferPtr,
                        RegRecPtr,
                        0 as libc::c_int != 0,
                    );
                    if Status == 0 as libc::c_int {
                        OsStatus = OS_read(
                            FileDescriptor,
                            ((*WorkingBufferPtr).BufferPtr as *mut uint8)
                                .offset(TblFileHeader.Offset as isize)
                                as *mut libc::c_void,
                            TblFileHeader.NumBytes as size_t,
                        );
                        if OsStatus as libc::c_long == TblFileHeader.NumBytes as libc::c_long {
                            OsStatus = OS_read(
                                FileDescriptor,
                                &mut ExtraByte as *mut uint8 as *mut libc::c_void,
                                1 as libc::c_int as size_t,
                            );
                            if OsStatus as libc::c_long == 1 as libc::c_int as libc::c_long {
                                CFE_EVS_SendEvent(
                                    75 as libc::c_int as uint16,
                                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                                    b"File '%s' has more data than Tbl Hdr indicates (%d)\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    LoadFilename.as_mut_ptr(),
                                    TblFileHeader.NumBytes as libc::c_int,
                                );
                            } else {
                                CFE_EVS_SendEvent(
                                    12 as libc::c_int as uint16,
                                    CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                                    b"Successful load of '%s' into '%s' working buffer\0"
                                        as *const u8
                                        as *const libc::c_char,
                                    LoadFilename.as_mut_ptr(),
                                    (TblFileHeader.TableName).as_mut_ptr(),
                                );
                                memcpy(
                                    ((*WorkingBufferPtr).DataSource).as_mut_ptr()
                                        as *mut libc::c_void,
                                    LoadFilename.as_mut_ptr() as *const libc::c_void,
                                    64 as libc::c_int as libc::c_ulong,
                                );
                                (*WorkingBufferPtr).FileCreateTimeSecs = StdFileHeader.TimeSeconds;
                                (*WorkingBufferPtr).FileCreateTimeSubSecs =
                                    StdFileHeader.TimeSubSeconds;
                                (*WorkingBufferPtr).Crc = CFE_ES_CalculateCRC(
                                    (*WorkingBufferPtr).BufferPtr,
                                    (*RegRecPtr).Size,
                                    0 as libc::c_int as uint32,
                                    CFE_ES_CrcType_16_ARC,
                                );
                                (*WorkingBufferPtr).Validated =
                                    ((*RegRecPtr).ValidationFuncPtr).is_none();
                                strncpy(
                                    (CFE_TBL_Global.HkPacket.Payload.LastFileLoaded).as_mut_ptr(),
                                    LoadFilename.as_mut_ptr(),
                                    (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                );
                                CFE_TBL_Global.HkPacket.Payload.LastFileLoaded
                                    [(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        as usize] = '\0' as i32 as libc::c_char;
                                strncpy(
                                    (CFE_TBL_Global.HkPacket.Payload.LastTableLoaded).as_mut_ptr(),
                                    (TblFileHeader.TableName).as_mut_ptr(),
                                    (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                );
                                CFE_TBL_Global.HkPacket.Payload.LastTableLoaded
                                    [(::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        as usize] = '\0' as i32 as libc::c_char;
                                ReturnCode = CFE_TBL_INC_CMD_CTR;
                            }
                        } else {
                            CFE_EVS_SendEvent(
                                71 as libc::c_int as uint16,
                                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                                b"Incomplete load of '%s' into '%s' working buffer\0" as *const u8
                                    as *const libc::c_char,
                                LoadFilename.as_mut_ptr(),
                                (TblFileHeader.TableName).as_mut_ptr(),
                            );
                        }
                    } else {
                        CFE_EVS_SendEvent(
                            60 as libc::c_int as uint16,
                            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                            b"No working buffers available for table '%s'\0" as *const u8
                                as *const libc::c_char,
                            (TblFileHeader.TableName).as_mut_ptr(),
                        );
                    }
                } else if (TblFileHeader.NumBytes).wrapping_add(TblFileHeader.Offset)
                    as libc::c_ulong
                    > (*RegRecPtr).Size
                {
                    CFE_EVS_SendEvent(
                        72 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Cannot load '%s' (%d) at offset %d in '%s' (%d)\0" as *const u8
                            as *const libc::c_char,
                        LoadFilename.as_mut_ptr(),
                        TblFileHeader.NumBytes as libc::c_int,
                        TblFileHeader.Offset as libc::c_int,
                        (TblFileHeader.TableName).as_mut_ptr(),
                        (*RegRecPtr).Size as libc::c_int,
                    );
                } else if TblFileHeader.NumBytes == 0 as libc::c_int as libc::c_uint {
                    CFE_EVS_SendEvent(
                        73 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Table Hdr in '%s' indicates no data in file\0" as *const u8
                            as *const libc::c_char,
                        LoadFilename.as_mut_ptr(),
                    );
                } else {
                    CFE_EVS_SendEvent(
                        74 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"'%s' has partial load for uninitialized table '%s'\0" as *const u8
                            as *const libc::c_char,
                        LoadFilename.as_mut_ptr(),
                        (TblFileHeader.TableName).as_mut_ptr(),
                    );
                }
            }
        }
        OS_close(FileDescriptor);
    } else {
        CFE_EVS_SendEvent(
            53 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to open file '%s' for table load, Status = %ld\0" as *const u8
                as *const libc::c_char,
            LoadFilename.as_mut_ptr(),
            OsStatus as libc::c_long,
        );
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_DumpCmd(mut data: *const CFE_TBL_DumpCmd_t) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut RegIndex: int16 = 0;
    let mut CmdPtr: *const CFE_TBL_DumpCmd_Payload_t = &(*data).Payload;
    let mut DumpFilename: [libc::c_char; 64] = [0; 64];
    let mut TableName: [libc::c_char; 40] = [0; 40];
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut DumpDataAddr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut WorkingBufferPtr: *mut CFE_TBL_LoadBuff_t = 0 as *mut CFE_TBL_LoadBuff_t;
    let mut DumpIndex: int32 = 0;
    let mut Status: int32 = 0;
    let mut DumpCtrlPtr: *mut CFE_TBL_DumpControl_t = 0 as *mut CFE_TBL_DumpControl_t;
    CFE_SB_MessageStringGet(
        DumpFilename.as_mut_ptr(),
        ((*CmdPtr).DumpFilename).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
    );
    CFE_SB_MessageStringGet(
        TableName.as_mut_ptr(),
        ((*CmdPtr).TableName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    RegIndex = CFE_TBL_FindTableInRegistry(TableName.as_mut_ptr());
    if RegIndex as libc::c_int != -(1 as libc::c_int) {
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset(RegIndex as isize) as *mut CFE_TBL_RegistryRec_t;
        if (*CmdPtr).ActiveTableFlag as libc::c_int == CFE_TBL_BufferSelect_ACTIVE as libc::c_int {
            DumpDataAddr = (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr;
        } else if (*CmdPtr).ActiveTableFlag as libc::c_int
            == CFE_TBL_BufferSelect_INACTIVE as libc::c_int
        {
            if (*RegRecPtr).DoubleBuffered {
                DumpDataAddr = (*RegRecPtr).Buffers[(1 as libc::c_uint)
                    .wrapping_sub((*RegRecPtr).ActiveBufferIndex as libc::c_uint)
                    as usize]
                    .BufferPtr;
            } else if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int)
                && !(*RegRecPtr).UserDefAddr
            {
                DumpDataAddr =
                    CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].BufferPtr;
            } else {
                CFE_EVS_SendEvent(
                    66 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"No Inactive Buffer for Table '%s' present\0" as *const u8
                        as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
            }
        } else {
            CFE_EVS_SendEvent(
                80 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Cmd for Table '%s' had illegal buffer parameter (0x%08X)\0" as *const u8
                    as *const libc::c_char,
                TableName.as_mut_ptr(),
                (*CmdPtr).ActiveTableFlag as libc::c_uint,
            );
        }
        if !DumpDataAddr.is_null() {
            if !(*RegRecPtr).DumpOnly {
                ReturnCode = CFE_TBL_DumpToFile(
                    DumpFilename.as_mut_ptr(),
                    TableName.as_mut_ptr(),
                    DumpDataAddr,
                    (*RegRecPtr).Size,
                );
            } else if (*RegRecPtr).DumpControlIndex == -(1 as libc::c_int) {
                DumpIndex = 0 as libc::c_int;
                while DumpIndex < 4 as libc::c_int
                    && CFE_TBL_Global.DumpControlBlocks[DumpIndex as usize].State as libc::c_uint
                        != CFE_TBL_DUMP_FREE as libc::c_int as libc::c_uint
                {
                    DumpIndex += 1;
                    DumpIndex;
                }
                if DumpIndex < 4 as libc::c_int {
                    Status = CFE_TBL_GetWorkingBuffer(
                        &mut WorkingBufferPtr,
                        RegRecPtr,
                        0 as libc::c_int != 0,
                    );
                    if Status == 0 as libc::c_int {
                        DumpCtrlPtr = &mut *(CFE_TBL_Global.DumpControlBlocks)
                            .as_mut_ptr()
                            .offset(DumpIndex as isize)
                            as *mut CFE_TBL_DumpControl_t;
                        (*DumpCtrlPtr).State = CFE_TBL_DUMP_PENDING;
                        (*DumpCtrlPtr).RegRecPtr = RegRecPtr;
                        (*DumpCtrlPtr).DumpBufferPtr = WorkingBufferPtr;
                        memcpy(
                            ((*(*DumpCtrlPtr).DumpBufferPtr).DataSource).as_mut_ptr()
                                as *mut libc::c_void,
                            DumpFilename.as_mut_ptr() as *const libc::c_void,
                            64 as libc::c_int as libc::c_ulong,
                        );
                        memcpy(
                            ((*DumpCtrlPtr).TableName).as_mut_ptr() as *mut libc::c_void,
                            TableName.as_mut_ptr() as *const libc::c_void,
                            (16 as libc::c_int + 20 as libc::c_int + 4 as libc::c_int)
                                as libc::c_ulong,
                        );
                        (*DumpCtrlPtr).Size = (*RegRecPtr).Size;
                        (*RegRecPtr).DumpControlIndex = DumpIndex;
                        CFE_TBL_SendNotificationMsg(RegRecPtr);
                        ReturnCode = CFE_TBL_INC_CMD_CTR;
                    } else {
                        CFE_EVS_SendEvent(
                            60 as libc::c_int as uint16,
                            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                            b"No working buffers available for table '%s'\0" as *const u8
                                as *const libc::c_char,
                            TableName.as_mut_ptr(),
                        );
                    }
                } else {
                    CFE_EVS_SendEvent(
                        76 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Too many Dump Only Table Dumps have been requested\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            } else {
                CFE_EVS_SendEvent(
                    77 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"A dump for '%s' is already pending\0" as *const u8 as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
            }
        }
    } else {
        CFE_EVS_SendEvent(
            57 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to locate '%s' in Table Registry\0" as *const u8 as *const libc::c_char,
            TableName.as_mut_ptr(),
        );
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_DumpToFile(
    mut DumpFilename: *const libc::c_char,
    mut TableName: *const libc::c_char,
    mut DumpDataAddr: *const libc::c_void,
    mut TblSizeInBytes: size_t,
) -> CFE_TBL_CmdProcRet_t {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut FileExistedPrev: bool = 0 as libc::c_int != 0;
    let mut StdFileHeader: CFE_FS_Header_t = CFE_FS_Header_t {
        ContentType: 0,
        SubType: 0,
        Length: 0,
        SpacecraftID: 0,
        ProcessorID: 0,
        ApplicationID: 0,
        TimeSeconds: 0,
        TimeSubSeconds: 0,
        Description: [0; 32],
    };
    let mut TblFileHeader: CFE_TBL_File_Hdr_t = CFE_TBL_File_Hdr_t {
        Reserved: 0,
        Offset: 0,
        NumBytes: 0,
        TableName: [0; 40],
    };
    let mut FileDescriptor: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut EndianCheck: int32 = 0x1020304 as libc::c_int;
    memset(
        &mut TblFileHeader as *mut CFE_TBL_File_Hdr_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TBL_File_Hdr_t>() as libc::c_ulong,
    );
    OsStatus = OS_OpenCreate(
        &mut FileDescriptor,
        DumpFilename,
        OS_FILE_FLAG_NONE as libc::c_int,
        0 as libc::c_int,
    );
    if OsStatus == 0 as libc::c_int {
        FileExistedPrev = 1 as libc::c_int != 0;
        OS_close(FileDescriptor);
    }
    OsStatus = OS_OpenCreate(
        &mut FileDescriptor,
        DumpFilename,
        OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
        1 as libc::c_int,
    );
    if OsStatus == 0 as libc::c_int {
        CFE_FS_InitHeader(
            &mut StdFileHeader,
            b"Table Dump Image\0" as *const u8 as *const libc::c_char,
            CFE_FS_SubType_TBL_IMG as libc::c_int as uint32,
        );
        Status = CFE_FS_WriteHeader(FileDescriptor, &mut StdFileHeader);
        if Status as libc::c_ulong == ::core::mem::size_of::<CFE_FS_Header_t>() as libc::c_ulong {
            strncpy(
                (TblFileHeader.TableName).as_mut_ptr(),
                TableName,
                (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            TblFileHeader.TableName[(::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
            TblFileHeader.Offset = 0 as libc::c_int as uint32;
            TblFileHeader.NumBytes = TblSizeInBytes as uint32;
            TblFileHeader.Reserved = 0 as libc::c_int as uint32;
            if *(&mut EndianCheck as *mut int32 as *mut libc::c_char) as libc::c_int
                == 0x4 as libc::c_int
            {
                CFE_TBL_ByteSwapTblHeader(&mut TblFileHeader);
            }
            OsStatus = OS_write(
                FileDescriptor,
                &mut TblFileHeader as *mut CFE_TBL_File_Hdr_t as *const libc::c_void,
                ::core::mem::size_of::<CFE_TBL_File_Hdr_t>() as libc::c_ulong,
            );
            if OsStatus as libc::c_long as libc::c_ulong
                == ::core::mem::size_of::<CFE_TBL_File_Hdr_t>() as libc::c_ulong
            {
                OsStatus = OS_write(FileDescriptor, DumpDataAddr, TblSizeInBytes);
                if OsStatus as libc::c_long as libc::c_ulong == TblSizeInBytes {
                    if FileExistedPrev {
                        CFE_EVS_SendEvent(
                            13 as libc::c_int as uint16,
                            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                            b"Successfully overwrote '%s' with Table '%s'\0" as *const u8
                                as *const libc::c_char,
                            DumpFilename,
                            TableName,
                        );
                    } else {
                        CFE_EVS_SendEvent(
                            14 as libc::c_int as uint16,
                            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                            b"Successfully dumped Table '%s' to '%s'\0" as *const u8
                                as *const libc::c_char,
                            TableName,
                            DumpFilename,
                        );
                    }
                    strncpy(
                        (CFE_TBL_Global.HkPacket.Payload.LastFileDumped).as_mut_ptr(),
                        DumpFilename,
                        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    );
                    CFE_TBL_Global.HkPacket.Payload.LastFileDumped[(::core::mem::size_of::<
                        [libc::c_char; 64],
                    >()
                        as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        as usize] = 0 as libc::c_int as libc::c_char;
                    ReturnCode = CFE_TBL_INC_CMD_CTR;
                } else {
                    CFE_EVS_SendEvent(
                        65 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Error writing Tbl image to '%s', Status=%ld\0" as *const u8
                            as *const libc::c_char,
                        DumpFilename,
                        OsStatus as libc::c_long,
                    );
                }
            } else {
                CFE_EVS_SendEvent(
                    64 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Error writing Tbl image File Header to '%s', Status=%ld\0" as *const u8
                        as *const libc::c_char,
                    DumpFilename,
                    OsStatus as libc::c_long,
                );
            }
        } else {
            CFE_EVS_SendEvent(
                63 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error writing cFE File Header to '%s', Status=0x%08X\0" as *const u8
                    as *const libc::c_char,
                DumpFilename,
                Status as libc::c_uint,
            );
        }
        OS_close(FileDescriptor);
    } else {
        CFE_EVS_SendEvent(
            62 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Error creating dump file '%s', Status=%ld\0" as *const u8 as *const libc::c_char,
            DumpFilename,
            OsStatus as libc::c_long,
        );
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ValidateCmd(mut data: *const CFE_TBL_ValidateCmd_t) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut RegIndex: int16 = 0;
    let mut CmdPtr: *const CFE_TBL_ValidateCmd_Payload_t = &(*data).Payload;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut ValidationDataPtr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut TableName: [libc::c_char; 40] = [0; 40];
    let mut CrcOfTable: uint32 = 0;
    let mut ValIndex: int32 = 0;
    CFE_SB_MessageStringGet(
        TableName.as_mut_ptr(),
        ((*CmdPtr).TableName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    RegIndex = CFE_TBL_FindTableInRegistry(TableName.as_mut_ptr());
    if RegIndex as libc::c_int != -(1 as libc::c_int) {
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset(RegIndex as isize) as *mut CFE_TBL_RegistryRec_t;
        if (*CmdPtr).ActiveTableFlag as libc::c_int == CFE_TBL_BufferSelect_ACTIVE as libc::c_int {
            ValidationDataPtr =
                (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].BufferPtr;
        } else if (*CmdPtr).ActiveTableFlag as libc::c_int
            == CFE_TBL_BufferSelect_INACTIVE as libc::c_int
        {
            if (*RegRecPtr).DoubleBuffered {
                ValidationDataPtr = (*RegRecPtr).Buffers[(1 as libc::c_uint)
                    .wrapping_sub((*RegRecPtr).ActiveBufferIndex as libc::c_uint)
                    as usize]
                    .BufferPtr;
            } else if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int) {
                ValidationDataPtr =
                    CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].BufferPtr;
            } else {
                CFE_EVS_SendEvent(
                    66 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"No Inactive Buffer for Table '%s' present\0" as *const u8
                        as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
            }
        } else {
            CFE_EVS_SendEvent(
                80 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Cmd for Table '%s' had illegal buffer parameter (0x%08X)\0" as *const u8
                    as *const libc::c_char,
                TableName.as_mut_ptr(),
                (*CmdPtr).ActiveTableFlag as libc::c_uint,
            );
        }
        if !ValidationDataPtr.is_null() {
            ValIndex = 0 as libc::c_int;
            while ValIndex < 10 as libc::c_int
                && CFE_TBL_Global.ValidationResults[ValIndex as usize].State as libc::c_uint
                    != CFE_TBL_VALIDATION_FREE as libc::c_int as libc::c_uint
            {
                ValIndex += 1;
                ValIndex;
            }
            if ValIndex < 10 as libc::c_int {
                CFE_TBL_Global.ValidationResults[ValIndex as usize].State =
                    CFE_TBL_VALIDATION_PENDING;
                CFE_TBL_Global.ValidationResults[ValIndex as usize].Result_0 = 0 as libc::c_int;
                memcpy(
                    (CFE_TBL_Global.ValidationResults[ValIndex as usize].TableName).as_mut_ptr()
                        as *mut libc::c_void,
                    TableName.as_mut_ptr() as *const libc::c_void,
                    (16 as libc::c_int + 20 as libc::c_int + 4 as libc::c_int) as libc::c_ulong,
                );
                CrcOfTable = CFE_ES_CalculateCRC(
                    ValidationDataPtr,
                    (*RegRecPtr).Size,
                    0 as libc::c_int as uint32,
                    CFE_ES_CrcType_16_ARC,
                );
                CFE_TBL_Global.ValidationResults[ValIndex as usize].CrcOfTable = CrcOfTable;
                CFE_TBL_Global.ValidationResults[ValIndex as usize].ActiveBuffer =
                    (*CmdPtr).ActiveTableFlag as libc::c_int != 0 as libc::c_int;
                if ((*RegRecPtr).ValidationFuncPtr).is_some() {
                    if (*CmdPtr).ActiveTableFlag != 0 {
                        (*RegRecPtr).ValidateActiveIndex = ValIndex;
                    } else {
                        (*RegRecPtr).ValidateInactiveIndex = ValIndex;
                    }
                    if CFE_TBL_SendNotificationMsg(RegRecPtr) == 0 as libc::c_int {
                        CFE_EVS_SendEvent(
                            16 as libc::c_int as uint16,
                            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                            b"Tbl Services issued validation request for '%s'\0" as *const u8
                                as *const libc::c_char,
                            TableName.as_mut_ptr(),
                        );
                    }
                    CFE_TBL_Global.NumValRequests = (CFE_TBL_Global.NumValRequests).wrapping_add(1);
                    CFE_TBL_Global.NumValRequests;
                } else {
                    CFE_TBL_Global.ValidationResults[ValIndex as usize].State =
                        CFE_TBL_VALIDATION_PERFORMED;
                    CFE_EVS_SendEvent(
                        23 as libc::c_int as uint16,
                        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                        b"Tbl Services assumes '%s' is valid. No Validation Function has been registered\0"
                            as *const u8 as *const libc::c_char,
                        TableName.as_mut_ptr(),
                    );
                }
                ReturnCode = CFE_TBL_INC_CMD_CTR;
            } else {
                CFE_EVS_SendEvent(
                    67 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Too many Table Validations have been requested\0" as *const u8
                        as *const libc::c_char,
                );
            }
        }
    } else {
        CFE_EVS_SendEvent(
            57 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to locate '%s' in Table Registry\0" as *const u8 as *const libc::c_char,
            TableName.as_mut_ptr(),
        );
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_ActivateCmd(mut data: *const CFE_TBL_ActivateCmd_t) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut RegIndex: int16 = 0;
    let mut CmdPtr: *const CFE_TBL_ActivateCmd_Payload_t = &(*data).Payload;
    let mut TableName: [libc::c_char; 40] = [0; 40];
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut ValidationStatus: bool = false;
    CFE_SB_MessageStringGet(
        TableName.as_mut_ptr(),
        ((*CmdPtr).TableName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    RegIndex = CFE_TBL_FindTableInRegistry(TableName.as_mut_ptr());
    if RegIndex as libc::c_int != -(1 as libc::c_int) {
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset(RegIndex as isize) as *mut CFE_TBL_RegistryRec_t;
        if (*RegRecPtr).DumpOnly {
            CFE_EVS_SendEvent(
                78 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Illegal attempt to activate dump-only table '%s'\0" as *const u8
                    as *const libc::c_char,
                TableName.as_mut_ptr(),
            );
        } else if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int) {
            if (*RegRecPtr).DoubleBuffered {
                ValidationStatus = (*RegRecPtr).Buffers[(1 as libc::c_uint)
                    .wrapping_sub((*RegRecPtr).ActiveBufferIndex as libc::c_uint)
                    as usize]
                    .Validated;
            } else {
                ValidationStatus =
                    CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].Validated;
            }
            if ValidationStatus as libc::c_int == 1 as libc::c_int {
                CFE_TBL_Global.Registry[RegIndex as usize].LoadPending = 1 as libc::c_int != 0;
                if CFE_TBL_SendNotificationMsg(RegRecPtr) == 0 as libc::c_int {
                    CFE_EVS_SendEvent(
                        17 as libc::c_int as uint16,
                        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                        b"Tbl Services notifying App that '%s' has a load pending\0" as *const u8
                            as *const libc::c_char,
                        TableName.as_mut_ptr(),
                    );
                }
                ReturnCode = CFE_TBL_INC_CMD_CTR;
            } else {
                CFE_EVS_SendEvent(
                    81 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Cannot activate table '%s'. Inactive image not Validated\0" as *const u8
                        as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
            }
        } else {
            CFE_EVS_SendEvent(
                70 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Cannot activate table '%s'. No Inactive image available\0" as *const u8
                    as *const libc::c_char,
                TableName.as_mut_ptr(),
            );
        }
    } else {
        CFE_EVS_SendEvent(
            57 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to locate '%s' in Table Registry\0" as *const u8 as *const libc::c_char,
            TableName.as_mut_ptr(),
        );
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_DumpRegistryGetter(
    mut Meta: *mut libc::c_void,
    mut RecordNum: uint32,
    mut Buffer: *mut *mut libc::c_void,
    mut BufSize: *mut size_t,
) -> bool {
    let mut StatePtr: *mut CFE_TBL_RegDumpStateInfo_t = Meta as *mut CFE_TBL_RegDumpStateInfo_t;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut HandleIterator: CFE_TBL_Handle_t = 0;
    let mut OwnerAppId: CFE_ES_AppId_t = 0;
    let mut IsValidEntry: bool = false;
    IsValidEntry = 0 as libc::c_int != 0;
    OwnerAppId = 0 as libc::c_int as CFE_ResourceId_t;
    if RecordNum < 128 as libc::c_int as libc::c_uint {
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset(RecordNum as isize) as *mut CFE_TBL_RegistryRec_t;
        CFE_TBL_LockRegistry();
        if !CFE_ResourceId_Equal(
            (*RegRecPtr).OwnerAppId,
            0 as libc::c_int as CFE_ResourceId_t,
        ) || (*RegRecPtr).HeadOfAccessList as libc::c_int
            != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
        {
            IsValidEntry = 1 as libc::c_int != 0;
            OwnerAppId = (*RegRecPtr).OwnerAppId;
            (*StatePtr).DumpRecord.Size = (*RegRecPtr).Size as CFE_ES_MemOffset_t;
            (*StatePtr).DumpRecord.TimeOfLastUpdate = (*RegRecPtr).TimeOfLastUpdate;
            (*StatePtr).DumpRecord.LoadInProgress = (*RegRecPtr).LoadInProgress;
            (*StatePtr).DumpRecord.ValidationFunc = ((*RegRecPtr).ValidationFuncPtr).is_some();
            (*StatePtr).DumpRecord.TableLoadedOnce = (*RegRecPtr).TableLoadedOnce;
            (*StatePtr).DumpRecord.LoadPending = (*RegRecPtr).LoadPending;
            (*StatePtr).DumpRecord.DumpOnly = (*RegRecPtr).DumpOnly;
            (*StatePtr).DumpRecord.DoubleBuffered = (*RegRecPtr).DoubleBuffered;
            (*StatePtr).DumpRecord.FileCreateTimeSecs =
                (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSecs;
            (*StatePtr).DumpRecord.FileCreateTimeSubSecs =
                (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].FileCreateTimeSubSecs;
            (*StatePtr).DumpRecord.Crc =
                (*RegRecPtr).Buffers[(*RegRecPtr).ActiveBufferIndex as usize].Crc;
            (*StatePtr).DumpRecord.CriticalTable = (*RegRecPtr).CriticalTable;
            if (*StatePtr).DumpRecord.LoadInProgress != -(1 as libc::c_int) {
                if (*StatePtr).DumpRecord.DoubleBuffered {
                    (*StatePtr).DumpRecord.LoadInProgress =
                        (*StatePtr).DumpRecord.LoadInProgress - 3 as libc::c_int;
                }
            }
            strncpy(
                ((*StatePtr).DumpRecord.Name).as_mut_ptr(),
                ((*RegRecPtr).Name).as_mut_ptr(),
                (::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*StatePtr).DumpRecord.Name[(::core::mem::size_of::<[libc::c_char; 40]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
            strncpy(
                ((*StatePtr).DumpRecord.LastFileLoaded).as_mut_ptr(),
                ((*RegRecPtr).LastFileLoaded).as_mut_ptr(),
                (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*StatePtr).DumpRecord.LastFileLoaded[(::core::mem::size_of::<[libc::c_char; 64]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
            (*StatePtr).DumpRecord.NumUsers = 0 as libc::c_int as uint32;
            HandleIterator = (*RegRecPtr).HeadOfAccessList;
            while HandleIterator as libc::c_int
                != 0xffff as libc::c_int as CFE_TBL_Handle_t as libc::c_int
            {
                (*StatePtr).DumpRecord.NumUsers = ((*StatePtr).DumpRecord.NumUsers).wrapping_add(1);
                (*StatePtr).DumpRecord.NumUsers;
                HandleIterator = CFE_TBL_Global.Handles[HandleIterator as usize].NextLink;
            }
        }
        CFE_TBL_UnlockRegistry();
    }
    if IsValidEntry {
        if !CFE_ResourceId_Equal(OwnerAppId, 0 as libc::c_int as CFE_ResourceId_t) {
            CFE_ES_GetAppName(
                ((*StatePtr).DumpRecord.OwnerAppName).as_mut_ptr(),
                OwnerAppId,
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
            );
        } else {
            strncpy(
                ((*StatePtr).DumpRecord.OwnerAppName).as_mut_ptr(),
                b"--UNOWNED--\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            (*StatePtr).DumpRecord.OwnerAppName[(::core::mem::size_of::<[libc::c_char; 20]>()
                as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] = 0 as libc::c_int as libc::c_char;
        }
        *Buffer = &mut (*StatePtr).DumpRecord as *mut CFE_TBL_RegDumpRec_t as *mut libc::c_void;
        *BufSize = ::core::mem::size_of::<CFE_TBL_RegDumpRec_t>() as libc::c_ulong;
    } else {
        *BufSize = 0 as libc::c_int as size_t;
        *Buffer = 0 as *mut libc::c_void;
    }
    return RecordNum >= (128 as libc::c_int - 1 as libc::c_int) as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_DumpRegistryEventHandler(
    mut Meta: *mut libc::c_void,
    mut Event: CFE_FS_FileWriteEvent_t,
    mut Status: int32,
    mut RecordNum: uint32,
    mut BlockSize: size_t,
    mut Position: size_t,
) {
    let mut StatePtr: *mut CFE_TBL_RegDumpStateInfo_t = Meta as *mut CFE_TBL_RegDumpStateInfo_t;
    match Event as libc::c_uint {
        1 => {
            if (*StatePtr).FileExisted {
                CFE_EVS_SendEventWithAppID(
                    15 as libc::c_int as uint16,
                    CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                    CFE_TBL_Global.TableTaskAppId,
                    b"Successfully overwrote '%s' with Table Registry:Size=%d,Entries=%d\0"
                        as *const u8 as *const libc::c_char,
                    ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
                    Position as libc::c_int,
                    RecordNum as libc::c_int,
                );
            } else {
                CFE_EVS_SendEventWithAppID(
                    22 as libc::c_int as uint16,
                    CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
                    CFE_TBL_Global.TableTaskAppId,
                    b"Successfully dumped Table Registry to '%s':Size=%d,Entries=%d\0" as *const u8
                        as *const libc::c_char,
                    ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
                    Position as libc::c_int,
                    RecordNum as libc::c_int,
                );
            }
        }
        4 => {
            CFE_EVS_SendEventWithAppID(
                68 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"Error writing Registry to '%s', Status=0x%08X\0" as *const u8
                    as *const libc::c_char,
                ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
                Status as libc::c_uint,
            );
        }
        3 => {
            CFE_EVS_SendEventWithAppID(
                63 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"Error writing cFE File Header to '%s', Status=0x%08X\0" as *const u8
                    as *const libc::c_char,
                ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
                Status as libc::c_uint,
            );
        }
        2 => {
            CFE_EVS_SendEventWithAppID(
                62 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                CFE_TBL_Global.TableTaskAppId,
                b"Error creating dump file '%s', Status=0x%08X\0" as *const u8
                    as *const libc::c_char,
                ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
                Status as libc::c_uint,
            );
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_DumpRegistryCmd(
    mut data: *const CFE_TBL_DumpRegistryCmd_t,
) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut Status: int32 = 0;
    let mut CmdPtr: *const CFE_TBL_DumpRegistryCmd_Payload_t = &(*data).Payload;
    let mut FileStat: os_fstat_t = os_fstat_t {
        FileModeBits: 0,
        FileTime: OS_time_t { ticks: 0 },
        FileSize: 0,
    };
    let mut StatePtr: *mut CFE_TBL_RegDumpStateInfo_t = 0 as *mut CFE_TBL_RegDumpStateInfo_t;
    StatePtr = &mut CFE_TBL_Global.RegDumpState;
    if !CFE_FS_BackgroundFileDumpIsPending(&mut (*StatePtr).FileWrite) {
        (*StatePtr).FileWrite.FileSubType = CFE_FS_SubType_TBL_REG as libc::c_int as uint32;
        snprintf(
            ((*StatePtr).FileWrite.Description).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            b"Table Registry\0" as *const u8 as *const libc::c_char,
        );
        (*StatePtr).FileWrite.GetData = Some(
            CFE_TBL_DumpRegistryGetter
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    uint32,
                    *mut *mut libc::c_void,
                    *mut size_t,
                ) -> bool,
        );
        (*StatePtr).FileWrite.OnEvent = Some(
            CFE_TBL_DumpRegistryEventHandler
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    CFE_FS_FileWriteEvent_t,
                    int32,
                    uint32,
                    size_t,
                    size_t,
                ) -> (),
        );
        Status = CFE_FS_ParseInputFileNameEx(
            ((*StatePtr).FileWrite.FileName).as_mut_ptr(),
            ((*CmdPtr).DumpFilename).as_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"/ram/cfe_tbl_reg.log\0" as *const u8 as *const libc::c_char,
            CFE_FS_GetDefaultMountPoint(CFE_FS_FileCategory_BINARY_DATA_DUMP),
            CFE_FS_GetDefaultExtension(CFE_FS_FileCategory_BINARY_DATA_DUMP),
        );
        if Status == 0 as libc::c_int {
            (*StatePtr).FileExisted =
                OS_stat(((*StatePtr).FileWrite.FileName).as_mut_ptr(), &mut FileStat)
                    == 0 as libc::c_int;
            Status = CFE_FS_BackgroundFileDumpRequest(&mut (*StatePtr).FileWrite);
            if Status == 0 as libc::c_int {
                ReturnCode = CFE_TBL_INC_CMD_CTR;
            }
        }
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_SendRegistryCmd(
    mut data: *const CFE_TBL_SendRegistryCmd_t,
) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut RegIndex: int16 = 0;
    let mut CmdPtr: *const CFE_TBL_SendRegistryCmd_Payload_t = &(*data).Payload;
    let mut TableName: [libc::c_char; 40] = [0; 40];
    CFE_SB_MessageStringGet(
        TableName.as_mut_ptr(),
        ((*CmdPtr).TableName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    RegIndex = CFE_TBL_FindTableInRegistry(TableName.as_mut_ptr());
    if RegIndex as libc::c_int != -(1 as libc::c_int) {
        CFE_TBL_Global.HkTlmTblRegIndex = RegIndex;
        CFE_EVS_SendEvent(
            18 as libc::c_int as uint16,
            CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
            b"Table Registry entry for '%s' will be telemetered\0" as *const u8
                as *const libc::c_char,
            TableName.as_mut_ptr(),
        );
        ReturnCode = CFE_TBL_INC_CMD_CTR;
    } else {
        CFE_EVS_SendEvent(
            57 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to locate '%s' in Table Registry\0" as *const u8 as *const libc::c_char,
            TableName.as_mut_ptr(),
        );
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_DeleteCDSCmd(mut data: *const CFE_TBL_DeleteCDSCmd_t) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut CmdPtr: *const CFE_TBL_DelCDSCmd_Payload_t = &(*data).Payload;
    let mut TableName: [libc::c_char; 40] = [0; 40];
    let mut CritRegRecPtr: *mut CFE_TBL_CritRegRec_t = 0 as *mut CFE_TBL_CritRegRec_t;
    let mut i: uint32 = 0;
    let mut RegIndex: int16 = 0;
    let mut Status: int32 = 0;
    CFE_SB_MessageStringGet(
        TableName.as_mut_ptr(),
        ((*CmdPtr).TableName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    RegIndex = CFE_TBL_FindTableInRegistry(TableName.as_mut_ptr());
    if RegIndex as libc::c_int == -(1 as libc::c_int) {
        i = 0 as libc::c_int as uint32;
        while i < 32 as libc::c_int as libc::c_uint {
            if strncmp(
                (CFE_TBL_Global.CritReg[i as usize].Name).as_mut_ptr(),
                TableName.as_mut_ptr(),
                (16 as libc::c_int + 20 as libc::c_int + 4 as libc::c_int) as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                CritRegRecPtr = &mut *(CFE_TBL_Global.CritReg).as_mut_ptr().offset(i as isize)
                    as *mut CFE_TBL_CritRegRec_t;
                break;
            } else {
                i = i.wrapping_add(1);
                i;
            }
        }
        if !CritRegRecPtr.is_null() {
            Status = CFE_ES_DeleteCDS(TableName.as_mut_ptr(), 1 as libc::c_int != 0);
            if Status == 0xc4000020 as libc::c_uint as CFE_Status_t {
                CFE_EVS_SendEvent(
                    83 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Table '%s' is in Critical Table Registry but CDS is not tagged as a table\0"
                        as *const u8 as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
            } else if Status == 0xc4000022 as libc::c_uint as CFE_Status_t {
                CFE_EVS_SendEvent(
                    87 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"CDS '%s' owning app is still active\0" as *const u8 as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
            } else if Status == 0xc4000002 as libc::c_uint as CFE_Status_t {
                CFE_EVS_SendEvent(
                    85 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Unable to locate '%s' in CDS Registry\0" as *const u8 as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
            } else if Status != 0 as libc::c_int {
                CFE_EVS_SendEvent(
                    86 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"Error while deleting '%s' from CDS, See SysLog.(Err=0x%08X)\0" as *const u8
                        as *const libc::c_char,
                    TableName.as_mut_ptr(),
                    Status as libc::c_uint,
                );
            } else {
                CFE_EVS_SendEvent(
                    38 as libc::c_int as uint16,
                    CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                    b"Successfully removed '%s' from CDS\0" as *const u8 as *const libc::c_char,
                    TableName.as_mut_ptr(),
                );
                (*CritRegRecPtr).CDSHandle = 0 as libc::c_int as CFE_ResourceId_t;
                ReturnCode = CFE_TBL_INC_CMD_CTR;
            }
        } else {
            CFE_EVS_SendEvent(
                84 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Table '%s' is not found in Critical Table Registry\0" as *const u8
                    as *const libc::c_char,
                TableName.as_mut_ptr(),
            );
        }
    } else {
        CFE_EVS_SendEvent(
            82 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"'%s' found in Table Registry. CDS cannot be deleted until table is unregistered\0"
                as *const u8 as *const libc::c_char,
            TableName.as_mut_ptr(),
        );
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_AbortLoadCmd(mut data: *const CFE_TBL_AbortLoadCmd_t) -> int32 {
    let mut ReturnCode: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    let mut RegIndex: int16 = 0;
    let mut CmdPtr: *const CFE_TBL_AbortLoadCmd_Payload_t = &(*data).Payload;
    let mut RegRecPtr: *mut CFE_TBL_RegistryRec_t = 0 as *mut CFE_TBL_RegistryRec_t;
    let mut TableName: [libc::c_char; 40] = [0; 40];
    CFE_SB_MessageStringGet(
        TableName.as_mut_ptr(),
        ((*CmdPtr).TableName).as_ptr() as *mut libc::c_char,
        0 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
    );
    RegIndex = CFE_TBL_FindTableInRegistry(TableName.as_mut_ptr());
    if RegIndex as libc::c_int != -(1 as libc::c_int) {
        RegRecPtr = &mut *(CFE_TBL_Global.Registry)
            .as_mut_ptr()
            .offset(RegIndex as isize) as *mut CFE_TBL_RegistryRec_t;
        if (*RegRecPtr).LoadInProgress != -(1 as libc::c_int) && !(*RegRecPtr).DumpOnly {
            CFE_TBL_AbortLoad(RegRecPtr);
            ReturnCode = CFE_TBL_INC_CMD_CTR;
        } else {
            CFE_EVS_SendEvent(
                69 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Cannot abort load of '%s'. No load started.\0" as *const u8
                    as *const libc::c_char,
                TableName.as_mut_ptr(),
            );
        }
    } else {
        CFE_EVS_SendEvent(
            57 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Unable to locate '%s' in Table Registry\0" as *const u8 as *const libc::c_char,
            TableName.as_mut_ptr(),
        );
    }
    return ReturnCode as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_AbortLoad(mut RegRecPtr: *mut CFE_TBL_RegistryRec_t) {
    if !(*RegRecPtr).DoubleBuffered {
        CFE_TBL_Global.LoadBuffs[(*RegRecPtr).LoadInProgress as usize].Taken =
            0 as libc::c_int != 0;
    }
    (*RegRecPtr).LoadInProgress = -(1 as libc::c_int);
    (*RegRecPtr).LoadPending = 0 as libc::c_int != 0;
    CFE_EVS_SendEvent(
        21 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Table Load Aborted for '%s'\0" as *const u8 as *const libc::c_char,
        ((*RegRecPtr).Name).as_mut_ptr(),
    );
}
#[no_mangle]
pub static mut CFE_TBL_CmdHandlerTbl: [CFE_TBL_CmdHandlerTblRec_t; 12] = unsafe {
    [
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 12 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_SendHkCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_MSG_CommandHeader_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_HousekeepingCmd
                        as unsafe extern "C" fn(*const CFE_MSG_CommandHeader_t) -> int32,
                )),
                MsgTypes: CFE_TBL_MSG_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_NoopCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_NoopCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_NoopCmd as unsafe extern "C" fn(*const CFE_TBL_NoopCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 1 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_ResetCountersCmd_t>()
                    as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_ResetCountersCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_ResetCountersCmd
                        as unsafe extern "C" fn(*const CFE_TBL_ResetCountersCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 2 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_LoadCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_LoadCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_LoadCmd as unsafe extern "C" fn(*const CFE_TBL_LoadCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 3 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_DumpCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_DumpCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_DumpCmd as unsafe extern "C" fn(*const CFE_TBL_DumpCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 4 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_ValidateCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_ValidateCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_ValidateCmd
                        as unsafe extern "C" fn(*const CFE_TBL_ValidateCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 5 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_ActivateCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_ActivateCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_ActivateCmd
                        as unsafe extern "C" fn(*const CFE_TBL_ActivateCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 6 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_DumpRegistryCmd_t>()
                    as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_DumpRegistryCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_DumpRegistryCmd
                        as unsafe extern "C" fn(*const CFE_TBL_DumpRegistryCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 7 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_SendRegistryCmd_t>()
                    as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_SendRegistryCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_SendRegistryCmd
                        as unsafe extern "C" fn(*const CFE_TBL_SendRegistryCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 8 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_DeleteCDSCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_DeleteCDSCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_DeleteCDSCmd
                        as unsafe extern "C" fn(*const CFE_TBL_DeleteCDSCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: (0x1800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 9 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: ::core::mem::size_of::<CFE_TBL_AbortLoadCmd_t>() as libc::c_ulong,
                MsgProcFuncPtr: ::core::mem::transmute::<
                    Option<unsafe extern "C" fn(*const CFE_TBL_AbortLoadCmd_t) -> int32>,
                    CFE_TBL_MsgProcFuncPtr_t,
                >(Some(
                    CFE_TBL_AbortLoadCmd
                        as unsafe extern "C" fn(*const CFE_TBL_AbortLoadCmd_t) -> int32,
                )),
                MsgTypes: CFE_TBL_CMD_MSGTYPE,
            };
            init
        },
        {
            let mut init = CFE_TBL_CmdHandlerTblRec_t {
                MsgId: {
                    let mut init = CFE_SB_MsgId_t {
                        Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
                    };
                    init
                },
                CmdCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                ExpectedLength: 0 as libc::c_int as size_t,
                MsgProcFuncPtr: None,
                MsgTypes: CFE_TBL_TERM_MSGTYPE,
            };
            init
        },
    ]
};
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_TaskPipe(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MessageID: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    let mut CommandCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    let mut CmdIndx: int16 = 0;
    let mut ActualLength: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut CmdStatus: CFE_TBL_CmdProcRet_t = CFE_TBL_INC_ERR_CTR;
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MessageID);
    CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut CommandCode);
    CmdIndx = CFE_TBL_SearchCmdHndlrTbl(MessageID, CommandCode);
    if CmdIndx as libc::c_int >= 0 as libc::c_int {
        CFE_MSG_GetSize(&(*SBBufPtr).Msg, &mut ActualLength);
        if ActualLength == CFE_TBL_CmdHandlerTbl[CmdIndx as usize].ExpectedLength {
            CmdStatus = (CFE_TBL_CmdHandlerTbl[CmdIndx as usize].MsgProcFuncPtr)
                .expect("non-null function pointer")(
                SBBufPtr as *const libc::c_void
            ) as CFE_TBL_CmdProcRet_t;
        } else {
            CFE_EVS_SendEvent(
                52 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Invalid msg length -- ID = 0x%X, CC = %u, Len = %u, Expected = %u\0" as *const u8
                    as *const libc::c_char,
                CFE_SB_MsgIdToValue(MessageID),
                CommandCode as libc::c_uint,
                ActualLength as libc::c_uint,
                CFE_TBL_CmdHandlerTbl[CmdIndx as usize].ExpectedLength as libc::c_uint,
            );
        }
        if CFE_TBL_CmdHandlerTbl[CmdIndx as usize].MsgTypes as libc::c_uint
            == CFE_TBL_CMD_MSGTYPE as libc::c_int as libc::c_uint
        {
            if CmdStatus as libc::c_int == CFE_TBL_INC_CMD_CTR as libc::c_int {
                CFE_TBL_Global.CommandCounter = (CFE_TBL_Global.CommandCounter).wrapping_add(1);
                CFE_TBL_Global.CommandCounter;
            } else if CmdStatus as libc::c_int == CFE_TBL_INC_ERR_CTR as libc::c_int {
                CFE_TBL_Global.CommandErrorCounter =
                    (CFE_TBL_Global.CommandErrorCounter).wrapping_add(1);
                CFE_TBL_Global.CommandErrorCounter;
            }
        }
    } else if CmdIndx as libc::c_int == -(1 as libc::c_int) {
        CFE_EVS_SendEvent(
            51 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid command code -- ID = 0x%X, CC = %u\0" as *const u8 as *const libc::c_char,
            CFE_SB_MsgIdToValue(MessageID),
            CommandCode as libc::c_uint,
        );
        CFE_TBL_Global.CommandErrorCounter = (CFE_TBL_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TBL_Global.CommandErrorCounter;
    } else {
        CFE_EVS_SendEvent(
            50 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid message ID -- ID = 0x%X\0" as *const u8 as *const libc::c_char,
            CFE_SB_MsgIdToValue(MessageID),
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TBL_SearchCmdHndlrTbl(
    mut MessageID: CFE_SB_MsgId_t,
    mut CommandCode: uint16,
) -> int16 {
    let mut TblIndx: int16 = -(1 as libc::c_int) as int16;
    let mut FoundMsg: bool = 0 as libc::c_int != 0;
    let mut FoundMatch: bool = 0 as libc::c_int != 0;
    loop {
        TblIndx += 1;
        TblIndx;
        if CFE_SB_MsgId_Equal(CFE_TBL_CmdHandlerTbl[TblIndx as usize].MsgId, MessageID)
            as libc::c_int
            != 0
            && CFE_TBL_CmdHandlerTbl[TblIndx as usize].MsgTypes as libc::c_uint
                != CFE_TBL_TERM_MSGTYPE as libc::c_int as libc::c_uint
        {
            FoundMsg = 1 as libc::c_int != 0;
            if CFE_TBL_CmdHandlerTbl[TblIndx as usize].MsgTypes as libc::c_uint
                == CFE_TBL_CMD_MSGTYPE as libc::c_int as libc::c_uint
            {
                if CFE_TBL_CmdHandlerTbl[TblIndx as usize].CmdCode as libc::c_int
                    == CommandCode as libc::c_int
                {
                    FoundMatch = 1 as libc::c_int != 0;
                }
            } else {
                FoundMatch = 1 as libc::c_int != 0;
            }
        }
        if !(!FoundMatch
            && CFE_TBL_CmdHandlerTbl[TblIndx as usize].MsgTypes as libc::c_uint
                != CFE_TBL_TERM_MSGTYPE as libc::c_int as libc::c_uint)
        {
            break;
        }
    }
    if !FoundMatch {
        if FoundMsg {
            TblIndx = -(1 as libc::c_int) as int16;
        } else {
            TblIndx = -(2 as libc::c_int) as int16;
        }
    }
    return TblIndx;
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_eventids_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_fcncodes_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_interface_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_internal_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_mission_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_msgdefs_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_msg_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_msgids_h_c__CheckHeader() {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_msgstruct_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_platform_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_tbl_src_check_cfe_tbl_topicids_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetTAI() -> CFE_TIME_SysTime_t {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut tai: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    tai = CFE_TIME_CalculateTAI(&mut Reference);
    return tai;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Add(
    mut Time1: CFE_TIME_SysTime_t,
    mut Time2: CFE_TIME_SysTime_t,
) -> CFE_TIME_SysTime_t {
    let mut Result: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    Result.Subseconds = (Time1.Subseconds).wrapping_add(Time2.Subseconds);
    if Result.Subseconds < Time1.Subseconds {
        Result.Seconds = (Time1.Seconds)
            .wrapping_add(Time2.Seconds)
            .wrapping_add(1 as libc::c_int as libc::c_uint);
    } else {
        Result.Seconds = (Time1.Seconds).wrapping_add(Time2.Seconds);
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Subtract(
    mut Time1: CFE_TIME_SysTime_t,
    mut Time2: CFE_TIME_SysTime_t,
) -> CFE_TIME_SysTime_t {
    let mut Result: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    Result.Subseconds = (Time1.Subseconds).wrapping_sub(Time2.Subseconds);
    if Result.Subseconds > Time1.Subseconds {
        Result.Seconds = (Time1.Seconds)
            .wrapping_sub(Time2.Seconds)
            .wrapping_sub(1 as libc::c_int as libc::c_uint);
    } else {
        Result.Seconds = (Time1.Seconds).wrapping_sub(Time2.Seconds);
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Micro2SubSecs(mut MicroSeconds: uint32) -> uint32 {
    let mut tm: OS_time_t = OS_time_t { ticks: 0 };
    let mut SubSeconds: uint32 = 0;
    if MicroSeconds > 999999 as libc::c_int as libc::c_uint {
        SubSeconds = 0xffffffff as libc::c_uint;
    } else {
        tm = OS_TimeAssembleFromNanoseconds(
            0 as libc::c_int as int64,
            MicroSeconds.wrapping_mul(1000 as libc::c_int as libc::c_uint),
        );
        SubSeconds = OS_TimeGetSubsecondsPart(tm);
    }
    return SubSeconds;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Compare(
    mut TimeA: CFE_TIME_SysTime_t,
    mut TimeB: CFE_TIME_SysTime_t,
) -> CFE_TIME_Compare_t {
    let mut Result: CFE_TIME_Compare_t = CFE_TIME_EQUAL;
    if TimeA.Seconds > TimeB.Seconds {
        if (TimeA.Seconds).wrapping_sub(TimeB.Seconds) > 0x80000000 as libc::c_uint {
            Result = CFE_TIME_A_LT_B;
        } else {
            Result = CFE_TIME_A_GT_B;
        }
    } else if TimeA.Seconds < TimeB.Seconds {
        if (TimeB.Seconds).wrapping_sub(TimeA.Seconds) > 0x80000000 as libc::c_uint {
            Result = CFE_TIME_A_GT_B;
        } else {
            Result = CFE_TIME_A_LT_B;
        }
    } else if TimeA.Subseconds > TimeB.Subseconds {
        Result = CFE_TIME_A_GT_B;
    } else if TimeA.Subseconds < TimeB.Subseconds {
        Result = CFE_TIME_A_LT_B;
    } else {
        Result = CFE_TIME_EQUAL;
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_UnregisterSynchCallback(
    mut CallbackFuncPtr: CFE_TIME_SynchCallbackPtr_t,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut AppIndex: uint32 = 0;
    if CallbackFuncPtr.is_none() {
        return 0xce000005 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_GetAppID(&mut AppId);
    if Status == 0 as libc::c_int {
        Status = CFE_ES_AppID_ToIndex(AppId, &mut AppIndex);
        if Status == 0 as libc::c_int {
            if AppIndex as libc::c_ulong
                >= (::core::mem::size_of::<[CFE_TIME_SynchCallbackRegEntry_t; 32]>()
                    as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<CFE_TIME_SynchCallbackRegEntry_t>() as libc::c_ulong
                    )
                || CFE_TIME_Global.SynchCallback[AppIndex as usize].Ptr != CallbackFuncPtr
            {
                Status = 0xce000004 as libc::c_uint as CFE_Status_t;
            } else {
                ::core::ptr::write_volatile(
                    &mut CFE_TIME_Global.SynchCallback[AppIndex as usize].Ptr
                        as *mut CFE_TIME_SynchCallbackPtr_t,
                    None,
                );
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Sub2MicroSecs(mut SubSeconds: uint32) -> uint32 {
    let mut tm: OS_time_t = OS_time_t { ticks: 0 };
    tm = OS_TimeAssembleFromSubseconds(0 as libc::c_int as int64, SubSeconds);
    return OS_TimeGetMicrosecondsPart(tm);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_RegisterSynchCallback(
    mut CallbackFuncPtr: CFE_TIME_SynchCallbackPtr_t,
) -> CFE_Status_t {
    let mut Status: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    let mut AppIndex: uint32 = 0;
    if CallbackFuncPtr.is_none() {
        return 0xce000005 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_GetAppID(&mut AppId);
    if Status == 0 as libc::c_int {
        Status = CFE_ES_AppID_ToIndex(AppId, &mut AppIndex);
        if Status == 0 as libc::c_int {
            if AppIndex as libc::c_ulong
                >= (::core::mem::size_of::<[CFE_TIME_SynchCallbackRegEntry_t; 32]>()
                    as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<CFE_TIME_SynchCallbackRegEntry_t>() as libc::c_ulong
                    )
                || (CFE_TIME_Global.SynchCallback[AppIndex as usize].Ptr).is_some()
            {
                Status = 0xce000003 as libc::c_uint as CFE_Status_t;
            } else {
                ::core::ptr::write_volatile(
                    &mut CFE_TIME_Global.SynchCallback[AppIndex as usize].Ptr
                        as *mut CFE_TIME_SynchCallbackPtr_t,
                    CallbackFuncPtr,
                );
            }
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ExternalTone() {
    CFE_TIME_Tone1HzISR();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_MET2SCTime(
    mut METTime: CFE_TIME_SysTime_t,
) -> CFE_TIME_SysTime_t {
    let mut STCF: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut TIATime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut ReturnTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    STCF = CFE_TIME_GetSTCF();
    TIATime = CFE_TIME_Add(METTime, STCF);
    ReturnTime = TIATime;
    return ReturnTime;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetClockState() -> CFE_TIME_ClockState_Enum_t {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut state: CFE_TIME_ClockState_Enum_t = 0;
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    state = CFE_TIME_CalculateState(&mut Reference);
    return state;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetLeapSeconds() -> int16 {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    return Reference.AtToneLeapSeconds;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetSTCF() -> CFE_TIME_SysTime_t {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    return Reference.AtToneSTCF;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetMETsubsecs() -> uint32 {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    return Reference.CurrentMET.Subseconds;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetMETseconds() -> uint32 {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    return Reference.CurrentMET.Seconds;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetMET() -> CFE_TIME_SysTime_t {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    return Reference.CurrentMET;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetUTC() -> CFE_TIME_SysTime_t {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut utc: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    utc = CFE_TIME_CalculateUTC(&mut Reference);
    return utc;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Print(
    mut PrintBuffer: *mut libc::c_char,
    mut TimeToPrint: CFE_TIME_SysTime_t,
) {
    let mut NumberOfYears: uint32 = 0;
    let mut NumberOfDays: uint32 = 0;
    let mut NumberOfHours: uint32 = 0;
    let mut NumberOfMinutes: uint32 = 0;
    let mut NumberOfSeconds: uint32 = 0;
    let mut NumberOfMicros: uint32 = 0;
    let mut DaysInThisYear: uint32 = 0;
    let mut StillCountingYears: bool = 1 as libc::c_int != 0;
    if PrintBuffer.is_null() {
        CFE_ES_WriteToSysLog(
            b"%s: Failed invalid arguments\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 15], &[libc::c_char; 15]>(b"CFE_TIME_Print\0"))
                .as_ptr(),
        );
        return;
    }
    NumberOfMicros = (CFE_TIME_Sub2MicroSecs(TimeToPrint.Subseconds))
        .wrapping_add(0 as libc::c_int as libc::c_uint);
    NumberOfMinutes = NumberOfMicros
        .wrapping_div(60000000 as libc::c_int as libc::c_uint)
        .wrapping_add((TimeToPrint.Seconds).wrapping_div(60 as libc::c_int as libc::c_uint))
        .wrapping_add(0 as libc::c_int as libc::c_uint);
    NumberOfMicros = NumberOfMicros.wrapping_rem(60000000 as libc::c_int as libc::c_uint);
    NumberOfSeconds = NumberOfMicros
        .wrapping_div(1000000 as libc::c_int as libc::c_uint)
        .wrapping_add((TimeToPrint.Seconds).wrapping_rem(60 as libc::c_int as libc::c_uint))
        .wrapping_add(0 as libc::c_int as libc::c_uint);
    NumberOfMicros = NumberOfMicros.wrapping_rem(1000000 as libc::c_int as libc::c_uint);
    while NumberOfSeconds >= 60 as libc::c_int as libc::c_uint {
        NumberOfMinutes = NumberOfMinutes.wrapping_add(1);
        NumberOfMinutes;
        NumberOfSeconds = (NumberOfSeconds as libc::c_uint)
            .wrapping_sub(60 as libc::c_int as libc::c_uint) as uint32
            as uint32;
    }
    NumberOfHours = NumberOfMinutes
        .wrapping_div(60 as libc::c_int as libc::c_uint)
        .wrapping_add(0 as libc::c_int as libc::c_uint);
    NumberOfMinutes = NumberOfMinutes.wrapping_rem(60 as libc::c_int as libc::c_uint);
    NumberOfDays = NumberOfHours
        .wrapping_div(24 as libc::c_int as libc::c_uint)
        .wrapping_add((1 as libc::c_int - 1 as libc::c_int) as libc::c_uint);
    NumberOfHours = NumberOfHours.wrapping_rem(24 as libc::c_int as libc::c_uint);
    NumberOfYears = 1980 as libc::c_int as uint32;
    while StillCountingYears {
        DaysInThisYear = 365 as libc::c_int as uint32;
        if NumberOfYears.wrapping_rem(4 as libc::c_int as libc::c_uint)
            == 0 as libc::c_int as libc::c_uint
        {
            if NumberOfYears.wrapping_rem(100 as libc::c_int as libc::c_uint)
                != 0 as libc::c_int as libc::c_uint
            {
                DaysInThisYear = 366 as libc::c_int as uint32;
            } else if NumberOfYears.wrapping_rem(400 as libc::c_int as libc::c_uint)
                == 0 as libc::c_int as libc::c_uint
            {
                DaysInThisYear = 366 as libc::c_int as uint32;
            }
        }
        if NumberOfDays < DaysInThisYear {
            StillCountingYears = 0 as libc::c_int != 0;
        } else {
            NumberOfYears = NumberOfYears.wrapping_add(1);
            NumberOfYears;
            NumberOfDays =
                (NumberOfDays as libc::c_uint).wrapping_sub(DaysInThisYear) as uint32 as uint32;
        }
    }
    NumberOfDays = NumberOfDays.wrapping_add(1);
    NumberOfDays;
    NumberOfMicros = NumberOfMicros.wrapping_div(10 as libc::c_int as libc::c_uint);
    let fresh19 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh19 = ('0' as i32
        + NumberOfYears.wrapping_div(1000 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    NumberOfYears = NumberOfYears.wrapping_rem(1000 as libc::c_int as libc::c_uint);
    let fresh20 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh20 = ('0' as i32
        + NumberOfYears.wrapping_div(100 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    NumberOfYears = NumberOfYears.wrapping_rem(100 as libc::c_int as libc::c_uint);
    let fresh21 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh21 = ('0' as i32
        + NumberOfYears.wrapping_div(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh22 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh22 = ('0' as i32
        + NumberOfYears.wrapping_rem(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh23 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh23 = '-' as i32 as libc::c_char;
    let fresh24 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh24 = ('0' as i32
        + NumberOfDays.wrapping_div(100 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    NumberOfDays = NumberOfDays.wrapping_rem(100 as libc::c_int as libc::c_uint);
    let fresh25 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh25 = ('0' as i32
        + NumberOfDays.wrapping_div(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh26 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh26 = ('0' as i32
        + NumberOfDays.wrapping_rem(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh27 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh27 = '-' as i32 as libc::c_char;
    let fresh28 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh28 = ('0' as i32
        + NumberOfHours.wrapping_div(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh29 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh29 = ('0' as i32
        + NumberOfHours.wrapping_rem(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh30 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh30 = ':' as i32 as libc::c_char;
    let fresh31 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh31 = ('0' as i32
        + NumberOfMinutes.wrapping_div(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh32 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh32 = ('0' as i32
        + NumberOfMinutes.wrapping_rem(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh33 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh33 = ':' as i32 as libc::c_char;
    let fresh34 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh34 = ('0' as i32
        + NumberOfSeconds.wrapping_div(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh35 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh35 = ('0' as i32
        + NumberOfSeconds.wrapping_rem(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh36 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh36 = '.' as i32 as libc::c_char;
    let fresh37 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh37 = ('0' as i32
        + NumberOfMicros.wrapping_div(10000 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    NumberOfMicros = NumberOfMicros.wrapping_rem(10000 as libc::c_int as libc::c_uint);
    let fresh38 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh38 = ('0' as i32
        + NumberOfMicros.wrapping_div(1000 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    NumberOfMicros = NumberOfMicros.wrapping_rem(1000 as libc::c_int as libc::c_uint);
    let fresh39 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh39 = ('0' as i32
        + NumberOfMicros.wrapping_div(100 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    NumberOfMicros = NumberOfMicros.wrapping_rem(100 as libc::c_int as libc::c_uint);
    let fresh40 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh40 = ('0' as i32
        + NumberOfMicros.wrapping_div(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh41 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh41 = ('0' as i32
        + NumberOfMicros.wrapping_rem(10 as libc::c_int as libc::c_uint) as libc::c_char
            as libc::c_int) as libc::c_char;
    let fresh42 = PrintBuffer;
    PrintBuffer = PrintBuffer.offset(1);
    *fresh42 = '\0' as i32 as libc::c_char;
}
#[inline]
unsafe extern "C" fn CFE_TIME_GetReferenceState() -> *mut CFE_TIME_ReferenceState_t {
    return &mut *(CFE_TIME_Global.ReferenceState).as_mut_ptr().offset(
        (CFE_TIME_Global.LastVersionCounter & (4 as libc::c_int - 1 as libc::c_int) as libc::c_uint)
            as isize,
    ) as *mut CFE_TIME_ReferenceState_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetClockInfo() -> uint16 {
    let mut StateFlags: uint16 = 0 as libc::c_int as uint16;
    let mut RefState: *mut CFE_TIME_ReferenceState_t = CFE_TIME_GetReferenceState();
    if (*RefState).ClockSetState as libc::c_int == CFE_TIME_SetState_WAS_SET as libc::c_int {
        StateFlags = (StateFlags as libc::c_int | 0x8000 as libc::c_int) as uint16;
    }
    if (*RefState).ClockFlyState as libc::c_int == CFE_TIME_FlywheelState_IS_FLY as libc::c_int {
        StateFlags = (StateFlags as libc::c_int | 0x4000 as libc::c_int) as uint16;
    }
    if CFE_TIME_Global.ClockSource as libc::c_int == CFE_TIME_SourceSelect_INTERNAL as libc::c_int {
        StateFlags = (StateFlags as libc::c_int | 0x2000 as libc::c_int) as uint16;
    }
    if CFE_TIME_Global.ClockSignal as libc::c_int
        == CFE_TIME_ToneSignalSelect_PRIMARY as libc::c_int
    {
        StateFlags = (StateFlags as libc::c_int | 0x1000 as libc::c_int) as uint16;
    }
    if CFE_TIME_Global.ServerFlyState as libc::c_int == CFE_TIME_FlywheelState_IS_FLY as libc::c_int
    {
        StateFlags = (StateFlags as libc::c_int | 0x800 as libc::c_int) as uint16;
    }
    if CFE_TIME_Global.Forced2Fly {
        StateFlags = (StateFlags as libc::c_int | 0x400 as libc::c_int) as uint16;
    }
    if CFE_TIME_Global.OneTimeDirection as libc::c_int
        == CFE_TIME_AdjustDirection_ADD as libc::c_int
    {
        StateFlags = (StateFlags as libc::c_int | 0x200 as libc::c_int) as uint16;
    }
    if CFE_TIME_Global.OneHzDirection as libc::c_int == CFE_TIME_AdjustDirection_ADD as libc::c_int
    {
        StateFlags = (StateFlags as libc::c_int | 0x100 as libc::c_int) as uint16;
    }
    if (*RefState).DelayDirection as libc::c_int == CFE_TIME_AdjustDirection_ADD as libc::c_int {
        StateFlags = (StateFlags as libc::c_int | 0x80 as libc::c_int) as uint16;
    }
    StateFlags = (StateFlags as libc::c_int | 0x40 as libc::c_int) as uint16;
    if CFE_TIME_Global.IsToneGood as libc::c_int == 1 as libc::c_int {
        StateFlags = (StateFlags as libc::c_int | 0x20 as libc::c_int) as uint16;
    }
    if CFE_TIME_Global.GetReferenceFail {
        StateFlags = (StateFlags as libc::c_int | 0x10 as libc::c_int) as uint16;
    }
    return StateFlags;
}
#[inline]
unsafe extern "C" fn CFE_TIME_FinishReferenceUpdate(mut NextState: *mut CFE_TIME_ReferenceState_t) {
    ::core::ptr::write_volatile(
        &mut CFE_TIME_Global.LastVersionCounter as *mut uint32,
        (*NextState).StateVersion,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetTime() -> CFE_TIME_SysTime_t {
    let mut CurrentTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    CurrentTime = CFE_TIME_GetTAI();
    return CurrentTime;
}
#[no_mangle]
pub static mut CFE_TIME_Global: CFE_TIME_Global_t = CFE_TIME_Global_t {
    CommandCounter: 0,
    CommandErrorCounter: 0,
    HkPacket: CFE_TIME_HousekeepingTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_TIME_HousekeepingTlm_Payload_t {
            CommandCounter: 0,
            CommandErrorCounter: 0,
            ClockStateFlags: 0,
            ClockStateAPI: 0,
            LeapSeconds: 0,
            SecondsMET: 0,
            SubsecsMET: 0,
            SecondsSTCF: 0,
            SubsecsSTCF: 0,
            Seconds1HzAdj: 0,
            Subsecs1HzAdj: 0,
        },
    },
    DiagPacket: CFE_TIME_DiagnosticTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CFE_TIME_DiagnosticTlm_Payload_t {
            AtToneMET: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            AtToneSTCF: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            AtToneDelay: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            AtToneLatch: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            AtToneLeapSeconds: 0,
            ClockStateAPI: 0,
            TimeSinceTone: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            CurrentLatch: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            CurrentMET: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            CurrentTAI: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            CurrentUTC: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            ClockSetState: 0,
            ClockFlyState: 0,
            ClockSource: 0,
            ClockSignal: 0,
            ServerFlyState: 0,
            Forced2Fly: 0,
            ClockStateFlags: 0,
            OneTimeDirection: 0,
            OneHzDirection: 0,
            DelayDirection: 0,
            OneTimeAdjust: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            OneHzAdjust: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            ToneSignalLatch: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            ToneDataLatch: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            ToneMatchCounter: 0,
            ToneMatchErrorCounter: 0,
            ToneSignalCounter: 0,
            ToneDataCounter: 0,
            ToneIntCounter: 0,
            ToneIntErrorCounter: 0,
            ToneTaskCounter: 0,
            VersionCounter: 0,
            LocalIntCounter: 0,
            LocalTaskCounter: 0,
            VirtualMET: 0,
            MinElapsed: 0,
            MaxElapsed: 0,
            MaxLocalClock: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            ToneOverLimit: 0,
            ToneUnderLimit: 0,
            DataStoreStatus: 0,
        },
    },
    CmdPipe: 0,
    ClockSource: 0,
    ClockSignal: 0,
    ServerFlyState: 0,
    PendingMET: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    PendingSTCF: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    PendingLeaps: 0,
    PendingState: 0,
    OneTimeAdjust: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    OneHzAdjust: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    OneTimeDirection: 0,
    OneHzDirection: 0,
    ToneSignalLatch: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    ToneDataLatch: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    ToneMatchCounter: 0,
    ToneMatchErrorCounter: 0,
    ToneSignalCounter: 0,
    ToneDataCounter: 0,
    ToneIntCounter: 0,
    ToneIntErrorCounter: 0,
    ToneTaskCounter: 0,
    VirtualMET: 0,
    LocalIntCounter: 0,
    LocalTaskCounter: 0,
    InternalCount: 0,
    ExternalCount: 0,
    ReferenceState: [CFE_TIME_ReferenceState_t {
        StateVersion: 0,
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    }; 4],
    LastVersionCounter: 0,
    ResetVersionCounter: 0,
    MinElapsed: 0,
    MaxElapsed: 0,
    MaxLocalClock: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    Forced2Fly: false,
    AutoStartFly: false,
    IsToneGood: false,
    GetReferenceFail: false,
    LocalOneHzCmd: CFE_TIME_OneHzCmd_t {
        CommandHeader: CFE_MSG_CommandHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_CommandSecondaryHeader_t {
                FunctionCode: 0,
                Checksum: 0,
            },
        },
    },
    ToneDataCmd: CFE_TIME_ToneDataCmd_t {
        CommandHeader: CFE_MSG_CommandHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_CommandSecondaryHeader_t {
                FunctionCode: 0,
                Checksum: 0,
            },
        },
        Payload: CFE_TIME_ToneDataCmd_Payload_t {
            AtToneMET: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            AtToneSTCF: CFE_TIME_SysTime_t {
                Seconds: 0,
                Subseconds: 0,
            },
            AtToneLeapSeconds: 0,
            AtToneState: 0,
        },
    },
    ToneSignalCmd: CFE_TIME_ToneSignalCmd_t {
        CommandHeader: CFE_MSG_CommandHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_CommandSecondaryHeader_t {
                FunctionCode: 0,
                Checksum: 0,
            },
        },
    },
    ToneSendCmd: CFE_TIME_FakeToneCmd_t {
        CommandHeader: CFE_MSG_CommandHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_CommandSecondaryHeader_t {
                FunctionCode: 0,
                Checksum: 0,
            },
        },
    },
    LocalSemaphore: 0,
    ToneSemaphore: 0,
    LocalTaskID: 0,
    ToneTaskID: 0,
    MaxDelta: CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    },
    ToneOverLimit: 0,
    ToneUnderLimit: 0,
    DataStoreStatus: 0,
    SynchCallback: [CFE_TIME_SynchCallbackRegEntry_t { Ptr: None }; 32],
};
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_EarlyInit() -> int32 {
    CFE_TIME_InitData();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_TaskMain() {
    let mut Status: int32 = 0;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(6 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    Status = CFE_TIME_TaskInit();
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Application Init Failed,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskMain\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        CFE_ES_PerfLogAdd(6 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_INIT_ERROR as libc::c_int as uint32);
    }
    CFE_ES_WaitForSystemState(
        CFE_ES_SystemState_CORE_READY as libc::c_int as uint32,
        30000 as libc::c_int as uint32,
    );
    while Status == 0 as libc::c_int {
        CFE_ES_IncrementTaskCounter();
        CFE_ES_PerfLogAdd(6 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        Status = CFE_SB_ReceiveBuffer(&mut SBBufPtr, CFE_TIME_Global.CmdPipe, -(1 as libc::c_int));
        CFE_ES_PerfLogAdd(6 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if Status == 0 as libc::c_int {
            CFE_TIME_TaskPipe(SBBufPtr);
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: Error reading cmd pipe,RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskMain\0"))
                    .as_ptr(),
                Status as libc::c_uint,
            );
        }
    }
    CFE_ES_ExitApp(CFE_ES_RunStatus_CORE_APP_RUNTIME_ERROR as libc::c_int as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_TaskInit() -> int32 {
    let mut Status: int32 = 0;
    let mut OsStatus: int32 = 0;
    let mut TimeBaseId: osal_id_t = 0;
    let mut TimerId: osal_id_t = 0;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    Status = CFE_EVS_Register(
        0 as *const libc::c_void,
        0 as libc::c_int as uint16,
        0 as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Call to CFE_EVS_Register Failed:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    OsStatus = OS_BinSemCreate(
        &mut CFE_TIME_Global.ToneSemaphore,
        b"TIME_TONE_SEM\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error creating tone semaphore:RC=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_BinSemCreate(
        &mut CFE_TIME_Global.LocalSemaphore,
        b"TIME_ONEHZ_SEM\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error creating local semaphore:RC=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_ES_CreateChildTask(
        &mut CFE_TIME_Global.ToneTaskID,
        b"TIME_TONE_TASK\0" as *const u8 as *const libc::c_char,
        Some(CFE_TIME_Tone1HzTask as unsafe extern "C" fn() -> ()),
        0 as *mut libc::c_void,
        4096 as libc::c_int as size_t,
        25 as libc::c_int as CFE_ES_TaskPriority_Atom_t,
        0 as libc::c_int as uint32,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error creating tone 1Hz child task:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_ES_CreateChildTask(
        &mut CFE_TIME_Global.LocalTaskID,
        b"TIME_ONEHZ_TASK\0" as *const u8 as *const libc::c_char,
        Some(CFE_TIME_Local1HzTask as unsafe extern "C" fn() -> ()),
        0 as *mut libc::c_void,
        8192 as libc::c_int as size_t,
        25 as libc::c_int as CFE_ES_TaskPriority_Atom_t,
        0 as libc::c_int as uint32,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error creating local 1Hz child task:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_CreatePipe(
        &mut CFE_TIME_Global.CmdPipe,
        12 as libc::c_int as uint16,
        b"TIME_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error creating cmd pipe:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 13 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TIME_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to HK Request:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_SubscribeLocal(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 16 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TIME_Global.CmdPipe,
        4 as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to tone cmd:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_SubscribeLocal(
        CFE_SB_ValueToMsgId((0x1860 as libc::c_int | 0 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TIME_Global.CmdPipe,
        4 as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to time data cmd:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_SubscribeLocal(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 17 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TIME_Global.CmdPipe,
        4 as libc::c_int as uint16,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to fake tone signal cmds:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1860 as libc::c_int | 2 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TIME_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to time at the tone request data cmds:RC=0x%08X\n\0"
                as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 5 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        CFE_TIME_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error subscribing to time task gnd cmds:RC=0x%08X\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    Status = CFE_EVS_SendEvent(
        1 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"cFE TIME Initialized: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error sending init event:RC=0x%08X\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                .as_ptr(),
            Status as libc::c_uint,
        );
        return Status;
    }
    OsStatus = OS_TimeBaseGetIdByName(
        &mut TimeBaseId,
        b"cFS-Master\0" as *const u8 as *const libc::c_char,
    );
    if OsStatus == 0 as libc::c_int {
        OsStatus = OS_TimerAdd(
            &mut TimerId,
            b"cFS-1Hz\0" as *const u8 as *const libc::c_char,
            TimeBaseId,
            Some(
                CFE_TIME_Local1HzTimerCallback
                    as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> (),
            ),
            0 as *mut libc::c_void,
        );
        if OsStatus == 0 as libc::c_int {
            OsStatus = OS_TimerSet(
                TimerId,
                500000 as libc::c_int as uint32,
                1000000 as libc::c_int as uint32,
            );
            if OsStatus != 0 as libc::c_int {
                CFE_ES_WriteToSysLog(
                    b"%s: 1Hz OS_TimerSet failed:RC=%ld\n\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(
                        b"CFE_TIME_TaskInit\0",
                    ))
                    .as_ptr(),
                    OsStatus as libc::c_long,
                );
            }
        } else {
            CFE_ES_WriteToSysLog(
                b"%s: 1Hz OS_TimerAdd failed:RC=%ld\n\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 18], &[libc::c_char; 18]>(b"CFE_TIME_TaskInit\0"))
                    .as_ptr(),
                OsStatus as libc::c_long,
            );
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SendHkCmd(mut data: *const CFE_TIME_SendHkCmd_t) -> int32 {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    CFE_TIME_GetReference(&mut Reference);
    CFE_TIME_UpdateResetVars(&mut Reference);
    CFE_TIME_GetHkData(&mut Reference);
    CFE_SB_TimeStampMsg(&mut CFE_TIME_Global.HkPacket.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut CFE_TIME_Global.HkPacket.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneSignalCmd(
    mut data: *const CFE_TIME_ToneSignalCmd_t,
) -> int32 {
    CFE_TIME_ToneSignal();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneDataCmd(mut data: *const CFE_TIME_ToneDataCmd_t) -> int32 {
    CFE_TIME_ToneData(&(*data).Payload);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_OneHzCmd(mut data: *const CFE_TIME_OneHzCmd_t) -> int32 {
    CFE_TIME_Local1HzStateMachine();
    CFE_TIME_Tone1HzISR();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneSendCmd(mut data: *const CFE_TIME_FakeToneCmd_t) -> int32 {
    CFE_TIME_ToneSend();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_NoopCmd(mut data: *const CFE_TIME_NoopCmd_t) -> int32 {
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
    CFE_TIME_Global.CommandCounter;
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    CFE_EVS_SendEvent(
        4 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"No-op Cmd Rcvd: %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ResetCountersCmd(
    mut data: *const CFE_TIME_ResetCountersCmd_t,
) -> int32 {
    CFE_TIME_Global.CommandCounter = 0 as libc::c_int as uint8;
    CFE_TIME_Global.CommandErrorCounter = 0 as libc::c_int as uint8;
    CFE_TIME_Global.ToneMatchCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneMatchErrorCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneSignalCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneDataCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneIntCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneIntErrorCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneTaskCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ResetVersionCounter = CFE_TIME_Global.LastVersionCounter;
    CFE_TIME_Global.LocalIntCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.LocalTaskCounter = 0 as libc::c_int as uint32;
    CFE_TIME_Global.InternalCount = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ExternalCount = 0 as libc::c_int as uint32;
    CFE_EVS_SendEvent(
        5 as libc::c_int as uint16,
        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
        b"Reset Counters command\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SendDiagnosticTlm(
    mut data: *const CFE_TIME_SendDiagnosticCmd_t,
) -> int32 {
    CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
    CFE_TIME_Global.CommandCounter;
    CFE_TIME_GetDiagData();
    CFE_SB_TimeStampMsg(&mut CFE_TIME_Global.DiagPacket.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut CFE_TIME_Global.DiagPacket.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    CFE_EVS_SendEvent(
        6 as libc::c_int as uint16,
        CFE_EVS_EventType_DEBUG as libc::c_int as uint16,
        b"Request diagnostics command\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetStateCmd(mut data: *const CFE_TIME_SetStateCmd_t) -> int32 {
    let mut CommandPtr: *const CFE_TIME_StateCmd_Payload_t = &(*data).Payload;
    let mut ClockStateText: *const libc::c_char = 0 as *const libc::c_char;
    if (*CommandPtr).ClockState as libc::c_int == CFE_TIME_ClockState_INVALID as libc::c_int
        || (*CommandPtr).ClockState as libc::c_int == CFE_TIME_ClockState_VALID as libc::c_int
        || (*CommandPtr).ClockState as libc::c_int == CFE_TIME_ClockState_FLYWHEEL as libc::c_int
    {
        CFE_TIME_SetState((*CommandPtr).ClockState);
        if (*CommandPtr).ClockState as libc::c_int == CFE_TIME_ClockState_INVALID as libc::c_int {
            ClockStateText = b"INVALID\0" as *const u8 as *const libc::c_char;
        } else if (*CommandPtr).ClockState as libc::c_int
            == CFE_TIME_ClockState_VALID as libc::c_int
        {
            ClockStateText = b"VALID\0" as *const u8 as *const libc::c_char;
        } else {
            ClockStateText = b"FLYWHEEL\0" as *const u8 as *const libc::c_char;
        }
        CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
        CFE_TIME_Global.CommandCounter;
        CFE_EVS_SendEvent(
            7 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"Set Clock State = %s\0" as *const u8 as *const libc::c_char,
            ClockStateText,
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            30 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid Clock State = 0x%X\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).ClockState as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetSourceCmd(mut data: *const CFE_TIME_SetSourceCmd_t) -> int32 {
    let mut CommandPtr: *const CFE_TIME_SourceCmd_Payload_t = &(*data).Payload;
    if (*CommandPtr).TimeSource as libc::c_int == CFE_TIME_SourceSelect_INTERNAL as libc::c_int
        || (*CommandPtr).TimeSource as libc::c_int == CFE_TIME_SourceSelect_EXTERNAL as libc::c_int
    {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            40 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Set Source commands invalid without CFE_PLATFORM_TIME_CFG_SOURCE set to TRUE\0"
                as *const u8 as *const libc::c_char,
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            31 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid Time Source = 0x%X\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).TimeSource as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetSignalCmd(mut data: *const CFE_TIME_SetSignalCmd_t) -> int32 {
    let mut CommandPtr: *const CFE_TIME_SignalCmd_Payload_t = &(*data).Payload;
    if (*CommandPtr).ToneSource as libc::c_int == CFE_TIME_ToneSignalSelect_PRIMARY as libc::c_int
        || (*CommandPtr).ToneSource as libc::c_int
            == CFE_TIME_ToneSignalSelect_REDUNDANT as libc::c_int
    {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            41 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Set Signal commands invalid without CFE_PLATFORM_TIME_CFG_SIGNAL set to TRUE\0"
                as *const u8 as *const libc::c_char,
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            32 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid Tone Source = 0x%X\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).ToneSource as libc::c_uint,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetDelayImpl(
    mut CommandPtr: *const CFE_TIME_TimeCmd_Payload_t,
    mut Direction: CFE_TIME_AdjustDirection_Enum_t,
) {
    if (*CommandPtr).MicroSeconds < 1000000 as libc::c_int as libc::c_uint {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            42 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Set Delay commands invalid without CFE_PLATFORM_TIME_CFG_CLIENT set to TRUE\0"
                as *const u8 as *const libc::c_char,
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            33 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid Tone Delay -- secs = %u, usecs = %u\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_AddDelayCmd(mut data: *const CFE_TIME_AddDelayCmd_t) -> int32 {
    CFE_TIME_SetDelayImpl(
        &(*data).Payload,
        CFE_TIME_AdjustDirection_ADD as libc::c_int as CFE_TIME_AdjustDirection_Enum_t,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SubDelayCmd(mut data: *const CFE_TIME_SubDelayCmd_t) -> int32 {
    CFE_TIME_SetDelayImpl(
        &(*data).Payload,
        CFE_TIME_AdjustDirection_SUBTRACT as libc::c_int as CFE_TIME_AdjustDirection_Enum_t,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetTimeCmd(mut data: *const CFE_TIME_SetTimeCmd_t) -> int32 {
    let mut CommandPtr: *const CFE_TIME_TimeCmd_Payload_t = &(*data).Payload;
    if (*CommandPtr).MicroSeconds < 1000000 as libc::c_int as libc::c_uint {
        let mut NewTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        };
        NewTime.Seconds = (*CommandPtr).Seconds;
        NewTime.Subseconds = CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds);
        CFE_TIME_SetTime(NewTime);
        CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
        CFE_TIME_Global.CommandCounter;
        CFE_EVS_SendEvent(
            12 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"Set Time -- secs = %u, usecs = %u, ssecs = 0x%X\0" as *const u8
                as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
            CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds),
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            34 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid Time -- secs = %u, usecs = %u\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetMETCmd(mut data: *const CFE_TIME_SetMETCmd_t) -> int32 {
    let mut CommandPtr: *const CFE_TIME_TimeCmd_Payload_t = &(*data).Payload;
    if (*CommandPtr).MicroSeconds < 1000000 as libc::c_int as libc::c_uint {
        let mut NewMET: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        };
        NewMET.Seconds = (*CommandPtr).Seconds;
        NewMET.Subseconds = CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds);
        CFE_TIME_SetMET(NewMET);
        CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
        CFE_TIME_Global.CommandCounter;
        CFE_EVS_SendEvent(
            13 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"Set MET -- secs = %u, usecs = %u, ssecs = 0x%X\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
            CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds),
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            35 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid MET -- secs = %u, usecs = %u\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetSTCFCmd(mut data: *const CFE_TIME_SetSTCFCmd_t) -> int32 {
    let mut CommandPtr: *const CFE_TIME_TimeCmd_Payload_t = &(*data).Payload;
    if (*CommandPtr).MicroSeconds < 1000000 as libc::c_int as libc::c_uint {
        let mut NewSTCF: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        };
        NewSTCF.Seconds = (*CommandPtr).Seconds;
        NewSTCF.Subseconds = CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds);
        CFE_TIME_SetSTCF(NewSTCF);
        CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
        CFE_TIME_Global.CommandCounter;
        CFE_EVS_SendEvent(
            14 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"Set STCF -- secs = %u, usecs = %u, ssecs = 0x%X\0" as *const u8
                as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
            CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds),
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            36 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid STCF -- secs = %u, usecs = %u\0" as *const u8 as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetLeapSecondsCmd(
    mut data: *const CFE_TIME_SetLeapSecondsCmd_t,
) -> int32 {
    let mut CommandPtr: *const CFE_TIME_LeapsCmd_Payload_t = &(*data).Payload;
    CFE_TIME_SetLeapSeconds((*CommandPtr).LeapSeconds);
    CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
    CFE_TIME_Global.CommandCounter;
    CFE_EVS_SendEvent(
        17 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Set Leap Seconds = %d\0" as *const u8 as *const libc::c_char,
        (*CommandPtr).LeapSeconds as libc::c_int,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_AdjustImpl(
    mut CommandPtr: *const CFE_TIME_TimeCmd_Payload_t,
    mut Direction: CFE_TIME_AdjustDirection_Enum_t,
) {
    if (*CommandPtr).MicroSeconds < 1000000 as libc::c_int as libc::c_uint {
        let mut Adjust: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        };
        Adjust.Seconds = (*CommandPtr).Seconds;
        Adjust.Subseconds = CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds);
        CFE_TIME_SetAdjust(Adjust, Direction as int16);
        CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
        CFE_TIME_Global.CommandCounter;
        CFE_EVS_SendEvent(
            15 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"STCF Adjust -- secs = %u, usecs = %u, ssecs = 0x%X, dir[1=Pos, 2=Neg] = %d\0"
                as *const u8 as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
            CFE_TIME_Micro2SubSecs((*CommandPtr).MicroSeconds),
            Direction as libc::c_int,
        );
    } else {
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
        CFE_EVS_SendEvent(
            37 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid STCF Adjust -- secs = %u, usecs = %u, dir[1=Pos, 2=Neg] = %d\0" as *const u8
                as *const libc::c_char,
            (*CommandPtr).Seconds,
            (*CommandPtr).MicroSeconds,
            Direction as libc::c_int,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_AddAdjustCmd(mut data: *const CFE_TIME_AddAdjustCmd_t) -> int32 {
    CFE_TIME_AdjustImpl(
        &(*data).Payload,
        CFE_TIME_AdjustDirection_ADD as libc::c_int as CFE_TIME_AdjustDirection_Enum_t,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SubAdjustCmd(mut data: *const CFE_TIME_SubAdjustCmd_t) -> int32 {
    CFE_TIME_AdjustImpl(
        &(*data).Payload,
        CFE_TIME_AdjustDirection_SUBTRACT as libc::c_int as CFE_TIME_AdjustDirection_Enum_t,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_1HzAdjImpl(
    mut CommandPtr: *const CFE_TIME_OneHzAdjustmentCmd_Payload_t,
    mut Direction: CFE_TIME_AdjustDirection_Enum_t,
) {
    let mut Adjust: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    Adjust.Seconds = (*CommandPtr).Seconds;
    Adjust.Subseconds = (*CommandPtr).Subseconds;
    CFE_TIME_Set1HzAdj(Adjust, Direction as int16);
    CFE_TIME_Global.CommandCounter = (CFE_TIME_Global.CommandCounter).wrapping_add(1);
    CFE_TIME_Global.CommandCounter;
    CFE_EVS_SendEvent(
        16 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"STCF 1Hz Adjust -- secs = %d, ssecs = 0x%X, dir[1=Pos, 2=Neg] = %d\0" as *const u8
            as *const libc::c_char,
        (*CommandPtr).Seconds as libc::c_int,
        (*CommandPtr).Subseconds,
        Direction as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_AddOneHzAdjustmentCmd(
    mut data: *const CFE_TIME_AddOneHzAdjustmentCmd_t,
) -> int32 {
    CFE_TIME_1HzAdjImpl(
        &(*data).Payload,
        CFE_TIME_AdjustDirection_ADD as libc::c_int as CFE_TIME_AdjustDirection_Enum_t,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SubOneHzAdjustmentCmd(
    mut data: *const CFE_TIME_SubOneHzAdjustmentCmd_t,
) -> int32 {
    CFE_TIME_1HzAdjImpl(
        &(*data).Payload,
        CFE_TIME_AdjustDirection_SUBTRACT as libc::c_int as CFE_TIME_AdjustDirection_Enum_t,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneSend() {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut NewMET: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    CFE_TIME_GetReference(&mut Reference);
    if Reference.ClockFlyState as libc::c_int == CFE_TIME_FlywheelState_IS_FLY as libc::c_int {
        NewMET.Seconds = Reference.CurrentMET.Seconds;
    } else {
        NewMET.Seconds = CFE_TIME_Global.VirtualMET;
    }
    NewMET.Subseconds = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneDataCmd.Payload.AtToneMET.Seconds = NewMET.Seconds;
    CFE_TIME_Global.ToneDataCmd.Payload.AtToneMET.Subseconds = NewMET.Subseconds;
    CFE_TIME_Global.ToneDataCmd.Payload.AtToneSTCF.Seconds = Reference.AtToneSTCF.Seconds;
    CFE_TIME_Global.ToneDataCmd.Payload.AtToneSTCF.Subseconds = Reference.AtToneSTCF.Subseconds;
    CFE_TIME_Global.ToneDataCmd.Payload.AtToneLeapSeconds = Reference.AtToneLeapSeconds;
    CFE_TIME_Global.ToneDataCmd.Payload.AtToneState = CFE_TIME_CalculateState(&mut Reference);
    CFE_SB_TransmitMsg(
        &mut CFE_TIME_Global.ToneDataCmd.CommandHeader.Msg,
        1 as libc::c_int != 0,
    );
    CFE_TIME_Global.InternalCount = (CFE_TIME_Global.InternalCount).wrapping_add(1);
    CFE_TIME_Global.InternalCount;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneData(mut ToneDataCmd: *const CFE_TIME_ToneDataCmd_Payload_t) {
    CFE_TIME_Global.ToneDataLatch = CFE_TIME_LatchClock();
    CFE_TIME_Global.PendingMET.Seconds = (*ToneDataCmd).AtToneMET.Seconds;
    CFE_TIME_Global.PendingMET.Subseconds = (*ToneDataCmd).AtToneMET.Subseconds;
    CFE_TIME_Global.PendingSTCF.Seconds = (*ToneDataCmd).AtToneSTCF.Seconds;
    CFE_TIME_Global.PendingSTCF.Subseconds = (*ToneDataCmd).AtToneSTCF.Subseconds;
    CFE_TIME_Global.PendingLeaps = (*ToneDataCmd).AtToneLeapSeconds;
    CFE_TIME_Global.PendingState = (*ToneDataCmd).AtToneState;
    CFE_TIME_ToneVerify(
        CFE_TIME_Global.ToneSignalLatch,
        CFE_TIME_Global.ToneDataLatch,
    );
    CFE_TIME_Global.ToneDataCounter = (CFE_TIME_Global.ToneDataCounter).wrapping_add(1);
    CFE_TIME_Global.ToneDataCounter;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneSignal() {
    CFE_TIME_Global.ToneSignalCounter = (CFE_TIME_Global.ToneSignalCounter).wrapping_add(1);
    CFE_TIME_Global.ToneSignalCounter;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneVerify(
    mut Time1: CFE_TIME_SysTime_t,
    mut Time2: CFE_TIME_SysTime_t,
) {
    let mut result: CFE_TIME_Compare_t = CFE_TIME_EQUAL;
    let mut elapsed: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    static mut PrevTime1: CFE_TIME_SysTime_t = {
        let mut init = CFE_TIME_SysTime {
            Seconds: 0 as libc::c_int as uint32,
            Subseconds: 0 as libc::c_int as uint32,
        };
        init
    };
    static mut PrevTime2: CFE_TIME_SysTime_t = {
        let mut init = CFE_TIME_SysTime {
            Seconds: 0 as libc::c_int as uint32,
            Subseconds: 0 as libc::c_int as uint32,
        };
        init
    };
    result = CFE_TIME_Compare(PrevTime1, Time1);
    if result as libc::c_int == CFE_TIME_EQUAL as libc::c_int {
        CFE_TIME_Global.ToneMatchErrorCounter =
            (CFE_TIME_Global.ToneMatchErrorCounter).wrapping_add(1);
        CFE_TIME_Global.ToneMatchErrorCounter;
    } else {
        result = CFE_TIME_Compare(PrevTime2, Time2);
        if result as libc::c_int == CFE_TIME_EQUAL as libc::c_int {
            CFE_TIME_Global.ToneMatchErrorCounter =
                (CFE_TIME_Global.ToneMatchErrorCounter).wrapping_add(1);
            CFE_TIME_Global.ToneMatchErrorCounter;
        } else {
            result = CFE_TIME_Compare(Time1, Time2);
            if result as libc::c_int == CFE_TIME_A_GT_B as libc::c_int {
                elapsed = CFE_TIME_Subtract(CFE_TIME_Global.MaxLocalClock, Time1);
                elapsed = CFE_TIME_Add(elapsed, Time2);
            } else {
                elapsed = CFE_TIME_Subtract(Time2, Time1);
            }
            if elapsed.Seconds != 0 as libc::c_int as libc::c_uint
                || elapsed.Subseconds < CFE_TIME_Global.MinElapsed
                || elapsed.Subseconds > CFE_TIME_Global.MaxElapsed
            {
                CFE_TIME_Global.ToneMatchErrorCounter =
                    (CFE_TIME_Global.ToneMatchErrorCounter).wrapping_add(1);
                CFE_TIME_Global.ToneMatchErrorCounter;
            } else {
                CFE_TIME_Global.ToneMatchCounter =
                    (CFE_TIME_Global.ToneMatchCounter).wrapping_add(1);
                CFE_TIME_Global.ToneMatchCounter;
                if !CFE_TIME_Global.Forced2Fly {
                    CFE_TIME_ToneUpdate();
                }
            }
        }
    }
    PrevTime1 = Time1;
    PrevTime2 = Time2;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_ToneUpdate() {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut NewFlywheelStatus: bool = 0 as libc::c_int != 0;
    let mut NextState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    CFE_TIME_GetReference(&mut Reference);
    NextState = CFE_TIME_StartReferenceUpdate();
    ::core::ptr::write_volatile(
        &mut (*NextState).AtToneLatch as *mut CFE_TIME_SysTime_t,
        CFE_TIME_Global.ToneSignalLatch,
    );
    if CFE_TIME_Global.ClockSource as libc::c_int == CFE_TIME_SourceSelect_INTERNAL as libc::c_int {
        if (*NextState).ClockFlyState as libc::c_int == CFE_TIME_FlywheelState_IS_FLY as libc::c_int
        {
            CFE_TIME_Global.VirtualMET = Reference.CurrentMET.Seconds;
        }
        ::core::ptr::write_volatile(
            &mut (*NextState).AtToneMET.Seconds as *mut uint32,
            CFE_TIME_Global.VirtualMET,
        );
        ::core::ptr::write_volatile(
            &mut (*NextState).AtToneMET.Subseconds as *mut uint32,
            0 as libc::c_int as uint32,
        );
    }
    if (*NextState).ClockFlyState as libc::c_int == CFE_TIME_FlywheelState_IS_FLY as libc::c_int {
        ::core::ptr::write_volatile(
            &mut (*NextState).ClockFlyState as *mut int16,
            CFE_TIME_FlywheelState_NO_FLY as libc::c_int as int16,
        );
        CFE_TIME_Global.ServerFlyState = CFE_TIME_FlywheelState_NO_FLY as libc::c_int as int16;
        NewFlywheelStatus = 1 as libc::c_int != 0;
    }
    CFE_TIME_FinishReferenceUpdate(NextState);
    if NewFlywheelStatus {
        CFE_EVS_SendEvent(
            21 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"Stop FLYWHEEL\0" as *const u8 as *const libc::c_char,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Local1HzTimerCallback(
    mut TimerId: osal_id_t,
    mut Arg: *mut libc::c_void,
) {
    CFE_TIME_Local1HzISR();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Tone1HzISR() {
    let mut ToneSignalLatch: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut Elapsed: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut Result: CFE_TIME_Compare_t = CFE_TIME_EQUAL;
    CFE_ES_PerfLogAdd(7 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    ToneSignalLatch = CFE_TIME_LatchClock();
    Result = CFE_TIME_Compare(ToneSignalLatch, CFE_TIME_Global.ToneSignalLatch);
    if Result as libc::c_int == CFE_TIME_A_LT_B as libc::c_int {
        Elapsed = CFE_TIME_Subtract(
            CFE_TIME_Global.MaxLocalClock,
            CFE_TIME_Global.ToneSignalLatch,
        );
        Elapsed = CFE_TIME_Add(Elapsed, ToneSignalLatch);
    } else {
        Elapsed = CFE_TIME_Subtract(ToneSignalLatch, CFE_TIME_Global.ToneSignalLatch);
    }
    if Elapsed.Seconds == 1 as libc::c_int as libc::c_uint
        && Elapsed.Subseconds < CFE_TIME_Global.ToneOverLimit
        || Elapsed.Seconds == 0 as libc::c_int as libc::c_uint
            && Elapsed.Subseconds > CFE_TIME_Global.ToneUnderLimit
    {
        CFE_TIME_Global.ToneIntCounter = (CFE_TIME_Global.ToneIntCounter).wrapping_add(1);
        CFE_TIME_Global.ToneIntCounter;
        CFE_TIME_Global.IsToneGood = 1 as libc::c_int != 0;
        CFE_TIME_Global.VirtualMET = (CFE_TIME_Global.VirtualMET).wrapping_add(1);
        CFE_TIME_Global.VirtualMET;
        OS_BinSemGive(CFE_TIME_Global.ToneSemaphore);
    } else {
        CFE_TIME_Global.ToneIntErrorCounter = (CFE_TIME_Global.ToneIntErrorCounter).wrapping_add(1);
        CFE_TIME_Global.ToneIntErrorCounter;
        CFE_TIME_Global.IsToneGood = 0 as libc::c_int != 0;
    }
    CFE_TIME_Global.ToneSignalLatch = ToneSignalLatch;
    CFE_TIME_NotifyTimeSynchApps();
    CFE_ES_PerfLogAdd(7 as libc::c_int as uint32, 1 as libc::c_int as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Tone1HzTask() {
    let mut OsStatus: int32 = 0;
    loop {
        CFE_ES_IncrementTaskCounter();
        OsStatus = OS_BinSemTake(CFE_TIME_Global.ToneSemaphore);
        if OsStatus != 0 as libc::c_int {
            break;
        }
        CFE_ES_PerfLogAdd(11 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        CFE_SB_TransmitMsg(
            &mut CFE_TIME_Global.ToneSignalCmd.CommandHeader.Msg,
            1 as libc::c_int != 0,
        );
        CFE_SB_TransmitMsg(
            &mut CFE_TIME_Global.ToneSendCmd.CommandHeader.Msg,
            1 as libc::c_int != 0,
        );
        CFE_TIME_Global.ToneTaskCounter = (CFE_TIME_Global.ToneTaskCounter).wrapping_add(1);
        CFE_TIME_Global.ToneTaskCounter;
        CFE_ES_PerfLogAdd(11 as libc::c_int as uint32, 1 as libc::c_int as uint32);
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Local1HzStateMachine() {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut NextState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    CFE_ES_PerfLogAdd(8 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    memset(
        &mut Reference as *mut CFE_TIME_Reference_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
    );
    if CFE_TIME_Global.OneHzAdjust.Seconds != 0 as libc::c_int as libc::c_uint
        || CFE_TIME_Global.OneHzAdjust.Subseconds != 0 as libc::c_int as libc::c_uint
    {
        let mut NewSTCF: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        };
        NextState = CFE_TIME_StartReferenceUpdate();
        if CFE_TIME_Global.OneHzDirection as libc::c_int
            == CFE_TIME_AdjustDirection_ADD as libc::c_int
        {
            NewSTCF = CFE_TIME_Add((*NextState).AtToneSTCF, CFE_TIME_Global.OneHzAdjust);
        } else {
            NewSTCF = CFE_TIME_Subtract((*NextState).AtToneSTCF, CFE_TIME_Global.OneHzAdjust);
        }
        ::core::ptr::write_volatile(
            &mut (*NextState).AtToneSTCF as *mut CFE_TIME_SysTime_t,
            NewSTCF,
        );
        CFE_TIME_FinishReferenceUpdate(NextState);
    }
    CFE_TIME_GetReference(&mut Reference);
    if Reference.ClockFlyState as libc::c_int == CFE_TIME_FlywheelState_NO_FLY as libc::c_int {
        if Reference.TimeSinceTone.Seconds >= 2 as libc::c_int as libc::c_uint {
            NextState = CFE_TIME_StartReferenceUpdate();
            ::core::ptr::write_volatile(
                &mut (*NextState).ClockFlyState as *mut int16,
                CFE_TIME_FlywheelState_IS_FLY as libc::c_int as int16,
            );
            CFE_TIME_Global.ServerFlyState = CFE_TIME_FlywheelState_IS_FLY as libc::c_int as int16;
            CFE_TIME_Global.AutoStartFly = 1 as libc::c_int != 0;
            CFE_TIME_FinishReferenceUpdate(NextState);
        }
    }
    if Reference.ClockFlyState as libc::c_int == CFE_TIME_FlywheelState_IS_FLY as libc::c_int {
        if Reference.TimeSinceTone.Seconds >= 8 as libc::c_int as libc::c_uint {
            NextState = CFE_TIME_StartReferenceUpdate();
            ::core::ptr::write_volatile(
                &mut (*NextState).AtToneMET as *mut CFE_TIME_SysTime_t,
                Reference.CurrentMET,
            );
            ::core::ptr::write_volatile(
                &mut (*NextState).AtToneLatch as *mut CFE_TIME_SysTime_t,
                Reference.CurrentLatch,
            );
            CFE_TIME_FinishReferenceUpdate(NextState);
        }
    }
    CFE_ES_PerfLogAdd(8 as libc::c_int as uint32, 1 as libc::c_int as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Local1HzISR() {
    CFE_TIME_Global.LocalIntCounter = (CFE_TIME_Global.LocalIntCounter).wrapping_add(1);
    CFE_TIME_Global.LocalIntCounter;
    OS_BinSemGive(CFE_TIME_Global.LocalSemaphore);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Local1HzTask() {
    let mut OsStatus: int32 = 0;
    loop {
        CFE_ES_IncrementTaskCounter();
        OsStatus = OS_BinSemTake(CFE_TIME_Global.LocalSemaphore);
        if OsStatus != 0 as libc::c_int {
            break;
        }
        CFE_ES_PerfLogAdd(10 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if CFE_TIME_Global.AutoStartFly {
            CFE_TIME_Global.AutoStartFly = 0 as libc::c_int != 0;
            CFE_EVS_SendEvent(
                20 as libc::c_int as uint16,
                CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
                b"Start FLYWHEEL\0" as *const u8 as *const libc::c_char,
            );
        }
        CFE_SB_TransmitMsg(
            &mut CFE_TIME_Global.LocalOneHzCmd.CommandHeader.Msg,
            1 as libc::c_int != 0,
        );
        CFE_TIME_Global.LocalTaskCounter = (CFE_TIME_Global.LocalTaskCounter).wrapping_add(1);
        CFE_TIME_Global.LocalTaskCounter;
        CFE_ES_PerfLogAdd(10 as libc::c_int as uint32, 1 as libc::c_int as uint32);
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_NotifyTimeSynchApps() {
    let mut i: uint32 = 0;
    let mut Func: CFE_TIME_SynchCallbackPtr_t = None;
    if CFE_TIME_Global.IsToneGood {
        i = 0 as libc::c_int as uint32;
        while (i as libc::c_ulong)
            < (::core::mem::size_of::<[CFE_TIME_SynchCallbackRegEntry_t; 32]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<CFE_TIME_SynchCallbackRegEntry_t>() as libc::c_ulong
                )
        {
            Func = CFE_TIME_Global.SynchCallback[i as usize].Ptr;
            if Func.is_some() {
                Func.expect("non-null function pointer")();
            }
            i = i.wrapping_add(1);
            i;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_StartReferenceUpdate() -> *mut CFE_TIME_ReferenceState_t {
    let mut Version: uint32 = CFE_TIME_Global.LastVersionCounter;
    let mut CurrState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    let mut NextState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    CurrState = &mut *(CFE_TIME_Global.ReferenceState)
        .as_mut_ptr()
        .offset((Version & (4 as libc::c_int - 1 as libc::c_int) as libc::c_uint) as isize)
        as *mut CFE_TIME_ReferenceState_t;
    Version = Version.wrapping_add(1);
    Version;
    NextState = &mut *(CFE_TIME_Global.ReferenceState)
        .as_mut_ptr()
        .offset((Version & (4 as libc::c_int - 1 as libc::c_int) as libc::c_uint) as isize)
        as *mut CFE_TIME_ReferenceState_t;
    ::core::ptr::write_volatile(&mut (*NextState).StateVersion as *mut uint32, Version);
    ::core::ptr::write_volatile(
        &mut (*NextState).AtToneLeapSeconds as *mut int16,
        (*CurrState).AtToneLeapSeconds,
    );
    ::core::ptr::write_volatile(
        &mut (*NextState).ClockSetState as *mut int16,
        (*CurrState).ClockSetState,
    );
    ::core::ptr::write_volatile(
        &mut (*NextState).ClockFlyState as *mut int16,
        (*CurrState).ClockFlyState,
    );
    ::core::ptr::write_volatile(
        &mut (*NextState).DelayDirection as *mut int16,
        (*CurrState).DelayDirection,
    );
    ::core::ptr::write_volatile(
        &mut (*NextState).AtToneMET as *mut CFE_TIME_SysTime_t,
        (*CurrState).AtToneMET,
    );
    ::core::ptr::write_volatile(
        &mut (*NextState).AtToneSTCF as *mut CFE_TIME_SysTime_t,
        (*CurrState).AtToneSTCF,
    );
    ::core::ptr::write_volatile(
        &mut (*NextState).AtToneDelay as *mut CFE_TIME_SysTime_t,
        (*CurrState).AtToneDelay,
    );
    ::core::ptr::write_volatile(
        &mut (*NextState).AtToneLatch as *mut CFE_TIME_SysTime_t,
        (*CurrState).AtToneLatch,
    );
    return NextState;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_LatchClock() -> CFE_TIME_SysTime_t {
    let mut LatchTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut LocalTime: OS_time_t = OS_time_t { ticks: 0 };
    memset(
        &mut LocalTime as *mut OS_time_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<OS_time_t>() as libc::c_ulong,
    );
    CFE_PSP_GetTime(&mut LocalTime);
    LatchTime.Seconds = OS_TimeGetTotalSeconds(LocalTime) as uint32;
    LatchTime.Subseconds = OS_TimeGetSubsecondsPart(LocalTime);
    return LatchTime;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_QueryResetVars() {
    let mut LocalResetVars: CFE_TIME_ResetVars_t = CFE_TIME_ResetVars_t {
        Signature: 0,
        LeapSeconds: 0,
        ClockSignal: 0,
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut DefSubsMET: uint32 = 0;
    let mut DefSubsSTCF: uint32 = 0;
    let mut PspStatus: int32 = 0;
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    let mut resetAreaSize: uint32 = 0;
    let mut resetAreaAddr: cpuaddr = 0;
    let mut CFE_TIME_ResetDataPtr: *mut CFE_ES_ResetData_t = 0 as *mut CFE_ES_ResetData_t;
    RefState = CFE_TIME_StartReferenceUpdate();
    PspStatus = CFE_PSP_GetResetArea(&mut resetAreaAddr, &mut resetAreaSize);
    if PspStatus != 0 as libc::c_int {
        CFE_TIME_Global.DataStoreStatus = 2 as libc::c_int as uint32;
    } else {
        CFE_TIME_ResetDataPtr = resetAreaAddr as *mut CFE_ES_ResetData_t;
        LocalResetVars = (*CFE_TIME_ResetDataPtr).TimeResetVars;
        if LocalResetVars.Signature == 0xa5a55a5a as libc::c_uint
            && (LocalResetVars.ClockSignal as libc::c_int
                == CFE_TIME_ToneSignalSelect_PRIMARY as libc::c_int
                || LocalResetVars.ClockSignal as libc::c_int
                    == CFE_TIME_ToneSignalSelect_REDUNDANT as libc::c_int)
        {
            ::core::ptr::write_volatile(
                &mut (*RefState).AtToneMET as *mut CFE_TIME_SysTime_t,
                LocalResetVars.CurrentMET,
            );
            ::core::ptr::write_volatile(
                &mut (*RefState).AtToneSTCF as *mut CFE_TIME_SysTime_t,
                LocalResetVars.CurrentSTCF,
            );
            ::core::ptr::write_volatile(
                &mut (*RefState).AtToneDelay as *mut CFE_TIME_SysTime_t,
                LocalResetVars.CurrentDelay,
            );
            ::core::ptr::write_volatile(
                &mut (*RefState).AtToneLeapSeconds as *mut int16,
                LocalResetVars.LeapSeconds,
            );
            CFE_TIME_Global.ClockSignal = LocalResetVars.ClockSignal as int16;
            CFE_TIME_Global.DataStoreStatus = 4 as libc::c_int as uint32;
        } else {
            CFE_TIME_Global.DataStoreStatus = 3 as libc::c_int as uint32;
        }
    }
    if CFE_TIME_Global.DataStoreStatus != 4 as libc::c_int as libc::c_uint {
        DefSubsMET = CFE_TIME_Micro2SubSecs(0 as libc::c_int as uint32);
        DefSubsSTCF = CFE_TIME_Micro2SubSecs(0 as libc::c_int as uint32);
        ::core::ptr::write_volatile(
            &mut (*RefState).AtToneMET.Seconds as *mut uint32,
            1000 as libc::c_int as uint32,
        );
        ::core::ptr::write_volatile(
            &mut (*RefState).AtToneMET.Subseconds as *mut uint32,
            DefSubsMET,
        );
        ::core::ptr::write_volatile(
            &mut (*RefState).AtToneSTCF.Seconds as *mut uint32,
            1000000 as libc::c_int as uint32,
        );
        ::core::ptr::write_volatile(
            &mut (*RefState).AtToneSTCF.Subseconds as *mut uint32,
            DefSubsSTCF,
        );
        ::core::ptr::write_volatile(
            &mut (*RefState).AtToneLeapSeconds as *mut int16,
            37 as libc::c_int as int16,
        );
        CFE_TIME_Global.ClockSignal = CFE_TIME_ToneSignalSelect_PRIMARY as libc::c_int as int16;
        ::core::ptr::write_volatile(
            &mut (*RefState).AtToneDelay.Seconds as *mut uint32,
            0 as libc::c_int as uint32,
        );
        ::core::ptr::write_volatile(
            &mut (*RefState).AtToneDelay.Subseconds as *mut uint32,
            0 as libc::c_int as uint32,
        );
    }
    CFE_TIME_FinishReferenceUpdate(RefState);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_UpdateResetVars(mut Reference: *const CFE_TIME_Reference_t) {
    let mut LocalResetVars: CFE_TIME_ResetVars_t = CFE_TIME_ResetVars_t {
        Signature: 0,
        LeapSeconds: 0,
        ClockSignal: 0,
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut resetAreaSize: uint32 = 0;
    let mut resetAreaAddr: cpuaddr = 0;
    let mut CFE_TIME_ResetDataPtr: *mut CFE_ES_ResetData_t = 0 as *mut CFE_ES_ResetData_t;
    if CFE_TIME_Global.DataStoreStatus != 1 as libc::c_int as libc::c_uint {
        LocalResetVars.Signature = 0xa5a55a5a as libc::c_uint;
        LocalResetVars.CurrentMET = (*Reference).CurrentMET;
        LocalResetVars.CurrentSTCF = (*Reference).AtToneSTCF;
        LocalResetVars.CurrentDelay = (*Reference).AtToneDelay;
        LocalResetVars.LeapSeconds = (*Reference).AtToneLeapSeconds;
        LocalResetVars.ClockSignal = CFE_TIME_Global.ClockSignal as uint16;
        if CFE_PSP_GetResetArea(&mut resetAreaAddr, &mut resetAreaSize) == 0 as libc::c_int {
            CFE_TIME_ResetDataPtr = resetAreaAddr as *mut CFE_ES_ResetData_t;
            (*CFE_TIME_ResetDataPtr).TimeResetVars = LocalResetVars;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_InitData() {
    let mut i: uint32 = 0;
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    memset(
        &mut CFE_TIME_Global as *mut CFE_TIME_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_TIME_Global_t>() as libc::c_ulong,
    );
    i = 0 as libc::c_int as uint32;
    while i < 4 as libc::c_int as libc::c_uint {
        ::core::ptr::write_volatile(
            &mut CFE_TIME_Global.ReferenceState[i as usize].StateVersion as *mut uint32,
            0xffffffff as libc::c_uint,
        );
        i = i.wrapping_add(1);
        i;
    }
    CFE_TIME_QueryResetVars();
    RefState = CFE_TIME_StartReferenceUpdate();
    ::core::ptr::write_volatile(
        &mut (*RefState).AtToneLatch as *mut CFE_TIME_SysTime_t,
        CFE_TIME_LatchClock(),
    );
    ::core::ptr::write_volatile(
        &mut (*RefState).ClockSetState as *mut int16,
        CFE_TIME_SetState_NOT_SET as libc::c_int as int16,
    );
    ::core::ptr::write_volatile(
        &mut (*RefState).ClockFlyState as *mut int16,
        CFE_TIME_FlywheelState_IS_FLY as libc::c_int as int16,
    );
    CFE_TIME_Global.ClockSource = CFE_TIME_SourceSelect_INTERNAL as libc::c_int as int16;
    CFE_TIME_Global.ServerFlyState = CFE_TIME_FlywheelState_IS_FLY as libc::c_int as int16;
    CFE_TIME_Global.PendingState =
        CFE_TIME_ClockState_INVALID as libc::c_int as CFE_TIME_ClockState_Enum_t;
    CFE_TIME_Global.OneTimeDirection = CFE_TIME_AdjustDirection_ADD as libc::c_int as int16;
    CFE_TIME_Global.OneHzDirection = CFE_TIME_AdjustDirection_ADD as libc::c_int as int16;
    ::core::ptr::write_volatile(
        &mut (*RefState).DelayDirection as *mut int16,
        CFE_TIME_AdjustDirection_ADD as libc::c_int as int16,
    );
    CFE_TIME_Global.VirtualMET = (*RefState).AtToneMET.Seconds;
    CFE_TIME_Global.MinElapsed = CFE_TIME_Micro2SubSecs(0 as libc::c_int as uint32);
    CFE_TIME_Global.MaxElapsed = CFE_TIME_Micro2SubSecs(200000 as libc::c_int as uint32);
    CFE_TIME_Global.MaxLocalClock.Seconds = 27 as libc::c_int as uint32;
    CFE_TIME_Global.MaxLocalClock.Subseconds = 0 as libc::c_int as uint32;
    CFE_TIME_Global.ToneOverLimit = CFE_TIME_Micro2SubSecs(20000 as libc::c_int as uint32);
    CFE_TIME_Global.ToneUnderLimit =
        CFE_TIME_Micro2SubSecs((1000000 as libc::c_int - 20000 as libc::c_int) as uint32);
    CFE_TIME_FinishReferenceUpdate(RefState);
    CFE_MSG_Init(
        &mut CFE_TIME_Global.HkPacket.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 5 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TIME_HousekeepingTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_TIME_Global.DiagPacket.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 6 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TIME_DiagnosticTlm_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_TIME_Global.ToneSignalCmd.CommandHeader.Msg,
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 16 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TIME_ToneSignalCmd_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_TIME_Global.ToneDataCmd.CommandHeader.Msg,
        CFE_SB_ValueToMsgId((0x1860 as libc::c_int | 0 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TIME_ToneDataCmd_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_TIME_Global.ToneSendCmd.CommandHeader.Msg,
        CFE_SB_ValueToMsgId((0x1860 as libc::c_int | 2 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TIME_FakeToneCmd_t>() as libc::c_ulong,
    );
    CFE_MSG_Init(
        &mut CFE_TIME_Global.LocalOneHzCmd.CommandHeader.Msg,
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 17 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CFE_TIME_OneHzCmd_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetHkData(mut Reference: *const CFE_TIME_Reference_t) {
    CFE_TIME_Global.HkPacket.Payload.CommandCounter = CFE_TIME_Global.CommandCounter;
    CFE_TIME_Global.HkPacket.Payload.CommandErrorCounter = CFE_TIME_Global.CommandErrorCounter;
    CFE_TIME_Global.HkPacket.Payload.ClockStateAPI = CFE_TIME_CalculateState(Reference);
    CFE_TIME_Global.HkPacket.Payload.ClockStateFlags = CFE_TIME_GetClockInfo();
    CFE_TIME_Global.HkPacket.Payload.LeapSeconds = (*Reference).AtToneLeapSeconds;
    CFE_TIME_Global.HkPacket.Payload.SecondsMET = (*Reference).CurrentMET.Seconds;
    CFE_TIME_Global.HkPacket.Payload.SubsecsMET = (*Reference).CurrentMET.Subseconds;
    CFE_TIME_Global.HkPacket.Payload.SecondsSTCF = (*Reference).AtToneSTCF.Seconds;
    CFE_TIME_Global.HkPacket.Payload.SubsecsSTCF = (*Reference).AtToneSTCF.Subseconds;
    CFE_TIME_Global.HkPacket.Payload.Seconds1HzAdj = CFE_TIME_Global.OneHzAdjust.Seconds;
    CFE_TIME_Global.HkPacket.Payload.Subsecs1HzAdj = CFE_TIME_Global.OneHzAdjust.Subseconds;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetDiagData() {
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut TempTime: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    CFE_TIME_GetReference(&mut Reference);
    CFE_TIME_Global.DiagPacket.Payload.AtToneMET.Seconds = Reference.AtToneMET.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneMET.Subseconds = Reference.AtToneMET.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneSTCF.Seconds = Reference.AtToneSTCF.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneSTCF.Subseconds = Reference.AtToneSTCF.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneDelay.Seconds = Reference.AtToneDelay.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneDelay.Subseconds = Reference.AtToneDelay.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneLatch.Seconds = Reference.AtToneLatch.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneLatch.Subseconds = Reference.AtToneLatch.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.AtToneLeapSeconds = Reference.AtToneLeapSeconds;
    CFE_TIME_Global.DiagPacket.Payload.ClockStateAPI = CFE_TIME_CalculateState(&mut Reference);
    CFE_TIME_Global.DiagPacket.Payload.TimeSinceTone.Seconds = Reference.TimeSinceTone.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.TimeSinceTone.Subseconds =
        Reference.TimeSinceTone.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.CurrentLatch.Seconds = Reference.CurrentLatch.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.CurrentLatch.Subseconds = Reference.CurrentLatch.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.CurrentMET.Seconds = Reference.CurrentMET.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.CurrentMET.Subseconds = Reference.CurrentMET.Subseconds;
    TempTime = CFE_TIME_CalculateTAI(&mut Reference);
    CFE_TIME_Global.DiagPacket.Payload.CurrentTAI.Seconds = TempTime.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.CurrentTAI.Subseconds = TempTime.Subseconds;
    TempTime = CFE_TIME_CalculateUTC(&mut Reference);
    CFE_TIME_Global.DiagPacket.Payload.CurrentUTC.Seconds = TempTime.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.CurrentUTC.Subseconds = TempTime.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.ClockSetState = Reference.ClockSetState;
    CFE_TIME_Global.DiagPacket.Payload.ClockFlyState = Reference.ClockFlyState;
    CFE_TIME_Global.DiagPacket.Payload.ClockSource = CFE_TIME_Global.ClockSource;
    CFE_TIME_Global.DiagPacket.Payload.ClockSignal = CFE_TIME_Global.ClockSignal;
    CFE_TIME_Global.DiagPacket.Payload.ServerFlyState = CFE_TIME_Global.ServerFlyState;
    CFE_TIME_Global.DiagPacket.Payload.Forced2Fly = CFE_TIME_Global.Forced2Fly as int16;
    CFE_TIME_Global.DiagPacket.Payload.ClockStateFlags = CFE_TIME_GetClockInfo();
    CFE_TIME_Global.DiagPacket.Payload.OneTimeDirection = CFE_TIME_Global.OneTimeDirection;
    CFE_TIME_Global.DiagPacket.Payload.OneHzDirection = CFE_TIME_Global.OneHzDirection;
    CFE_TIME_Global.DiagPacket.Payload.DelayDirection = Reference.DelayDirection;
    CFE_TIME_Global.DiagPacket.Payload.OneTimeAdjust.Seconds =
        CFE_TIME_Global.OneTimeAdjust.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.OneTimeAdjust.Subseconds =
        CFE_TIME_Global.OneTimeAdjust.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.OneHzAdjust.Seconds = CFE_TIME_Global.OneHzAdjust.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.OneHzAdjust.Subseconds =
        CFE_TIME_Global.OneHzAdjust.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.ToneSignalLatch.Seconds =
        CFE_TIME_Global.ToneSignalLatch.Seconds;
    CFE_TIME_Global
        .DiagPacket
        .Payload
        .ToneSignalLatch
        .Subseconds = CFE_TIME_Global.ToneSignalLatch.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.ToneDataLatch.Seconds =
        CFE_TIME_Global.ToneDataLatch.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.ToneDataLatch.Subseconds =
        CFE_TIME_Global.ToneDataLatch.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.ToneMatchCounter = CFE_TIME_Global.ToneMatchCounter;
    CFE_TIME_Global.DiagPacket.Payload.ToneMatchErrorCounter =
        CFE_TIME_Global.ToneMatchErrorCounter;
    CFE_TIME_Global.DiagPacket.Payload.ToneSignalCounter = CFE_TIME_Global.ToneSignalCounter;
    CFE_TIME_Global.DiagPacket.Payload.ToneDataCounter = CFE_TIME_Global.ToneDataCounter;
    CFE_TIME_Global.DiagPacket.Payload.ToneIntCounter = CFE_TIME_Global.ToneIntCounter;
    CFE_TIME_Global.DiagPacket.Payload.ToneIntErrorCounter = CFE_TIME_Global.ToneIntErrorCounter;
    CFE_TIME_Global.DiagPacket.Payload.ToneTaskCounter = CFE_TIME_Global.ToneTaskCounter;
    CFE_TIME_Global.DiagPacket.Payload.VersionCounter =
        (CFE_TIME_Global.LastVersionCounter).wrapping_sub(CFE_TIME_Global.ResetVersionCounter);
    CFE_TIME_Global.DiagPacket.Payload.LocalIntCounter = CFE_TIME_Global.LocalIntCounter;
    CFE_TIME_Global.DiagPacket.Payload.LocalTaskCounter = CFE_TIME_Global.LocalTaskCounter;
    CFE_TIME_Global.DiagPacket.Payload.VirtualMET = CFE_TIME_Global.VirtualMET;
    CFE_TIME_Global.DiagPacket.Payload.MinElapsed = CFE_TIME_Global.MinElapsed;
    CFE_TIME_Global.DiagPacket.Payload.MaxElapsed = CFE_TIME_Global.MaxElapsed;
    CFE_TIME_Global.DiagPacket.Payload.MaxLocalClock.Seconds =
        CFE_TIME_Global.MaxLocalClock.Seconds;
    CFE_TIME_Global.DiagPacket.Payload.MaxLocalClock.Subseconds =
        CFE_TIME_Global.MaxLocalClock.Subseconds;
    CFE_TIME_Global.DiagPacket.Payload.ToneOverLimit = CFE_TIME_Global.ToneOverLimit;
    CFE_TIME_Global.DiagPacket.Payload.ToneUnderLimit = CFE_TIME_Global.ToneUnderLimit;
    CFE_TIME_Global.DiagPacket.Payload.DataStoreStatus = CFE_TIME_Global.DataStoreStatus;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_GetReference(mut Reference: *mut CFE_TIME_Reference_t) {
    let mut TimeSinceTone: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut CurrentMET: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut VersionCounter: uint32 = 0;
    let mut RetryCount: uint32 = 4 as libc::c_int as uint32;
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    loop {
        VersionCounter = CFE_TIME_Global.LastVersionCounter;
        RefState = &mut *(CFE_TIME_Global.ReferenceState).as_mut_ptr().offset(
            (VersionCounter & (4 as libc::c_int - 1 as libc::c_int) as libc::c_uint) as isize,
        ) as *mut CFE_TIME_ReferenceState_t;
        (*Reference).CurrentLatch = CFE_TIME_LatchClock();
        (*Reference).AtToneMET = (*RefState).AtToneMET;
        (*Reference).AtToneSTCF = (*RefState).AtToneSTCF;
        (*Reference).AtToneLeapSeconds = (*RefState).AtToneLeapSeconds;
        (*Reference).AtToneDelay = (*RefState).AtToneDelay;
        (*Reference).AtToneLatch = (*RefState).AtToneLatch;
        (*Reference).ClockSetState = (*RefState).ClockSetState;
        (*Reference).ClockFlyState = (*RefState).ClockFlyState;
        (*Reference).DelayDirection = (*RefState).DelayDirection;
        if VersionCounter == (*RefState).StateVersion {
            break;
        }
        if RetryCount == 0 as libc::c_int as libc::c_uint {
            break;
        }
        RetryCount = RetryCount.wrapping_sub(1);
        RetryCount;
    }
    if RetryCount == 0 as libc::c_int as libc::c_uint {
        CFE_TIME_Global.GetReferenceFail = 1 as libc::c_int != 0;
        memset(
            Reference as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_TIME_Reference_t>() as libc::c_ulong,
        );
        return;
    }
    if CFE_TIME_Compare((*Reference).CurrentLatch, (*Reference).AtToneLatch) as libc::c_int
        == CFE_TIME_A_LT_B as libc::c_int
    {
        TimeSinceTone = CFE_TIME_Subtract(CFE_TIME_Global.MaxLocalClock, (*Reference).AtToneLatch);
        TimeSinceTone = CFE_TIME_Add(TimeSinceTone, (*Reference).CurrentLatch);
    } else {
        TimeSinceTone = CFE_TIME_Subtract((*Reference).CurrentLatch, (*Reference).AtToneLatch);
    }
    (*Reference).TimeSinceTone = TimeSinceTone;
    CurrentMET = CFE_TIME_Add(TimeSinceTone, (*Reference).AtToneMET);
    (*Reference).CurrentMET = CurrentMET;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_CalculateTAI(
    mut Reference: *const CFE_TIME_Reference_t,
) -> CFE_TIME_SysTime_t {
    let mut TimeAsTAI: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    TimeAsTAI = CFE_TIME_Add((*Reference).CurrentMET, (*Reference).AtToneSTCF);
    return TimeAsTAI;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_CalculateUTC(
    mut Reference: *const CFE_TIME_Reference_t,
) -> CFE_TIME_SysTime_t {
    let mut TimeAsUTC: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    TimeAsUTC = CFE_TIME_Add((*Reference).CurrentMET, (*Reference).AtToneSTCF);
    TimeAsUTC.Seconds = (TimeAsUTC.Seconds as libc::c_uint)
        .wrapping_sub((*Reference).AtToneLeapSeconds as libc::c_uint)
        as uint32 as uint32;
    return TimeAsUTC;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_CalculateState(
    mut Reference: *const CFE_TIME_Reference_t,
) -> CFE_TIME_ClockState_Enum_t {
    let mut ClockState: CFE_TIME_ClockState_Enum_t = 0;
    if (*Reference).ClockSetState as libc::c_int == CFE_TIME_SetState_WAS_SET as libc::c_int {
        if (*Reference).ClockFlyState as libc::c_int == CFE_TIME_FlywheelState_NO_FLY as libc::c_int
        {
            ClockState = CFE_TIME_ClockState_VALID as libc::c_int as CFE_TIME_ClockState_Enum_t;
        } else {
            ClockState = CFE_TIME_ClockState_FLYWHEEL as libc::c_int as CFE_TIME_ClockState_Enum_t;
        }
    } else {
        ClockState = CFE_TIME_ClockState_INVALID as libc::c_int as CFE_TIME_ClockState_Enum_t;
    }
    return ClockState;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetState(mut NewState: CFE_TIME_ClockState_Enum_t) {
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    RefState = CFE_TIME_StartReferenceUpdate();
    if NewState as libc::c_int == CFE_TIME_ClockState_FLYWHEEL as libc::c_int {
        CFE_TIME_Global.Forced2Fly = 1 as libc::c_int != 0;
        ::core::ptr::write_volatile(
            &mut (*RefState).ClockFlyState as *mut int16,
            CFE_TIME_FlywheelState_IS_FLY as libc::c_int as int16,
        );
        CFE_TIME_Global.ServerFlyState = CFE_TIME_FlywheelState_IS_FLY as libc::c_int as int16;
    } else if NewState as libc::c_int == CFE_TIME_ClockState_VALID as libc::c_int {
        CFE_TIME_Global.Forced2Fly = 0 as libc::c_int != 0;
        ::core::ptr::write_volatile(
            &mut (*RefState).ClockSetState as *mut int16,
            CFE_TIME_SetState_WAS_SET as libc::c_int as int16,
        );
    } else {
        CFE_TIME_Global.Forced2Fly = 0 as libc::c_int != 0;
        ::core::ptr::write_volatile(
            &mut (*RefState).ClockSetState as *mut int16,
            CFE_TIME_SetState_NOT_SET as libc::c_int as int16,
        );
    }
    CFE_TIME_FinishReferenceUpdate(RefState);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetTime(mut NewTime: CFE_TIME_SysTime_t) {
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    let mut Reference: CFE_TIME_Reference_t = CFE_TIME_Reference_t {
        AtToneMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneSTCF: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLeapSeconds: 0,
        ClockSetState: 0,
        ClockFlyState: 0,
        DelayDirection: 0,
        AtToneDelay: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        AtToneLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentLatch: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TimeSinceTone: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        CurrentMET: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
    };
    let mut NewSTCF: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    CFE_TIME_GetReference(&mut Reference);
    NewSTCF = CFE_TIME_Subtract(NewTime, Reference.CurrentMET);
    RefState = CFE_TIME_StartReferenceUpdate();
    ::core::ptr::write_volatile(
        &mut (*RefState).AtToneSTCF as *mut CFE_TIME_SysTime_t,
        NewSTCF,
    );
    CFE_TIME_FinishReferenceUpdate(RefState);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetMET(mut NewMET: CFE_TIME_SysTime_t) {
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    RefState = CFE_TIME_StartReferenceUpdate();
    ::core::ptr::write_volatile(
        &mut (*RefState).AtToneMET as *mut CFE_TIME_SysTime_t,
        NewMET,
    );
    CFE_TIME_Global.VirtualMET = NewMET.Seconds;
    ::core::ptr::write_volatile(
        &mut (*RefState).AtToneLatch as *mut CFE_TIME_SysTime_t,
        CFE_TIME_LatchClock(),
    );
    CFE_TIME_FinishReferenceUpdate(RefState);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetSTCF(mut NewSTCF: CFE_TIME_SysTime_t) {
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    RefState = CFE_TIME_StartReferenceUpdate();
    ::core::ptr::write_volatile(
        &mut (*RefState).AtToneSTCF as *mut CFE_TIME_SysTime_t,
        NewSTCF,
    );
    CFE_TIME_FinishReferenceUpdate(RefState);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetLeapSeconds(mut NewLeaps: int16) {
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    RefState = CFE_TIME_StartReferenceUpdate();
    ::core::ptr::write_volatile(&mut (*RefState).AtToneLeapSeconds as *mut int16, NewLeaps);
    CFE_TIME_FinishReferenceUpdate(RefState);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_SetAdjust(
    mut NewAdjust: CFE_TIME_SysTime_t,
    mut Direction: int16,
) {
    let mut NewSTCF: CFE_TIME_SysTime_t = CFE_TIME_SysTime_t {
        Seconds: 0,
        Subseconds: 0,
    };
    let mut RefState: *mut CFE_TIME_ReferenceState_t = 0 as *mut CFE_TIME_ReferenceState_t;
    RefState = CFE_TIME_StartReferenceUpdate();
    CFE_TIME_Global.OneTimeAdjust = NewAdjust;
    CFE_TIME_Global.OneTimeDirection = Direction;
    if Direction as libc::c_int == CFE_TIME_AdjustDirection_ADD as libc::c_int {
        NewSTCF = CFE_TIME_Add((*RefState).AtToneSTCF, NewAdjust);
    } else {
        NewSTCF = CFE_TIME_Subtract((*RefState).AtToneSTCF, NewAdjust);
    }
    ::core::ptr::write_volatile(
        &mut (*RefState).AtToneSTCF as *mut CFE_TIME_SysTime_t,
        NewSTCF,
    );
    CFE_TIME_FinishReferenceUpdate(RefState);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_Set1HzAdj(
    mut NewAdjust: CFE_TIME_SysTime_t,
    mut Direction: int16,
) {
    CFE_TIME_Global.OneHzAdjust = NewAdjust;
    CFE_TIME_Global.OneHzDirection = Direction;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_CleanUpApp(mut AppId: CFE_ES_AppId_t) -> int32 {
    let mut Status: int32 = 0;
    let mut AppIndex: uint32 = 0;
    Status = CFE_ES_AppID_ToIndex(AppId, &mut AppIndex);
    if !(Status != 0 as libc::c_int) {
        if (AppIndex as libc::c_ulong)
            < (::core::mem::size_of::<[CFE_TIME_SynchCallbackRegEntry_t; 32]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<CFE_TIME_SynchCallbackRegEntry_t>() as libc::c_ulong
                )
        {
            ::core::ptr::write_volatile(
                &mut CFE_TIME_Global.SynchCallback[AppIndex as usize].Ptr
                    as *mut CFE_TIME_SynchCallbackPtr_t,
                None,
            );
        } else {
            Status = 0xce000004 as libc::c_uint as CFE_Status_t;
        }
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_VerifyCmdLength(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut ExpectedLength: size_t,
) -> bool {
    let mut result: bool = 1 as libc::c_int != 0;
    let mut ActualLength: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetSize(MsgPtr, &mut ActualLength);
    if ExpectedLength != ActualLength {
        CFE_MSG_GetMsgId(MsgPtr, &mut MsgId);
        CFE_MSG_GetFcnCode(MsgPtr, &mut FcnCode);
        CFE_EVS_SendEvent(
            49 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid msg length: ID = 0x%X,  CC = %u, Len = %u, Expected = %u\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            FcnCode as libc::c_uint,
            ActualLength as libc::c_uint,
            ExpectedLength as libc::c_uint,
        );
        result = 0 as libc::c_int != 0;
        CFE_TIME_Global.CommandErrorCounter = (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
        CFE_TIME_Global.CommandErrorCounter;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_TIME_TaskPipe(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MessageID: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    let mut CommandCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MessageID);
    match CFE_SB_MsgIdToValue(MessageID) {
        6157 => {
            CFE_TIME_SendHkCmd(SBBufPtr as *const CFE_TIME_SendHkCmd_t);
        }
        6160 => {
            CFE_TIME_ToneSignalCmd(SBBufPtr as *const CFE_TIME_ToneSignalCmd_t);
        }
        6240 => {
            CFE_TIME_ToneDataCmd(SBBufPtr as *const CFE_TIME_ToneDataCmd_t);
        }
        6161 => {
            CFE_TIME_OneHzCmd(SBBufPtr as *const CFE_TIME_OneHzCmd_t);
        }
        6242 => {
            CFE_TIME_ToneSendCmd(SBBufPtr as *const CFE_TIME_FakeToneCmd_t);
        }
        6149 => {
            CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut CommandCode);
            match CommandCode as libc::c_int {
                0 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_NoopCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_NoopCmd(SBBufPtr as *const CFE_TIME_NoopCmd_t);
                    }
                }
                1 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_ResetCountersCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_ResetCountersCmd(SBBufPtr as *const CFE_TIME_ResetCountersCmd_t);
                    }
                }
                2 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SendDiagnosticCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SendDiagnosticTlm(SBBufPtr as *const CFE_TIME_SendDiagnosticCmd_t);
                    }
                }
                4 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SetStateCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SetStateCmd(SBBufPtr as *const CFE_TIME_SetStateCmd_t);
                    }
                }
                3 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SetSourceCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SetSourceCmd(SBBufPtr as *const CFE_TIME_SetSourceCmd_t);
                    }
                }
                15 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SetSignalCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SetSignalCmd(SBBufPtr as *const CFE_TIME_SetSignalCmd_t);
                    }
                }
                5 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_AddDelayCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_AddDelayCmd(SBBufPtr as *const CFE_TIME_AddDelayCmd_t);
                    }
                }
                6 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SubDelayCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SubDelayCmd(SBBufPtr as *const CFE_TIME_SubDelayCmd_t);
                    }
                }
                7 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SetTimeCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SetTimeCmd(SBBufPtr as *const CFE_TIME_SetTimeCmd_t);
                    }
                }
                8 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SetMETCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SetMETCmd(SBBufPtr as *const CFE_TIME_SetMETCmd_t);
                    }
                }
                9 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SetSTCFCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SetSTCFCmd(SBBufPtr as *const CFE_TIME_SetSTCFCmd_t);
                    }
                }
                10 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SetLeapSecondsCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SetLeapSecondsCmd(SBBufPtr as *const CFE_TIME_SetLeapSecondsCmd_t);
                    }
                }
                11 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_AddAdjustCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_AddAdjustCmd(SBBufPtr as *const CFE_TIME_AddAdjustCmd_t);
                    }
                }
                12 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SubAdjustCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SubAdjustCmd(SBBufPtr as *const CFE_TIME_SubAdjustCmd_t);
                    }
                }
                13 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_AddOneHzAdjustmentCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_AddOneHzAdjustmentCmd(
                            SBBufPtr as *const CFE_TIME_AddOneHzAdjustmentCmd_t,
                        );
                    }
                }
                14 => {
                    if CFE_TIME_VerifyCmdLength(
                        &(*SBBufPtr).Msg,
                        ::core::mem::size_of::<CFE_TIME_SubOneHzAdjustmentCmd_t>() as libc::c_ulong,
                    ) {
                        CFE_TIME_SubOneHzAdjustmentCmd(
                            SBBufPtr as *const CFE_TIME_SubOneHzAdjustmentCmd_t,
                        );
                    }
                }
                _ => {
                    CFE_TIME_Global.CommandErrorCounter =
                        (CFE_TIME_Global.CommandErrorCounter).wrapping_add(1);
                    CFE_TIME_Global.CommandErrorCounter;
                    CFE_EVS_SendEvent(
                        27 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Invalid command code -- ID = 0x%X, CC = %d\0" as *const u8
                            as *const libc::c_char,
                        CFE_SB_MsgIdToValue(MessageID),
                        CommandCode as libc::c_int,
                    );
                }
            }
        }
        _ => {
            CFE_EVS_SendEvent(
                26 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Invalid message ID -- ID = 0x%X\0" as *const u8 as *const libc::c_char,
                CFE_SB_MsgIdToValue(MessageID),
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_eventids_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_extern_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_fcncodes_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_interface_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_internal_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_mission_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_msgdefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_msg_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_msgids_h_c__CheckHeader()
{
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_msgstruct_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_platform_cfg_h_c__CheckHeader(
) {
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_time_src_check_cfe_time_topicids_h_c__CheckHeader(
) {
}
#[no_mangle]
pub static mut CFE_PSP_BASE_MODULE_LIST: [CFE_StaticModuleLoadEntry_t; 8] = unsafe {
    [
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: b"soft_timebase\0" as *const u8 as *const libc::c_char,
                Api: &CFE_PSP_soft_timebase_API as *const CFE_PSP_ModuleApi_t
                    as *const libc::c_void,
            };
            init
        },
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: b"timebase_posix_clock\0" as *const u8 as *const libc::c_char,
                Api: &CFE_PSP_timebase_posix_clock_API as *const CFE_PSP_ModuleApi_t
                    as *const libc::c_void,
            };
            init
        },
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: b"eeprom_mmap_file\0" as *const u8 as *const libc::c_char,
                Api: &CFE_PSP_eeprom_mmap_file_API as *const CFE_PSP_ModuleApi_t
                    as *const libc::c_void,
            };
            init
        },
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: b"ram_notimpl\0" as *const u8 as *const libc::c_char,
                Api: &CFE_PSP_ram_notimpl_API as *const CFE_PSP_ModuleApi_t as *const libc::c_void,
            };
            init
        },
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: b"port_notimpl\0" as *const u8 as *const libc::c_char,
                Api: &CFE_PSP_port_notimpl_API as *const CFE_PSP_ModuleApi_t as *const libc::c_void,
            };
            init
        },
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: b"iodriver\0" as *const u8 as *const libc::c_char,
                Api: &CFE_PSP_iodriver_API as *const CFE_PSP_ModuleApi_t as *const libc::c_void,
            };
            init
        },
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: b"linux_sysmon\0" as *const u8 as *const libc::c_char,
                Api: &CFE_PSP_linux_sysmon_API as *const CFE_PSP_ModuleApi_t as *const libc::c_void,
            };
            init
        },
        {
            let mut init = CFE_StaticModuleLoadEntry_t {
                Name: 0 as *const libc::c_char,
                Api: 0 as *const libc::c_void,
            };
            init
        },
    ]
};
#[no_mangle]
pub static mut CFE_PSP_AsyncMask: sigset_t = sigset_t { __val: [0; 16] };
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_ExceptionSigHandler(
    mut signo: libc::c_int,
    mut si: *mut siginfo_t,
    mut ctxt: *mut libc::c_void,
) {
    let mut Buffer: *mut CFE_PSP_Exception_LogData_t = 0 as *mut CFE_PSP_Exception_LogData_t;
    let mut NumAddrs: libc::c_int = 0;
    Buffer = CFE_PSP_Exception_GetNextContextBuffer();
    if !Buffer.is_null() {
        clock_gettime(1 as libc::c_int, &mut (*Buffer).context_info.event_time);
        memcpy(
            &mut (*Buffer).context_info.si as *mut siginfo_t as *mut libc::c_void,
            si as *const libc::c_void,
            ::core::mem::size_of::<siginfo_t>() as libc::c_ulong,
        );
        NumAddrs = backtrace(
            ((*Buffer).context_info.bt_addrs).as_mut_ptr(),
            16 as libc::c_int,
        );
        (*Buffer).context_size = (offset_of!(CFE_PSP_Exception_ContextDataEntry_t, bt_addrs)
            + ::core::mem::size_of::<*mut libc::c_void>() * NumAddrs as usize)
            as libc::c_ulong as uint32;
        (*Buffer).sys_task_id = pthread_self();
        CFE_PSP_Exception_WriteComplete();
    }
    pthread_kill(CFE_PSP_IdleTaskState.ThreadID, 10 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_ExceptionSigHandlerSuspend(
    mut signo: libc::c_int,
    mut si: *mut siginfo_t,
    mut ctxt: *mut libc::c_void,
) {
    CFE_PSP_ExceptionSigHandler(signo, si, ctxt);
    sigsuspend(&mut CFE_PSP_AsyncMask);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_AttachSigHandler(mut signo: libc::c_int) {
    let mut sa: sigaction = sigaction {
        __sigaction_handler: C2RustUnnamed_9 { sa_handler: None },
        sa_mask: sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    memset(
        &mut sa as *mut sigaction as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<sigaction>() as libc::c_ulong,
    );
    sa.sa_mask = CFE_PSP_AsyncMask;
    if sigismember(&mut CFE_PSP_AsyncMask, signo) == 0 {
        sa.__sigaction_handler.sa_sigaction = Some(
            CFE_PSP_ExceptionSigHandlerSuspend
                as unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
        );
        sigaddset(&mut sa.sa_mask, signo);
    } else {
        sa.__sigaction_handler.sa_sigaction = Some(
            CFE_PSP_ExceptionSigHandler
                as unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
        );
    }
    sa.sa_flags = 4 as libc::c_int;
    sigaction(signo, &mut sa, 0 as *mut sigaction);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_AttachExceptions() {
    let mut Addr: [*mut libc::c_void; 1] = [0 as *mut libc::c_void; 1];
    backtrace(Addr.as_mut_ptr(), 1 as libc::c_int);
    OS_printf(
        b"CFE_PSP: %s called\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 25], &[libc::c_char; 25]>(b"CFE_PSP_AttachExceptions\0"))
            .as_ptr(),
    );
    sigfillset(&mut CFE_PSP_AsyncMask);
    sigdelset(&mut CFE_PSP_AsyncMask, 4 as libc::c_int);
    sigdelset(&mut CFE_PSP_AsyncMask, 8 as libc::c_int);
    sigdelset(&mut CFE_PSP_AsyncMask, 7 as libc::c_int);
    sigdelset(&mut CFE_PSP_AsyncMask, 11 as libc::c_int);
    CFE_PSP_AttachSigHandler(2 as libc::c_int);
    CFE_PSP_AttachSigHandler(15 as libc::c_int);
    CFE_PSP_Exception_Reset();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_ExceptionGetSummary_Impl(
    mut Buffer: *const CFE_PSP_Exception_LogData_t,
    mut ReasonBuf: *mut libc::c_char,
    mut ReasonSize: uint32,
) -> int32 {
    let mut ComputedReason: *const libc::c_char = b"unknown\0" as *const u8 as *const libc::c_char;
    if (*Buffer).context_info.si.si_signo == 8 as libc::c_int {
        match (*Buffer).context_info.si.si_code {
            1 => {
                ComputedReason = b"Integer divide by zero\0" as *const u8 as *const libc::c_char;
            }
            2 => {
                ComputedReason = b"Integer overflow\0" as *const u8 as *const libc::c_char;
            }
            3 => {
                ComputedReason =
                    b"Floating-point divide by zero\0" as *const u8 as *const libc::c_char;
            }
            4 => {
                ComputedReason = b"Floating-point overflow\0" as *const u8 as *const libc::c_char;
            }
            5 => {
                ComputedReason = b"Floating-point underflow\0" as *const u8 as *const libc::c_char;
            }
            6 => {
                ComputedReason =
                    b"Floating-point inexact result\0" as *const u8 as *const libc::c_char;
            }
            7 => {
                ComputedReason =
                    b"Invalid floating-point operation\0" as *const u8 as *const libc::c_char;
            }
            8 => {
                ComputedReason = b"Subscript out of range\0" as *const u8 as *const libc::c_char;
            }
            _ => {
                ComputedReason = b"Unknown SIGFPE\0" as *const u8 as *const libc::c_char;
            }
        }
        snprintf(
            ReasonBuf,
            ReasonSize as libc::c_ulong,
            b"%s at ip 0x%lx\0" as *const u8 as *const libc::c_char,
            ComputedReason,
            (*Buffer).context_info.si._sifields._sigfault.si_addr as libc::c_ulong,
        );
    } else if (*Buffer).context_info.si.si_signo == 2 as libc::c_int {
        snprintf(
            ReasonBuf,
            ReasonSize as libc::c_ulong,
            b"Caught SIGINT\0" as *const u8 as *const libc::c_char,
        );
    } else {
        snprintf(
            ReasonBuf,
            ReasonSize as libc::c_ulong,
            b"Caught Signal %d\0" as *const u8 as *const libc::c_char,
            (*Buffer).context_info.si.si_signo,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_SetDefaultExceptionEnvironment() {
    CFE_PSP_AttachSigHandler(8 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_InitCDS() {
    let mut key: key_t = 0;
    key = ftok(
        b".cdskeyfile\0" as *const u8 as *const libc::c_char,
        'R' as i32,
    );
    if key == -(1 as libc::c_int) {
        perror(
            b"CFE_PSP - Cannot Create CDS Shared memory key\0" as *const u8 as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    CDSShmId = shmget(
        key,
        (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize as size_t,
        0o644 as libc::c_int | 0o1000 as libc::c_int,
    );
    if CDSShmId == -(1 as libc::c_int) {
        perror(
            b"CFE_PSP - Cannot shmget CDS Shared memory Segment\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    CFE_PSP_ReservedMemoryMap.CDSMemory.BlockPtr =
        shmat(CDSShmId, 0 as *const libc::c_void, 0 as libc::c_int);
    if CFE_PSP_ReservedMemoryMap.CDSMemory.BlockPtr == -(1 as libc::c_int) as *mut libc::c_void {
        perror(
            b"CFE_PSP - Cannot shmat to CDS Shared memory Segment\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    CFE_PSP_ReservedMemoryMap.CDSMemory.BlockSize =
        (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetCFETextSegmentInfo(
    mut PtrToCFESegment: *mut cpuaddr,
    mut SizeOfCFESegment: *mut uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    if SizeOfCFESegment.is_null() {
        return_code = -(1 as libc::c_int);
    } else {
        *PtrToCFESegment = &mut _init as *mut libc::c_uint as cpuaddr;
        *SizeOfCFESegment = (&mut _fini as *mut libc::c_uint as cpuaddr)
            .wrapping_sub(&mut _init as *mut libc::c_uint as cpuaddr)
            as uint32;
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_InitResetArea() {
    let mut key: key_t = 0;
    let mut total_size: size_t = 0;
    let mut reset_offset: size_t = 0;
    let mut align_mask: size_t = 0;
    let mut block_addr: cpuaddr = 0;
    let mut FixedBlocksPtr: *mut CFE_PSP_LinuxReservedAreaFixedLayout_t =
        0 as *mut CFE_PSP_LinuxReservedAreaFixedLayout_t;
    key = ftok(
        b".resetkeyfile\0" as *const u8 as *const libc::c_char,
        'R' as i32,
    );
    if key == -(1 as libc::c_int) {
        perror(
            b"CFE_PSP - Cannot Create Reset Area Shared memory key\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    align_mask =
        (sysconf(_SC_PAGESIZE as libc::c_int) - 1 as libc::c_int as libc::c_long) as size_t;
    total_size = ::core::mem::size_of::<CFE_PSP_LinuxReservedAreaFixedLayout_t>() as libc::c_ulong;
    total_size = total_size.wrapping_add(align_mask) & !align_mask;
    reset_offset = total_size;
    total_size = (total_size as libc::c_ulong)
        .wrapping_add((*GLOBAL_CONFIGDATA.CfeConfig).ResetAreaSize as libc::c_ulong)
        as size_t as size_t;
    total_size = total_size.wrapping_add(align_mask) & !align_mask;
    ResetAreaShmId = shmget(
        key,
        total_size,
        0o644 as libc::c_int | 0o1000 as libc::c_int,
    );
    if ResetAreaShmId == -(1 as libc::c_int) {
        perror(
            b"CFE_PSP - Cannot shmget Reset Area Shared memory Segment\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    block_addr = shmat(ResetAreaShmId, 0 as *const libc::c_void, 0 as libc::c_int) as cpuaddr;
    if block_addr == -(1 as libc::c_int) as cpuaddr {
        perror(
            b"CFE_PSP - Cannot shmat to Reset Area Shared memory Segment\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    FixedBlocksPtr = block_addr as *mut CFE_PSP_LinuxReservedAreaFixedLayout_t;
    block_addr = (block_addr as libc::c_ulong).wrapping_add(reset_offset) as cpuaddr as cpuaddr;
    CFE_PSP_ReservedMemoryMap.BootPtr = &mut (*FixedBlocksPtr).BootRecord;
    CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr = &mut (*FixedBlocksPtr).ExceptionStorage;
    CFE_PSP_ReservedMemoryMap.ResetMemory.BlockPtr = block_addr as *mut libc::c_void;
    CFE_PSP_ReservedMemoryMap.ResetMemory.BlockSize =
        (*GLOBAL_CONFIGDATA.CfeConfig).ResetAreaSize as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetKernelTextSegmentInfo(
    mut PtrToKernelSegment: *mut cpuaddr,
    mut SizeOfKernelSegment: *mut uint32,
) -> int32 {
    if PtrToKernelSegment.is_null() || SizeOfKernelSegment.is_null() {
        return -(1 as libc::c_int);
    }
    *PtrToKernelSegment = 0 as libc::c_int as cpuaddr;
    *SizeOfKernelSegment = 0 as libc::c_int as uint32;
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetUserReservedArea(
    mut PtrToUserArea: *mut cpuaddr,
    mut SizeOfUserArea: *mut uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    if SizeOfUserArea.is_null() {
        return_code = -(1 as libc::c_int);
    } else {
        *PtrToUserArea = CFE_PSP_ReservedMemoryMap.UserReservedMemory.BlockPtr as cpuaddr;
        *SizeOfUserArea = CFE_PSP_ReservedMemoryMap.UserReservedMemory.BlockSize as uint32;
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_InitProcessorReservedMemory(mut RestartType: uint32) -> int32 {
    if RestartType == 2 as libc::c_int as libc::c_uint {
        OS_printf(
            b"CFE_PSP: Clearing out CFE CDS Shared memory segment.\n\0" as *const u8
                as *const libc::c_char,
        );
        memset(
            CFE_PSP_ReservedMemoryMap.CDSMemory.BlockPtr,
            0 as libc::c_int,
            (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize as libc::c_ulong,
        );
        OS_printf(
            b"CFE_PSP: Clearing out CFE Reset Shared memory segment.\n\0" as *const u8
                as *const libc::c_char,
        );
        memset(
            CFE_PSP_ReservedMemoryMap.ResetMemory.BlockPtr,
            0 as libc::c_int,
            (*GLOBAL_CONFIGDATA.CfeConfig).ResetAreaSize as libc::c_ulong,
        );
        OS_printf(
            b"CFE_PSP: Clearing out CFE User Reserved Shared memory segment.\n\0" as *const u8
                as *const libc::c_char,
        );
        memset(
            CFE_PSP_ReservedMemoryMap.UserReservedMemory.BlockPtr,
            0 as libc::c_int,
            (*GLOBAL_CONFIGDATA.CfeConfig).UserReservedSize as libc::c_ulong,
        );
        memset(
            CFE_PSP_ReservedMemoryMap.BootPtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_PSP_ReservedMemoryBootRecord_t>() as libc::c_ulong,
        );
        memset(
            CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_PSP_ExceptionStorage_t>() as libc::c_ulong,
        );
        (*CFE_PSP_ReservedMemoryMap.BootPtr).NextResetType = 1 as libc::c_int as uint32;
    } else {
        (*CFE_PSP_ReservedMemoryMap.BootPtr).NextResetType = 2 as libc::c_int as uint32;
    }
    (*CFE_PSP_ReservedMemoryMap.BootPtr).ValidityFlag = !(0x2aebe984 as libc::c_int as uint32);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_InitVolatileDiskMem() {}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetResetArea(
    mut PtrToResetArea: *mut cpuaddr,
    mut SizeOfResetArea: *mut uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    if SizeOfResetArea.is_null() {
        return_code = -(1 as libc::c_int);
    } else {
        *PtrToResetArea = CFE_PSP_ReservedMemoryMap.ResetMemory.BlockPtr as cpuaddr;
        *SizeOfResetArea = CFE_PSP_ReservedMemoryMap.ResetMemory.BlockSize as uint32;
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_DeleteProcessorReservedMemory() {
    CFE_PSP_DeleteCDS();
    CFE_PSP_DeleteResetArea();
    CFE_PSP_DeleteUserReservedArea();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_WriteToCDS(
    mut PtrToDataToWrite: *const libc::c_void,
    mut CDSOffset: uint32,
    mut NumBytes: uint32,
) -> int32 {
    let mut CopyPtr: *mut uint8 = 0 as *mut uint8;
    let mut return_code: int32 = 0;
    if PtrToDataToWrite.is_null() {
        return_code = -(1 as libc::c_int);
    } else if CDSOffset < (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize
        && CDSOffset.wrapping_add(NumBytes) <= (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize
    {
        CopyPtr = CFE_PSP_ReservedMemoryMap.CDSMemory.BlockPtr as *mut uint8;
        CopyPtr = CopyPtr.offset(CDSOffset as isize);
        memcpy(
            CopyPtr as *mut libc::c_void,
            PtrToDataToWrite as *mut libc::c_char as *const libc::c_void,
            NumBytes as libc::c_ulong,
        );
        return_code = 0 as libc::c_int;
    } else {
        return_code = -(1 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub static mut CDSShmId: libc::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_DeleteUserReservedArea() {
    let mut ReturnCode: libc::c_int = 0;
    let mut ShmCtrl: shmid_ds = shmid_ds {
        shm_perm: ipc_perm {
            __key: 0,
            uid: 0,
            gid: 0,
            cuid: 0,
            cgid: 0,
            mode: 0,
            __seq: 0,
            __pad2: 0,
            __glibc_reserved1: 0,
            __glibc_reserved2: 0,
        },
        shm_segsz: 0,
        shm_atime: 0,
        shm_dtime: 0,
        shm_ctime: 0,
        shm_cpid: 0,
        shm_lpid: 0,
        shm_nattch: 0,
        __glibc_reserved5: 0,
        __glibc_reserved6: 0,
    };
    ReturnCode = shmctl(UserShmId, 0 as libc::c_int, &mut ShmCtrl);
    if ReturnCode == 0 as libc::c_int {
        OS_printf(
            b"User Reserved Area Shared memory segment removed\n\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        OS_printf(
            b"Error Removing User Reserved Area Shared memory Segment.\n\0" as *const u8
                as *const libc::c_char,
        );
        OS_printf(
            b"It can be manually checked and removed using the ipcs and ipcrm commands.\n\0"
                as *const u8 as *const libc::c_char,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_DeleteCDS() {
    let mut ReturnCode: libc::c_int = 0;
    let mut ShmCtrl: shmid_ds = shmid_ds {
        shm_perm: ipc_perm {
            __key: 0,
            uid: 0,
            gid: 0,
            cuid: 0,
            cgid: 0,
            mode: 0,
            __seq: 0,
            __pad2: 0,
            __glibc_reserved1: 0,
            __glibc_reserved2: 0,
        },
        shm_segsz: 0,
        shm_atime: 0,
        shm_dtime: 0,
        shm_ctime: 0,
        shm_cpid: 0,
        shm_lpid: 0,
        shm_nattch: 0,
        __glibc_reserved5: 0,
        __glibc_reserved6: 0,
    };
    ReturnCode = shmctl(CDSShmId, 0 as libc::c_int, &mut ShmCtrl);
    if ReturnCode == 0 as libc::c_int {
        OS_printf(
            b"CFE_PSP: Critical Data Store Shared memory segment removed\n\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        OS_printf(
            b"CFE_PSP: Error Removing Critical Data Store Shared memory Segment.\n\0" as *const u8
                as *const libc::c_char,
        );
        OS_printf(
            b"CFE_PSP: It can be manually checked and removed using the ipcs and ipcrm commands.\n\0"
                as *const u8 as *const libc::c_char,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_ReadFromCDS(
    mut PtrToDataToRead: *mut libc::c_void,
    mut CDSOffset: uint32,
    mut NumBytes: uint32,
) -> int32 {
    let mut CopyPtr: *mut uint8 = 0 as *mut uint8;
    let mut return_code: int32 = 0;
    if PtrToDataToRead.is_null() {
        return_code = -(1 as libc::c_int);
    } else if CDSOffset < (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize
        && CDSOffset.wrapping_add(NumBytes) <= (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize
    {
        CopyPtr = CFE_PSP_ReservedMemoryMap.CDSMemory.BlockPtr as *mut uint8;
        CopyPtr = CopyPtr.offset(CDSOffset as isize);
        memcpy(
            PtrToDataToRead as *mut libc::c_char as *mut libc::c_void,
            CopyPtr as *const libc::c_void,
            NumBytes as libc::c_ulong,
        );
        return_code = 0 as libc::c_int;
    } else {
        return_code = -(1 as libc::c_int);
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetCDSSize(mut SizeOfCDS: *mut uint32) -> int32 {
    let mut return_code: int32 = 0;
    if SizeOfCDS.is_null() {
        return_code = -(1 as libc::c_int);
    } else {
        *SizeOfCDS = (*GLOBAL_CONFIGDATA.CfeConfig).CdsSize;
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetVolatileDiskMem(
    mut PtrToVolDisk: *mut cpuaddr,
    mut SizeOfVolDisk: *mut uint32,
) -> int32 {
    let mut return_code: int32 = 0;
    if SizeOfVolDisk.is_null() {
        return_code = -(1 as libc::c_int);
    } else {
        *PtrToVolDisk = CFE_PSP_ReservedMemoryMap.VolatileDiskMemory.BlockPtr as cpuaddr;
        *SizeOfVolDisk = CFE_PSP_ReservedMemoryMap.VolatileDiskMemory.BlockSize as uint32;
        return_code = 0 as libc::c_int;
    }
    return return_code;
}
#[no_mangle]
pub static mut CFE_PSP_ReservedMemoryMap: CFE_PSP_ReservedMemoryMap_t =
    CFE_PSP_ReservedMemoryMap_t {
        BootPtr: 0 as *const CFE_PSP_ReservedMemoryBootRecord_t
            as *mut CFE_PSP_ReservedMemoryBootRecord_t,
        ExceptionStoragePtr: 0 as *const CFE_PSP_ExceptionStorage_t
            as *mut CFE_PSP_ExceptionStorage_t,
        ResetMemory: CFE_PSP_MemoryBlock_t {
            BlockPtr: 0 as *const libc::c_void as *mut libc::c_void,
            BlockSize: 0,
        },
        VolatileDiskMemory: CFE_PSP_MemoryBlock_t {
            BlockPtr: 0 as *const libc::c_void as *mut libc::c_void,
            BlockSize: 0,
        },
        CDSMemory: CFE_PSP_MemoryBlock_t {
            BlockPtr: 0 as *const libc::c_void as *mut libc::c_void,
            BlockSize: 0,
        },
        UserReservedMemory: CFE_PSP_MemoryBlock_t {
            BlockPtr: 0 as *const libc::c_void as *mut libc::c_void,
            BlockSize: 0,
        },
        SysMemoryTable: [CFE_PSP_MemTable_t {
            MemoryType: 0,
            WordSize: 0,
            StartAddr: 0,
            Size: 0,
            Attributes: 0,
        }; 10],
    };
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_SetupReservedMemoryMap() {
    let mut tempFd: libc::c_int = 0;
    tempFd = open(
        b".cdskeyfile\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int | 0o100 as libc::c_int,
        0o400 as libc::c_int | 0o200 as libc::c_int | 0o100 as libc::c_int,
    );
    close(tempFd);
    tempFd = open(
        b".resetkeyfile\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int | 0o100 as libc::c_int,
        0o400 as libc::c_int | 0o200 as libc::c_int | 0o100 as libc::c_int,
    );
    close(tempFd);
    tempFd = open(
        b".reservedkeyfile\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int | 0o100 as libc::c_int,
        0o400 as libc::c_int | 0o200 as libc::c_int | 0o100 as libc::c_int,
    );
    close(tempFd);
    CFE_PSP_InitCDS();
    CFE_PSP_InitResetArea();
    CFE_PSP_InitVolatileDiskMem();
    CFE_PSP_InitUserReservedArea();
    CFE_PSP_MemRangeSet(
        0 as libc::c_int as uint32,
        1 as libc::c_int as uint32,
        0 as libc::c_int as cpuaddr,
        18446744073709551615 as libc::c_ulong,
        0x4 as libc::c_int as size_t,
        0x3 as libc::c_int as uint32,
    );
}
#[no_mangle]
pub static mut ResetAreaShmId: libc::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_InitUserReservedArea() {
    let mut key: key_t = 0;
    key = ftok(
        b".reservedkeyfile\0" as *const u8 as *const libc::c_char,
        'R' as i32,
    );
    if key == -(1 as libc::c_int) {
        perror(
            b"CFE_PSP - Cannot Create User Reserved Area Shared memory key\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    UserShmId = shmget(
        key,
        (*GLOBAL_CONFIGDATA.CfeConfig).UserReservedSize as size_t,
        0o644 as libc::c_int | 0o1000 as libc::c_int,
    );
    if UserShmId == -(1 as libc::c_int) {
        perror(
            b"CFE_PSP - Cannot shmget User Reserved Area Shared memory Segment\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    CFE_PSP_ReservedMemoryMap.UserReservedMemory.BlockPtr =
        shmat(UserShmId, 0 as *const libc::c_void, 0 as libc::c_int);
    if CFE_PSP_ReservedMemoryMap.UserReservedMemory.BlockPtr
        == -(1 as libc::c_int) as *mut libc::c_void
    {
        perror(
            b"CFE_PSP - Cannot shmat to User Reserved Area Shared memory Segment\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(-(1 as libc::c_int));
    }
    CFE_PSP_ReservedMemoryMap.UserReservedMemory.BlockSize =
        (*GLOBAL_CONFIGDATA.CfeConfig).UserReservedSize as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_DeleteResetArea() {
    let mut ReturnCode: libc::c_int = 0;
    let mut ShmCtrl: shmid_ds = shmid_ds {
        shm_perm: ipc_perm {
            __key: 0,
            uid: 0,
            gid: 0,
            cuid: 0,
            cgid: 0,
            mode: 0,
            __seq: 0,
            __pad2: 0,
            __glibc_reserved1: 0,
            __glibc_reserved2: 0,
        },
        shm_segsz: 0,
        shm_atime: 0,
        shm_dtime: 0,
        shm_ctime: 0,
        shm_cpid: 0,
        shm_lpid: 0,
        shm_nattch: 0,
        __glibc_reserved5: 0,
        __glibc_reserved6: 0,
    };
    ReturnCode = shmctl(ResetAreaShmId, 0 as libc::c_int, &mut ShmCtrl);
    if ReturnCode == 0 as libc::c_int {
        OS_printf(
            b"Reset Area Shared memory segment removed\n\0" as *const u8 as *const libc::c_char,
        );
    } else {
        OS_printf(
            b"Error Removing Reset Area Shared memory Segment.\n\0" as *const u8
                as *const libc::c_char,
        );
        OS_printf(
            b"It can be manually checked and removed using the ipcs and ipcrm commands.\n\0"
                as *const u8 as *const libc::c_char,
        );
    };
}
#[no_mangle]
pub static mut UserShmId: libc::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_InitSSR(
    mut bus: uint32,
    mut device: uint32,
    mut DeviceName: *mut libc::c_char,
) -> int32 {
    let mut Status: int32 = 0;
    Status = -(1 as libc::c_int);
    return Status;
}
#[no_mangle]
pub static mut CFE_PSP_CpuId: uint32 = 0;
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_DisplayUsage(mut Name: *mut libc::c_char) {
    printf(
        b"usage : %s [-R <value>] [-S <value>] [-C <value] [-N <value] [-I <value] [-h] \n\0"
            as *const u8 as *const libc::c_char,
        Name,
    );
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"        All parameters are optional and can be used in any order\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    printf(b"        Parameters include:\n\0" as *const u8 as *const libc::c_char);
    printf(b"        -R [ --reset ] Reset Type is one of:\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"             PO   for Power On reset ( default )\n\0" as *const u8 as *const libc::c_char,
    );
    printf(b"             PR   for Processor Reset\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"        -S [ --subtype ] Reset Sub Type is one of\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"             1   for  Power on ( default )\n\0" as *const u8 as *const libc::c_char);
    printf(b"             2   for  Push Button Reset\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"             3   for  Hardware Special Command Reset\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(b"             4   for  Watchdog Reset\n\0" as *const u8 as *const libc::c_char);
    printf(b"             5   for  Reset Command\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"        -C [ --cpuid ]   CPU ID is an integer CPU identifier.\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"             The default  CPU ID is from the platform configuration file: %d\n\0"
            as *const u8 as *const libc::c_char,
        GLOBAL_CONFIGDATA.Default_CpuId as libc::c_int,
    );
    printf(
        b"        -N [ --cpuname ] CPU Name is a string to identify the CPU.\n\0" as *const u8
            as *const libc::c_char,
    );
    printf(
        b"             The default  CPU Name is from the platform configuration file: %s\n\0"
            as *const u8 as *const libc::c_char,
        GLOBAL_CONFIGDATA.Default_CpuName,
    );
    printf(
        b"        -I [ --scid ]    Spacecraft ID is an integer Spacecraft identifier.\n\0"
            as *const u8 as *const libc::c_char,
    );
    printf(
        b"             The default Spacecraft ID is from the mission configuration file: %d\n\0"
            as *const u8 as *const libc::c_char,
        GLOBAL_CONFIGDATA.Default_SpacecraftId as libc::c_int,
    );
    printf(b"        -h [ --help ]    This message.\n\0" as *const u8 as *const libc::c_char);
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    printf(b"       Example invocation:\n\0" as *const u8 as *const libc::c_char);
    printf(b" \n\0" as *const u8 as *const libc::c_char);
    printf(b"       Short form:\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"       %s -R PO -S 1 -C 1 -N CPU1 -I 32\n\0" as *const u8 as *const libc::c_char,
        Name,
    );
    printf(b"       Long form:\n\0" as *const u8 as *const libc::c_char);
    printf(
        b"       %s --reset PO --subtype 1 --cpuid 1 --cpuname CPU1 --scid 32\n\0" as *const u8
            as *const libc::c_char,
        Name,
    );
    printf(b" \n\0" as *const u8 as *const libc::c_char);
    exit(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_OS_EventHandler(
    mut event: OS_Event_t,
    mut object_id: osal_id_t,
    mut data: *mut libc::c_void,
) -> int32 {
    let mut taskname: [libc::c_char; 20] = [0; 20];
    let mut cpuset: cpu_set_t = cpu_set_t { __bits: [0; 16] };
    memset(
        taskname.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    match event as libc::c_uint {
        4 => {
            if OS_GetResourceName(
                object_id,
                taskname.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                if strncmp(
                    taskname.as_mut_ptr(),
                    b"CFE_\0" as *const u8 as *const libc::c_char,
                    4 as libc::c_int as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    libc::memset(
                        &mut cpuset as *mut cpu_set_t as *mut libc::c_void,
                        '\0' as i32,
                        ::core::mem::size_of::<cpu_set_t>() as libc::c_ulong as libc::size_t,
                    );
                    let mut __cpu: size_t = 0 as libc::c_int as size_t;
                    if __cpu.wrapping_div(8 as libc::c_int as libc::c_ulong)
                        < ::core::mem::size_of::<cpu_set_t>() as libc::c_ulong
                    {
                        let ref mut fresh43 = *(cpuset.__bits).as_mut_ptr().offset(
                            __cpu.wrapping_div(
                                (8 as libc::c_int as libc::c_ulong).wrapping_mul(
                                    ::core::mem::size_of::<__cpu_mask>() as libc::c_ulong,
                                ),
                            ) as isize,
                        );
                        *fresh43 |= (1 as libc::c_int as __cpu_mask)
                            << __cpu.wrapping_rem(
                                (8 as libc::c_int as libc::c_ulong).wrapping_mul(
                                    ::core::mem::size_of::<__cpu_mask>() as libc::c_ulong,
                                ),
                            );
                    } else {
                    };
                    pthread_setaffinity_np(
                        pthread_self(),
                        ::core::mem::size_of::<cpu_set_t>() as libc::c_ulong,
                        &mut cpuset,
                    );
                }
                if strlen(taskname.as_mut_ptr()) >= 16 as libc::c_int as libc::c_ulong {
                    taskname[(16 as libc::c_int - 1 as libc::c_int) as usize] =
                        0 as libc::c_int as libc::c_char;
                }
                pthread_setname_np(pthread_self(), taskname.as_mut_ptr());
            }
        }
        1 | 2 | 3 | _ => {}
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut CFE_PSP_SpacecraftId: uint32 = 0;
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_ProcessArgumentDefaults(
    mut CommandDataDefault: *mut CFE_PSP_CommandData_t,
) {
    if (*CommandDataDefault).GotSubType == 0 as libc::c_int as libc::c_uint {
        (*CommandDataDefault).SubType = 1 as libc::c_int as uint32;
        printf(b"CFE_PSP: Default Reset SubType = 1\n\0" as *const u8 as *const libc::c_char);
        (*CommandDataDefault).GotSubType = 1 as libc::c_int as uint32;
    }
    if (*CommandDataDefault).GotCpuId == 0 as libc::c_int as libc::c_uint {
        (*CommandDataDefault).CpuId = GLOBAL_CONFIGDATA.Default_CpuId as uint32;
        printf(
            b"CFE_PSP: Default CPU ID = %d\n\0" as *const u8 as *const libc::c_char,
            GLOBAL_CONFIGDATA.Default_CpuId as libc::c_int,
        );
        (*CommandDataDefault).GotCpuId = 1 as libc::c_int as uint32;
    }
    if (*CommandDataDefault).GotSpacecraftId == 0 as libc::c_int as libc::c_uint {
        (*CommandDataDefault).SpacecraftId = GLOBAL_CONFIGDATA.Default_SpacecraftId as uint32;
        printf(
            b"CFE_PSP: Default Spacecraft ID = %d\n\0" as *const u8 as *const libc::c_char,
            GLOBAL_CONFIGDATA.Default_SpacecraftId as libc::c_int,
        );
        (*CommandDataDefault).GotSpacecraftId = 1 as libc::c_int as uint32;
    }
    if (*CommandDataDefault).GotCpuName == 0 as libc::c_int as libc::c_uint {
        strncpy(
            ((*CommandDataDefault).CpuName).as_mut_ptr(),
            GLOBAL_CONFIGDATA.Default_CpuName,
            (32 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
        );
        (*CommandDataDefault).CpuName[(32 as libc::c_int - 1 as libc::c_int) as usize] =
            0 as libc::c_int as libc::c_char;
        printf(
            b"CFE_PSP: Default CPU Name: %s\n\0" as *const u8 as *const libc::c_char,
            GLOBAL_CONFIGDATA.Default_CpuName,
        );
        (*CommandDataDefault).GotCpuName = 1 as libc::c_int as uint32;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OS_Application_Run() {
    let mut sig: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut sigset: sigset_t = sigset_t { __val: [0; 16] };
    sigemptyset(&mut sigset);
    sigaddset(&mut sigset, 3 as libc::c_int);
    sigaddset(&mut sigset, 15 as libc::c_int);
    pthread_sigmask(1 as libc::c_int, &mut sigset, 0 as *mut __sigset_t);
    sigemptyset(&mut sigset);
    sigaddset(&mut sigset, 10 as libc::c_int);
    while !CFE_PSP_IdleTaskState.ShutdownReq {
        ret = sigwait(&mut sigset, &mut sig);
        if ret == 0 as libc::c_int
            && !CFE_PSP_IdleTaskState.ShutdownReq
            && sig == 10 as libc::c_int
            && (GLOBAL_CFE_CONFIGDATA.SystemNotify).is_some()
        {
            (GLOBAL_CFE_CONFIGDATA.SystemNotify).expect("non-null function pointer")();
        }
    }
    OS_printf(
        b"\nCFE_PSP: Shutdown initiated - Exiting cFE\n\0" as *const u8 as *const libc::c_char,
    );
    OS_TaskDelay(100 as libc::c_int as uint32);
    OS_DeleteAllObjects();
}
#[no_mangle]
pub static mut CommandData: CFE_PSP_CommandData_t = CFE_PSP_CommandData_t {
    ResetType: [0; 10],
    GotResetType: 0,
    SubType: 0,
    GotSubType: 0,
    CpuName: [0; 32],
    GotCpuName: 0,
    CpuId: 0,
    GotCpuId: 0,
    SpacecraftId: 0,
    GotSpacecraftId: 0,
};
static mut optString: *const libc::c_char = b"R:S:C:I:N:h\0" as *const u8 as *const libc::c_char;
#[no_mangle]
pub static mut CFE_PSP_CpuName: [libc::c_char; 32] = [0; 32];
#[no_mangle]
pub static mut TimerCounter: uint32 = 0;
#[no_mangle]
pub unsafe extern "C" fn OS_Application_Startup() {
    let mut reset_type: uint32 = 0;
    let mut reset_subtype: uint32 = 0;
    let mut fs_id: osal_id_t = 0;
    let mut opt: libc::c_int = 0 as libc::c_int;
    let mut longIndex: libc::c_int = 0 as libc::c_int;
    let mut Status: int32 = 0;
    let mut argv: *const *mut libc::c_char = 0 as *const *mut libc::c_char;
    let mut argc: libc::c_int = 0;
    memset(
        &mut CommandData as *mut CFE_PSP_CommandData_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_PSP_CommandData_t>() as libc::c_ulong,
    );
    argc = OS_BSP_GetArgC() as libc::c_int;
    argv = OS_BSP_GetArgV();
    opt = getopt_long(argc, argv, optString, longOpts.as_ptr(), &mut longIndex);
    while opt != -(1 as libc::c_int) {
        match opt {
            82 => {
                strncpy(
                    (CommandData.ResetType).as_mut_ptr(),
                    optarg,
                    (10 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
                );
                CommandData.ResetType[(10 as libc::c_int - 1 as libc::c_int) as usize] =
                    0 as libc::c_int as libc::c_char;
                if strncmp(
                    (CommandData.ResetType).as_mut_ptr(),
                    b"PO\0" as *const u8 as *const libc::c_char,
                    10 as libc::c_int as libc::c_ulong,
                ) != 0 as libc::c_int
                    && strncmp(
                        (CommandData.ResetType).as_mut_ptr(),
                        b"PR\0" as *const u8 as *const libc::c_char,
                        10 as libc::c_int as libc::c_ulong,
                    ) != 0 as libc::c_int
                {
                    printf(
                        b"\nERROR: Invalid Reset Type: %s\n\n\0" as *const u8
                            as *const libc::c_char,
                        (CommandData.ResetType).as_mut_ptr(),
                    );
                    CommandData.GotResetType = 0 as libc::c_int as uint32;
                    CFE_PSP_DisplayUsage(*argv.offset(0 as libc::c_int as isize));
                } else {
                    printf(
                        b"CFE_PSP: Reset Type: %s\n\0" as *const u8 as *const libc::c_char,
                        optarg,
                    );
                    CommandData.GotResetType = 1 as libc::c_int as uint32;
                }
            }
            83 => {
                CommandData.SubType =
                    strtol(optarg, 0 as *mut *mut libc::c_char, 0 as libc::c_int) as uint32;
                if CommandData.SubType < 1 as libc::c_int as libc::c_uint
                    || CommandData.SubType > 5 as libc::c_int as libc::c_uint
                {
                    printf(
                        b"\nERROR: Invalid Reset SubType: %s\n\n\0" as *const u8
                            as *const libc::c_char,
                        optarg,
                    );
                    CommandData.SubType = 0 as libc::c_int as uint32;
                    CommandData.GotSubType = 0 as libc::c_int as uint32;
                    CFE_PSP_DisplayUsage(*argv.offset(0 as libc::c_int as isize));
                } else {
                    printf(
                        b"CFE_PSP: Reset SubType: %d\n\0" as *const u8 as *const libc::c_char,
                        CommandData.SubType as libc::c_int,
                    );
                    CommandData.GotSubType = 1 as libc::c_int as uint32;
                }
            }
            78 => {
                strncpy(
                    (CommandData.CpuName).as_mut_ptr(),
                    optarg,
                    (32 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
                );
                CommandData.CpuName[(32 as libc::c_int - 1 as libc::c_int) as usize] =
                    0 as libc::c_int as libc::c_char;
                printf(
                    b"CFE_PSP: CPU Name: %s\n\0" as *const u8 as *const libc::c_char,
                    (CommandData.CpuName).as_mut_ptr(),
                );
                CommandData.GotCpuName = 1 as libc::c_int as uint32;
            }
            67 => {
                CommandData.CpuId =
                    strtol(optarg, 0 as *mut *mut libc::c_char, 0 as libc::c_int) as uint32;
                printf(
                    b"CFE_PSP: CPU ID: %d\n\0" as *const u8 as *const libc::c_char,
                    CommandData.CpuId as libc::c_int,
                );
                CommandData.GotCpuId = 1 as libc::c_int as uint32;
            }
            73 => {
                CommandData.SpacecraftId =
                    strtol(optarg, 0 as *mut *mut libc::c_char, 0 as libc::c_int) as uint32;
                printf(
                    b"CFE_PSP: Spacecraft ID: %d\n\0" as *const u8 as *const libc::c_char,
                    CommandData.SpacecraftId as libc::c_int,
                );
                CommandData.GotSpacecraftId = 1 as libc::c_int as uint32;
            }
            104 => {
                CFE_PSP_DisplayUsage(*argv.offset(0 as libc::c_int as isize));
            }
            _ => {
                CFE_PSP_DisplayUsage(*argv.offset(0 as libc::c_int as isize));
            }
        }
        opt = getopt_long(argc, argv, optString, longOpts.as_ptr(), &mut longIndex);
    }
    CFE_PSP_ProcessArgumentDefaults(&mut CommandData);
    CFE_PSP_SpacecraftId = CommandData.SpacecraftId;
    CFE_PSP_CpuId = CommandData.CpuId;
    strncpy(
        CFE_PSP_CpuName.as_mut_ptr(),
        (CommandData.CpuName).as_mut_ptr(),
        (::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    CFE_PSP_CpuName[(::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
        0 as libc::c_int as libc::c_char;
    reset_subtype = CommandData.SubType;
    Status = OS_API_Init();
    if Status != 0 as libc::c_int {
        printf(b"CFE_PSP: OS_API_Init() failure\n\0" as *const u8 as *const libc::c_char);
        CFE_PSP_Panic(Status);
    }
    OS_RegisterEventHandler(Some(
        CFE_PSP_OS_EventHandler
            as unsafe extern "C" fn(OS_Event_t, osal_id_t, *mut libc::c_void) -> int32,
    ));
    CFE_PSP_SetupReservedMemoryMap();
    memset(
        &mut CFE_PSP_IdleTaskState as *mut CFE_PSP_IdleTaskState_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_PSP_IdleTaskState_t>() as libc::c_ulong,
    );
    CFE_PSP_IdleTaskState.ThreadID = pthread_self();
    Status = OS_FileSysAddFixedMap(
        &mut fs_id,
        b"./cf\0" as *const u8 as *const libc::c_char,
        b"/cf\0" as *const u8 as *const libc::c_char,
    );
    if Status != 0 as libc::c_int {
        OS_printf(
            b"CFE_PSP: OS_FileSysAddFixedMap() failure: %d\n\0" as *const u8 as *const libc::c_char,
            Status,
        );
    }
    CFE_PSP_ModuleInit();
    sleep(1 as libc::c_int as libc::c_uint);
    if (*CFE_PSP_ReservedMemoryMap.BootPtr).ValidityFlag == 0x2aebe984 as libc::c_int as uint32 {
        OS_printf(
            b"CFE_PSP: Normal exit from previous cFE instance\n\0" as *const u8
                as *const libc::c_char,
        );
    } else if (*CFE_PSP_ReservedMemoryMap.BootPtr).ValidityFlag
        == !(0x2aebe984 as libc::c_int as uint32)
    {
        OS_printf(
            b"CFE_PSP: Abnormal exit from previous cFE instance\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    reset_type = 0 as libc::c_int as uint32;
    if CommandData.GotResetType == 0 {
        if (*CFE_PSP_ReservedMemoryMap.BootPtr).ValidityFlag == 0x2aebe984 as libc::c_int as uint32
            || (*CFE_PSP_ReservedMemoryMap.BootPtr).ValidityFlag
                == !(0x2aebe984 as libc::c_int as uint32)
        {
            reset_type = (*CFE_PSP_ReservedMemoryMap.BootPtr).NextResetType;
        }
    } else if strncmp(
        b"PR\0" as *const u8 as *const libc::c_char,
        (CommandData.ResetType).as_mut_ptr(),
        2 as libc::c_int as libc::c_ulong,
    ) == 0 as libc::c_int
    {
        reset_type = 1 as libc::c_int as uint32;
    }
    if reset_type == 1 as libc::c_int as libc::c_uint {
        OS_printf(
            b"CFE_PSP: Starting the cFE with a PROCESSOR reset.\n\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        reset_type = 2 as libc::c_int as uint32;
        OS_printf(
            b"CFE_PSP: Starting the cFE with a POWER ON reset.\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    Status = CFE_PSP_InitProcessorReservedMemory(reset_type);
    if Status != 0 as libc::c_int {
        OS_printf(
            b"CFE_PSP: CFE_PSP_InitProcessorReservedMemory() Failure\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_Panic(Status);
    }
    (Some(((*GLOBAL_CONFIGDATA.CfeConfig).SystemMain).expect("non-null function pointer")))
        .expect("non-null function pointer")(
        reset_type,
        reset_subtype,
        1 as libc::c_int as uint32,
        (*GLOBAL_CONFIGDATA.CfeConfig).NonvolStartupFile,
    );
}
static mut longOpts: [option; 7] = [
    {
        let mut init = option {
            name: b"reset\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'R' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"subtype\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'S' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"cpuid\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'C' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"scid\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'I' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"cpuname\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'N' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"help\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'h' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: 0 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 0 as libc::c_int,
        };
        init
    },
];
#[no_mangle]
pub static mut CFE_PSP_IdleTaskState: CFE_PSP_IdleTaskState_t = CFE_PSP_IdleTaskState_t {
    ThreadID: 0,
    ShutdownReq: false,
};
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Restart(mut resetType: uint32) {
    if resetType == 2 as libc::c_int as libc::c_uint {
        OS_printf(
            b"CFE_PSP: Exiting cFE with POWERON Reset status.\n\0" as *const u8
                as *const libc::c_char,
        );
        CFE_PSP_DeleteProcessorReservedMemory();
    } else {
        OS_printf(
            b"CFE_PSP: Exiting cFE with PROCESSOR Reset status.\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    (*CFE_PSP_ReservedMemoryMap.BootPtr).NextResetType = resetType;
    (*CFE_PSP_ReservedMemoryMap.BootPtr).ValidityFlag = 0x2aebe984 as libc::c_int as uint32;
    ::core::ptr::write_volatile(
        &mut CFE_PSP_IdleTaskState.ShutdownReq as *mut bool,
        1 as libc::c_int != 0,
    );
    pthread_kill(CFE_PSP_IdleTaskState.ThreadID, 10 as libc::c_int);
    OS_TaskDelay(10000 as libc::c_int as uint32);
    abort();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Panic(mut ErrorCode: int32) {
    OS_printf(
        b"%s called with error code = 0x%08X. Exiting.\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"CFE_PSP_Panic\0")).as_ptr(),
        ErrorCode as libc::c_uint,
    );
    OS_printf(b"The cFE could not start.\n\0" as *const u8 as *const libc::c_char);
    abort();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_FlushCaches(
    mut type_0: uint32,
    mut address: *mut libc::c_void,
    mut size: uint32,
) {
    printf(
        b"%s called -- Currently no Linux/OSX/Cygwin implementation\n\0" as *const u8
            as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"CFE_PSP_FlushCaches\0"))
            .as_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetProcessorId() -> uint32 {
    return CFE_PSP_CpuId;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetSpacecraftId() -> uint32 {
    return CFE_PSP_SpacecraftId;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetProcessorName() -> *const libc::c_char {
    return CFE_PSP_CpuName.as_mut_ptr();
}
#[no_mangle]
pub static mut CFE_PSP_WatchdogValue: uint32 = 0xffffffff as libc::c_uint;
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_WatchdogInit() {
    CFE_PSP_WatchdogValue = 0xffffffff as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_WatchdogEnable() {}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_WatchdogDisable() {}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_WatchdogService() {}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_WatchdogGet() -> uint32 {
    return CFE_PSP_WatchdogValue;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_WatchdogSet(mut WatchdogValue: uint32) {
    CFE_PSP_WatchdogValue = WatchdogValue;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_StatusToString(
    mut status: CFE_PSP_Status_t,
    mut status_string: *mut CFE_PSP_StatusString_t,
) -> *mut libc::c_char {
    let mut string: *mut libc::c_char = 0 as *mut libc::c_char;
    if !status_string.is_null() {
        snprintf(
            (*status_string).as_mut_ptr(),
            ::core::mem::size_of::<CFE_PSP_StatusString_t>() as libc::c_ulong,
            b"%ld\0" as *const u8 as *const libc::c_char,
            status as libc::c_long,
        );
        string = (*status_string).as_mut_ptr();
    }
    return string;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Exception_Reset() {
    ::core::ptr::write_volatile(
        &mut (*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumRead as *mut uint32,
        (*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumWritten,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Exception_GetBuffer(
    mut seq: uint32,
) -> *mut CFE_PSP_Exception_LogData {
    return &mut *((*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).Entries)
        .as_mut_ptr()
        .offset((seq & (4 as libc::c_int - 1 as libc::c_int) as libc::c_uint) as isize)
        as *mut CFE_PSP_Exception_LogData;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Exception_GetNextContextBuffer() -> *mut CFE_PSP_Exception_LogData
{
    let mut Buffer: *mut CFE_PSP_Exception_LogData_t = 0 as *mut CFE_PSP_Exception_LogData_t;
    let mut NextWrite: uint32 = 0;
    NextWrite = (*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumWritten;
    if NextWrite.wrapping_sub((*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumRead)
        >= 4 as libc::c_int as libc::c_uint
    {
        return 0 as *mut CFE_PSP_Exception_LogData;
    }
    Buffer = CFE_PSP_Exception_GetBuffer(NextWrite);
    memset(
        Buffer as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_PSP_Exception_LogData_t>() as libc::c_ulong,
    );
    (*Buffer).context_id = (((0x10 as libc::c_int + 0x101 as libc::c_int) << 16 as libc::c_int)
        as libc::c_uint)
        .wrapping_add(NextWrite & 0xffff as libc::c_int as libc::c_uint);
    return Buffer;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Exception_WriteComplete() {
    let mut Buffer: *mut CFE_PSP_Exception_LogData_t = 0 as *mut CFE_PSP_Exception_LogData_t;
    ::core::ptr::write_volatile(
        &mut (*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumWritten as *mut uint32,
        (::core::ptr::read_volatile::<uint32>(
            &(*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumWritten as *const uint32,
        ))
        .wrapping_add(1),
    );
    ::core::ptr::read_volatile::<uint32>(
        &(*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumWritten as *const uint32,
    );
    Buffer =
        CFE_PSP_Exception_GetBuffer((*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumWritten);
    (*Buffer).context_id = 0 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Exception_GetCount() -> uint32 {
    return ((*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumWritten)
        .wrapping_sub((*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumRead);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Exception_GetSummary(
    mut ContextLogId: *mut uint32,
    mut TaskId: *mut osal_id_t,
    mut ReasonBuf: *mut libc::c_char,
    mut ReasonSize: uint32,
) -> int32 {
    let mut Buffer: *const CFE_PSP_Exception_LogData_t = 0 as *const CFE_PSP_Exception_LogData_t;
    let mut NumStored: uint32 = 0;
    let mut Status: int32 = 0;
    NumStored = CFE_PSP_Exception_GetCount();
    if NumStored == 0 as libc::c_int as libc::c_uint {
        return -(30 as libc::c_int);
    }
    Buffer = CFE_PSP_Exception_GetBuffer((*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumRead);
    if !ContextLogId.is_null() {
        *ContextLogId = (*Buffer).context_id;
    }
    if !TaskId.is_null() {
        Status = OS_TaskFindIdBySystemData(
            TaskId,
            &(*Buffer).sys_task_id as *const CFE_PSP_Exception_SysTaskId_t as *const libc::c_void,
            ::core::mem::size_of::<CFE_PSP_Exception_SysTaskId_t>() as libc::c_ulong,
        );
        if Status != 0 as libc::c_int {
            *TaskId = 0 as libc::c_int as osal_id_t;
        }
    }
    if !ReasonBuf.is_null() && ReasonSize > 0 as libc::c_int as libc::c_uint {
        Status = CFE_PSP_ExceptionGetSummary_Impl(Buffer, ReasonBuf, ReasonSize);
        if Status != 0 as libc::c_int {
            *ReasonBuf.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
        }
    }
    ::core::ptr::write_volatile(
        &mut (*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumRead as *mut uint32,
        (::core::ptr::read_volatile::<uint32>(
            &(*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumRead as *const uint32,
        ))
        .wrapping_add(1),
    );
    ::core::ptr::read_volatile::<uint32>(
        &(*CFE_PSP_ReservedMemoryMap.ExceptionStoragePtr).NumRead as *const uint32,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Exception_CopyContext(
    mut ContextLogId: uint32,
    mut ContextBuf: *mut libc::c_void,
    mut ContextSize: uint32,
) -> int32 {
    let mut Buffer: *const CFE_PSP_Exception_LogData_t = 0 as *const CFE_PSP_Exception_LogData_t;
    let mut SeqId: uint32 = 0;
    let mut ActualSize: uint32 = 0;
    SeqId = ContextLogId.wrapping_sub(
        ((0x10 as libc::c_int + 0x101 as libc::c_int) << 16 as libc::c_int) as libc::c_uint,
    );
    if SeqId > 0xffff as libc::c_int as libc::c_uint {
        return -(30 as libc::c_int);
    }
    Buffer = CFE_PSP_Exception_GetBuffer(SeqId);
    if (*Buffer).context_id != ContextLogId {
        return -(30 as libc::c_int);
    }
    if ContextSize >= (*Buffer).context_size {
        ActualSize = (*Buffer).context_size;
    } else {
        OS_printf(
            b"CFE_PSP: Insufficient buffer for exception context, total=%lu bytes, saved=%lu\n\0"
                as *const u8 as *const libc::c_char,
            (*Buffer).context_size as libc::c_ulong,
            ContextSize as libc::c_ulong,
        );
        ActualSize = ContextSize;
    }
    memcpy(
        ContextBuf,
        &(*Buffer).context_info as *const CFE_PSP_Exception_ContextDataEntry_t
            as *const libc::c_void,
        ActualSize as libc::c_ulong,
    );
    return ActualSize as int32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemValidateRange(
    mut Address: cpuaddr,
    mut Size: size_t,
    mut MemoryType: uint32,
) -> int32 {
    let mut StartAddressToTest: cpuaddr = Address;
    let mut EndAddressToTest: cpuaddr = Address
        .wrapping_add(Size)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong);
    let mut StartAddressInTable: cpuaddr = 0;
    let mut EndAddressInTable: cpuaddr = 0;
    let mut TypeInTable: uint32 = 0;
    let mut ReturnCode: int32 = -(21 as libc::c_int);
    let mut i: size_t = 0;
    let mut SysMemPtr: *mut CFE_PSP_MemTable_t = 0 as *mut CFE_PSP_MemTable_t;
    if MemoryType != 3 as libc::c_int as libc::c_uint
        && MemoryType != 1 as libc::c_int as libc::c_uint
        && MemoryType != 2 as libc::c_int as libc::c_uint
    {
        return -(22 as libc::c_int);
    }
    if EndAddressToTest < StartAddressToTest {
        return -(23 as libc::c_int);
    }
    SysMemPtr = (CFE_PSP_ReservedMemoryMap.SysMemoryTable).as_mut_ptr();
    i = 0 as libc::c_int as size_t;
    while i < 10 as libc::c_int as libc::c_ulong {
        if (*SysMemPtr).MemoryType != 4 as libc::c_int as libc::c_uint {
            StartAddressInTable = (*SysMemPtr).StartAddr;
            EndAddressInTable = ((*SysMemPtr).StartAddr)
                .wrapping_add((*SysMemPtr).Size)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong);
            TypeInTable = (*SysMemPtr).MemoryType;
            if StartAddressToTest >= StartAddressInTable && StartAddressToTest <= EndAddressInTable
            {
                if EndAddressToTest <= EndAddressInTable {
                    if MemoryType == 3 as libc::c_int as libc::c_uint {
                        ReturnCode = 0 as libc::c_int;
                        break;
                    } else if MemoryType == 1 as libc::c_int as libc::c_uint
                        && TypeInTable == 1 as libc::c_int as libc::c_uint
                    {
                        ReturnCode = 0 as libc::c_int;
                        break;
                    } else if MemoryType == 2 as libc::c_int as libc::c_uint
                        && TypeInTable == 2 as libc::c_int as libc::c_uint
                    {
                        ReturnCode = 0 as libc::c_int;
                        break;
                    } else {
                        ReturnCode = -(22 as libc::c_int);
                    }
                } else {
                    ReturnCode = -(23 as libc::c_int);
                }
            } else {
                ReturnCode = -(21 as libc::c_int);
            }
        }
        SysMemPtr = SysMemPtr.offset(1);
        SysMemPtr;
        i = i.wrapping_add(1);
        i;
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemRanges() -> uint32 {
    return 10 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemRangeSet(
    mut RangeNum: uint32,
    mut MemoryType: uint32,
    mut StartAddr: cpuaddr,
    mut Size: size_t,
    mut WordSize: size_t,
    mut Attributes: uint32,
) -> int32 {
    let mut SysMemPtr: *mut CFE_PSP_MemTable_t = 0 as *mut CFE_PSP_MemTable_t;
    if RangeNum >= 10 as libc::c_int as libc::c_uint {
        return -(23 as libc::c_int);
    }
    if MemoryType != 1 as libc::c_int as libc::c_uint
        && MemoryType != 2 as libc::c_int as libc::c_uint
    {
        return -(22 as libc::c_int);
    }
    if WordSize != 0x1 as libc::c_int as libc::c_ulong
        && WordSize != 0x2 as libc::c_int as libc::c_ulong
        && WordSize != 0x4 as libc::c_int as libc::c_ulong
    {
        return -(24 as libc::c_int);
    }
    if Attributes != 0x2 as libc::c_int as libc::c_uint
        && Attributes != 0x1 as libc::c_int as libc::c_uint
        && Attributes != 0x3 as libc::c_int as libc::c_uint
    {
        return -(26 as libc::c_int);
    }
    SysMemPtr = &mut *(CFE_PSP_ReservedMemoryMap.SysMemoryTable)
        .as_mut_ptr()
        .offset(RangeNum as isize) as *mut CFE_PSP_MemTable_t;
    (*SysMemPtr).MemoryType = MemoryType;
    (*SysMemPtr).StartAddr = StartAddr;
    (*SysMemPtr).Size = Size;
    (*SysMemPtr).WordSize = WordSize;
    (*SysMemPtr).Attributes = Attributes;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemRangeGet(
    mut RangeNum: uint32,
    mut MemoryType: *mut uint32,
    mut StartAddr: *mut cpuaddr,
    mut Size: *mut size_t,
    mut WordSize: *mut size_t,
    mut Attributes: *mut uint32,
) -> int32 {
    let mut SysMemPtr: *mut CFE_PSP_MemTable_t = 0 as *mut CFE_PSP_MemTable_t;
    if MemoryType.is_null()
        || StartAddr.is_null()
        || Size.is_null()
        || WordSize.is_null()
        || Attributes.is_null()
    {
        return -(2 as libc::c_int);
    }
    if RangeNum >= 10 as libc::c_int as libc::c_uint {
        return -(23 as libc::c_int);
    }
    SysMemPtr = &mut *(CFE_PSP_ReservedMemoryMap.SysMemoryTable)
        .as_mut_ptr()
        .offset(RangeNum as isize) as *mut CFE_PSP_MemTable_t;
    *MemoryType = (*SysMemPtr).MemoryType;
    *StartAddr = (*SysMemPtr).StartAddr;
    *Size = (*SysMemPtr).Size;
    *WordSize = (*SysMemPtr).WordSize;
    *Attributes = (*SysMemPtr).Attributes;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemCpy(
    mut dest: *mut libc::c_void,
    mut src: *const libc::c_void,
    mut n: uint32,
) -> int32 {
    memcpy(dest, src, n as libc::c_ulong);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemSet(
    mut dest: *mut libc::c_void,
    mut value: uint8,
    mut n: uint32,
) -> int32 {
    memset(dest, value as libc::c_int, n as size_t);
    return 0 as libc::c_int;
}
static mut CFE_PSP_ConfigPspModuleListLength: uint32 = 0 as libc::c_int as uint32;
static mut CFE_PSP_StandardPspModuleListLength: uint32 = 0 as libc::c_int as uint32;
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_ModuleInitList(
    mut BaseId: uint32,
    mut ListPtr: *const CFE_StaticModuleLoadEntry_t,
) -> uint32_t {
    let mut Entry: *const CFE_StaticModuleLoadEntry_t = 0 as *const CFE_StaticModuleLoadEntry_t;
    let mut ApiPtr: *const CFE_PSP_ModuleApi_t = 0 as *const CFE_PSP_ModuleApi_t;
    let mut ModuleCount: uint32 = 0;
    let mut ModuleId: uint32 = 0;
    Entry = ListPtr;
    ModuleCount = 0 as libc::c_int as uint32;
    if !Entry.is_null() {
        while !((*Entry).Name).is_null() {
            ApiPtr = (*Entry).Api as *const CFE_PSP_ModuleApi_t;
            ModuleId = BaseId.wrapping_add(ModuleCount);
            if (*ApiPtr).ModuleType as uint32
                != CFE_PSP_MODULE_TYPE_INVALID as libc::c_int as libc::c_uint
                && ((*ApiPtr).Init).is_some()
            {
                printf(
                    b"CFE_PSP: initializing module '%s' with ID %08lx\n\0" as *const u8
                        as *const libc::c_char,
                    (*Entry).Name,
                    ModuleId as libc::c_ulong,
                );
                (Some(((*ApiPtr).Init).expect("non-null function pointer")))
                    .expect("non-null function pointer")(ModuleId);
            }
            Entry = Entry.offset(1);
            Entry;
            ModuleCount = ModuleCount.wrapping_add(1);
            ModuleCount;
        }
    }
    return ModuleCount;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_ModuleInit() {
    CFE_PSP_StandardPspModuleListLength = CFE_PSP_ModuleInitList(
        (((0x10 as libc::c_int + 0x100 as libc::c_int) << 16 as libc::c_int
            | 0xffff as libc::c_int)
            & !(0xff as libc::c_int)) as uint32,
        CFE_PSP_BASE_MODULE_LIST.as_ptr(),
    );
    CFE_PSP_ConfigPspModuleListLength = CFE_PSP_ModuleInitList(
        ((0x10 as libc::c_int + 0x100 as libc::c_int) << 16 as libc::c_int) as uint32,
        GLOBAL_CONFIGDATA.PspModuleList,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Module_GetAPIEntry(
    mut PspModuleId: uint32,
    mut API: *mut *const CFE_PSP_ModuleApi_t,
) -> int32 {
    let mut Result: int32 = 0;
    let mut LocalId: uint32 = 0;
    Result = -(29 as libc::c_int);
    if PspModuleId & !(0xffff as libc::c_int) as libc::c_uint
        == ((0x10 as libc::c_int + 0x100 as libc::c_int) << 16 as libc::c_int) as libc::c_uint
    {
        if PspModuleId & 0xffff as libc::c_int as libc::c_uint
            >= 0xff00 as libc::c_int as libc::c_uint
        {
            LocalId = PspModuleId & 0xff as libc::c_int as libc::c_uint;
            if LocalId < CFE_PSP_StandardPspModuleListLength {
                *API = CFE_PSP_BASE_MODULE_LIST[LocalId as usize].Api as *const CFE_PSP_ModuleApi_t;
                Result = 0 as libc::c_int;
            }
        } else {
            LocalId = PspModuleId & 0xffff as libc::c_int as libc::c_uint;
            if LocalId < CFE_PSP_ConfigPspModuleListLength {
                *API = (*(GLOBAL_CONFIGDATA.PspModuleList).offset(LocalId as isize)).Api
                    as *const CFE_PSP_ModuleApi_t;
                Result = 0 as libc::c_int;
            }
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Module_FindByName(
    mut ModuleName: *const libc::c_char,
    mut PspModuleId: *mut uint32,
) -> int32 {
    let mut i: uint32 = 0;
    let mut Result: int32 = 0;
    let mut Entry: *const CFE_StaticModuleLoadEntry_t = 0 as *const CFE_StaticModuleLoadEntry_t;
    Entry = GLOBAL_CONFIGDATA.PspModuleList;
    Result = -(28 as libc::c_int);
    i = 0 as libc::c_int as uint32;
    while i < CFE_PSP_ConfigPspModuleListLength {
        if strcmp((*Entry).Name, ModuleName) == 0 as libc::c_int {
            *PspModuleId = ((0x10 as libc::c_int + 0x100 as libc::c_int) << 16 as libc::c_int)
                as libc::c_uint
                | i & 0xffff as libc::c_int as libc::c_uint;
            Result = 0 as libc::c_int;
            break;
        } else {
            Entry = Entry.offset(1);
            Entry;
            i = i.wrapping_add(1);
            i;
        }
    }
    if Result != 0 as libc::c_int {
        Entry = CFE_PSP_BASE_MODULE_LIST.as_ptr();
        i = 0 as libc::c_int as uint32;
        while i < CFE_PSP_StandardPspModuleListLength {
            if strcmp((*Entry).Name, ModuleName) == 0 as libc::c_int {
                *PspModuleId = (((0x10 as libc::c_int + 0x100 as libc::c_int) << 16 as libc::c_int
                    | 0xffff as libc::c_int)
                    & !(0xff as libc::c_int)) as libc::c_uint
                    | i & 0xffff as libc::c_int as libc::c_uint;
                Result = 0 as libc::c_int;
                break;
            } else {
                Entry = Entry.offset(1);
                Entry;
                i = i.wrapping_add(1);
                i;
            }
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetVersionString() -> *const libc::c_char {
    return b"equuleus-rc1+dev38\0" as *const u8 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetVersionCodeName() -> *const libc::c_char {
    return b"Equuleus\0" as *const u8 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetVersionNumber(mut VersionNumbers: *mut uint8) {
    *VersionNumbers.offset(0 as libc::c_int as isize) = 1 as libc::c_int as uint8;
    *VersionNumbers.offset(1 as libc::c_int as isize) = 4 as libc::c_int as uint8;
    *VersionNumbers.offset(2 as libc::c_int as isize) = 0 as libc::c_int as uint8;
    *VersionNumbers.offset(3 as libc::c_int as isize) = 0xff as libc::c_int as uint8;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetBuildNumber() -> uint32 {
    return 38 as libc::c_int as uint32;
}
#[no_mangle]
pub static mut CFE_PSP_soft_timebase_API: CFE_PSP_ModuleApi_t = unsafe {
    {
        let mut init = CFE_PSP_ModuleApi_t {
            ModuleType: CFE_PSP_MODULE_TYPE_SIMPLE,
            OperationFlags: 0 as libc::c_int as uint32,
            Init: Some(soft_timebase_Init as unsafe extern "C" fn(uint32) -> ()),
            ExtendedApi: 0 as *const libc::c_void,
        };
        init
    }
};
static mut PSP_SoftTimebase_Global: C2RustUnnamed_28 = C2RustUnnamed_28 { sys_timebase_id: 0 };
#[no_mangle]
pub unsafe extern "C" fn soft_timebase_Init(mut PspModuleId: uint32) {
    let mut status: int32 = 0;
    memset(
        &mut PSP_SoftTimebase_Global as *mut C2RustUnnamed_28 as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<C2RustUnnamed_28>() as libc::c_ulong,
    );
    status = OS_TimeBaseCreate(
        &mut PSP_SoftTimebase_Global.sys_timebase_id,
        b"cFS-Master\0" as *const u8 as *const libc::c_char,
        None,
    );
    if status == 0 as libc::c_int {
        status = OS_TimeBaseSet(
            PSP_SoftTimebase_Global.sys_timebase_id,
            10000 as libc::c_int as uint32,
            10000 as libc::c_int as uint32,
        );
    }
    if status != 0 as libc::c_int {
        printf(
            b"CFE_PSP: *** Failed to configure software timebase '%s', status = %d! ***\n\0"
                as *const u8 as *const libc::c_char,
            b"cFS-Master\0" as *const u8 as *const libc::c_char,
            status,
        );
    } else {
        printf(
            b"CFE_PSP: Instantiated software timebase '%s' running at %lu usec\n\0" as *const u8
                as *const libc::c_char,
            b"cFS-Master\0" as *const u8 as *const libc::c_char,
            10000 as libc::c_int as libc::c_ulong,
        );
    };
}
#[no_mangle]
pub static mut CFE_PSP_timebase_posix_clock_API: CFE_PSP_ModuleApi_t = unsafe {
    {
        let mut init = CFE_PSP_ModuleApi_t {
            ModuleType: CFE_PSP_MODULE_TYPE_SIMPLE,
            OperationFlags: 0 as libc::c_int as uint32,
            Init: Some(timebase_posix_clock_Init as unsafe extern "C" fn(uint32) -> ()),
            ExtendedApi: 0 as *const libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn timebase_posix_clock_Init(mut PspModuleId: uint32) {
    printf(
        b"CFE_PSP: Using POSIX monotonic clock as CFE timebase\n\0" as *const u8
            as *const libc::c_char,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_Get_Timebase(mut Tbu: *mut uint32, mut Tbl: *mut uint32) {
    let mut now: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    if clock_gettime(1 as libc::c_int, &mut now) != 0 as libc::c_int {
        now.tv_sec = 0 as libc::c_int as __time_t;
        now.tv_nsec = 0 as libc::c_int as __syscall_slong_t;
    }
    *Tbu = (now.tv_sec & 0xffffffff as libc::c_uint as libc::c_long) as uint32;
    *Tbl = now.tv_nsec as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetTime(mut LocalTime: *mut OS_time_t) {
    let mut now: timespec = timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    if clock_gettime(1 as libc::c_int, &mut now) != 0 as libc::c_int {
        now.tv_sec = 0 as libc::c_int as __time_t;
        now.tv_nsec = 0 as libc::c_int as __syscall_slong_t;
    }
    *LocalTime = OS_TimeAssembleFromNanoseconds(now.tv_sec, now.tv_nsec as uint32);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetTimerTicksPerSecond() -> uint32 {
    return 1000000000 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_GetTimerLow32Rollover() -> uint32 {
    return 1000000000 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_EepromWrite8(
    mut MemoryAddress: cpuaddr,
    mut ByteValue: uint8,
) -> int32 {
    *(MemoryAddress as *mut uint8) = ByteValue;
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut CFE_PSP_eeprom_mmap_file_API: CFE_PSP_ModuleApi_t = unsafe {
    {
        let mut init = CFE_PSP_ModuleApi_t {
            ModuleType: CFE_PSP_MODULE_TYPE_SIMPLE,
            OperationFlags: 0 as libc::c_int as uint32,
            Init: Some(eeprom_mmap_file_Init as unsafe extern "C" fn(uint32) -> ()),
            ExtendedApi: 0 as *const libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_SetupEEPROM(
    mut EEPROMSize: uint32,
    mut EEPROMAddress: *mut cpuaddr,
) -> int32 {
    let mut FileDescriptor: libc::c_int = 0;
    let mut ReturnStatus: libc::c_int = 0;
    let mut DataBuffer: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut StatBuf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_mtim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        st_ctim: timespec {
            tv_sec: 0,
            tv_nsec: 0,
        },
        __glibc_reserved: [0; 3],
    };
    ReturnStatus = stat(
        b"EEPROM.DAT\0" as *const u8 as *const libc::c_char,
        &mut StatBuf,
    );
    if ReturnStatus == -(1 as libc::c_int) {
        FileDescriptor = open(
            b"EEPROM.DAT\0" as *const u8 as *const libc::c_char,
            0o2 as libc::c_int | 0o100 as libc::c_int,
            0o400 as libc::c_int | 0o200 as libc::c_int | 0o100 as libc::c_int,
        );
        if FileDescriptor == -(1 as libc::c_int) {
            OS_printf(
                b"CFE_PSP: Cannot open EEPROM File: %s\n\0" as *const u8 as *const libc::c_char,
                b"EEPROM.DAT\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        } else {
            if lseek(
                FileDescriptor,
                EEPROMSize.wrapping_sub(1 as libc::c_int as libc::c_uint) as __off_t,
                0 as libc::c_int,
            ) == -(1 as libc::c_int) as libc::c_long
            {
                OS_printf(
                    b"CFE_PSP: Cannot Seek to end of EEPROM file.\n\0" as *const u8
                        as *const libc::c_char,
                );
                close(FileDescriptor);
                return -(1 as libc::c_int);
            }
            if write(
                FileDescriptor,
                b"\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                1 as libc::c_int as size_t,
            ) != 1 as libc::c_int as libc::c_long
            {
                OS_printf(
                    b"CFE_PSP: Cannot write to EEPROM file\n\0" as *const u8 as *const libc::c_char,
                );
                close(FileDescriptor);
                return -(1 as libc::c_int);
            }
        }
    } else {
        FileDescriptor = open(
            b"EEPROM.DAT\0" as *const u8 as *const libc::c_char,
            0o2 as libc::c_int,
        );
        if FileDescriptor == -(1 as libc::c_int) {
            OS_printf(
                b"CFE_PSP: Cannot open EEPROM File: %s\n\0" as *const u8 as *const libc::c_char,
                b"EEPROM.DAT\0" as *const u8 as *const libc::c_char,
            );
            perror(b"CFE_PSP: open\0" as *const u8 as *const libc::c_char);
            return -(1 as libc::c_int);
        }
    }
    DataBuffer = mmap(
        0 as *mut libc::c_void,
        EEPROMSize as size_t,
        0x1 as libc::c_int | 0x2 as libc::c_int,
        0x1 as libc::c_int,
        FileDescriptor,
        0 as libc::c_int as __off_t,
    ) as *mut libc::c_char;
    if DataBuffer == -(1 as libc::c_int) as *mut libc::c_void as *mut libc::c_char {
        OS_printf(b"CFE_PSP: mmap to EEPROM File failed\n\0" as *const u8 as *const libc::c_char);
        close(FileDescriptor);
        return -(1 as libc::c_int);
    }
    *EEPROMAddress = DataBuffer as cpuaddr;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_EepromWrite32(
    mut MemoryAddress: cpuaddr,
    mut uint32Value: uint32,
) -> int32 {
    *(MemoryAddress as *mut uint32) = uint32Value;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_EepromWrite16(
    mut MemoryAddress: cpuaddr,
    mut uint16Value: uint16,
) -> int32 {
    *(MemoryAddress as *mut uint16) = uint16Value;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_EepromWriteEnable(mut Bank: uint32) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_EepromWriteDisable(mut Bank: uint32) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_EepromPowerUp(mut Bank: uint32) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_EepromPowerDown(mut Bank: uint32) -> int32 {
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn eeprom_mmap_file_Init(mut PspModuleId: uint32) {
    let mut Status: int32 = 0;
    let mut eeprom_address: cpuaddr = 0;
    let mut eeprom_size: uint32 = 0;
    printf(
        b"CFE_PSP: Using MMAP simulated EEPROM implementation\n\0" as *const u8
            as *const libc::c_char,
    );
    eeprom_size = 0x80000 as libc::c_int as uint32;
    Status = CFE_PSP_SetupEEPROM(eeprom_size, &mut eeprom_address);
    if Status == 0 as libc::c_int {
        Status = CFE_PSP_MemRangeSet(
            1 as libc::c_int as uint32,
            2 as libc::c_int as uint32,
            eeprom_address,
            eeprom_size as size_t,
            0x4 as libc::c_int as size_t,
            0x3 as libc::c_int as uint32,
        );
        OS_printf(
            b"CFE_PSP: EEPROM Range (2) created: Start Address = %08lX, Size = %08X Status = %d\n\0"
                as *const u8 as *const libc::c_char,
            eeprom_address,
            eeprom_size,
            Status,
        );
    } else {
        OS_printf(
            b"CFE_PSP: Cannot create EEPROM Range from Memory Mapped file.\n\0" as *const u8
                as *const libc::c_char,
        );
    };
}
#[no_mangle]
pub static mut CFE_PSP_ram_notimpl_API: CFE_PSP_ModuleApi_t = unsafe {
    {
        let mut init = CFE_PSP_ModuleApi_t {
            ModuleType: CFE_PSP_MODULE_TYPE_SIMPLE,
            OperationFlags: 0 as libc::c_int as uint32,
            Init: Some(ram_notimpl_Init as unsafe extern "C" fn(uint32) -> ()),
            ExtendedApi: 0 as *const libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn ram_notimpl_Init(mut PspModuleId: uint32) {
    printf(b"CFE_PSP: Physical RAM access not implemented\n\0" as *const u8 as *const libc::c_char);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemRead8(
    mut MemoryAddress: cpuaddr,
    mut ByteValue: *mut uint8,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemWrite8(
    mut MemoryAddress: cpuaddr,
    mut ByteValue: uint8,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemRead16(
    mut MemoryAddress: cpuaddr,
    mut uint16Value: *mut uint16,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemWrite16(
    mut MemoryAddress: cpuaddr,
    mut uint16Value: uint16,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemRead32(
    mut MemoryAddress: cpuaddr,
    mut uint32Value: *mut uint32,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_MemWrite32(
    mut MemoryAddress: cpuaddr,
    mut uint32Value: uint32,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub static mut CFE_PSP_port_notimpl_API: CFE_PSP_ModuleApi_t = unsafe {
    {
        let mut init = CFE_PSP_ModuleApi_t {
            ModuleType: CFE_PSP_MODULE_TYPE_SIMPLE,
            OperationFlags: 0 as libc::c_int as uint32,
            Init: Some(port_notimpl_Init as unsafe extern "C" fn(uint32) -> ()),
            ExtendedApi: 0 as *const libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn port_notimpl_Init(mut PspModuleId: uint32) {
    printf(b"CFE_PSP: I/O Port access not implemented\n\0" as *const u8 as *const libc::c_char);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_PortRead8(
    mut PortAddress: cpuaddr,
    mut ByteValue: *mut uint8,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_PortWrite8(
    mut PortAddress: cpuaddr,
    mut ByteValue: uint8,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_PortRead16(
    mut PortAddress: cpuaddr,
    mut uint16Value: *mut uint16,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_PortWrite16(
    mut PortAddress: cpuaddr,
    mut uint16Value: uint16,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_PortRead32(
    mut PortAddress: cpuaddr,
    mut uint32Value: *mut uint32,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_PortWrite32(
    mut PortAddress: cpuaddr,
    mut uint32Value: uint32,
) -> int32 {
    return -(27 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_IODriver_FindByName(
    mut DriverName: *const libc::c_char,
    mut PspModuleId: *mut uint32,
) -> int32 {
    let mut Result: int32 = 0;
    let mut API: *const CFE_PSP_ModuleApi_t = 0 as *const CFE_PSP_ModuleApi_t;
    Result = CFE_PSP_Module_FindByName(DriverName, PspModuleId);
    if Result == 0 as libc::c_int {
        Result = CFE_PSP_Module_GetAPIEntry(*PspModuleId, &mut API);
        if Result == 0 as libc::c_int
            && (*API).ModuleType as libc::c_uint
                != CFE_PSP_MODULE_TYPE_DEVICEDRIVER as libc::c_int as libc::c_uint
        {
            Result = -(28 as libc::c_int);
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_IODriver_Command(
    mut Location: *const CFE_PSP_IODriver_Location_t,
    mut CommandCode: uint32,
    mut Arg: CFE_PSP_IODriver_Arg_t,
) -> int32 {
    let mut Result: int32 = 0;
    let mut MutexId: osal_id_t = 0;
    let mut API: *const CFE_PSP_IODriver_API_t = 0 as *const CFE_PSP_IODriver_API_t;
    API = CFE_PSP_IODriver_GetAPI((*Location).PspModuleId);
    if ((*API).DeviceCommand).is_some() {
        if ((*API).DeviceMutex).is_some() {
            MutexId = CFE_PSP_IODriver_GetMutex(
                (*Location).PspModuleId,
                ((*API).DeviceMutex).expect("non-null function pointer")(
                    CommandCode,
                    (*Location).SubsystemId,
                    (*Location).SubchannelId,
                    Arg,
                ),
            );
        } else {
            MutexId = 0 as libc::c_int as osal_id_t;
        }
        if OS_ObjectIdDefined(MutexId) {
            OS_MutSemTake(MutexId);
        }
        Result = ((*API).DeviceCommand).expect("non-null function pointer")(
            CommandCode,
            (*Location).SubsystemId,
            (*Location).SubchannelId,
            Arg,
        );
        if OS_ObjectIdDefined(MutexId) {
            OS_MutSemGive(MutexId);
        }
    } else {
        Result = -(27 as libc::c_int);
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_IODriver_GetMutex(
    mut PspModuleId: uint32,
    mut DeviceHash: int32,
) -> osal_id_t {
    let mut LookupId: uint32 = 0;
    let mut ResultId: osal_id_t = 0;
    if DeviceHash < 0 as libc::c_int {
        ResultId = 0 as libc::c_int as osal_id_t;
    } else {
        LookupId = DeviceHash as uint32;
        if PspModuleId != 0 as libc::c_int as libc::c_uint {
            LookupId ^= PspModuleId;
        }
        ResultId = CFE_PSP_IODriver_Mutex_Table
            [LookupId.wrapping_rem(7 as libc::c_int as libc::c_uint) as usize];
    }
    return ResultId;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_IODriver_GetAPI(
    mut PspModuleId: uint32,
) -> *const CFE_PSP_IODriver_API_t {
    let mut Result: int32 = 0;
    let mut API: *const CFE_PSP_ModuleApi_t = 0 as *const CFE_PSP_ModuleApi_t;
    let mut CFE_PSP_IODriver_API: *const CFE_PSP_IODriver_API_t =
        0 as *const CFE_PSP_IODriver_API_t;
    Result = CFE_PSP_Module_GetAPIEntry(PspModuleId, &mut API);
    if Result == 0 as libc::c_int
        && (*API).ModuleType as libc::c_uint
            == CFE_PSP_MODULE_TYPE_DEVICEDRIVER as libc::c_int as libc::c_uint
    {
        CFE_PSP_IODriver_API = (*API).ExtendedApi as *const CFE_PSP_IODriver_API_t;
    } else {
        CFE_PSP_IODriver_API = &CFE_PSP_IODriver_DEFAULT_API;
    }
    return CFE_PSP_IODriver_API;
}
#[no_mangle]
pub static mut CFE_PSP_IODriver_DEFAULT_API: CFE_PSP_IODriver_API_t = {
    let mut init = CFE_PSP_IODriver_API_t {
        DeviceCommand: None,
        DeviceMutex: None,
    };
    init
};
#[no_mangle]
pub unsafe extern "C" fn CFE_PSP_IODriver_HashMutex(
    mut StartHash: int32,
    mut Datum: int32,
) -> int32 {
    Datum *= 0x10ab as libc::c_int;
    return StartHash + Datum & 0x7fffffff as libc::c_int;
}
static mut CFE_PSP_IODriver_Mutex_Table: [osal_id_t; 7] = [0; 7];
#[no_mangle]
pub unsafe extern "C" fn iodriver_Init(mut PspModuleId: uint32) {
    let mut i: uint32 = 0;
    let mut TempName: [libc::c_char; 64] = [0; 64];
    i = 0 as libc::c_int as uint32;
    while i < 7 as libc::c_int as libc::c_uint {
        snprintf(
            TempName.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"DriverMutex-%02u\0" as *const u8 as *const libc::c_char,
            i.wrapping_add(1 as libc::c_int as libc::c_uint),
        );
        OS_MutSemCreate(
            &mut *CFE_PSP_IODriver_Mutex_Table.as_mut_ptr().offset(i as isize),
            TempName.as_mut_ptr(),
            0 as libc::c_int as uint32,
        );
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub static mut CFE_PSP_iodriver_API: CFE_PSP_ModuleApi_t = unsafe {
    {
        let mut init = CFE_PSP_ModuleApi_t {
            ModuleType: CFE_PSP_MODULE_TYPE_SIMPLE,
            OperationFlags: 0 as libc::c_int as uint32,
            Init: Some(iodriver_Init as unsafe extern "C" fn(uint32) -> ()),
            ExtendedApi: 0 as *const libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub static mut linux_sysmon_DevApi: CFE_PSP_IODriver_API_t = unsafe {
    {
        let mut init = CFE_PSP_IODriver_API_t {
            DeviceCommand: Some(
                linux_sysmon_DevCmd
                    as unsafe extern "C" fn(
                        uint32_t,
                        uint16_t,
                        uint16_t,
                        CFE_PSP_IODriver_Arg_t,
                    ) -> int32_t,
            ),
            DeviceMutex: None,
        };
        init
    }
};
#[no_mangle]
pub static mut CFE_PSP_linux_sysmon_API: CFE_PSP_ModuleApi_t = unsafe {
    {
        let mut init = CFE_PSP_ModuleApi_t {
            ModuleType: CFE_PSP_MODULE_TYPE_DEVICEDRIVER,
            OperationFlags: 0 as libc::c_int as uint32,
            Init: Some(linux_sysmon_Init as unsafe extern "C" fn(uint32_t) -> ()),
            ExtendedApi: &linux_sysmon_DevApi as *const CFE_PSP_IODriver_API_t
                as *const libc::c_void,
        };
        init
    }
};
static mut linux_sysmon_global: linux_sysmon_state_t = linux_sysmon_state_t {
    local_module_id: 0,
    cpu_load: linux_sysmon_cpuload_state_t {
        is_running: false,
        should_run: false,
        num_cpus: 0,
        task_id: 0,
        dev_fd: 0,
        num_samples: 0,
        last_sample_time: 0,
        per_core: [linux_sysmon_cpuload_core_t {
            avg_load: 0,
            last_run_time: 0,
        }; 128],
    },
};
static mut linux_sysmon_subsystem_names: [*const libc::c_char; 3] = [
    b"aggregate\0" as *const u8 as *const libc::c_char,
    b"per-cpu\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
];
static mut linux_sysmon_subchannel_names: [*const libc::c_char; 2] = [
    b"cpu-load\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
];
unsafe extern "C" fn linux_sysmon_Init(mut local_module_id: uint32_t) {
    memset(
        &mut linux_sysmon_global as *mut linux_sysmon_state_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<linux_sysmon_state_t>() as libc::c_ulong,
    );
    linux_sysmon_global.local_module_id = local_module_id;
}
#[no_mangle]
pub unsafe extern "C" fn linux_sysmon_read_cpuuse_line(
    mut line_data: *const libc::c_char,
    mut cpu_num: *mut libc::c_uint,
    mut run_time: *mut libc::c_ulong,
) {
    let mut value: libc::c_ulong = 0;
    let mut val_end: *const libc::c_char = 0 as *const libc::c_char;
    let mut val_count: libc::c_int = 0;
    val_count = 0 as libc::c_int;
    while val_count < 10 as libc::c_int && *line_data as libc::c_int != 0 as libc::c_int {
        while *(*__ctype_b_loc()).offset(*line_data as libc::c_uchar as libc::c_int as isize)
            as libc::c_int
            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            line_data = line_data.offset(1);
            line_data;
        }
        value = strtoul(
            line_data,
            &mut val_end as *mut *const libc::c_char as *mut *mut libc::c_char,
            10 as libc::c_int,
        );
        if val_end == line_data {
            break;
        }
        line_data = val_end;
        match val_count {
            0 => {
                *cpu_num = value as libc::c_uint;
            }
            7 => {
                *run_time = value;
            }
            _ => {}
        }
        val_count += 1;
        val_count;
    }
}
#[no_mangle]
pub unsafe extern "C" fn linux_sysmon_update_schedstat(
    mut state: *mut linux_sysmon_cpuload_state_t,
    mut elapsed_ms: libc::c_int,
) {
    let mut cpu_time_ms: libc::c_uint = 0;
    let mut cpu_num: libc::c_uint = 0;
    let mut highest_cpu_num: libc::c_uint = 0;
    let mut run_time: libc::c_ulong = 0;
    let mut line_data: [libc::c_char; 256] = [0; 256];
    let mut line_size: size_t = 0;
    let mut line_rdsz: ssize_t = 0;
    let mut eol_p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut core_p: *mut linux_sysmon_cpuload_core_t = 0 as *mut linux_sysmon_cpuload_core_t;
    line_size = 0 as libc::c_int as size_t;
    highest_cpu_num = 0 as libc::c_int as libc::c_uint;
    lseek(
        (*state).dev_fd,
        0 as libc::c_int as __off_t,
        0 as libc::c_int,
    );
    loop {
        line_rdsz = read(
            (*state).dev_fd,
            &mut *line_data.as_mut_ptr().offset(line_size as isize) as *mut libc::c_char
                as *mut libc::c_void,
            (::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
                .wrapping_sub(line_size),
        );
        if line_rdsz <= 0 as libc::c_int as libc::c_long {
            break;
        }
        eol_p = memchr(
            &mut *line_data.as_mut_ptr().offset(line_size as isize) as *mut libc::c_char
                as *const libc::c_void,
            '\n' as i32,
            line_rdsz as libc::c_ulong,
        ) as *mut libc::c_char;
        line_size = (line_size as libc::c_ulong).wrapping_add(line_rdsz as libc::c_ulong) as size_t
            as size_t;
        while !eol_p.is_null() {
            *eol_p = 0 as libc::c_int as libc::c_char;
            eol_p = eol_p.offset(1);
            eol_p;
            if strncmp(
                b"cpu\0" as *const u8 as *const libc::c_char,
                line_data.as_mut_ptr(),
                3 as libc::c_int as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                cpu_num = -(1 as libc::c_int) as libc::c_uint;
                run_time = 0 as libc::c_int as libc::c_ulong;
                linux_sysmon_read_cpuuse_line(
                    &mut *line_data.as_mut_ptr().offset(3 as libc::c_int as isize),
                    &mut cpu_num,
                    &mut run_time,
                );
                if cpu_num < 128 as libc::c_int as libc::c_uint {
                    core_p = &mut *((*state).per_core).as_mut_ptr().offset(cpu_num as isize)
                        as *mut linux_sysmon_cpuload_core_t;
                    if cpu_num > highest_cpu_num {
                        highest_cpu_num = cpu_num;
                    }
                } else {
                    core_p = 0 as *mut linux_sysmon_cpuload_core_t;
                }
                if !core_p.is_null() {
                    cpu_time_ms = OS_TimeGetTotalMilliseconds(OS_TimeFromTotalNanoseconds(
                        run_time.wrapping_sub((*core_p).last_run_time) as int64,
                    )) as libc::c_uint;
                    (*core_p).last_run_time = run_time;
                    if cpu_time_ms >= elapsed_ms as libc::c_uint {
                        (*core_p).avg_load = 0xffffff as libc::c_int;
                    } else if elapsed_ms == 0 as libc::c_int {
                        (*core_p).avg_load = 0 as libc::c_int;
                    } else {
                        (*core_p).avg_load = (0x1000 as libc::c_int as libc::c_uint)
                            .wrapping_mul(cpu_time_ms)
                            .wrapping_div(elapsed_ms as libc::c_uint)
                            as CFE_PSP_IODriver_AdcCode_t;
                        (*core_p).avg_load |= (*core_p).avg_load << 12 as libc::c_int;
                    }
                }
            }
            line_rdsz = eol_p.offset_from(
                &mut *line_data.as_mut_ptr().offset(0 as libc::c_int as isize) as *mut libc::c_char,
            ) as libc::c_long;
            if (line_rdsz as libc::c_ulong) < line_size {
                memmove(
                    line_data.as_mut_ptr() as *mut libc::c_void,
                    eol_p as *const libc::c_void,
                    line_size.wrapping_sub(line_rdsz as libc::c_ulong),
                );
                line_size = (line_size as libc::c_ulong).wrapping_sub(line_rdsz as libc::c_ulong)
                    as size_t as size_t;
            } else {
                line_size = 0 as libc::c_int as size_t;
            }
            eol_p = memchr(
                line_data.as_mut_ptr() as *const libc::c_void,
                '\n' as i32,
                line_size,
            ) as *mut libc::c_char;
        }
        if !(line_size >= ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong) {
            continue;
        }
        OS_printf(
            b"CFE_PSP(linux_sysmon): malformed data from /proc/schedstat\n\0" as *const u8
                as *const libc::c_char,
        );
        break;
    }
    (*state).num_cpus = (1 as libc::c_int as libc::c_uint).wrapping_add(highest_cpu_num) as uint8_t;
}
unsafe extern "C" fn linux_sysmon_Task(mut arg: *mut libc::c_void) -> *mut libc::c_void {
    let mut state: *mut linux_sysmon_cpuload_state_t = arg as *mut linux_sysmon_cpuload_state_t;
    let mut last_sample: OS_time_t = OS_time_t { ticks: 0 };
    let mut curr_sample: OS_time_t = OS_time_t { ticks: 0 };
    let mut next_sample: OS_time_t = OS_time_t { ticks: 0 };
    let mut msec_diff: libc::c_int = 0;
    let mut pfd: pollfd = pollfd {
        fd: 0,
        events: 0,
        revents: 0,
    };
    CFE_PSP_GetTime(&mut next_sample);
    curr_sample = next_sample;
    memset(
        &mut pfd as *mut pollfd as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<pollfd>() as libc::c_ulong,
    );
    linux_sysmon_update_schedstat(state, 0 as libc::c_int);
    while (*state).should_run {
        next_sample = OS_TimeAdd(
            next_sample,
            OS_TimeFromTotalSeconds(30 as libc::c_int as int64),
        );
        msec_diff =
            OS_TimeGetTotalMilliseconds(OS_TimeSubtract(next_sample, curr_sample)) as libc::c_int;
        if msec_diff > 0 as libc::c_int {
            poll(&mut pfd, 0 as libc::c_int as nfds_t, msec_diff);
        }
        last_sample = curr_sample;
        CFE_PSP_GetTime(&mut curr_sample);
        msec_diff =
            OS_TimeGetTotalMilliseconds(OS_TimeSubtract(curr_sample, last_sample)) as libc::c_int;
        linux_sysmon_update_schedstat(state, msec_diff);
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn linux_sysmon_Start(mut state: *mut linux_sysmon_cpuload_state_t) -> int32_t {
    let mut StatusCode: int32_t = 0;
    let mut DelayCount: int32_t = 0;
    DelayCount = 0 as libc::c_int;
    if (*state).is_running {
        StatusCode = 0 as libc::c_int;
    } else {
        memset(
            state as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<linux_sysmon_cpuload_state_t>() as libc::c_ulong,
        );
        StatusCode = -(1 as libc::c_int);
        (*state).dev_fd = open(
            b"/proc/schedstat\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
        );
        if (*state).dev_fd < 0 as libc::c_int {
            perror(b"open(/proc/schedstat)\0" as *const u8 as *const libc::c_char);
        } else {
            ::core::ptr::write_volatile(
                &mut (*state).should_run as *mut bool,
                1 as libc::c_int != 0,
            );
            if pthread_create(
                &mut (*state).task_id,
                0 as *const pthread_attr_t,
                Some(
                    linux_sysmon_Task
                        as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
                ),
                state as *mut libc::c_void,
            ) < 0 as libc::c_int
            {
                perror(b"pthread_create()\0" as *const u8 as *const libc::c_char);
                ::core::ptr::write_volatile(
                    &mut (*state).should_run as *mut bool,
                    0 as libc::c_int != 0,
                );
                close((*state).dev_fd);
            } else {
                while (*state).num_cpus as libc::c_int == 0 as libc::c_int
                    && DelayCount < 100000000 as libc::c_int
                {
                    DelayCount += 1;
                    DelayCount;
                    OS_TaskDelay(10 as libc::c_int as uint32);
                }
                if (*state).num_cpus as libc::c_int == 0 as libc::c_int {
                    OS_printf(
                        b"CFE_PSP(Linux_SysMon): Failed to detect number of CPUs\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    ::core::ptr::write_volatile(
                        &mut (*state).should_run as *mut bool,
                        0 as libc::c_int != 0,
                    );
                    pthread_cancel((*state).task_id);
                    pthread_join((*state).task_id, 0 as *mut *mut libc::c_void);
                    close((*state).dev_fd);
                } else {
                    OS_printf(
                        b"CFE_PSP(Linux_SysMon): Started CPU utilization monitoring on %u CPU(s)\n\0"
                            as *const u8 as *const libc::c_char,
                        (*state).num_cpus as libc::c_uint,
                    );
                    StatusCode = 0 as libc::c_int;
                    ::core::ptr::write_volatile(
                        &mut (*state).is_running as *mut bool,
                        1 as libc::c_int != 0,
                    );
                }
            }
        }
    }
    return StatusCode;
}
unsafe extern "C" fn linux_sysmon_Stop(mut state: *mut linux_sysmon_cpuload_state_t) -> int32_t {
    if (*state).is_running {
        ::core::ptr::write_volatile(&mut (*state).should_run as *mut bool, 0 as libc::c_int != 0);
        ::core::ptr::write_volatile(&mut (*state).is_running as *mut bool, 0 as libc::c_int != 0);
        pthread_cancel((*state).task_id);
        pthread_join((*state).task_id, 0 as *mut *mut libc::c_void);
        close((*state).dev_fd);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn linux_sysmon_calc_aggregate_cpu(
    mut state: *mut linux_sysmon_cpuload_state_t,
    mut Val: *mut CFE_PSP_IODriver_AdcCode_t,
) -> int32_t {
    let mut cpu: uint8_t = 0;
    let mut sum: uint32_t = 0;
    sum = 0 as libc::c_int as uint32_t;
    cpu = 0 as libc::c_int as uint8_t;
    while (cpu as libc::c_int) < (*state).num_cpus as libc::c_int {
        sum = (sum as libc::c_uint)
            .wrapping_add((*state).per_core[cpu as usize].avg_load as libc::c_uint)
            as uint32_t as uint32_t;
        cpu = cpu.wrapping_add(1);
        cpu;
    }
    if cpu as libc::c_int == 0 as libc::c_int {
        *Val = 0 as libc::c_int;
        return -(1 as libc::c_int);
    }
    sum = (sum as libc::c_uint).wrapping_div(cpu as libc::c_uint) as uint32_t as uint32_t;
    *Val = sum as CFE_PSP_IODriver_AdcCode_t;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn linux_sysmon_aggregate_dispatch(
    mut CommandCode: uint32_t,
    mut Subchannel: uint16_t,
    mut Arg: CFE_PSP_IODriver_Arg_t,
) -> int32_t {
    let mut StatusCode: int32_t = 0;
    let mut state: *mut linux_sysmon_cpuload_state_t = 0 as *mut linux_sysmon_cpuload_state_t;
    state = &mut linux_sysmon_global.cpu_load;
    StatusCode = -(27 as libc::c_int);
    match CommandCode {
        0 | 65536 => {
            StatusCode = 0 as libc::c_int;
        }
        1 => {
            if Arg.U32 != 0 {
                StatusCode = linux_sysmon_Start(state);
            } else {
                StatusCode = linux_sysmon_Stop(state);
            }
        }
        2 => {
            StatusCode = (*state).is_running as int32_t;
        }
        5 => {
            let mut i: uint16_t = 0;
            i = 0 as libc::c_int as uint16_t;
            while !(linux_sysmon_subsystem_names[i as usize]).is_null() {
                if strcmp(Arg.ConstStr, linux_sysmon_subsystem_names[i as usize])
                    == 0 as libc::c_int
                {
                    StatusCode = i as int32_t;
                    break;
                } else {
                    i = i.wrapping_add(1);
                    i;
                }
            }
        }
        6 => {
            let mut i_0: uint16_t = 0;
            i_0 = 0 as libc::c_int as uint16_t;
            while !(linux_sysmon_subchannel_names[i_0 as usize]).is_null() {
                if strcmp(Arg.ConstStr, linux_sysmon_subchannel_names[i_0 as usize])
                    == 0 as libc::c_int
                {
                    StatusCode = i_0 as int32_t;
                    break;
                } else {
                    i_0 = i_0.wrapping_add(1);
                    i_0;
                }
            }
        }
        8 => {
            let mut DirPtr: *mut CFE_PSP_IODriver_Direction_t =
                Arg.Vptr as *mut CFE_PSP_IODriver_Direction_t;
            if !DirPtr.is_null() {
                *DirPtr = CFE_PSP_IODriver_Direction_INPUT_ONLY;
                StatusCode = 0 as libc::c_int;
            }
        }
        65537 => {
            let mut RdWr: *mut CFE_PSP_IODriver_AnalogRdWr_t =
                Arg.Vptr as *mut CFE_PSP_IODriver_AnalogRdWr_t;
            if (*RdWr).NumChannels as libc::c_int == 1 as libc::c_int
                && Subchannel as libc::c_int == 0 as libc::c_int
            {
                StatusCode = linux_sysmon_calc_aggregate_cpu(state, (*RdWr).Samples);
            }
        }
        3 | 4 | _ => {}
    }
    return StatusCode;
}
#[no_mangle]
pub unsafe extern "C" fn linux_sysmon_cpu_load_dispatch(
    mut CommandCode: uint32_t,
    mut Subchannel: uint16_t,
    mut Arg: CFE_PSP_IODriver_Arg_t,
) -> int32_t {
    let mut StatusCode: int32_t = 0;
    let mut state: *mut linux_sysmon_cpuload_state_t = 0 as *mut linux_sysmon_cpuload_state_t;
    state = &mut linux_sysmon_global.cpu_load;
    StatusCode = -(27 as libc::c_int);
    match CommandCode {
        0 | 65536 => {
            StatusCode = 0 as libc::c_int;
        }
        65537 => {
            let mut RdWr: *mut CFE_PSP_IODriver_AnalogRdWr_t =
                Arg.Vptr as *mut CFE_PSP_IODriver_AnalogRdWr_t;
            let mut ch: uint32_t = 0;
            if (Subchannel as libc::c_int) < (*state).num_cpus as libc::c_int
                && Subchannel as libc::c_int + (*RdWr).NumChannels as libc::c_int
                    <= (*state).num_cpus as libc::c_int
            {
                ch = Subchannel as uint32_t;
                while ch
                    < (Subchannel as libc::c_int + (*RdWr).NumChannels as libc::c_int)
                        as libc::c_uint
                {
                    *((*RdWr).Samples).offset(ch as isize) =
                        (*state).per_core[ch as usize].avg_load;
                    ch = ch.wrapping_add(1);
                    ch;
                }
            }
        }
        _ => {}
    }
    return StatusCode;
}
unsafe extern "C" fn linux_sysmon_DevCmd(
    mut CommandCode: uint32_t,
    mut SubsystemId: uint16_t,
    mut SubchannelId: uint16_t,
    mut Arg: CFE_PSP_IODriver_Arg_t,
) -> int32_t {
    let mut StatusCode: int32_t = 0;
    StatusCode = -(27 as libc::c_int);
    match SubsystemId as libc::c_int {
        0 => {
            StatusCode = linux_sysmon_aggregate_dispatch(CommandCode, SubchannelId, Arg);
        }
        1 => {
            StatusCode = linux_sysmon_cpu_load_dispatch(CommandCode, SubchannelId, Arg);
        }
        _ => {}
    }
    return StatusCode;
}
#[inline]
unsafe extern "C" fn CFE_MSG_GetHeaderField(
    mut Word: *const uint8,
    mut Val: *mut uint16,
    mut Mask: uint16,
) {
    *Val = (((*Word.offset(0 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int
        | *Word.offset(1 as libc::c_int as isize) as libc::c_int)
        & Mask as libc::c_int) as uint16;
}
#[inline]
unsafe extern "C" fn CFE_MSG_SetHeaderField(
    mut Word: *mut uint8,
    mut Val: uint16,
    mut Mask: uint16,
) {
    *Word.offset(0 as libc::c_int as isize) =
        (*Word.offset(0 as libc::c_int as isize) as libc::c_int
            & !(Mask as libc::c_int >> 8 as libc::c_int)
            | (Val as libc::c_int & Mask as libc::c_int) >> 8 as libc::c_int) as uint8;
    *Word.offset(1 as libc::c_int as isize) =
        ((*Word.offset(1 as libc::c_int as isize) as libc::c_int & !(Mask as libc::c_int)
            | Val as libc::c_int & Mask as libc::c_int)
            & 0xff as libc::c_int) as uint8;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetSequenceCount(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut SeqCnt: *mut CFE_MSG_SequenceCount_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || SeqCnt.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHeaderField(
        ((*MsgPtr).CCSDS.Pri.Sequence).as_ptr(),
        SeqCnt,
        0x3fff as libc::c_int as uint16,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetDefaultCCSDSPri(mut MsgPtr: *mut CFE_MSG_Message_t) {
    CFE_MSG_SetHasSecondaryHeader(MsgPtr, 1 as libc::c_int != 0);
    CFE_MSG_SetHeaderVersion(MsgPtr, 0 as libc::c_int as CFE_MSG_HeaderVersion_t);
    CFE_MSG_SetApId(MsgPtr, 0 as libc::c_int as CFE_MSG_ApId_t);
    CFE_MSG_SetSegmentationFlag(MsgPtr, CFE_MSG_SegFlag_Unsegmented);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetSegmentationFlag(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut SegFlag: CFE_MSG_SegmentationFlag_t,
) -> CFE_Status_t {
    let mut rawval: uint16 = 0 as libc::c_int as uint16;
    let mut status: CFE_Status_t = 0 as libc::c_int;
    if MsgPtr.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    match SegFlag as libc::c_uint {
        1 => {
            rawval = 0 as libc::c_int as uint16;
        }
        2 => {
            rawval = 0x4000 as libc::c_int as uint16;
        }
        3 => {
            rawval = 0x8000 as libc::c_int as uint16;
        }
        4 => {
            rawval = 0xc000 as libc::c_int as uint16;
        }
        0 | _ => {
            status = 0xca000003 as libc::c_uint as CFE_Status_t;
        }
    }
    if status == 0 as libc::c_int {
        CFE_MSG_SetHeaderField(
            ((*MsgPtr).CCSDS.Pri.Sequence).as_mut_ptr(),
            rawval,
            0xc000 as libc::c_int as uint16,
        );
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetApId(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut ApId: CFE_MSG_ApId_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || ApId as libc::c_int & !(0x7ff as libc::c_int) != 0 as libc::c_int {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_SetHeaderField(
        ((*MsgPtr).CCSDS.Pri.StreamId).as_mut_ptr(),
        ApId,
        0x7ff as libc::c_int as uint16,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetHeaderVersion(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut Version: CFE_MSG_HeaderVersion_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || Version as libc::c_int > 0xe000 as libc::c_int >> 13 as libc::c_int {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_SetHeaderField(
        ((*MsgPtr).CCSDS.Pri.StreamId).as_mut_ptr(),
        ((Version as libc::c_int) << 13 as libc::c_int) as uint16,
        0xe000 as libc::c_int as uint16,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetHasSecondaryHeader(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut HasSecondary: *mut bool,
) -> CFE_Status_t {
    if MsgPtr.is_null() || HasSecondary.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    *HasSecondary = (*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] as libc::c_int
        & 0x800 as libc::c_int >> 8 as libc::c_int
        != 0 as libc::c_int;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetType(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut Type: *mut CFE_MSG_Type_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || Type.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    if (*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] as libc::c_int
        & 0x1000 as libc::c_int >> 8 as libc::c_int
        != 0 as libc::c_int
    {
        *Type = CFE_MSG_Type_Cmd;
    } else {
        *Type = CFE_MSG_Type_Tlm;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetSegmentationFlag(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut SegFlag: *mut CFE_MSG_SegmentationFlag_t,
) -> CFE_Status_t {
    let mut rawval: uint16 = 0;
    if MsgPtr.is_null() || SegFlag.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHeaderField(
        ((*MsgPtr).CCSDS.Pri.Sequence).as_ptr(),
        &mut rawval,
        0xc000 as libc::c_int as uint16,
    );
    match rawval as libc::c_int {
        0 => {
            *SegFlag = CFE_MSG_SegFlag_Continue;
        }
        16384 => {
            *SegFlag = CFE_MSG_SegFlag_First;
        }
        32768 => {
            *SegFlag = CFE_MSG_SegFlag_Last;
        }
        49152 | _ => {
            *SegFlag = CFE_MSG_SegFlag_Unsegmented;
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetApId(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut ApId: *mut CFE_MSG_ApId_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || ApId.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHeaderField(
        ((*MsgPtr).CCSDS.Pri.StreamId).as_ptr(),
        ApId,
        0x7ff as libc::c_int as uint16,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetHeaderVersion(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut Version: *mut CFE_MSG_HeaderVersion_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || Version.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHeaderField(
        ((*MsgPtr).CCSDS.Pri.StreamId).as_ptr(),
        Version,
        0xe000 as libc::c_int as uint16,
    );
    *Version = (*Version as libc::c_int >> 13 as libc::c_int) as CFE_MSG_HeaderVersion_t;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetType(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut Type: CFE_MSG_Type_t,
) -> CFE_Status_t {
    let mut status: CFE_Status_t = 0 as libc::c_int;
    if MsgPtr.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    if Type as libc::c_uint == CFE_MSG_Type_Cmd as libc::c_int as libc::c_uint {
        (*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] =
            ((*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] as libc::c_int
                | 0x1000 as libc::c_int >> 8 as libc::c_int) as uint8;
    } else if Type as libc::c_uint == CFE_MSG_Type_Tlm as libc::c_int as libc::c_uint {
        (*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] =
            ((*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] as libc::c_int
                & !(0x1000 as libc::c_int >> 8 as libc::c_int)) as uint8;
    } else {
        status = 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetHasSecondaryHeader(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut HasSecondary: bool,
) -> CFE_Status_t {
    if MsgPtr.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    if HasSecondary {
        (*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] =
            ((*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] as libc::c_int
                | 0x800 as libc::c_int >> 8 as libc::c_int) as uint8;
    } else {
        (*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] =
            ((*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] as libc::c_int
                & !(0x800 as libc::c_int >> 8 as libc::c_int)) as uint8;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetSequenceCount(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut SeqCnt: CFE_MSG_SequenceCount_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || SeqCnt as libc::c_int & !(0x3fff as libc::c_int) != 0 as libc::c_int {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_SetHeaderField(
        ((*MsgPtr).CCSDS.Pri.Sequence).as_mut_ptr(),
        SeqCnt,
        0x3fff as libc::c_int as uint16,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetNextSequenceCount(
    mut SeqCnt: CFE_MSG_SequenceCount_t,
) -> CFE_MSG_SequenceCount_t {
    SeqCnt = SeqCnt.wrapping_add(1);
    SeqCnt;
    if SeqCnt as libc::c_int > 0x3fff as libc::c_int {
        SeqCnt = 0 as libc::c_int as CFE_MSG_SequenceCount_t;
    }
    return SeqCnt;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetSize(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut Size: *mut CFE_MSG_Size_t,
) -> CFE_Status_t {
    if MsgPtr.is_null() || Size.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    *Size = ((((*MsgPtr).CCSDS.Pri.Length[0 as libc::c_int as usize] as libc::c_int)
        << 8 as libc::c_int)
        + (*MsgPtr).CCSDS.Pri.Length[1 as libc::c_int as usize] as libc::c_int
        + 7 as libc::c_int) as CFE_MSG_Size_t;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetSize(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut Size: CFE_MSG_Size_t,
) -> CFE_Status_t {
    if MsgPtr.is_null()
        || Size < 7 as libc::c_int as libc::c_ulong
        || Size > (0xffff as libc::c_int + 7 as libc::c_int) as libc::c_ulong
    {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    Size = (Size as libc::c_ulong).wrapping_sub(7 as libc::c_int as libc::c_ulong) as CFE_MSG_Size_t
        as CFE_MSG_Size_t;
    (*MsgPtr).CCSDS.Pri.Length[0 as libc::c_int as usize] =
        (Size >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_ulong) as uint8;
    (*MsgPtr).CCSDS.Pri.Length[1 as libc::c_int as usize] =
        (Size & 0xff as libc::c_int as libc::c_ulong) as uint8;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_Init(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut MsgId: CFE_SB_MsgId_t,
    mut Size: CFE_MSG_Size_t,
) -> CFE_Status_t {
    let mut status: int32 = 0;
    if MsgPtr.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    memset(MsgPtr as *mut libc::c_void, 0 as libc::c_int, Size);
    CFE_MSG_InitDefaultHdr(MsgPtr);
    status = CFE_MSG_SetMsgId(MsgPtr, MsgId);
    if status == 0 as libc::c_int {
        status = CFE_MSG_SetSize(MsgPtr, Size);
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_OriginationAction(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut BufferSize: size_t,
    mut IsAcceptable: *mut bool,
) -> CFE_Status_t {
    if MsgPtr.is_null() || IsAcceptable.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_SetMsgTime(MsgPtr, CFE_TIME_GetTime());
    CFE_MSG_GenerateChecksum(MsgPtr);
    *IsAcceptable = 1 as libc::c_int != 0;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_VerificationAction(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut BufferSize: size_t,
    mut IsAcceptable: *mut bool,
) -> CFE_Status_t {
    if MsgPtr.is_null() || IsAcceptable.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    *IsAcceptable = 1 as libc::c_int != 0;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetTypeFromMsgId(
    mut MsgId: CFE_SB_MsgId_t,
    mut Type: *mut CFE_MSG_Type_t,
) -> CFE_Status_t {
    let mut msg: CFE_MSG_Message_t = CFE_MSG_Message_t {
        CCSDS: CCSDS_SpacePacket_t {
            Pri: CCSDS_PrimaryHeader_t {
                StreamId: [0; 2],
                Sequence: [0; 2],
                Length: [0; 2],
            },
        },
    };
    let mut Status: int32 = 0;
    memset(
        &mut msg as *mut CFE_MSG_Message_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_MSG_Message_t>() as libc::c_ulong,
    );
    if Type.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_MSG_SetMsgId(&mut msg, MsgId);
    if Status == 0 as libc::c_int {
        Status = CFE_MSG_GetType(&mut msg, Type);
    }
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_ComputeCheckSum(
    mut MsgPtr: *const CFE_MSG_Message_t,
) -> CFE_MSG_Checksum_t {
    let mut PktLen: CFE_MSG_Size_t = 0 as libc::c_int as CFE_MSG_Size_t;
    let mut BytePtr: *const uint8 = MsgPtr as *const uint8;
    let mut chksum: CFE_MSG_Checksum_t = 0xff as libc::c_int as CFE_MSG_Checksum_t;
    CFE_MSG_GetSize(MsgPtr, &mut PktLen);
    loop {
        let fresh44 = PktLen;
        PktLen = PktLen.wrapping_sub(1);
        if !(fresh44 != 0) {
            break;
        }
        let fresh45 = BytePtr;
        BytePtr = BytePtr.offset(1);
        chksum ^= *fresh45 as libc::c_uint;
    }
    return chksum;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GenerateChecksum(
    mut MsgPtr: *mut CFE_MSG_Message_t,
) -> CFE_Status_t {
    let mut status: CFE_Status_t = 0;
    let mut type_0: CFE_MSG_Type_t = CFE_MSG_Type_Invalid;
    let mut hassechdr: bool = 0 as libc::c_int != 0;
    let mut cmd: *mut CFE_MSG_CommandHeader_t = MsgPtr as *mut CFE_MSG_CommandHeader_t;
    if MsgPtr.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHasSecondaryHeader(MsgPtr, &mut hassechdr);
    status = CFE_MSG_GetType(MsgPtr, &mut type_0);
    if status != 0 as libc::c_int
        || type_0 as libc::c_uint != CFE_MSG_Type_Cmd as libc::c_int as libc::c_uint
        || !hassechdr
    {
        return 0xca00000d as libc::c_uint as CFE_Status_t;
    }
    (*cmd).Sec.Checksum = 0 as libc::c_int as uint8;
    (*cmd).Sec.Checksum = CFE_MSG_ComputeCheckSum(MsgPtr) as uint8;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_ValidateChecksum(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut IsValid: *mut bool,
) -> CFE_Status_t {
    let mut status: CFE_Status_t = 0;
    let mut type_0: CFE_MSG_Type_t = CFE_MSG_Type_Invalid;
    let mut hassechdr: bool = 0 as libc::c_int != 0;
    if MsgPtr.is_null() || IsValid.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHasSecondaryHeader(MsgPtr, &mut hassechdr);
    status = CFE_MSG_GetType(MsgPtr, &mut type_0);
    if status != 0 as libc::c_int
        || type_0 as libc::c_uint != CFE_MSG_Type_Cmd as libc::c_int as libc::c_uint
        || !hassechdr
    {
        return 0xca00000d as libc::c_uint as CFE_Status_t;
    }
    *IsValid = CFE_MSG_ComputeCheckSum(MsgPtr) == 0 as libc::c_int as libc::c_uint;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetFcnCode(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut FcnCode: *mut CFE_MSG_FcnCode_t,
) -> CFE_Status_t {
    let mut status: CFE_Status_t = 0;
    let mut type_0: CFE_MSG_Type_t = CFE_MSG_Type_Invalid;
    let mut hassechdr: bool = 0 as libc::c_int != 0;
    let mut cmd: *mut CFE_MSG_CommandHeader_t = MsgPtr as *mut CFE_MSG_CommandHeader_t;
    if MsgPtr.is_null() || FcnCode.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHasSecondaryHeader(MsgPtr, &mut hassechdr);
    status = CFE_MSG_GetType(MsgPtr, &mut type_0);
    if status != 0 as libc::c_int
        || type_0 as libc::c_uint != CFE_MSG_Type_Cmd as libc::c_int as libc::c_uint
        || !hassechdr
    {
        *FcnCode = 0 as libc::c_int as CFE_MSG_FcnCode_t;
        return 0xca00000d as libc::c_uint as CFE_Status_t;
    }
    *FcnCode = ((*cmd).Sec.FunctionCode as libc::c_int & 0x7f as libc::c_int) as CFE_MSG_FcnCode_t;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetFcnCode(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut FcnCode: CFE_MSG_FcnCode_t,
) -> CFE_Status_t {
    let mut status: CFE_Status_t = 0;
    let mut type_0: CFE_MSG_Type_t = CFE_MSG_Type_Invalid;
    let mut hassechdr: bool = 0 as libc::c_int != 0;
    let mut cmd: *mut CFE_MSG_CommandHeader_t = MsgPtr as *mut CFE_MSG_CommandHeader_t;
    if MsgPtr.is_null() || FcnCode as libc::c_int > 0x7f as libc::c_int {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHasSecondaryHeader(MsgPtr, &mut hassechdr);
    status = CFE_MSG_GetType(MsgPtr, &mut type_0);
    if status != 0 as libc::c_int
        || type_0 as libc::c_uint != CFE_MSG_Type_Cmd as libc::c_int as libc::c_uint
        || !hassechdr
    {
        return 0xca00000d as libc::c_uint as CFE_Status_t;
    }
    (*cmd).Sec.FunctionCode = FcnCode as uint8;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetMsgTime(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut NewTime: CFE_TIME_SysTime_t,
) -> CFE_Status_t {
    let mut status: CFE_Status_t = 0;
    let mut type_0: CFE_MSG_Type_t = CFE_MSG_Type_Invalid;
    let mut hassechdr: bool = 0 as libc::c_int != 0;
    let mut tlm: *mut CFE_MSG_TelemetryHeader_t = MsgPtr as *mut CFE_MSG_TelemetryHeader_t;
    if MsgPtr.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHasSecondaryHeader(MsgPtr, &mut hassechdr);
    status = CFE_MSG_GetType(MsgPtr, &mut type_0);
    if status != 0 as libc::c_int
        || type_0 as libc::c_uint != CFE_MSG_Type_Tlm as libc::c_int as libc::c_uint
        || !hassechdr
    {
        return 0xca00000d as libc::c_uint as CFE_Status_t;
    }
    (*tlm).Sec.Time[0 as libc::c_int as usize] =
        (NewTime.Seconds >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8;
    (*tlm).Sec.Time[1 as libc::c_int as usize] =
        (NewTime.Seconds >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8;
    (*tlm).Sec.Time[2 as libc::c_int as usize] =
        (NewTime.Seconds >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8;
    (*tlm).Sec.Time[3 as libc::c_int as usize] =
        (NewTime.Seconds & 0xff as libc::c_int as libc::c_uint) as uint8;
    (*tlm).Sec.Time[4 as libc::c_int as usize] =
        (NewTime.Subseconds >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8;
    (*tlm).Sec.Time[5 as libc::c_int as usize] =
        (NewTime.Subseconds >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetMsgTime(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut Time: *mut CFE_TIME_SysTime_t,
) -> CFE_Status_t {
    let mut status: CFE_Status_t = 0;
    let mut type_0: CFE_MSG_Type_t = CFE_MSG_Type_Invalid;
    let mut hassechdr: bool = 0 as libc::c_int != 0;
    let mut tlm: *mut CFE_MSG_TelemetryHeader_t = MsgPtr as *mut CFE_MSG_TelemetryHeader_t;
    if MsgPtr.is_null() || Time.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    CFE_MSG_GetHasSecondaryHeader(MsgPtr, &mut hassechdr);
    status = CFE_MSG_GetType(MsgPtr, &mut type_0);
    if status != 0 as libc::c_int
        || type_0 as libc::c_uint != CFE_MSG_Type_Tlm as libc::c_int as libc::c_uint
        || !hassechdr
    {
        memset(
            Time as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<CFE_TIME_SysTime_t>() as libc::c_ulong,
        );
        return 0xca00000d as libc::c_uint as CFE_Status_t;
    }
    (*Time).Subseconds = ((((*tlm).Sec.Time[4 as libc::c_int as usize] as libc::c_int)
        << 24 as libc::c_int)
        + (((*tlm).Sec.Time[5 as libc::c_int as usize] as libc::c_int) << 16 as libc::c_int))
        as uint32;
    (*Time).Seconds =
        ((((*tlm).Sec.Time[0 as libc::c_int as usize] as libc::c_int) << 24 as libc::c_int)
            + (((*tlm).Sec.Time[1 as libc::c_int as usize] as libc::c_int) << 16 as libc::c_int)
            + (((*tlm).Sec.Time[2 as libc::c_int as usize] as libc::c_int) << 8 as libc::c_int)
            + (*tlm).Sec.Time[3 as libc::c_int as usize] as libc::c_int) as uint32;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_InitDefaultHdr(mut MsgPtr: *mut CFE_MSG_Message_t) {
    CFE_MSG_SetDefaultCCSDSPri(MsgPtr);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_GetMsgId(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut MsgId: *mut CFE_SB_MsgId_t,
) -> CFE_Status_t {
    let mut msgidval: CFE_SB_MsgId_Atom_t = 0;
    if MsgPtr.is_null() || MsgId.is_null() {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    msgidval = ((((*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] as libc::c_int)
        << 8 as libc::c_int)
        + (*MsgPtr).CCSDS.Pri.StreamId[1 as libc::c_int as usize] as libc::c_int)
        as CFE_SB_MsgId_Atom_t;
    *MsgId = CFE_SB_ValueToMsgId(msgidval);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_MSG_SetMsgId(
    mut MsgPtr: *mut CFE_MSG_Message_t,
    mut MsgId: CFE_SB_MsgId_t,
) -> CFE_Status_t {
    let mut msgidval: CFE_SB_MsgId_Atom_t = CFE_SB_MsgIdToValue(MsgId);
    if MsgPtr.is_null() || !CFE_SB_IsValidMsgId(MsgId) {
        return 0xca000003 as libc::c_uint as CFE_Status_t;
    }
    (*MsgPtr).CCSDS.Pri.StreamId[0 as libc::c_int as usize] =
        (msgidval >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as uint8;
    (*MsgPtr).CCSDS.Pri.StreamId[1 as libc::c_int as usize] =
        (msgidval & 0xff as libc::c_int as libc::c_uint) as uint8;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_msg_src_check_ccsds_hdr_h_c__CheckHeader() {}
#[no_mangle]
pub unsafe extern "C" fn build_native_default_cpu1_msg_src_check_cfe_msg_api_typedefs_h_c__CheckHeader(
) {
}
#[no_mangle]
pub static mut CFE_SBR_MSGMAP: [CFE_SBR_RouteId_t; 8192] = [CFE_SBR_RouteId_t { RouteId: 0 }; 8192];
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_Init_Map() {
    memset(
        &mut CFE_SBR_MSGMAP as *mut [CFE_SBR_RouteId_t; 8192] as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[CFE_SBR_RouteId_t; 8192]>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_SetRouteId(
    mut MsgId: CFE_SB_MsgId_t,
    mut RouteId: CFE_SBR_RouteId_t,
) -> uint32 {
    if CFE_SB_IsValidMsgId(MsgId) {
        CFE_SBR_MSGMAP[CFE_SB_MsgIdToValue(MsgId) as usize] = RouteId;
    }
    return 0 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_GetRouteId(mut MsgId: CFE_SB_MsgId_t) -> CFE_SBR_RouteId_t {
    let mut routeid: CFE_SBR_RouteId_t = {
        let mut init = CFE_SBR_RouteId_t {
            RouteId: 0 as libc::c_int as CFE_SB_RouteId_Atom_t,
        };
        init
    };
    if CFE_SB_IsValidMsgId(MsgId) {
        routeid = CFE_SBR_MSGMAP[CFE_SB_MsgIdToValue(MsgId) as usize];
    }
    return routeid;
}
#[no_mangle]
pub static mut CFE_SBR_RDATA: cfe_sbr_route_data_t = cfe_sbr_route_data_t {
    RoutingTbl: [CFE_SBR_RouteEntry_t {
        ListHeadPtr: 0 as *const CFE_SB_DestinationD_t as *mut CFE_SB_DestinationD_t,
        MsgId: CFE_SB_MsgId_t { Value: 0 },
        SeqCnt: 0,
    }; 256],
    RouteIdxTop: 0,
};
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_Init() {
    let mut routeidx: CFE_SB_RouteId_Atom_t = 0;
    memset(
        &mut CFE_SBR_RDATA as *mut cfe_sbr_route_data_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<cfe_sbr_route_data_t>() as libc::c_ulong,
    );
    routeidx = 0 as libc::c_int as CFE_SB_RouteId_Atom_t;
    while (routeidx as libc::c_int) < 256 as libc::c_int {
        CFE_SBR_RDATA.RoutingTbl[routeidx as usize].MsgId = {
            let mut init = CFE_SB_MsgId_t {
                Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
            };
            init
        };
        routeidx = routeidx.wrapping_add(1);
        routeidx;
    }
    CFE_SBR_Init_Map();
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_AddRoute(
    mut MsgId: CFE_SB_MsgId_t,
    mut CollisionsPtr: *mut uint32,
) -> CFE_SBR_RouteId_t {
    let mut routeid: CFE_SBR_RouteId_t = {
        let mut init = CFE_SBR_RouteId_t {
            RouteId: 0 as libc::c_int as CFE_SB_RouteId_Atom_t,
        };
        init
    };
    let mut collisions: uint32 = 0 as libc::c_int as uint32;
    if CFE_SB_IsValidMsgId(MsgId) as libc::c_int != 0
        && (CFE_SBR_RDATA.RouteIdxTop as libc::c_int) < 256 as libc::c_int
    {
        routeid = CFE_SBR_ValueToRouteId(CFE_SBR_RDATA.RouteIdxTop);
        collisions = CFE_SBR_SetRouteId(MsgId, routeid);
        CFE_SBR_RDATA.RoutingTbl[CFE_SBR_RDATA.RouteIdxTop as usize].MsgId = MsgId;
        CFE_SBR_RDATA.RouteIdxTop = (CFE_SBR_RDATA.RouteIdxTop).wrapping_add(1);
        CFE_SBR_RDATA.RouteIdxTop;
    }
    if !CollisionsPtr.is_null() {
        *CollisionsPtr = collisions;
    }
    return routeid;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_GetMsgId(mut RouteId: CFE_SBR_RouteId_t) -> CFE_SB_MsgId_t {
    let mut msgid: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    if CFE_SBR_IsValidRouteId(RouteId) {
        msgid = CFE_SBR_RDATA.RoutingTbl[CFE_SBR_RouteIdToValue(RouteId) as usize].MsgId;
    }
    return msgid;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_GetDestListHeadPtr(
    mut RouteId: CFE_SBR_RouteId_t,
) -> *mut CFE_SB_DestinationD_t {
    let mut destptr: *mut CFE_SB_DestinationD_t = 0 as *mut CFE_SB_DestinationD_t;
    if CFE_SBR_IsValidRouteId(RouteId) {
        destptr = CFE_SBR_RDATA.RoutingTbl[CFE_SBR_RouteIdToValue(RouteId) as usize].ListHeadPtr;
    }
    return destptr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_SetDestListHeadPtr(
    mut RouteId: CFE_SBR_RouteId_t,
    mut DestPtr: *mut CFE_SB_DestinationD_t,
) {
    if CFE_SBR_IsValidRouteId(RouteId) {
        CFE_SBR_RDATA.RoutingTbl[CFE_SBR_RouteIdToValue(RouteId) as usize].ListHeadPtr = DestPtr;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_IncrementSequenceCounter(mut RouteId: CFE_SBR_RouteId_t) {
    let mut cnt: *mut CFE_MSG_SequenceCount_t = 0 as *mut CFE_MSG_SequenceCount_t;
    if CFE_SBR_IsValidRouteId(RouteId) {
        cnt = &mut (*(CFE_SBR_RDATA.RoutingTbl)
            .as_mut_ptr()
            .offset((CFE_SBR_RouteIdToValue
                as unsafe extern "C" fn(CFE_SBR_RouteId_t) -> CFE_SB_RouteId_Atom_t)(
                RouteId
            ) as isize))
        .SeqCnt;
        *cnt = CFE_MSG_GetNextSequenceCount(*cnt);
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_GetSequenceCounter(
    mut RouteId: CFE_SBR_RouteId_t,
) -> CFE_MSG_SequenceCount_t {
    let mut seqcnt: CFE_MSG_SequenceCount_t = 0 as libc::c_int as CFE_MSG_SequenceCount_t;
    if CFE_SBR_IsValidRouteId(RouteId) {
        seqcnt = CFE_SBR_RDATA.RoutingTbl[CFE_SBR_RouteIdToValue(RouteId) as usize].SeqCnt;
    }
    return seqcnt;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_SBR_ForEachRouteId(
    mut CallbackPtr: CFE_SBR_CallbackPtr_t,
    mut ArgPtr: *mut libc::c_void,
    mut ThrottlePtr: *mut CFE_SBR_Throttle_t,
) {
    let mut routeidx: CFE_SB_RouteId_Atom_t = 0;
    let mut startidx: CFE_SB_RouteId_Atom_t = 0 as libc::c_int as CFE_SB_RouteId_Atom_t;
    let mut endidx: CFE_SB_RouteId_Atom_t = CFE_SBR_RDATA.RouteIdxTop;
    if !ThrottlePtr.is_null() {
        startidx = (*ThrottlePtr).StartIndex as CFE_SB_RouteId_Atom_t;
        (*ThrottlePtr).NextIndex = 0 as libc::c_int as uint32;
        if (startidx as libc::c_uint).wrapping_add((*ThrottlePtr).MaxLoop) < endidx as libc::c_uint
        {
            endidx = (startidx as libc::c_uint).wrapping_add((*ThrottlePtr).MaxLoop)
                as CFE_SB_RouteId_Atom_t;
            (*ThrottlePtr).NextIndex = endidx as uint32;
        }
    }
    routeidx = startidx;
    while (routeidx as libc::c_int) < endidx as libc::c_int {
        (Some(CallbackPtr.expect("non-null function pointer"))).expect("non-null function pointer")(
            CFE_SBR_ValueToRouteId(routeidx),
            ArgPtr,
        );
        routeidx = routeidx.wrapping_add(1);
        routeidx;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ResourceId_GetBase(mut ResourceId: CFE_ResourceId_t) -> uint32 {
    return (CFE_ResourceId_ToInteger(ResourceId)
        & !(0xffff as libc::c_int as uint32) as libc::c_ulong) as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ResourceId_GetSerial(mut ResourceId: CFE_ResourceId_t) -> uint32 {
    return (CFE_ResourceId_ToInteger(ResourceId) & 0xffff as libc::c_int as uint32 as libc::c_ulong)
        as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ResourceId_ToIndex(
    mut Id: CFE_ResourceId_t,
    mut BaseValue: uint32,
    mut TableSize: uint32,
    mut Idx: *mut uint32,
) -> int32 {
    let mut Serial: uint32 = 0;
    if Idx.is_null() {
        return 0xc400000a as libc::c_uint as CFE_Status_t;
    }
    Serial = (CFE_ResourceId_ToInteger(Id)).wrapping_sub(BaseValue as libc::c_ulong) as uint32;
    if Serial > 0xffff as libc::c_int as libc::c_uint
        || TableSize == 0 as libc::c_int as libc::c_uint
    {
        return 0xc4000001 as libc::c_uint as CFE_Status_t;
    }
    *Idx = Serial.wrapping_rem(TableSize);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_ResourceId_FindNext(
    mut StartId: CFE_ResourceId_t,
    mut TableSize: uint32,
    mut CheckFunc: Option<unsafe extern "C" fn(CFE_ResourceId_t) -> bool>,
) -> CFE_ResourceId_t {
    let mut Serial: uint32 = 0;
    let mut Count: uint32 = 0;
    let mut ResourceType: uint32 = 0;
    let mut CheckId: CFE_ResourceId_t = 0;
    let mut IsTaken: bool = false;
    if CheckFunc.is_none() {
        return 0 as libc::c_int as CFE_ResourceId_t;
    }
    ResourceType = CFE_ResourceId_GetBase(StartId);
    Serial = CFE_ResourceId_GetSerial(StartId);
    Count = TableSize;
    IsTaken = 1 as libc::c_int != 0;
    loop {
        if Count == 0 as libc::c_int as libc::c_uint {
            CheckId = 0 as libc::c_int as CFE_ResourceId_t;
            break;
        } else {
            Count = Count.wrapping_sub(1);
            Count;
            Serial = Serial.wrapping_add(1);
            Serial;
            if Serial >= 0xffff as libc::c_int as libc::c_uint {
                Serial = (Serial as libc::c_uint).wrapping_rem(TableSize) as uint32 as uint32;
            }
            CheckId =
                CFE_ResourceId_FromInteger(ResourceType.wrapping_add(Serial) as libc::c_ulong);
            IsTaken = CheckFunc.expect("non-null function pointer")(CheckId);
            if !IsTaken {
                break;
            }
        }
    }
    return CheckId;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_FindStaticModName(
    mut ModuleListSet: *mut *const CFE_ConfigName_t,
    mut SetLength: size_t,
    mut ModuleName: *const libc::c_char,
) -> *const libc::c_char {
    let mut Result: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: size_t = 0;
    Result = 0 as *const libc::c_char;
    i = 0 as libc::c_int as size_t;
    while i < SetLength {
        Result = CFE_Config_IsModuleInList(*ModuleListSet.offset(i as isize), ModuleName);
        if !Result.is_null() {
            break;
        }
        i = i.wrapping_add(1);
        i;
    }
    return Result;
}
#[inline]
unsafe extern "C" fn CFE_Config_OffsetToId(mut OffsetVal: uint32) -> CFE_ConfigId_t {
    return CFE_ResourceId_FromInteger(
        (CFE_CONFIGID_BASE as libc::c_int as libc::c_uint).wrapping_add(OffsetVal) as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_IsPspModule(
    mut PspModuleList: *const CFE_StaticModuleLoadEntry_t,
    mut ModuleName: *const libc::c_char,
) -> *const libc::c_char {
    let mut Result: *const libc::c_char = 0 as *const libc::c_char;
    let mut ModuleListPtr: *const CFE_StaticModuleLoadEntry_t =
        0 as *const CFE_StaticModuleLoadEntry_t;
    ModuleListPtr = PspModuleList;
    Result = 0 as *const libc::c_char;
    while !ModuleListPtr.is_null() && !((*ModuleListPtr).Name).is_null() {
        if CFE_Config_StrCaseEq((*ModuleListPtr).Name, ModuleName) {
            Result = (*ModuleListPtr).Name;
            break;
        } else {
            ModuleListPtr = ModuleListPtr.offset(1);
            ModuleListPtr;
        }
    }
    return Result;
}
#[inline]
unsafe extern "C" fn CFE_Config_IdToOffset(mut ConfigId: CFE_ConfigId_t) -> uint32 {
    let mut OffsetVal: uint32 = 0;
    OffsetVal = CFE_ResourceId_ToInteger(ConfigId) as uint32;
    OffsetVal = (OffsetVal as libc::c_uint)
        .wrapping_sub(CFE_CONFIGID_BASE as libc::c_int as libc::c_uint) as uint32
        as uint32;
    return OffsetVal;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_FindTargetKeyValue(
    mut ConfigList: *const CFE_ConfigKeyValue_t,
    mut KeyName: *const libc::c_char,
) -> *const libc::c_char {
    let mut ValuePtr: *const libc::c_char = 0 as *const libc::c_char;
    ValuePtr = 0 as *const libc::c_char;
    if !KeyName.is_null() && !ConfigList.is_null() {
        while !((*ConfigList).Key).is_null() {
            if CFE_Config_StrCaseEq(KeyName, (*ConfigList).Key) {
                ValuePtr = (*ConfigList).Value as *const libc::c_char;
                break;
            } else {
                ConfigList = ConfigList.offset(1);
                ConfigList;
            }
        }
    }
    return ValuePtr;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_StrCaseEq(
    mut c1: *const libc::c_char,
    mut c2: *const libc::c_char,
) -> bool {
    while *c1 as libc::c_int != 0 as libc::c_int && *c2 as libc::c_int != 0 as libc::c_int {
        if toupper(*c1 as libc::c_uchar as libc::c_int)
            != toupper(*c2 as libc::c_uchar as libc::c_int)
        {
            break;
        }
        c1 = c1.offset(1);
        c1;
        c2 = c2.offset(1);
        c2;
    }
    return *c1 as libc::c_int == 0 as libc::c_int && *c2 as libc::c_int == 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_IsModuleInList(
    mut ModuleListPtr: *const CFE_ConfigName_t,
    mut ModuleName: *const libc::c_char,
) -> *const libc::c_char {
    let mut Result: *const libc::c_char = 0 as *const libc::c_char;
    Result = 0 as *const libc::c_char;
    while !ModuleListPtr.is_null() && !((*ModuleListPtr).Name).is_null() {
        if CFE_Config_StrCaseEq((*ModuleListPtr).Name, ModuleName) {
            Result = (*ModuleListPtr).Name;
            break;
        } else {
            ModuleListPtr = ModuleListPtr.offset(1);
            ModuleListPtr;
        }
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_SetupModuleVersions(
    mut ModuleListSet: *mut *const CFE_ConfigName_t,
    mut SetLength: size_t,
    mut ActiveList: *const CFE_ConfigKeyValue_t,
) {
    let mut ModName: *const libc::c_char = 0 as *const libc::c_char;
    let mut KeyVal: *const libc::c_char = 0 as *const libc::c_char;
    let mut OffsetVal: uint32 = 0;
    let mut NamePtr: *const CFE_Config_IdNameEntry_t = 0 as *const CFE_Config_IdNameEntry_t;
    static mut IDNAME_PREFIX: [libc::c_char; 12] =
        unsafe { *::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"MOD_SRCVER_\0") };
    NamePtr = CFE_CONFIG_IDNAME_MAP.as_ptr();
    OffsetVal = 0 as libc::c_int as uint32;
    while OffsetVal < CFE_ConfigIdOffset_MAX as libc::c_int as libc::c_uint {
        if !((*NamePtr).Name).is_null()
            && strncmp(
                (*NamePtr).Name,
                IDNAME_PREFIX.as_ptr(),
                (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            ) == 0 as libc::c_int
        {
            ModName = ((*NamePtr).Name)
                .offset(::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong as isize)
                .offset(-(1 as libc::c_int as isize));
            ModName = CFE_Config_FindStaticModName(ModuleListSet, SetLength, ModName);
            if !ModName.is_null() {
                KeyVal = CFE_Config_FindTargetKeyValue(ActiveList, ModName);
                if !KeyVal.is_null() {
                    CFE_Config_SetString(CFE_Config_OffsetToId(OffsetVal), KeyVal);
                }
            }
        }
        NamePtr = NamePtr.offset(1);
        NamePtr;
        OffsetVal = OffsetVal.wrapping_add(1);
        OffsetVal;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_SetupBasicBuildInfo() {
    let mut KeyVal: *const libc::c_char = 0 as *const libc::c_char;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_Config_SetString(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_MISSION_NAME as libc::c_int)
                as libc::c_ulong,
        ),
        GLOBAL_CONFIGDATA.MissionName,
    );
    KeyVal = CFE_Config_FindTargetKeyValue(
        GLOBAL_CONFIGDATA.ModuleVersionList,
        b"MISSION\0" as *const u8 as *const libc::c_char,
    );
    CFE_Config_SetString(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_MISSION_SRCVER as libc::c_int)
                as libc::c_ulong,
        ),
        KeyVal,
    );
    CFE_Config_SetObjPointer(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_MISSION_EDS_DB as libc::c_int)
                as libc::c_ulong,
        ),
        GLOBAL_CONFIGDATA.EdsDb as *const libc::c_void,
    );
    CFE_Config_SetObjPointer(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int + CFE_ConfigIdOffset_MISSION_SBINTF_DB as libc::c_int)
                as libc::c_ulong,
        ),
        GLOBAL_CONFIGDATA.SbIntfDb as *const libc::c_void,
    );
    CFE_Config_SetValue(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_VERSION_MAJOR as libc::c_int)
                as libc::c_ulong,
        ),
        6 as libc::c_int as uint32,
    );
    CFE_Config_SetValue(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_VERSION_MINOR as libc::c_int)
                as libc::c_ulong,
        ),
        7 as libc::c_int as uint32,
    );
    CFE_Config_SetValue(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_VERSION_REVISION as libc::c_int)
                as libc::c_ulong,
        ),
        0 as libc::c_int as uint32,
    );
    CFE_Config_SetValue(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_VERSION_MISSION_REV as libc::c_int)
                as libc::c_ulong,
        ),
        0xff as libc::c_int as uint32,
    );
    CFE_Config_SetValue(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_VERSION_BUILDNUM as libc::c_int)
                as libc::c_ulong,
        ),
        96 as libc::c_int as uint32,
    );
    CFE_Config_SetString(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_VERSION_BASELINE as libc::c_int)
                as libc::c_ulong,
        ),
        b"equuleus-rc1\0" as *const u8 as *const libc::c_char,
    );
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"cFE\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v6.7.0\0" as *const u8 as *const libc::c_char,
    );
    CFE_Config_SetString(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_VERSION_DESCRIPTION as libc::c_int)
                as libc::c_ulong,
        ),
        VersionString.as_mut_ptr(),
    );
    KeyVal = CFE_Config_FindTargetKeyValue(
        GLOBAL_CONFIGDATA.BuildEnvironment,
        b"BUILDDATE\0" as *const u8 as *const libc::c_char,
    );
    CFE_Config_SetString(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_BUILDINFO_DATE as libc::c_int)
                as libc::c_ulong,
        ),
        KeyVal,
    );
    KeyVal = CFE_Config_FindTargetKeyValue(
        GLOBAL_CONFIGDATA.BuildEnvironment,
        b"BUILDUSER\0" as *const u8 as *const libc::c_char,
    );
    CFE_Config_SetString(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_BUILDINFO_USER as libc::c_int)
                as libc::c_ulong,
        ),
        KeyVal,
    );
    KeyVal = CFE_Config_FindTargetKeyValue(
        GLOBAL_CONFIGDATA.BuildEnvironment,
        b"BUILDHOST\0" as *const u8 as *const libc::c_char,
    );
    CFE_Config_SetString(
        CFE_ResourceId_FromInteger(
            (CFE_CONFIGID_BASE as libc::c_int
                + CFE_ConfigIdOffset_CORE_BUILDINFO_HOST as libc::c_int)
                as libc::c_ulong,
        ),
        KeyVal,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_Init() -> int32 {
    memset(
        &mut CFE_Config_Global as *mut CFE_Config_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_Config_Global_t>() as libc::c_ulong,
    );
    let mut ModuleListSet: [*const CFE_ConfigName_t; 2] = [
        GLOBAL_CONFIGDATA.CoreModuleList,
        GLOBAL_CONFIGDATA.StaticAppList,
    ];
    CFE_Config_Global.UnknownString = b"[unknown]\0" as *const u8 as *const libc::c_char;
    CFE_Config_SetupBasicBuildInfo();
    CFE_Config_SetupModuleVersions(
        ModuleListSet.as_mut_ptr(),
        2 as libc::c_int as size_t,
        GLOBAL_CONFIGDATA.ModuleVersionList,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut CFE_Config_Global: CFE_Config_Global_t = CFE_Config_Global_t {
    UnknownString: 0 as *const libc::c_char,
    Table: [CFE_Config_ValueEntry_t {
        ActualType: CFE_ConfigType_UNDEFINED,
        Datum: CFE_Config_ValueBuffer { AsInteger: 0 },
    }; 34],
};
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_LocateConfigRecordByID(
    mut ConfigId: CFE_ConfigId_t,
) -> *mut CFE_Config_ValueEntry_t {
    let mut OffsetVal: uint32 = 0;
    OffsetVal = CFE_Config_IdToOffset(ConfigId);
    if OffsetVal >= CFE_ConfigIdOffset_MAX as libc::c_int as libc::c_uint {
        return 0 as *mut CFE_Config_ValueEntry_t;
    }
    return &mut *(CFE_Config_Global.Table)
        .as_mut_ptr()
        .offset(OffsetVal as isize) as *mut CFE_Config_ValueEntry_t;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_GetValue(mut ConfigId: CFE_ConfigId_t) -> uint32 {
    let mut Entry: *const CFE_Config_ValueEntry_t = 0 as *const CFE_Config_ValueEntry_t;
    Entry = CFE_Config_LocateConfigRecordByID(ConfigId);
    if Entry.is_null()
        || (*Entry).ActualType as libc::c_uint
            != CFE_ConfigType_VALUE as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int as uint32;
    }
    return (*Entry).Datum.AsInteger;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_GetObjPointer(
    mut ConfigId: CFE_ConfigId_t,
) -> *const libc::c_void {
    let mut Entry: *const CFE_Config_ValueEntry_t = 0 as *const CFE_Config_ValueEntry_t;
    Entry = CFE_Config_LocateConfigRecordByID(ConfigId);
    if Entry.is_null()
        || (*Entry).ActualType as libc::c_uint
            != CFE_ConfigType_POINTER as libc::c_int as libc::c_uint
            && (*Entry).ActualType as libc::c_uint
                != CFE_ConfigType_STRING as libc::c_int as libc::c_uint
    {
        return 0 as *const libc::c_void;
    }
    return (*Entry).Datum.AsPointer;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_GetString(mut ConfigId: CFE_ConfigId_t) -> *const libc::c_char {
    let mut Entry: *const CFE_Config_ValueEntry_t = 0 as *const CFE_Config_ValueEntry_t;
    Entry = CFE_Config_LocateConfigRecordByID(ConfigId);
    if Entry.is_null()
        || (*Entry).ActualType as libc::c_uint
            != CFE_ConfigType_STRING as libc::c_int as libc::c_uint
    {
        return CFE_Config_Global.UnknownString;
    }
    return (*Entry).Datum.AsPointer as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_GetName(mut ConfigId: CFE_ConfigId_t) -> *const libc::c_char {
    let mut OffsetVal: uint32 = 0;
    OffsetVal = CFE_Config_IdToOffset(ConfigId);
    if OffsetVal >= CFE_ConfigIdOffset_MAX as libc::c_int as libc::c_uint {
        return CFE_Config_Global.UnknownString;
    }
    return (*CFE_CONFIG_IDNAME_MAP.as_ptr().offset(OffsetVal as isize)).Name;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_GetIdByName(mut Name: *const libc::c_char) -> CFE_ConfigId_t {
    let mut NamePtr: *const CFE_Config_IdNameEntry_t = 0 as *const CFE_Config_IdNameEntry_t;
    let mut OffsetVal: uint32 = 0;
    NamePtr = CFE_CONFIG_IDNAME_MAP.as_ptr();
    OffsetVal = 0 as libc::c_int as uint32;
    while OffsetVal < CFE_ConfigIdOffset_MAX as libc::c_int as libc::c_uint {
        if !((*NamePtr).Name).is_null() && strcmp((*NamePtr).Name, Name) == 0 as libc::c_int {
            break;
        }
        NamePtr = NamePtr.offset(1);
        NamePtr;
        OffsetVal = OffsetVal.wrapping_add(1);
        OffsetVal;
    }
    if OffsetVal >= CFE_ConfigIdOffset_MAX as libc::c_int as libc::c_uint {
        return 0 as libc::c_int as CFE_ResourceId_t;
    }
    return CFE_Config_OffsetToId(OffsetVal);
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_IterateAll(
    mut Arg: *mut libc::c_void,
    mut Callback: CFE_Config_Callback_t,
) {
    let mut NamePtr: *const CFE_Config_IdNameEntry_t = 0 as *const CFE_Config_IdNameEntry_t;
    let mut OffsetVal: uint32 = 0;
    NamePtr = CFE_CONFIG_IDNAME_MAP.as_ptr();
    OffsetVal = 0 as libc::c_int as uint32;
    while OffsetVal < CFE_ConfigIdOffset_MAX as libc::c_int as libc::c_uint {
        if CFE_Config_Global.Table[OffsetVal as usize].ActualType as libc::c_uint
            != CFE_ConfigType_UNDEFINED as libc::c_int as libc::c_uint
        {
            Callback.expect("non-null function pointer")(
                Arg,
                CFE_Config_OffsetToId(OffsetVal),
                (*NamePtr).Name,
            );
        }
        NamePtr = NamePtr.offset(1);
        NamePtr;
        OffsetVal = OffsetVal.wrapping_add(1);
        OffsetVal;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_GetVersionString(
    mut Buf: *mut libc::c_char,
    mut Size: size_t,
    mut Component: *const libc::c_char,
    mut SrcVersion: *const libc::c_char,
    mut CodeName: *const libc::c_char,
    mut LastOffcRel: *const libc::c_char,
) {
    snprintf(
        Buf,
        Size,
        b"%s %s %s (Codename %s), Last Official Release: %s %s)\0" as *const u8
            as *const libc::c_char,
        Component,
        if 0 as libc::c_int == 0 as libc::c_int {
            b"Development Build\0" as *const u8 as *const libc::c_char
        } else {
            b"Release\0" as *const u8 as *const libc::c_char
        },
        SrcVersion,
        CodeName,
        Component,
        LastOffcRel,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_SetValue(mut ConfigId: CFE_ConfigId_t, mut Value: uint32) {
    let mut Entry: *mut CFE_Config_ValueEntry_t = 0 as *mut CFE_Config_ValueEntry_t;
    Entry = CFE_Config_LocateConfigRecordByID(ConfigId);
    if !Entry.is_null() {
        (*Entry).ActualType = CFE_ConfigType_VALUE;
        (*Entry).Datum.AsInteger = Value;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_SetObjPointer(
    mut ConfigId: CFE_ConfigId_t,
    mut Ptr: *const libc::c_void,
) {
    let mut Entry: *mut CFE_Config_ValueEntry_t = 0 as *mut CFE_Config_ValueEntry_t;
    Entry = CFE_Config_LocateConfigRecordByID(ConfigId);
    if !Entry.is_null() {
        (*Entry).ActualType = CFE_ConfigType_POINTER;
        (*Entry).Datum.AsPointer = Ptr;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Config_SetString(
    mut ConfigId: CFE_ConfigId_t,
    mut Ptr: *const libc::c_char,
) {
    let mut Entry: *mut CFE_Config_ValueEntry_t = 0 as *mut CFE_Config_ValueEntry_t;
    Entry = CFE_Config_LocateConfigRecordByID(ConfigId);
    if !Entry.is_null() {
        (*Entry).ActualType = CFE_ConfigType_STRING;
        (*Entry).Datum.AsPointer = Ptr as *const libc::c_void;
    }
}
#[no_mangle]
pub static mut CFE_CONFIG_IDNAME_MAP: [CFE_Config_IdNameEntry_t; 34] = [
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MISSION_NAME\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MISSION_SRCVER\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MISSION_EDS_DB\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MISSION_SBINTF_DB\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_VERSION_MAJOR\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_VERSION_MINOR\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_VERSION_REVISION\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_VERSION_MISSION_REV\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_VERSION_BUILDNUM\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_VERSION_BASELINE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_VERSION_DESCRIPTION\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_BUILDINFO_DATE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_BUILDINFO_USER\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"CORE_BUILDINFO_HOST\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_CORE_API\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_CORE_PRIVATE\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_CI_LAB\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_TO_LAB\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_SCH_LAB\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_CFE_ASSERT\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_SAMPLE_APP\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_SAMPLE_LIB\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_ES\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_EVS\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_FS\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_SB\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_TBL\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_TIME\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_OSAL\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_PSP\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_MSG\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_SBR\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_RESOURCEID\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_Config_IdNameEntry {
            Name: b"MOD_SRCVER_CONFIG\0" as *const u8 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut CI_LAB_Global: CI_LAB_GlobalData_t = CI_LAB_GlobalData_t {
    SocketConnected: false,
    Scheduled: false,
    CommandPipe: 0,
    SocketID: 0,
    SocketAddress: OS_SockAddr_t {
        ActualLength: 0,
        AddrData: OS_SockAddrData_t { Buffer: [0; 28] },
    },
    HkTlm: CI_LAB_HkTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: CI_LAB_HkTlm_Payload_t {
            CommandErrorCounter: 0,
            CommandCounter: 0,
            EnableChecksums: 0,
            SocketConnected: 0,
            Spare1: [0; 8],
            IngestPackets: 0,
            IngestErrors: 0,
            Spare2: 0,
        },
    },
    NetBufPtr: 0 as *const libc::c_void as *mut libc::c_void,
    NetBufSize: 0,
};
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_ReadUpLink() {
    let mut i: libc::c_int = 0;
    let mut OsStatus: int32 = 0;
    let mut CfeStatus: CFE_Status_t = 0;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    i = 0 as libc::c_int;
    while i <= 10 as libc::c_int {
        if (CI_LAB_Global.NetBufPtr).is_null() {
            CI_LAB_GetInputBuffer(&mut CI_LAB_Global.NetBufPtr, &mut CI_LAB_Global.NetBufSize);
        }
        if (CI_LAB_Global.NetBufPtr).is_null() {
            break;
        }
        OsStatus = OS_SocketRecvFrom(
            CI_LAB_Global.SocketID,
            CI_LAB_Global.NetBufPtr,
            CI_LAB_Global.NetBufSize,
            &mut CI_LAB_Global.SocketAddress,
            0 as libc::c_int,
        );
        if !(OsStatus > 0 as libc::c_int) {
            break;
        }
        CFE_ES_PerfLogAdd(33 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        CfeStatus =
            CI_LAB_DecodeInputMessage(CI_LAB_Global.NetBufPtr, OsStatus as size_t, &mut SBBufPtr);
        if CfeStatus != 0 as libc::c_int {
            CI_LAB_Global.HkTlm.Payload.IngestErrors =
                (CI_LAB_Global.HkTlm.Payload.IngestErrors).wrapping_add(1);
            CI_LAB_Global.HkTlm.Payload.IngestErrors;
        } else {
            CI_LAB_Global.HkTlm.Payload.IngestPackets =
                (CI_LAB_Global.HkTlm.Payload.IngestPackets).wrapping_add(1);
            CI_LAB_Global.HkTlm.Payload.IngestPackets;
            CfeStatus = CFE_SB_TransmitBuffer(SBBufPtr, 0 as libc::c_int != 0);
        }
        CFE_ES_PerfLogAdd(33 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        if CfeStatus == 0 as libc::c_int {
            CI_LAB_Global.NetBufPtr = 0 as *mut libc::c_void;
            CI_LAB_Global.NetBufSize = 0 as libc::c_int as size_t;
        } else {
            CFE_EVS_SendEvent(
                10 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"CI_LAB: Ingest failed, status=%d\n\0" as *const u8 as *const libc::c_char,
                CfeStatus,
            );
        }
        i += 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_delete_callback() {
    OS_printf(
        b"CI delete callback -- Closing CI Network socket.\n\0" as *const u8 as *const libc::c_char,
    );
    OS_close(CI_LAB_Global.SocketID);
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_TaskInit() {
    let mut status: int32 = 0;
    let mut DefaultListenPort: uint16 = 0;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    memset(
        &mut CI_LAB_Global as *mut CI_LAB_GlobalData_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CI_LAB_GlobalData_t>() as libc::c_ulong,
    );
    status = CFE_EVS_Register(
        0 as *const libc::c_void,
        0 as libc::c_int as uint16,
        CFE_EVS_EventFilter_BINARY as libc::c_int as uint16,
    );
    if status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"CI_LAB: Error registering for Event Services, RC = 0x%08X\n\0" as *const u8
                as *const libc::c_char,
            status as libc::c_uint,
        );
    }
    status = CFE_SB_CreatePipe(
        &mut CI_LAB_Global.CommandPipe,
        32 as libc::c_int as uint16,
        b"CI_LAB_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    if status == 0 as libc::c_int {
        status = CFE_SB_Subscribe(
            CFE_SB_ValueToMsgId(
                (0x1800 as libc::c_int | 0x84 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            CI_LAB_Global.CommandPipe,
        );
        if status != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                12 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error subscribing to SB Commands, RC = 0x%08X\0" as *const u8
                    as *const libc::c_char,
                status as libc::c_uint,
            );
        }
        status = CFE_SB_Subscribe(
            CFE_SB_ValueToMsgId(
                (0x1800 as libc::c_int | 0x85 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            CI_LAB_Global.CommandPipe,
        );
        if status != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                13 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error subscribing to SB HK Request, RC = 0x%08X\0" as *const u8
                    as *const libc::c_char,
                status as libc::c_uint,
            );
        }
        status = CFE_SB_Subscribe(
            CFE_SB_ValueToMsgId(
                (0x1800 as libc::c_int | 0x86 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            CI_LAB_Global.CommandPipe,
        );
        if status != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                14 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Error subscribing to SB Read Uplink Request, RC = 0x%08X\0" as *const u8
                    as *const libc::c_char,
                status as libc::c_uint,
            );
        }
    } else {
        CFE_EVS_SendEvent(
            11 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Error creating SB Command Pipe, RC = 0x%08X\0" as *const u8 as *const libc::c_char,
            status as libc::c_uint,
        );
    }
    status = OS_SocketOpen(
        &mut CI_LAB_Global.SocketID,
        OS_SocketDomain_INET,
        OS_SocketType_DATAGRAM,
    );
    if status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            1 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CI: create socket failed = %d\0" as *const u8 as *const libc::c_char,
            status,
        );
    } else {
        OS_SocketAddrInit(&mut CI_LAB_Global.SocketAddress, OS_SocketDomain_INET);
        DefaultListenPort = (1234 as libc::c_int as libc::c_uint)
            .wrapping_add(CFE_PSP_GetProcessorId())
            .wrapping_sub(1 as libc::c_int as libc::c_uint) as uint16;
        OS_SocketAddrSetPort(&mut CI_LAB_Global.SocketAddress, DefaultListenPort);
        status = OS_SocketBind(CI_LAB_Global.SocketID, &mut CI_LAB_Global.SocketAddress);
        if status != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                2 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"CI: bind socket failed = %d\0" as *const u8 as *const libc::c_char,
                status,
            );
        } else {
            CI_LAB_Global.SocketConnected = 1 as libc::c_int != 0;
            CFE_ES_WriteToSysLog(
                b"CI_LAB listening on UDP port: %u\n\0" as *const u8 as *const libc::c_char,
                DefaultListenPort as libc::c_uint,
            );
        }
    }
    CI_LAB_ResetCounters_Internal();
    OS_TaskInstallDeleteHandler(Some(CI_LAB_delete_callback as unsafe extern "C" fn() -> ()));
    CFE_MSG_Init(
        &mut CI_LAB_Global.HkTlm.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 0x84 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<CI_LAB_HkTlm_t>() as libc::c_ulong,
    );
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"CI Lab App\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev57\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v2.3.0\0" as *const u8 as *const libc::c_char,
    );
    CFE_EVS_SendEvent(
        3 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"CI Lab Initialized.%s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_AppMain() {
    let mut status: CFE_Status_t = 0;
    let mut RunStatus: uint32 = CFE_ES_RunStatus_APP_RUN as libc::c_int as uint32;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(32 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    CI_LAB_TaskInit();
    while CFE_ES_RunLoop(&mut RunStatus) as libc::c_int == 1 as libc::c_int {
        CFE_ES_PerfLogAdd(32 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        status = CFE_SB_ReceiveBuffer(&mut SBBufPtr, CI_LAB_Global.CommandPipe, 500 as libc::c_int);
        CFE_ES_PerfLogAdd(32 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if status == 0 as libc::c_int {
            CI_LAB_TaskPipe(SBBufPtr);
        }
        if CI_LAB_Global.SocketConnected as libc::c_int != 0 && !CI_LAB_Global.Scheduled {
            CI_LAB_ReadUpLink();
        }
    }
    CFE_ES_ExitApp(RunStatus);
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_ResetCounters_Internal() {
    CI_LAB_Global.HkTlm.Payload.CommandCounter = 0 as libc::c_int as uint8;
    CI_LAB_Global.HkTlm.Payload.CommandErrorCounter = 0 as libc::c_int as uint8;
    CI_LAB_Global.HkTlm.Payload.IngestPackets = 0 as libc::c_int as uint32;
    CI_LAB_Global.HkTlm.Payload.IngestErrors = 0 as libc::c_int as uint32;
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_NoopCmd(mut cmd: *const CI_LAB_NoopCmd_t) -> CFE_Status_t {
    CI_LAB_Global.HkTlm.Payload.CommandCounter =
        (CI_LAB_Global.HkTlm.Payload.CommandCounter).wrapping_add(1);
    CI_LAB_Global.HkTlm.Payload.CommandCounter;
    CFE_EVS_SendEvent(
        5 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"CI: NOOP command. Version %d.%d.%d.%d\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        3 as libc::c_int,
        0 as libc::c_int,
        0xff as libc::c_int,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_ResetCountersCmd(
    mut cmd: *const CI_LAB_ResetCountersCmd_t,
) -> CFE_Status_t {
    CFE_EVS_SendEvent(
        6 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"CI: RESET command\0" as *const u8 as *const libc::c_char,
    );
    CI_LAB_ResetCounters_Internal();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_SendHkCmd(mut cmd: *const CI_LAB_SendHkCmd_t) -> CFE_Status_t {
    CI_LAB_Global.HkTlm.Payload.SocketConnected = CI_LAB_Global.SocketConnected as uint8;
    CFE_SB_TimeStampMsg(&mut CI_LAB_Global.HkTlm.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut CI_LAB_Global.HkTlm.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_ReadUplinkCmd(
    mut cmd: *const CI_LAB_ReadUplinkCmd_t,
) -> CFE_Status_t {
    CI_LAB_Global.Scheduled = 1 as libc::c_int != 0;
    CI_LAB_ReadUpLink();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_VerifyCmdLength(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut ExpectedLength: size_t,
) -> bool {
    let mut result: bool = 1 as libc::c_int != 0;
    let mut ActualLength: size_t = 0 as libc::c_int as size_t;
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetSize(MsgPtr, &mut ActualLength);
    if ExpectedLength != ActualLength {
        CFE_MSG_GetMsgId(MsgPtr, &mut MsgId);
        CFE_MSG_GetFcnCode(MsgPtr, &mut FcnCode);
        CFE_EVS_SendEvent(
            16 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid msg length: ID = 0x%X,  CC = %u, Len = %u, Expected = %u\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            FcnCode as libc::c_uint,
            ActualLength as libc::c_uint,
            ExpectedLength as libc::c_uint,
        );
        result = 0 as libc::c_int != 0;
        CI_LAB_Global.HkTlm.Payload.CommandErrorCounter =
            (CI_LAB_Global.HkTlm.Payload.CommandErrorCounter).wrapping_add(1);
        CI_LAB_Global.HkTlm.Payload.CommandErrorCounter;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_ProcessGroundCommand(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut FcnCode);
    match FcnCode as libc::c_int {
        0 => {
            if CI_LAB_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CI_LAB_NoopCmd_t>() as libc::c_ulong,
            ) {
                CI_LAB_NoopCmd(SBBufPtr as *const CI_LAB_NoopCmd_t);
            }
        }
        1 => {
            if CI_LAB_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<CI_LAB_ResetCountersCmd_t>() as libc::c_ulong,
            ) {
                CI_LAB_ResetCountersCmd(SBBufPtr as *const CI_LAB_ResetCountersCmd_t);
            }
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_TaskPipe(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MsgId);
    match CFE_SB_MsgIdToValue(MsgId) {
        6276 => {
            CI_LAB_ProcessGroundCommand(SBBufPtr);
        }
        6277 => {
            CI_LAB_SendHkCmd(SBBufPtr as *const CI_LAB_SendHkCmd_t);
        }
        6278 => {
            CI_LAB_ReadUplinkCmd(SBBufPtr as *const CI_LAB_ReadUplinkCmd_t);
        }
        _ => {
            CI_LAB_Global.HkTlm.Payload.CommandErrorCounter =
                (CI_LAB_Global.HkTlm.Payload.CommandErrorCounter).wrapping_add(1);
            CI_LAB_Global.HkTlm.Payload.CommandErrorCounter;
            CFE_EVS_SendEvent(
                4 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"CI: invalid command packet,MID = 0x%x\0" as *const u8 as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_GetInputBuffer(
    mut BufferOut: *mut *mut libc::c_void,
    mut SizeOut: *mut size_t,
) -> CFE_Status_t {
    let mut IngestBuffer: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    let IngestSize: size_t = 768 as libc::c_int as size_t;
    IngestBuffer = CFE_SB_AllocateMessageBuffer(IngestSize);
    if IngestBuffer.is_null() {
        *BufferOut = 0 as *mut libc::c_void;
        *SizeOut = 0 as libc::c_int as size_t;
        CFE_EVS_SendEvent(
            9 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CI_LAB: buffer allocation failed\n\0" as *const u8 as *const libc::c_char,
        );
        return 0xca000008 as libc::c_uint as CFE_Status_t;
    }
    *BufferOut = IngestBuffer as *mut libc::c_void;
    *SizeOut = IngestSize;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CI_LAB_DecodeInputMessage(
    mut SourceBuffer: *mut libc::c_void,
    mut SourceSize: size_t,
    mut DestBufferOut: *mut *mut CFE_SB_Buffer_t,
) -> CFE_Status_t {
    let mut MsgBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    let mut MsgSize: CFE_MSG_Size_t = 0;
    let mut Status: CFE_Status_t = 0;
    if SourceSize < ::core::mem::size_of::<CFE_MSG_CommandHeader_t>() as libc::c_ulong {
        MsgBufPtr = 0 as *mut CFE_SB_Buffer_t;
        Status = 0xc8000002 as libc::c_uint as CFE_Status_t;
        CFE_EVS_SendEvent(
            8 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"CI: cmd dropped, bad packet length=%lu\n\0" as *const u8 as *const libc::c_char,
            SourceSize,
        );
    } else {
        MsgBufPtr = SourceBuffer as *mut CFE_SB_Buffer_t;
        CFE_MSG_GetSize(&mut (*MsgBufPtr).Msg, &mut MsgSize);
        if MsgSize > SourceSize {
            Status = 0xc8000002 as libc::c_uint as CFE_Status_t;
            CFE_EVS_SendEvent(
                8 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"CI: cmd dropped - length mismatch, %lu (hdr) / %lu (packet)\n\0" as *const u8
                    as *const libc::c_char,
                MsgSize,
                SourceSize,
            );
        } else {
            Status = 0 as libc::c_int;
        }
    }
    *DestBufferOut = MsgBufPtr;
    return Status;
}
#[no_mangle]
pub static mut TO_LAB_Subs: TO_LAB_Subs_t = {
    let mut init = TO_LAB_Subs_t {
        Subs: [
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 0x80 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 0x81 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 0 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 1 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 3 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 4 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 5 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 6 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 10 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 12 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 8 as libc::c_int) as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 32 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 11 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 16 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 0x84 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x800 as libc::c_int | 0x83 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 4 as libc::c_int as uint16,
                };
                init
            },
            {
                let mut init = TO_LAB_Sub_t {
                    Stream: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    Flags: {
                        let mut init = CFE_SB_Qos_t {
                            Priority: 0 as libc::c_int as uint8,
                            Reliability: 0 as libc::c_int as uint8,
                        };
                        init
                    },
                    BufLimit: 0 as libc::c_int as uint16,
                };
                init
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
            TO_LAB_Sub_t {
                Stream: CFE_SB_MsgId_t { Value: 0 },
                Flags: CFE_SB_Qos_t {
                    Priority: 0,
                    Reliability: 0,
                },
                BufLimit: 0,
            },
        ],
    };
    init
};
#[no_mangle]
pub static mut CFE_TBL_FileDef: CFE_TBL_FileDef_t = unsafe {
    {
        let mut init = CFE_TBL_FileDef {
            ObjectName: *::core::mem::transmute::<
                &[u8; 64],
                &mut [libc::c_char; 64],
            >(
                b"TO_LAB_Subs\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
            ),
            TableName: *::core::mem::transmute::<
                &[u8; 40],
                &mut [libc::c_char; 40],
            >(b"TO_LAB_APP.TO_LAB_Subs\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
            Description: *::core::mem::transmute::<
                &[u8; 32],
                &mut [libc::c_char; 32],
            >(b"TO Lab Sub Tbl\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
            TgtFilename: *::core::mem::transmute::<
                &[u8; 20],
                &mut [libc::c_char; 20],
            >(b"to_lab_sub.tbl\0\0\0\0\0\0"),
            ObjectSize: ::core::mem::size_of::<TO_LAB_Subs_t>() as libc::c_ulong
                as uint32,
        };
        init
    }
};
#[no_mangle]
pub static mut TO_LAB_Global: TO_LAB_GlobalData_t = TO_LAB_GlobalData_t {
    Tlm_pipe: 0,
    Cmd_pipe: 0,
    TLMsockid: 0,
    downlink_on: false,
    tlm_dest_IP: [0; 17],
    suppress_sendto: false,
    HkTlm: TO_LAB_HkTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: TO_LAB_HkTlm_Payload_t {
            CommandCounter: 0,
            CommandErrorCounter: 0,
            spareToAlign: [0; 2],
        },
    },
    DataTypesTlm: TO_LAB_DataTypesTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: TO_LAB_DataTypes_Payload_t {
            synch: 0,
            bl1: 0,
            bl2: 0,
            b1: 0,
            b2: 0,
            b3: 0,
            b4: 0,
            w1: 0,
            w2: 0,
            dw1: 0,
            dw2: 0,
            f1: 0.,
            f2: 0.,
            df1: 0.,
            df2: 0.,
            str_0: [0; 10],
        },
    },
    SubsTblPtr: 0 as *const TO_LAB_Subs_t as *mut TO_LAB_Subs_t,
    SubsTblHandle: 0,
};
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_openTLM() {
    let mut status: int32 = 0;
    status = OS_SocketOpen(
        &mut TO_LAB_Global.TLMsockid,
        OS_SocketDomain_INET,
        OS_SocketType_DATAGRAM,
    );
    if status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            6 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d, TO TLM socket error: %d\0" as *const u8 as *const libc::c_char,
            252 as libc::c_int,
            status,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_delete_callback() {
    OS_printf(
        b"TO delete callback -- Closing TO Network socket.\n\0" as *const u8 as *const libc::c_char,
    );
    if TO_LAB_Global.downlink_on {
        OS_close(TO_LAB_Global.TLMsockid);
    }
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_init() -> int32 {
    let mut status: CFE_Status_t = 0;
    let mut PipeName: [libc::c_char; 16] = [0; 16];
    let mut PipeDepth: uint16 = 0;
    let mut i: uint16 = 0;
    let mut ToTlmPipeName: [libc::c_char; 16] = [0; 16];
    let mut ToTlmPipeDepth: uint16 = 0;
    let mut TblPtr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut SubEntry: *mut TO_LAB_Sub_t = 0 as *mut TO_LAB_Sub_t;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    TO_LAB_Global.downlink_on = 0 as libc::c_int != 0;
    PipeDepth = 8 as libc::c_int as uint16;
    strcpy(
        PipeName.as_mut_ptr(),
        b"TO_LAB_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    ToTlmPipeDepth = 50 as libc::c_int as uint16;
    strcpy(
        ToTlmPipeName.as_mut_ptr(),
        b"TO_LAB_TLM_PIPE\0" as *const u8 as *const libc::c_char,
    );
    status = CFE_EVS_Register(
        0 as *const libc::c_void,
        0 as libc::c_int as uint16,
        CFE_EVS_EventFilter_BINARY as libc::c_int as uint16,
    );
    if status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"TO_LAB: Error registering for Event Services, RC = 0x%08X\n\0" as *const u8
                as *const libc::c_char,
            status as libc::c_uint,
        );
        return status;
    }
    CFE_MSG_Init(
        &mut TO_LAB_Global.HkTlm.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 0x80 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<TO_LAB_HkTlm_t>() as libc::c_ulong,
    );
    status = CFE_TBL_Register(
        &mut TO_LAB_Global.SubsTblHandle,
        b"TO_LAB_Subs\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<TO_LAB_Subs_t>() as libc::c_ulong,
        (0 as libc::c_int | 0 as libc::c_int) as uint16,
        None,
    );
    if status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            19 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d TO Can't register table status %i\0" as *const u8 as *const libc::c_char,
            138 as libc::c_int,
            status,
        );
        return status;
    }
    status = CFE_TBL_Load(
        TO_LAB_Global.SubsTblHandle,
        CFE_TBL_SRC_FILE,
        b"/cf/to_lab_sub.tbl\0" as *const u8 as *const libc::c_char as *const libc::c_void,
    );
    if status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            19 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d TO Can't load table status %i\0" as *const u8 as *const libc::c_char,
            146 as libc::c_int,
            status,
        );
        return status;
    }
    status = CFE_TBL_GetAddress(
        &mut TblPtr as *mut *mut libc::c_void,
        TO_LAB_Global.SubsTblHandle,
    );
    if status != 0 as libc::c_int && status != 0x4c00000e as libc::c_int {
        CFE_EVS_SendEvent(
            19 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d TO Can't get table addr status %i\0" as *const u8 as *const libc::c_char,
            156 as libc::c_int,
            status,
        );
        return status;
    }
    TO_LAB_Global.SubsTblPtr = TblPtr as *mut TO_LAB_Subs_t;
    status = CFE_SB_CreatePipe(
        &mut TO_LAB_Global.Cmd_pipe,
        PipeDepth,
        PipeName.as_mut_ptr(),
    );
    if status == 0 as libc::c_int {
        CFE_SB_Subscribe(
            CFE_SB_ValueToMsgId(
                (0x1800 as libc::c_int | 0x80 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            TO_LAB_Global.Cmd_pipe,
        );
        CFE_SB_Subscribe(
            CFE_SB_ValueToMsgId(
                (0x1800 as libc::c_int | 0x81 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            TO_LAB_Global.Cmd_pipe,
        );
    } else {
        CFE_EVS_SendEvent(
            2 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d TO Can't create cmd pipe status %i\0" as *const u8 as *const libc::c_char,
            171 as libc::c_int,
            status,
        );
    }
    status = CFE_SB_CreatePipe(
        &mut TO_LAB_Global.Tlm_pipe,
        ToTlmPipeDepth,
        ToTlmPipeName.as_mut_ptr(),
    );
    if status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            5 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d TO Can't create Tlm pipe status %i\0" as *const u8 as *const libc::c_char,
            178 as libc::c_int,
            status,
        );
    }
    SubEntry = ((*TO_LAB_Global.SubsTblPtr).Subs).as_mut_ptr();
    i = 0 as libc::c_int as uint16;
    while (i as libc::c_int) < 32 as libc::c_int {
        if !CFE_SB_IsValidMsgId((*SubEntry).Stream) {
            break;
        }
        status = CFE_SB_SubscribeEx(
            (*SubEntry).Stream,
            TO_LAB_Global.Tlm_pipe,
            (*SubEntry).Flags,
            (*SubEntry).BufLimit,
        );
        if status != 0 as libc::c_int {
            CFE_EVS_SendEvent(
                4 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"L%d TO Can't subscribe to stream 0x%x status %i\0" as *const u8
                    as *const libc::c_char,
                195 as libc::c_int,
                CFE_SB_MsgIdToValue((*SubEntry).Stream),
                status,
            );
        }
        SubEntry = SubEntry.offset(1);
        SubEntry;
        i = i.wrapping_add(1);
        i;
    }
    OS_TaskInstallDeleteHandler(Some(TO_LAB_delete_callback as unsafe extern "C" fn() -> ()));
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"TO Lab\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev44\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v2.3.0\0" as *const u8 as *const libc::c_char,
    );
    CFE_EVS_SendEvent(
        1 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"TO Lab Initialized.%s, Awaiting enable command.\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_AppMain() {
    let mut RunStatus: uint32 = CFE_ES_RunStatus_APP_RUN as libc::c_int as uint32;
    let mut status: CFE_Status_t = 0;
    CFE_ES_PerfLogAdd(34 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    status = TO_LAB_init();
    if status != 0 as libc::c_int {
        return;
    }
    while CFE_ES_RunLoop(&mut RunStatus) as libc::c_int == 1 as libc::c_int {
        CFE_ES_PerfLogAdd(34 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        OS_TaskDelay(500 as libc::c_int as uint32);
        CFE_ES_PerfLogAdd(34 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        TO_LAB_forward_telemetry();
        TO_LAB_process_commands();
    }
    CFE_ES_ExitApp(RunStatus);
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_process_commands() {
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    let mut Status: CFE_Status_t = 0;
    loop {
        Status = CFE_SB_ReceiveBuffer(&mut SBBufPtr, TO_LAB_Global.Cmd_pipe, 0 as libc::c_int);
        if Status != 0 as libc::c_int {
            break;
        }
        TO_LAB_TaskPipe(SBBufPtr);
    }
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_forward_telemetry() {
    let mut d_addr: OS_SockAddr_t = OS_SockAddr_t {
        ActualLength: 0,
        AddrData: OS_SockAddrData_t { Buffer: [0; 28] },
    };
    let mut OsStatus: int32 = 0;
    let mut CfeStatus: CFE_Status_t = 0;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    let mut NetBufPtr: *const libc::c_void = 0 as *const libc::c_void;
    let mut NetBufSize: size_t = 0;
    let mut PktCount: uint32 = 0 as libc::c_int as uint32;
    OS_SocketAddrInit(&mut d_addr, OS_SocketDomain_INET);
    OS_SocketAddrSetPort(&mut d_addr, 1235 as libc::c_int as uint16);
    OS_SocketAddrFromString(&mut d_addr, (TO_LAB_Global.tlm_dest_IP).as_mut_ptr());
    OsStatus = 0 as libc::c_int;
    loop {
        CfeStatus = CFE_SB_ReceiveBuffer(&mut SBBufPtr, TO_LAB_Global.Tlm_pipe, 0 as libc::c_int);
        if CfeStatus == 0 as libc::c_int
            && TO_LAB_Global.suppress_sendto as libc::c_int == 0 as libc::c_int
        {
            OsStatus = 0 as libc::c_int;
            if TO_LAB_Global.downlink_on as libc::c_int == 1 as libc::c_int {
                CFE_ES_PerfLogAdd(35 as libc::c_int as uint32, 0 as libc::c_int as uint32);
                CfeStatus = TO_LAB_EncodeOutputMessage(SBBufPtr, &mut NetBufPtr, &mut NetBufSize);
                if CfeStatus != 0 as libc::c_int {
                    CFE_EVS_SendEvent(
                        20 as libc::c_int as uint16,
                        CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                        b"Error packing output: %d\n\0" as *const u8 as *const libc::c_char,
                        CfeStatus,
                    );
                } else {
                    OsStatus = OS_SocketSendTo(
                        TO_LAB_Global.TLMsockid,
                        NetBufPtr,
                        NetBufSize,
                        &mut d_addr,
                    );
                }
                CFE_ES_PerfLogAdd(35 as libc::c_int as uint32, 1 as libc::c_int as uint32);
            }
            if OsStatus < 0 as libc::c_int {
                CFE_EVS_SendEvent(
                    7 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"L%d TO sendto error %d. Tlm output suppressed\n\0" as *const u8
                        as *const libc::c_char,
                    308 as libc::c_int,
                    OsStatus,
                );
                TO_LAB_Global.suppress_sendto = 1 as libc::c_int != 0;
            }
        }
        PktCount = PktCount.wrapping_add(1);
        PktCount;
        if !(CfeStatus == 0 as libc::c_int && PktCount < 50 as libc::c_int as libc::c_uint) {
            break;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_EnableOutputCmd(
    mut data: *const TO_LAB_EnableOutputCmd_t,
) -> CFE_Status_t {
    let mut pCmd: *const TO_LAB_EnableOutput_Payload_t = &(*data).Payload;
    CFE_SB_MessageStringGet(
        (TO_LAB_Global.tlm_dest_IP).as_mut_ptr(),
        ((*pCmd).dest_IP).as_ptr(),
        b"\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong,
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    TO_LAB_Global.suppress_sendto = 0 as libc::c_int != 0;
    CFE_EVS_SendEvent(
        3 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"TO telemetry output enabled for IP %s\0" as *const u8 as *const libc::c_char,
        (TO_LAB_Global.tlm_dest_IP).as_mut_ptr(),
    );
    if !TO_LAB_Global.downlink_on {
        TO_LAB_openTLM();
        TO_LAB_Global.downlink_on = 1 as libc::c_int != 0;
    }
    TO_LAB_Global.HkTlm.Payload.CommandCounter =
        (TO_LAB_Global.HkTlm.Payload.CommandCounter).wrapping_add(1);
    TO_LAB_Global.HkTlm.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_NoopCmd(mut data: *const TO_LAB_NoopCmd_t) -> CFE_Status_t {
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"TO Lab\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev44\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v2.3.0\0" as *const u8 as *const libc::c_char,
    );
    CFE_EVS_SendEvent(
        18 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"TO: NOOP command. %s\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    TO_LAB_Global.HkTlm.Payload.CommandCounter =
        (TO_LAB_Global.HkTlm.Payload.CommandCounter).wrapping_add(1);
    TO_LAB_Global.HkTlm.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_ResetCountersCmd(
    mut data: *const TO_LAB_ResetCountersCmd_t,
) -> CFE_Status_t {
    TO_LAB_Global.HkTlm.Payload.CommandErrorCounter = 0 as libc::c_int as uint8;
    TO_LAB_Global.HkTlm.Payload.CommandCounter = 0 as libc::c_int as uint8;
    CFE_EVS_SendEvent(
        13 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"Reset counters command\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_SendDataTypesCmd(
    mut data: *const TO_LAB_SendDataTypesCmd_t,
) -> CFE_Status_t {
    let mut i: int16 = 0;
    let mut string_variable: [libc::c_char; 10] =
        *::core::mem::transmute::<&[u8; 10], &mut [libc::c_char; 10]>(b"ABCDEFGHIJ");
    CFE_MSG_Init(
        &mut TO_LAB_Global.DataTypesTlm.TelemetryHeader.Msg,
        CFE_SB_ValueToMsgId((0x800 as libc::c_int | 0x81 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        ::core::mem::size_of::<TO_LAB_DataTypesTlm_t>() as libc::c_ulong,
    );
    CFE_SB_TimeStampMsg(&mut TO_LAB_Global.DataTypesTlm.TelemetryHeader.Msg);
    TO_LAB_Global.DataTypesTlm.Payload.synch = 0x6969 as libc::c_int as uint16;
    TO_LAB_Global.DataTypesTlm.Payload.bl1 = 0 as libc::c_int as uint8;
    TO_LAB_Global.DataTypesTlm.Payload.bl2 = 1 as libc::c_int as uint8;
    TO_LAB_Global.DataTypesTlm.Payload.b1 = 16 as libc::c_int as int8;
    TO_LAB_Global.DataTypesTlm.Payload.b2 = 127 as libc::c_int as int8;
    TO_LAB_Global.DataTypesTlm.Payload.b3 = 0x7f as libc::c_int as int8;
    TO_LAB_Global.DataTypesTlm.Payload.b4 = 0x45 as libc::c_int as int8;
    TO_LAB_Global.DataTypesTlm.Payload.w1 = 0x2468 as libc::c_int as int16;
    TO_LAB_Global.DataTypesTlm.Payload.w2 = 0x7fff as libc::c_int as int16;
    TO_LAB_Global.DataTypesTlm.Payload.dw1 = 0x12345678 as libc::c_int;
    TO_LAB_Global.DataTypesTlm.Payload.dw2 = 0x87654321 as libc::c_uint as int32;
    TO_LAB_Global.DataTypesTlm.Payload.f1 = 90.01f64 as libc::c_float;
    TO_LAB_Global.DataTypesTlm.Payload.f2 = 0.0000045f64 as libc::c_float;
    TO_LAB_Global.DataTypesTlm.Payload.df1 = 99.9f64;
    TO_LAB_Global.DataTypesTlm.Payload.df2 = 0.4444f64;
    i = 0 as libc::c_int as int16;
    while (i as libc::c_int) < 10 as libc::c_int {
        TO_LAB_Global.DataTypesTlm.Payload.str_0[i as usize] = string_variable[i as usize];
        i += 1;
        i;
    }
    CFE_SB_TransmitMsg(
        &mut TO_LAB_Global.DataTypesTlm.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    TO_LAB_Global.HkTlm.Payload.CommandCounter =
        (TO_LAB_Global.HkTlm.Payload.CommandCounter).wrapping_add(1);
    TO_LAB_Global.HkTlm.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_SendHkCmd(mut data: *const TO_LAB_SendHkCmd_t) -> CFE_Status_t {
    CFE_SB_TimeStampMsg(&mut TO_LAB_Global.HkTlm.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut TO_LAB_Global.HkTlm.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_AddPacketCmd(
    mut data: *const TO_LAB_AddPacketCmd_t,
) -> CFE_Status_t {
    let mut pCmd: *const TO_LAB_AddPacket_Payload_t = &(*data).Payload;
    let mut status: int32 = 0;
    status = CFE_SB_SubscribeEx(
        (*pCmd).Stream,
        TO_LAB_Global.Tlm_pipe,
        (*pCmd).Flags,
        (*pCmd).BufLimit as uint16,
    );
    if status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            10 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d TO Can't subscribe 0x%x status %i\0" as *const u8 as *const libc::c_char,
            169 as libc::c_int,
            CFE_SB_MsgIdToValue((*pCmd).Stream),
            status,
        );
    } else {
        CFE_EVS_SendEvent(
            15 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"L%d TO AddPkt 0x%x, QoS %d.%d, limit %d\0" as *const u8 as *const libc::c_char,
            172 as libc::c_int,
            CFE_SB_MsgIdToValue((*pCmd).Stream),
            (*pCmd).Flags.Priority as libc::c_int,
            (*pCmd).Flags.Reliability as libc::c_int,
            (*pCmd).BufLimit as libc::c_int,
        );
    }
    TO_LAB_Global.HkTlm.Payload.CommandCounter =
        (TO_LAB_Global.HkTlm.Payload.CommandCounter).wrapping_add(1);
    TO_LAB_Global.HkTlm.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_RemovePacketCmd(
    mut data: *const TO_LAB_RemovePacketCmd_t,
) -> CFE_Status_t {
    let mut pCmd: *const TO_LAB_RemovePacket_Payload_t = &(*data).Payload;
    let mut status: int32 = 0;
    status = CFE_SB_Unsubscribe((*pCmd).Stream, TO_LAB_Global.Tlm_pipe);
    if status != 0 as libc::c_int {
        CFE_EVS_SendEvent(
            11 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"L%d TO Can't Unsubscribe to Stream 0x%x, status %i\0" as *const u8
                as *const libc::c_char,
            193 as libc::c_int,
            CFE_SB_MsgIdToValue((*pCmd).Stream),
            status,
        );
    } else {
        CFE_EVS_SendEvent(
            16 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"L%d TO RemovePkt 0x%x\0" as *const u8 as *const libc::c_char,
            196 as libc::c_int,
            CFE_SB_MsgIdToValue((*pCmd).Stream),
        );
    }
    TO_LAB_Global.HkTlm.Payload.CommandCounter =
        (TO_LAB_Global.HkTlm.Payload.CommandCounter).wrapping_add(1);
    TO_LAB_Global.HkTlm.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_RemoveAllCmd(
    mut data: *const TO_LAB_RemoveAllCmd_t,
) -> CFE_Status_t {
    let mut status: int32 = 0;
    let mut i: libc::c_int = 0;
    let mut SubEntry: *mut TO_LAB_Sub_t = 0 as *mut TO_LAB_Sub_t;
    SubEntry = ((*TO_LAB_Global.SubsTblPtr).Subs).as_mut_ptr();
    i = 0 as libc::c_int;
    while i < 32 as libc::c_int {
        if CFE_SB_IsValidMsgId((*SubEntry).Stream) {
            status = CFE_SB_Unsubscribe((*SubEntry).Stream, TO_LAB_Global.Tlm_pipe);
            if status != 0 as libc::c_int {
                CFE_EVS_SendEvent(
                    12 as libc::c_int as uint16,
                    CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                    b"L%d TO Can't Unsubscribe to stream 0x%x status %i\0" as *const u8
                        as *const libc::c_char,
                    222 as libc::c_int,
                    CFE_SB_MsgIdToValue((*SubEntry).Stream),
                    status,
                );
            }
        }
        i += 1;
        i;
    }
    CFE_EVS_SendEvent(
        17 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"L%d TO Unsubscribed to all Commands and Telemetry\0" as *const u8 as *const libc::c_char,
        228 as libc::c_int,
    );
    TO_LAB_Global.HkTlm.Payload.CommandCounter =
        (TO_LAB_Global.HkTlm.Payload.CommandCounter).wrapping_add(1);
    TO_LAB_Global.HkTlm.Payload.CommandCounter;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_ProcessGroundCommand(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut CommandCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut CommandCode);
    match CommandCode as libc::c_int {
        0 => {
            TO_LAB_NoopCmd(SBBufPtr as *const TO_LAB_NoopCmd_t);
        }
        1 => {
            TO_LAB_ResetCountersCmd(SBBufPtr as *const TO_LAB_ResetCountersCmd_t);
        }
        3 => {
            TO_LAB_SendDataTypesCmd(SBBufPtr as *const TO_LAB_SendDataTypesCmd_t);
        }
        2 => {
            TO_LAB_AddPacketCmd(SBBufPtr as *const TO_LAB_AddPacketCmd_t);
        }
        4 => {
            TO_LAB_RemovePacketCmd(SBBufPtr as *const TO_LAB_RemovePacketCmd_t);
        }
        5 => {
            TO_LAB_RemoveAllCmd(SBBufPtr as *const TO_LAB_RemoveAllCmd_t);
        }
        6 => {
            TO_LAB_EnableOutputCmd(SBBufPtr as *const TO_LAB_EnableOutputCmd_t);
        }
        _ => {
            CFE_EVS_SendEvent(
                9 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"L%d TO: Invalid Function Code Rcvd In Ground Command 0x%x\0" as *const u8
                    as *const libc::c_char,
                76 as libc::c_int,
                CommandCode as libc::c_uint,
            );
            TO_LAB_Global.HkTlm.Payload.CommandErrorCounter =
                (TO_LAB_Global.HkTlm.Payload.CommandErrorCounter).wrapping_add(1);
            TO_LAB_Global.HkTlm.Payload.CommandErrorCounter;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_TaskPipe(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MsgId: CFE_SB_MsgId_t = CFE_SB_MsgId_t { Value: 0 };
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MsgId);
    match CFE_SB_MsgIdToValue(MsgId) {
        6272 => {
            TO_LAB_ProcessGroundCommand(SBBufPtr);
        }
        6273 => {
            TO_LAB_SendHkCmd(SBBufPtr as *const TO_LAB_SendHkCmd_t);
        }
        _ => {
            CFE_EVS_SendEvent(
                8 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"L%d TO: Invalid Msg ID Rcvd 0x%x\0" as *const u8 as *const libc::c_char,
                101 as libc::c_int,
                CFE_SB_MsgIdToValue(MsgId),
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn TO_LAB_EncodeOutputMessage(
    mut SourceBuffer: *const CFE_SB_Buffer_t,
    mut DestBufferOut: *mut *const libc::c_void,
    mut DestSizeOut: *mut size_t,
) -> CFE_Status_t {
    let mut ResultStatus: CFE_Status_t = 0;
    let mut SourceBufferSize: CFE_MSG_Size_t = 0;
    ResultStatus = CFE_MSG_GetSize(&(*SourceBuffer).Msg, &mut SourceBufferSize);
    *DestBufferOut = SourceBuffer as *const libc::c_void;
    *DestSizeOut = SourceBufferSize;
    return ResultStatus;
}
#[no_mangle]
pub static mut SCH_LAB_ScheduleTable: SCH_LAB_ScheduleTable_t = {
    let mut init = SCH_LAB_ScheduleTable_t {
        TickRate: 100 as libc::c_int as uint32,
        Config: [
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 8 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 100 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 12 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 50 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 13 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 98 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 11 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 97 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 9 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 96 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 0x85 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 95 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 0x81 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 94 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            {
                let mut init = SCH_LAB_ScheduleTableEntry_t {
                    MessageID: {
                        let mut init = CFE_SB_MsgId_t {
                            Value: (0x1800 as libc::c_int | 0x83 as libc::c_int)
                                as CFE_SB_MsgId_Atom_t,
                        };
                        init
                    },
                    PacketRate: 93 as libc::c_int as uint32,
                    FcnCode: 0 as libc::c_int as CFE_MSG_FcnCode_t,
                    PayloadLength: 0,
                    MessageBuffer: [0; 32],
                };
                init
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
            SCH_LAB_ScheduleTableEntry_t {
                MessageID: CFE_SB_MsgId_t { Value: 0 },
                PacketRate: 0,
                FcnCode: 0,
                PayloadLength: 0,
                MessageBuffer: [0; 32],
            },
        ],
    };
    init
};
#[no_mangle]
pub static mut apps_sch_lab_fsw_tables_sch_lab_table_c__CFE_TBL_FileDef: CFE_TBL_FileDef_t = unsafe {
    {
        let mut init = CFE_TBL_FileDef {
            ObjectName: *::core::mem::transmute::<
                &[u8; 64],
                &mut [libc::c_char; 64],
            >(
                b"SCH_LAB_ScheduleTable\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
            ),
            TableName: *::core::mem::transmute::<
                &[u8; 40],
                &mut [libc::c_char; 40],
            >(b"SCH_LAB_APP.ScheduleTable\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
            Description: *::core::mem::transmute::<
                &[u8; 32],
                &mut [libc::c_char; 32],
            >(b"Schedule Lab MsgID Table\0\0\0\0\0\0\0\0"),
            TgtFilename: *::core::mem::transmute::<
                &[u8; 20],
                &mut [libc::c_char; 20],
            >(b"sch_lab_table.tbl\0\0\0"),
            ObjectSize: ::core::mem::size_of::<SCH_LAB_ScheduleTable_t>()
                as libc::c_ulong as uint32,
        };
        init
    }
};
#[no_mangle]
pub static mut SCH_LAB_Global: SCH_LAB_GlobalData_t = SCH_LAB_GlobalData_t {
    State: [SCH_LAB_StateEntry_t {
        CommandHeader: CFE_MSG_CommandHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_CommandSecondaryHeader_t {
                FunctionCode: 0,
                Checksum: 0,
            },
        },
        MessageBuffer: [0; 32],
        PayloadLength: 0,
        PacketRate: 0,
        Counter: 0,
    }; 32],
    TimerId: 0,
    TimingSem: 0,
    TblHandle: 0,
    CmdPipe: 0,
};
#[no_mangle]
pub unsafe extern "C" fn SCH_LAB_AppMain() {
    let mut i: libc::c_int = 0;
    let mut SCH_OneHzPktsRcvd: uint32 = 0 as libc::c_int as uint32;
    let mut OsStatus: int32 = 0;
    let mut Status: CFE_Status_t = 0;
    let mut RunStatus: uint32 = CFE_ES_RunStatus_APP_RUN as libc::c_int as uint32;
    let mut LocalStateEntry: *mut SCH_LAB_StateEntry_t = 0 as *mut SCH_LAB_StateEntry_t;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(36 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    Status = SCH_LAB_AppInit();
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"SCH_LAB: Error Initializing RC = 0x%08lX\n\0" as *const u8 as *const libc::c_char,
            Status as libc::c_ulong,
        );
        RunStatus = CFE_ES_RunStatus_APP_ERROR as libc::c_int as uint32;
    }
    while CFE_ES_RunLoop(&mut RunStatus) as libc::c_int == 1 as libc::c_int {
        CFE_ES_PerfLogAdd(36 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        OsStatus = OS_CountSemTake(SCH_LAB_Global.TimingSem);
        if OsStatus == 0 as libc::c_int {
            Status = CFE_SB_ReceiveBuffer(&mut SBBufPtr, SCH_LAB_Global.CmdPipe, 0 as libc::c_int);
        } else {
            Status = 0xc8000005 as libc::c_uint as CFE_Status_t;
        }
        CFE_ES_PerfLogAdd(36 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if Status == 0 as libc::c_int {
            SCH_OneHzPktsRcvd = SCH_OneHzPktsRcvd.wrapping_add(1);
            SCH_OneHzPktsRcvd;
        }
        if OsStatus == 0 as libc::c_int && SCH_OneHzPktsRcvd > 0 as libc::c_int as libc::c_uint {
            LocalStateEntry = (SCH_LAB_Global.State).as_mut_ptr();
            i = 0 as libc::c_int;
            while i < 32 as libc::c_int {
                if (*LocalStateEntry).PacketRate != 0 as libc::c_int as libc::c_uint {
                    (*LocalStateEntry).Counter = ((*LocalStateEntry).Counter).wrapping_add(1);
                    (*LocalStateEntry).Counter;
                    if (*LocalStateEntry).Counter >= (*LocalStateEntry).PacketRate {
                        (*LocalStateEntry).Counter = 0 as libc::c_int as uint32;
                        CFE_SB_TransmitMsg(
                            &mut (*LocalStateEntry).CommandHeader.Msg,
                            1 as libc::c_int != 0,
                        );
                    }
                }
                LocalStateEntry = LocalStateEntry.offset(1);
                LocalStateEntry;
                i += 1;
                i;
            }
        }
    }
    CFE_ES_ExitApp(RunStatus);
}
#[no_mangle]
pub unsafe extern "C" fn SCH_LAB_LocalTimerCallback(
    mut object_id: osal_id_t,
    mut arg: *mut libc::c_void,
) {
    OS_CountSemGive(SCH_LAB_Global.TimingSem);
}
#[no_mangle]
pub unsafe extern "C" fn SCH_LAB_AppInit() -> CFE_Status_t {
    let mut i: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut Status: CFE_Status_t = 0;
    let mut OsStatus: int32 = 0;
    let mut TimerPeriod: uint32 = 0;
    let mut TimeBaseId: osal_id_t = 0 as libc::c_int as osal_id_t;
    let mut ConfigTable: *mut SCH_LAB_ScheduleTable_t = 0 as *mut SCH_LAB_ScheduleTable_t;
    let mut ConfigEntry: *mut SCH_LAB_ScheduleTableEntry_t = 0 as *mut SCH_LAB_ScheduleTableEntry_t;
    let mut LocalStateEntry: *mut SCH_LAB_StateEntry_t = 0 as *mut SCH_LAB_StateEntry_t;
    let mut TableAddr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    memset(
        &mut SCH_LAB_Global as *mut SCH_LAB_GlobalData_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<SCH_LAB_GlobalData_t>() as libc::c_ulong,
    );
    OsStatus = OS_CountSemCreate(
        &mut SCH_LAB_Global.TimingSem,
        b"SCH_LAB\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: OS_CountSemCreate failed:RC=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SCH_LAB_AppInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_TimeBaseGetIdByName(
        &mut TimeBaseId,
        b"cFS-Master\0" as *const u8 as *const libc::c_char,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: OS_TimeBaseGetIdByName failed:RC=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SCH_LAB_AppInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    OsStatus = OS_TimerAdd(
        &mut SCH_LAB_Global.TimerId,
        b"SCH_LAB\0" as *const u8 as *const libc::c_char,
        TimeBaseId,
        Some(
            SCH_LAB_LocalTimerCallback as unsafe extern "C" fn(osal_id_t, *mut libc::c_void) -> (),
        ),
        0 as *mut libc::c_void,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: OS_TimerAdd failed:RC=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SCH_LAB_AppInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    Status = CFE_TBL_Register(
        &mut SCH_LAB_Global.TblHandle,
        b"ScheduleTable\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<SCH_LAB_ScheduleTable_t>() as libc::c_ulong,
        (0 as libc::c_int | 0 as libc::c_int) as uint16,
        None,
    );
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"SCH_LAB: Error Registering ScheduleTable, RC = 0x%08lX\n\0" as *const u8
                as *const libc::c_char,
            Status as libc::c_ulong,
        );
        return Status;
    } else {
        Status = CFE_TBL_Load(
            SCH_LAB_Global.TblHandle,
            CFE_TBL_SRC_FILE,
            b"/cf/sch_lab_table.tbl\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        );
        if Status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"SCH_LAB: Error Loading Table ScheduleTable, RC = 0x%08lX\n\0" as *const u8
                    as *const libc::c_char,
                Status as libc::c_ulong,
            );
            CFE_TBL_ReleaseAddress(SCH_LAB_Global.TblHandle);
            return Status;
        }
    }
    Status = CFE_TBL_GetAddress(&mut TableAddr, SCH_LAB_Global.TblHandle);
    if Status != 0 as libc::c_int && Status != 0x4c00000e as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"SCH_LAB: Error Getting Table's Address ScheduleTable, RC = 0x%08lX\n\0" as *const u8
                as *const libc::c_char,
            Status as libc::c_ulong,
        );
        return Status;
    }
    ConfigTable = TableAddr as *mut SCH_LAB_ScheduleTable_t;
    ConfigEntry = ((*ConfigTable).Config).as_mut_ptr();
    LocalStateEntry = (SCH_LAB_Global.State).as_mut_ptr();
    i = 0 as libc::c_int;
    while i < 32 as libc::c_int {
        if (*ConfigEntry).PacketRate != 0 as libc::c_int as libc::c_uint {
            CFE_MSG_Init(
                &mut (*LocalStateEntry).CommandHeader.Msg,
                (*ConfigEntry).MessageID,
                (::core::mem::size_of::<CFE_MSG_CommandHeader_t>() as libc::c_ulong)
                    .wrapping_add((*ConfigEntry).PayloadLength as libc::c_ulong),
            );
            CFE_MSG_SetFcnCode(
                &mut (*LocalStateEntry).CommandHeader.Msg,
                (*ConfigEntry).FcnCode,
            );
            (*LocalStateEntry).PacketRate = (*ConfigEntry).PacketRate;
            (*LocalStateEntry).PayloadLength = (*ConfigEntry).PayloadLength;
            x = 0 as libc::c_int;
            while x < 32 as libc::c_int {
                (*LocalStateEntry).MessageBuffer[x as usize] =
                    (*ConfigEntry).MessageBuffer[x as usize];
                x += 1;
                x;
            }
        }
        ConfigEntry = ConfigEntry.offset(1);
        ConfigEntry;
        LocalStateEntry = LocalStateEntry.offset(1);
        LocalStateEntry;
        i += 1;
        i;
    }
    if (*ConfigTable).TickRate == 0 as libc::c_int as libc::c_uint {
        CFE_ES_WriteToSysLog(
            b"%s: Using default tick rate of 1 second\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SCH_LAB_AppInit\0"))
                .as_ptr(),
        );
        TimerPeriod = 1000000 as libc::c_int as uint32;
    } else {
        TimerPeriod =
            (1000000 as libc::c_int as libc::c_uint).wrapping_div((*ConfigTable).TickRate);
        if TimerPeriod.wrapping_mul((*ConfigTable).TickRate)
            != 1000000 as libc::c_int as libc::c_uint
        {
            CFE_ES_WriteToSysLog(
                b"%s: WARNING: tick rate of %lu is not an integer number of microseconds\n\0"
                    as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SCH_LAB_AppInit\0"))
                    .as_ptr(),
                (*ConfigTable).TickRate as libc::c_ulong,
            );
        }
    }
    Status = CFE_TBL_ReleaseAddress(SCH_LAB_Global.TblHandle);
    if Status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"SCH_LAB: Error Releasing Table ScheduleTable, RC = 0x%08lX\n\0" as *const u8
                as *const libc::c_char,
            Status as libc::c_ulong,
        );
    }
    Status = CFE_SB_CreatePipe(
        &mut SCH_LAB_Global.CmdPipe,
        8 as libc::c_int as uint16,
        b"SCH_LAB_CMD_PIPE\0" as *const u8 as *const libc::c_char,
    );
    if Status != 0 as libc::c_int {
        OS_printf(b"SCH Error creating pipe!\n\0" as *const u8 as *const libc::c_char);
    }
    Status = CFE_SB_Subscribe(
        CFE_SB_ValueToMsgId((0x1800 as libc::c_int | 17 as libc::c_int) as CFE_SB_MsgId_Atom_t),
        SCH_LAB_Global.CmdPipe,
    );
    if Status != 0 as libc::c_int {
        OS_printf(b"SCH Error subscribing to 1hz!\n\0" as *const u8 as *const libc::c_char);
    }
    OsStatus = OS_TimerSet(
        SCH_LAB_Global.TimerId,
        1000000 as libc::c_int as uint32,
        TimerPeriod,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: OS_TimerSet failed:RC=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SCH_LAB_AppInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
    }
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"SCH Lab\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev29\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v2.3.0\0" as *const u8 as *const libc::c_char,
    );
    OS_printf(
        b"SCH Lab Initialized.%s\n\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_Unlock() {
    let mut OsStatus: int32 = 0;
    OsStatus = OS_MutSemGive(CFE_Assert_Global.AccessMutex);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s(): Error from OS_MutSemGive(): %ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"UT_BSP_Unlock\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_WriteLogFile(
    mut FileDesc: osal_id_t,
    mut MessageType: uint8,
    mut Prefix: *const libc::c_char,
    mut OutputMessage: *const libc::c_char,
) {
    let mut LogFileBuffer: [libc::c_char; 512] = [0; 512];
    let mut MsgEnabled: uint32 = CFE_Assert_Global.CurrVerbosity >> MessageType as libc::c_int;
    if MsgEnabled & 1 as libc::c_int as libc::c_uint != 0 {
        snprintf(
            LogFileBuffer.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
            b"[%5s] %s\n\0" as *const u8 as *const libc::c_char,
            Prefix,
            OutputMessage,
        );
        OS_write(
            FileDesc,
            LogFileBuffer.as_mut_ptr() as *const libc::c_void,
            strlen(LogFileBuffer.as_mut_ptr()),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_DoText(
    mut MessageType: uint8,
    mut OutputMessage: *const libc::c_char,
) {
    let mut Prefix: *const libc::c_char = 0 as *const libc::c_char;
    let mut StatusCallback: CFE_Assert_StatusCallback_t = None;
    Prefix = UtAssert_GetCaseTypeAbbrev(MessageType as UtAssert_CaseType_t);
    StatusCallback = CFE_Assert_Global.StatusCallback;
    if StatusCallback.is_none() {
        StatusCallback = Some(
            UT_BSP_SysLogStatusReport
                as unsafe extern "C" fn(uint8, *const libc::c_char, *const libc::c_char) -> (),
        );
    }
    StatusCallback.expect("non-null function pointer")(MessageType, Prefix, OutputMessage);
    if OS_ObjectIdDefined(CFE_Assert_Global.LogFileDesc) {
        UT_BSP_WriteLogFile(
            CFE_Assert_Global.LogFileDesc,
            MessageType,
            Prefix,
            OutputMessage,
        );
    }
    if MessageType as libc::c_int == UTASSERT_CASETYPE_ABORT as libc::c_int {
        OS_TaskExit();
    }
}
#[no_mangle]
pub static mut CFE_Assert_Global: CFE_Assert_Global_t = CFE_Assert_Global_t {
    LibState: CFE_Assert_State_INIT,
    CurrVerbosity: 0,
    StatusCallback: None,
    LogFileFinal: [0; 64],
    LogFileTemp: [0; 64],
    LogFileDesc: 0,
    AccessMutex: 0,
    OwnerAppId: 0,
    CurrentTestName: [0; 20],
    StoredStatus: 0,
    StoredText: [0; 512],
    StoredFile: [0; 64],
    StoredLine: 0,
};
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_Setup() {
    CFE_Assert_Global.CurrVerbosity = (((2 as libc::c_int)
        << UTASSERT_CASETYPE_PASS as libc::c_int)
        - 1 as libc::c_int) as uint32;
    UT_BSP_DoText(
        UTASSERT_CASETYPE_BEGIN as libc::c_int as uint8,
        b"CFE FUNCTIONAL TEST\0" as *const u8 as *const libc::c_char,
    );
}
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_StartTestSegment(
    mut SegmentNumber: uint32,
    mut SegmentName: *const libc::c_char,
) {
    let mut ReportBuffer: [libc::c_char; 128] = [0; 128];
    snprintf(
        ReportBuffer.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
        b"%02u %s\0" as *const u8 as *const libc::c_char,
        SegmentNumber,
        SegmentName,
    );
    UT_BSP_DoText(
        UTASSERT_CASETYPE_BEGIN as libc::c_int as uint8,
        ReportBuffer.as_mut_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_SysLogStatusReport(
    mut MessageType: uint8,
    mut Prefix: *const libc::c_char,
    mut OutputMessage: *const libc::c_char,
) {
    let mut MsgEnabled: uint32 = CFE_Assert_Global.CurrVerbosity >> MessageType as libc::c_int;
    if MsgEnabled & 1 as libc::c_int as libc::c_uint != 0 {
        CFE_ES_WriteToSysLog(
            b"[%5s] %s\n\0" as *const u8 as *const libc::c_char,
            Prefix,
            OutputMessage,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_Lock() {
    let mut OsStatus: int32 = 0;
    OsStatus = OS_MutSemTake(CFE_Assert_Global.AccessMutex);
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s(): Error from OS_MutSemTake(): %ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"UT_BSP_Lock\0")).as_ptr(),
            OsStatus as libc::c_long,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn UT_BSP_EndTest(mut TestCounters: *const UtAssert_TestCounter_t) {
    CFE_ES_WriteToSysLog(
        b"TEST COMPLETE: %u tests Segment(s) executed\n\n\0" as *const u8 as *const libc::c_char,
        (*TestCounters).TestSegmentCount,
    );
    if (*TestCounters).TestSegmentCount > 1 as libc::c_int as libc::c_uint {
        UtAssert_DoTestSegmentReport(
            b"SUMMARY\0" as *const u8 as *const libc::c_char,
            TestCounters,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_RegisterCallback(mut Callback: CFE_Assert_StatusCallback_t) {
    CFE_Assert_Global.StatusCallback = Callback;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_OpenLogFile(mut Filename: *const libc::c_char) -> int32 {
    let mut OsStatus: int32 = 0;
    let mut Ext: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut NameLen: size_t = 0;
    strncpy(
        (CFE_Assert_Global.LogFileFinal).as_mut_ptr(),
        Filename,
        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    CFE_Assert_Global.LogFileFinal[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = 0 as libc::c_int as libc::c_char;
    strncpy(
        (CFE_Assert_Global.LogFileTemp).as_mut_ptr(),
        Filename,
        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    CFE_Assert_Global.LogFileTemp[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = 0 as libc::c_int as libc::c_char;
    Ext = strrchr((CFE_Assert_Global.LogFileTemp).as_mut_ptr(), '.' as i32);
    if Ext.is_null() {
        NameLen = strlen((CFE_Assert_Global.LogFileTemp).as_mut_ptr());
    } else {
        NameLen =
            Ext.offset_from((CFE_Assert_Global.LogFileTemp).as_mut_ptr()) as libc::c_long as size_t;
    }
    if NameLen
        > (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(5 as libc::c_int as libc::c_ulong)
    {
        NameLen = (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(5 as libc::c_int as libc::c_ulong);
    }
    strcpy(
        &mut *(CFE_Assert_Global.LogFileTemp)
            .as_mut_ptr()
            .offset(NameLen as isize),
        b".tmp\0" as *const u8 as *const libc::c_char,
    );
    OsStatus = OS_OpenCreate(
        &mut CFE_Assert_Global.LogFileDesc,
        (CFE_Assert_Global.LogFileTemp).as_mut_ptr(),
        OS_FILE_FLAG_CREATE as libc::c_int | OS_FILE_FLAG_TRUNCATE as libc::c_int,
        1 as libc::c_int,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Failed to open %s, rc=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_Assert_OpenLogFile\0",
            ))
            .as_ptr(),
            (CFE_Assert_Global.LogFileTemp).as_mut_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_CloseLogFile() {
    if OS_ObjectIdDefined(CFE_Assert_Global.LogFileDesc) {
        OS_close(CFE_Assert_Global.LogFileDesc);
        OS_rename(
            (CFE_Assert_Global.LogFileTemp).as_mut_ptr(),
            (CFE_Assert_Global.LogFileFinal).as_mut_ptr(),
        );
    }
    CFE_Assert_Global.LogFileDesc = 0 as libc::c_int as osal_id_t;
    CFE_Assert_Global.LogFileTemp[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    CFE_Assert_Global.LogFileFinal[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_LibInit(mut LibId: CFE_ES_LibId_t) -> int32 {
    let mut OsStatus: int32 = 0;
    memset(
        &mut CFE_Assert_Global as *mut CFE_Assert_Global_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CFE_Assert_Global_t>() as libc::c_ulong,
    );
    UtTest_EarlyInit();
    UT_BSP_Setup();
    OsStatus = OS_MutSemCreate(
        &mut CFE_Assert_Global.AccessMutex,
        b"CFE_Assert\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as uint32,
    );
    if OsStatus != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: OS_MutSemCreate failed, rc=%ld\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 19], &[libc::c_char; 19]>(b"CFE_Assert_LibInit\0"))
                .as_ptr(),
            OsStatus as libc::c_long,
        );
        return 0xc8000005 as libc::c_uint as CFE_Status_t;
    }
    UtAssert_BeginTest(b"CFE-STARTUP\0" as *const u8 as *const libc::c_char);
    return 0 as libc::c_int;
}
static mut CFE_TR_EventFilters: [CFE_EVS_BinFilter_t; 11] = [
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_ABORT as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_FAILURE as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_TSF as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_TTF as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_MIR as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_NA as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_BEGIN as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_END as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_INFO as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_PASS as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
    {
        let mut init = CFE_EVS_BinFilter {
            EventID: UTASSERT_CASETYPE_DEBUG as libc::c_int as uint16,
            Mask: 0 as libc::c_int as uint16,
        };
        init
    },
];
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_StatusCheck(
    mut Status: CFE_Status_t,
    mut ExpectSuccess: bool,
    mut CaseType: UtAssert_CaseType_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut Text: *const libc::c_char,
) -> bool {
    let mut Result: bool = Status >= 0 as libc::c_int;
    let mut MatchText: *const libc::c_char = 0 as *const libc::c_char;
    if ExpectSuccess {
        MatchText = b"OK\0" as *const u8 as *const libc::c_char;
    } else {
        Result = !Result;
        MatchText = b"ERROR\0" as *const u8 as *const libc::c_char;
    }
    return UtAssertEx(
        Result,
        CaseType,
        File,
        Line,
        b"%s (0x%lx) is %s\0" as *const u8 as *const libc::c_char,
        Text,
        Status as libc::c_ulong,
        MatchText,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_Status_Store(
    mut Status: CFE_Status_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut Text: *const libc::c_char,
) -> CFE_Status_t {
    let mut BaseName: *const libc::c_char = 0 as *const libc::c_char;
    CFE_Assert_Global.StoredStatus = Status;
    strncpy(
        (CFE_Assert_Global.StoredText).as_mut_ptr(),
        Text,
        (::core::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    CFE_Assert_Global.StoredText[(::core::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = 0 as libc::c_int as libc::c_char;
    BaseName = strrchr(File, '/' as i32);
    if BaseName.is_null() {
        BaseName = File;
    } else {
        BaseName = BaseName.offset(1);
        BaseName;
    }
    strncpy(
        (CFE_Assert_Global.StoredFile).as_mut_ptr(),
        BaseName,
        (::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    CFE_Assert_Global.StoredFile[(::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = 0 as libc::c_int as libc::c_char;
    CFE_Assert_Global.StoredLine = Line;
    return Status;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_Status_SilentCheck(mut Status: CFE_Status_t) -> bool {
    return Status == CFE_Assert_Global.StoredStatus;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_Status_DeferredCheck(
    mut Status: CFE_Status_t,
    mut CaseType: UtAssert_CaseType_t,
    mut File: *const libc::c_char,
    mut Line: uint32,
    mut Text: *const libc::c_char,
) -> bool {
    let mut Result: bool = false;
    let mut ExtraTag: *const libc::c_char = 0 as *const libc::c_char;
    if CFE_Assert_Global.StoredText[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
        UtAssertEx(
            0 as libc::c_int != 0,
            UTASSERT_CASETYPE_FAILURE,
            File,
            Line,
            b"TEST BUG: No stored status to assert (%s)\0" as *const u8 as *const libc::c_char,
            Text,
        );
        Result = 0 as libc::c_int != 0;
    } else {
        Result = CFE_Assert_Status_SilentCheck(Status);
        if Result {
            ExtraTag = b"\0" as *const u8 as *const libc::c_char;
        } else {
            ExtraTag = b" [false]\0" as *const u8 as *const libc::c_char;
        }
        Result = UtAssertEx(
            Result,
            CaseType,
            (CFE_Assert_Global.StoredFile).as_mut_ptr(),
            CFE_Assert_Global.StoredLine,
            b"%s (%ld) == %s (%ld)%s\0" as *const u8 as *const libc::c_char,
            (CFE_Assert_Global.StoredText).as_mut_ptr(),
            CFE_Assert_Global.StoredStatus as libc::c_long,
            Text,
            Status as libc::c_long,
            ExtraTag,
        );
    }
    return Result;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_StatusReport(
    mut MessageType: uint8,
    mut Prefix: *const libc::c_char,
    mut OutputMessage: *const libc::c_char,
) {
    let mut EventType: uint16 = 0;
    match MessageType as libc::c_int {
        1 => {
            EventType = CFE_EVS_EventType_CRITICAL as libc::c_int as uint16;
        }
        2 | 3 | 4 => {
            EventType = CFE_EVS_EventType_ERROR as libc::c_int as uint16;
        }
        8 | 9 | 10 | 5 => {
            EventType = CFE_EVS_EventType_INFORMATION as libc::c_int as uint16;
        }
        7 | 11 | 13 | _ => {
            EventType = CFE_EVS_EventType_DEBUG as libc::c_int as uint16;
        }
    }
    CFE_EVS_SendEvent(
        MessageType as uint16,
        EventType,
        b"[%5s] %s\0" as *const u8 as *const libc::c_char,
        Prefix,
        OutputMessage,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_RegisterTest(mut TestName: *const libc::c_char) -> int32 {
    let mut rc: int32 = 0;
    let mut SetupSegmentName: [libc::c_char; 64] = [0; 64];
    let mut SelfId: CFE_ES_AppId_t = 0;
    rc = CFE_EVS_Register(
        CFE_TR_EventFilters.as_mut_ptr() as *const libc::c_void,
        (::core::mem::size_of::<[CFE_EVS_BinFilter_t; 11]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<CFE_EVS_BinFilter_t>() as libc::c_ulong)
            as uint16,
        CFE_EVS_EventFilter_BINARY as libc::c_int as uint16,
    );
    if rc != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error from CFE_EVS_Register: %08lx\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_Assert_RegisterTest\0",
            ))
            .as_ptr(),
            rc as libc::c_ulong,
        );
        return rc;
    }
    rc = CFE_ES_WaitForSystemState(
        CFE_ES_SystemState_OPERATIONAL as libc::c_int as uint32,
        30000 as libc::c_int as uint32,
    );
    if rc != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s: Error while waiting for OPERATIONAL state: %08lx\n\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_Assert_RegisterTest\0",
            ))
            .as_ptr(),
            rc as libc::c_ulong,
        );
        return rc;
    }
    rc = CFE_ES_GetAppID(&mut SelfId);
    if rc != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"%s(): Error from CFE_ES_GetAppId(): %08x\n\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 24], &[libc::c_char; 24]>(
                b"CFE_Assert_RegisterTest\0",
            ))
            .as_ptr(),
            rc as libc::c_uint,
        );
        return rc;
    }
    UT_BSP_Lock();
    while CFE_ResourceId_IsDefined(CFE_Assert_Global.OwnerAppId) {
        UT_BSP_Unlock();
        OS_TaskDelay(100 as libc::c_int as uint32);
        UT_BSP_Lock();
    }
    CFE_Assert_Global.OwnerAppId = SelfId;
    UT_BSP_Unlock();
    if CFE_Assert_Global.LibState as libc::c_uint
        != CFE_Assert_State_ACTIVE as libc::c_int as libc::c_uint
    {
        UtAssert_EndTest();
        CFE_Assert_Global.LibState = CFE_Assert_State_ACTIVE;
        OS_TaskDelay(1000 as libc::c_int as uint32);
    }
    UtTest_EarlyInit();
    strncpy(
        (CFE_Assert_Global.CurrentTestName).as_mut_ptr(),
        TestName,
        (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    );
    CFE_Assert_Global.CurrentTestName[(::core::mem::size_of::<[libc::c_char; 20]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = 0 as libc::c_int as libc::c_char;
    CFE_Assert_RegisterCallback(Some(
        CFE_Assert_StatusReport
            as unsafe extern "C" fn(uint8, *const libc::c_char, *const libc::c_char) -> (),
    ));
    snprintf(
        SetupSegmentName.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"%s TEST SETUP\0" as *const u8 as *const libc::c_char,
        TestName,
    );
    UtAssert_BeginTest(SetupSegmentName.as_mut_ptr());
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn CFE_Assert_ExecuteTest() {
    let mut rc: int32 = 0;
    let mut AppId: CFE_ES_AppId_t = 0;
    rc = CFE_ES_GetAppID(&mut AppId);
    if rc != 0 as libc::c_int || !CFE_ResourceId_Equal(AppId, CFE_Assert_Global.OwnerAppId) {
        CFE_ES_WriteToSysLog(
            b"%s: Invalid calling context, CFE_ES_GetAppId() rc=%08x AppId=%lx, OwnerAppId=%lx\n\0"
                as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 23], &[libc::c_char; 23]>(
                b"CFE_Assert_ExecuteTest\0",
            ))
            .as_ptr(),
            rc as libc::c_uint,
            CFE_ResourceId_ToInteger(AppId),
            CFE_ResourceId_ToInteger(CFE_Assert_Global.OwnerAppId),
        );
        return;
    }
    UtAssert_EndTest();
    OS_TaskDelay(1000 as libc::c_int as uint32);
    UtTest_Run();
    UT_BSP_Lock();
    CFE_Assert_RegisterCallback(None);
    CFE_Assert_CloseLogFile();
    CFE_Assert_Global.OwnerAppId = 0 as libc::c_int as CFE_ResourceId_t;
    UT_BSP_Unlock();
}
#[no_mangle]
pub static mut ExampleTable: SAMPLE_APP_ExampleTable_t = {
    let mut init = SAMPLE_APP_ExampleTable_t {
        Int1: 1 as libc::c_int as uint16,
        Int2: 2 as libc::c_int as uint16,
    };
    init
};
#[no_mangle]
pub static mut apps_sample_app_fsw_tables_sample_app_tbl_c__CFE_TBL_FileDef: CFE_TBL_FileDef_t = unsafe {
    {
        let mut init = CFE_TBL_FileDef {
            ObjectName: *::core::mem::transmute::<
                &[u8; 64],
                &mut [libc::c_char; 64],
            >(
                b"ExampleTable\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
            ),
            TableName: *::core::mem::transmute::<
                &[u8; 40],
                &mut [libc::c_char; 40],
            >(b"SAMPLE_APP.ExampleTable\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
            Description: *::core::mem::transmute::<
                &[u8; 32],
                &mut [libc::c_char; 32],
            >(b"Table Utility Test Table\0\0\0\0\0\0\0\0"),
            TgtFilename: *::core::mem::transmute::<
                &[u8; 20],
                &mut [libc::c_char; 20],
            >(b"sample_app_tbl.tbl\0\0"),
            ObjectSize: ::core::mem::size_of::<SAMPLE_APP_ExampleTable_t>()
                as libc::c_ulong as uint32,
        };
        init
    }
};
#[no_mangle]
pub static mut SAMPLE_APP_Data: SAMPLE_APP_Data_t = SAMPLE_APP_Data_t {
    CmdCounter: 0,
    ErrCounter: 0,
    HkTlm: SAMPLE_APP_HkTlm_t {
        TelemetryHeader: CFE_MSG_TelemetryHeader_t {
            Msg: CFE_MSG_Message_t {
                CCSDS: CCSDS_SpacePacket_t {
                    Pri: CCSDS_PrimaryHeader_t {
                        StreamId: [0; 2],
                        Sequence: [0; 2],
                        Length: [0; 2],
                    },
                },
            },
            Sec: CFE_MSG_TelemetrySecondaryHeader_t { Time: [0; 6] },
            Spare: [0; 4],
        },
        Payload: SAMPLE_APP_HkTlm_Payload_t {
            CommandErrorCounter: 0,
            CommandCounter: 0,
            spare: [0; 2],
        },
    },
    RunStatus: 0,
    CommandPipe: 0,
    PipeName: [0; 20],
    PipeDepth: 0,
    TblHandles: [0; 1],
};
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_Main() {
    let mut status: int32 = 0;
    let mut SBBufPtr: *mut CFE_SB_Buffer_t = 0 as *mut CFE_SB_Buffer_t;
    CFE_ES_PerfLogAdd(91 as libc::c_int as uint32, 0 as libc::c_int as uint32);
    status = SAMPLE_APP_Init();
    if status != 0 as libc::c_int {
        SAMPLE_APP_Data.RunStatus = CFE_ES_RunStatus_APP_ERROR as libc::c_int as uint32;
    }
    while CFE_ES_RunLoop(&mut SAMPLE_APP_Data.RunStatus) as libc::c_int == 1 as libc::c_int {
        CFE_ES_PerfLogAdd(91 as libc::c_int as uint32, 1 as libc::c_int as uint32);
        status = CFE_SB_ReceiveBuffer(
            &mut SBBufPtr,
            SAMPLE_APP_Data.CommandPipe,
            -(1 as libc::c_int),
        );
        CFE_ES_PerfLogAdd(91 as libc::c_int as uint32, 0 as libc::c_int as uint32);
        if status == 0 as libc::c_int {
            SAMPLE_APP_TaskPipe(SBBufPtr);
        } else {
            CFE_EVS_SendEvent(
                7 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"SAMPLE APP: SB Pipe Read Error, App Will Exit\0" as *const u8
                    as *const libc::c_char,
            );
            SAMPLE_APP_Data.RunStatus = CFE_ES_RunStatus_APP_ERROR as libc::c_int as uint32;
        }
    }
    CFE_ES_PerfLogAdd(91 as libc::c_int as uint32, 1 as libc::c_int as uint32);
    CFE_ES_ExitApp(SAMPLE_APP_Data.RunStatus);
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_Init() -> int32 {
    let mut status: int32 = 0;
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    memset(
        &mut SAMPLE_APP_Data as *mut SAMPLE_APP_Data_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<SAMPLE_APP_Data_t>() as libc::c_ulong,
    );
    SAMPLE_APP_Data.RunStatus = CFE_ES_RunStatus_APP_RUN as libc::c_int as uint32;
    SAMPLE_APP_Data.PipeDepth = 32 as libc::c_int as uint16;
    strncpy(
        (SAMPLE_APP_Data.PipeName).as_mut_ptr(),
        b"SAMPLE_APP_CMD_PIPE\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    SAMPLE_APP_Data.PipeName[(::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
        0 as libc::c_int as libc::c_char;
    status = CFE_EVS_Register(
        0 as *const libc::c_void,
        0 as libc::c_int as uint16,
        CFE_EVS_EventFilter_BINARY as libc::c_int as uint16,
    );
    if status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"Sample App: Error Registering Events, RC = 0x%08lX\n\0" as *const u8
                as *const libc::c_char,
            status as libc::c_ulong,
        );
    } else {
        CFE_MSG_Init(
            &mut SAMPLE_APP_Data.HkTlm.TelemetryHeader.Msg,
            CFE_SB_ValueToMsgId(
                (0x800 as libc::c_int | 0x83 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            ::core::mem::size_of::<SAMPLE_APP_HkTlm_t>() as libc::c_ulong,
        );
        status = CFE_SB_CreatePipe(
            &mut SAMPLE_APP_Data.CommandPipe,
            SAMPLE_APP_Data.PipeDepth,
            (SAMPLE_APP_Data.PipeName).as_mut_ptr(),
        );
        if status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"Sample App: Error creating pipe, RC = 0x%08lX\n\0" as *const u8
                    as *const libc::c_char,
                status as libc::c_ulong,
            );
        }
    }
    if status == 0 as libc::c_int {
        status = CFE_SB_Subscribe(
            CFE_SB_ValueToMsgId(
                (0x1800 as libc::c_int | 0x83 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            SAMPLE_APP_Data.CommandPipe,
        );
        if status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"Sample App: Error Subscribing to HK request, RC = 0x%08lX\n\0" as *const u8
                    as *const libc::c_char,
                status as libc::c_ulong,
            );
        }
    }
    if status == 0 as libc::c_int {
        status = CFE_SB_Subscribe(
            CFE_SB_ValueToMsgId(
                (0x1800 as libc::c_int | 0x82 as libc::c_int) as CFE_SB_MsgId_Atom_t,
            ),
            SAMPLE_APP_Data.CommandPipe,
        );
        if status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"Sample App: Error Subscribing to Command, RC = 0x%08lX\n\0" as *const u8
                    as *const libc::c_char,
                status as libc::c_ulong,
            );
        }
    }
    if status == 0 as libc::c_int {
        status = CFE_TBL_Register(
            &mut *(SAMPLE_APP_Data.TblHandles)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize),
            b"ExampleTable\0" as *const u8 as *const libc::c_char,
            ::core::mem::size_of::<SAMPLE_APP_ExampleTable_t>() as libc::c_ulong,
            (0 as libc::c_int | 0 as libc::c_int) as uint16,
            Some(SAMPLE_APP_TblValidationFunc as unsafe extern "C" fn(*mut libc::c_void) -> int32),
        );
        if status != 0 as libc::c_int {
            CFE_ES_WriteToSysLog(
                b"Sample App: Error Registering Example Table, RC = 0x%08lX\n\0" as *const u8
                    as *const libc::c_char,
                status as libc::c_ulong,
            );
        } else {
            status = CFE_TBL_Load(
                *(SAMPLE_APP_Data.TblHandles)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize),
                CFE_TBL_SRC_FILE,
                b"/cf/sample_app_tbl.tbl\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
            );
        }
        CFE_Config_GetVersionString(
            VersionString.as_mut_ptr(),
            256 as libc::c_int as size_t,
            b"Sample App\0" as *const u8 as *const libc::c_char,
            b"equuleus-rc1+dev36\0" as *const u8 as *const libc::c_char,
            b"Equuleus\0" as *const u8 as *const libc::c_char,
            b"v1.1.0\0" as *const u8 as *const libc::c_char,
        );
        CFE_EVS_SendEvent(
            1 as libc::c_int as uint16,
            CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
            b"Sample App Initialized.%s\0" as *const u8 as *const libc::c_char,
            VersionString.as_mut_ptr(),
        );
    }
    return status;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_NoopCmd(mut Msg: *const SAMPLE_APP_NoopCmd_t) -> CFE_Status_t {
    SAMPLE_APP_Data.CmdCounter = (SAMPLE_APP_Data.CmdCounter).wrapping_add(1);
    SAMPLE_APP_Data.CmdCounter;
    CFE_EVS_SendEvent(
        3 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"SAMPLE: NOOP command %s\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev36\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_SendHkCmd(
    mut Msg: *const SAMPLE_APP_SendHkCmd_t,
) -> CFE_Status_t {
    let mut i: libc::c_int = 0;
    SAMPLE_APP_Data.HkTlm.Payload.CommandErrorCounter = SAMPLE_APP_Data.ErrCounter;
    SAMPLE_APP_Data.HkTlm.Payload.CommandCounter = SAMPLE_APP_Data.CmdCounter;
    CFE_SB_TimeStampMsg(&mut SAMPLE_APP_Data.HkTlm.TelemetryHeader.Msg);
    CFE_SB_TransmitMsg(
        &mut SAMPLE_APP_Data.HkTlm.TelemetryHeader.Msg,
        1 as libc::c_int != 0,
    );
    i = 0 as libc::c_int;
    while i < 1 as libc::c_int {
        CFE_TBL_Manage(*(SAMPLE_APP_Data.TblHandles).as_mut_ptr().offset(i as isize));
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_ResetCountersCmd(
    mut Msg: *const SAMPLE_APP_ResetCountersCmd_t,
) -> CFE_Status_t {
    SAMPLE_APP_Data.CmdCounter = 0 as libc::c_int as uint8;
    SAMPLE_APP_Data.ErrCounter = 0 as libc::c_int as uint8;
    CFE_EVS_SendEvent(
        4 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"SAMPLE: RESET command\0" as *const u8 as *const libc::c_char,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_ProcessCmd(
    mut Msg: *const SAMPLE_APP_ProcessCmd_t,
) -> CFE_Status_t {
    let mut status: int32 = 0;
    let mut TblAddr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut TblPtr: *mut SAMPLE_APP_ExampleTable_t = 0 as *mut SAMPLE_APP_ExampleTable_t;
    let mut TableName: *const libc::c_char =
        b"SAMPLE_APP.ExampleTable\0" as *const u8 as *const libc::c_char;
    status = CFE_TBL_GetAddress(
        &mut TblAddr,
        *(SAMPLE_APP_Data.TblHandles)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize),
    );
    if status < 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"Sample App: Fail to get table address: 0x%08lx\0" as *const u8 as *const libc::c_char,
            status as libc::c_ulong,
        );
        return status;
    }
    TblPtr = TblAddr as *mut SAMPLE_APP_ExampleTable_t;
    CFE_ES_WriteToSysLog(
        b"Sample App: Example Table Value 1: %d  Value 2: %d\0" as *const u8 as *const libc::c_char,
        (*TblPtr).Int1 as libc::c_int,
        (*TblPtr).Int2 as libc::c_int,
    );
    SAMPLE_APP_GetCrc(TableName);
    status = CFE_TBL_ReleaseAddress(
        *(SAMPLE_APP_Data.TblHandles)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize),
    );
    if status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"Sample App: Fail to release table address: 0x%08lx\0" as *const u8
                as *const libc::c_char,
            status as libc::c_ulong,
        );
        return status;
    }
    SAMPLE_LIB_Function();
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_DisplayParamCmd(
    mut Msg: *const SAMPLE_APP_DisplayParamCmd_t,
) -> CFE_Status_t {
    CFE_EVS_SendEvent(
        8 as libc::c_int as uint16,
        CFE_EVS_EventType_INFORMATION as libc::c_int as uint16,
        b"SAMPLE_APP: ValU32=%lu, ValI16=%d, ValStr=%s\0" as *const u8 as *const libc::c_char,
        (*Msg).Payload.ValU32 as libc::c_ulong,
        (*Msg).Payload.ValI16 as libc::c_int,
        ((*Msg).Payload.ValStr).as_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_TblValidationFunc(mut TblData: *mut libc::c_void) -> int32 {
    let mut ReturnCode: int32 = 0 as libc::c_int;
    let mut TblDataPtr: *mut SAMPLE_APP_ExampleTable_t = TblData as *mut SAMPLE_APP_ExampleTable_t;
    if (*TblDataPtr).Int1 as libc::c_int > 10 as libc::c_int {
        ReturnCode = -(1 as libc::c_int);
    }
    return ReturnCode;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_GetCrc(mut TableName: *const libc::c_char) {
    let mut status: int32 = 0;
    let mut Crc: uint32 = 0;
    let mut TblInfoPtr: CFE_TBL_Info_t = CFE_TBL_Info_t {
        Size: 0,
        NumUsers: 0,
        FileCreateTimeSecs: 0,
        FileCreateTimeSubSecs: 0,
        Crc: 0,
        TimeOfLastUpdate: CFE_TIME_SysTime_t {
            Seconds: 0,
            Subseconds: 0,
        },
        TableLoadedOnce: false,
        DumpOnly: false,
        DoubleBuffered: false,
        UserDefAddr: false,
        Critical: false,
        LastFileLoaded: [0; 64],
    };
    status = CFE_TBL_GetInfo(&mut TblInfoPtr, TableName);
    if status != 0 as libc::c_int {
        CFE_ES_WriteToSysLog(
            b"Sample App: Error Getting Example Table Info\0" as *const u8 as *const libc::c_char,
        );
    } else {
        Crc = TblInfoPtr.Crc;
        CFE_ES_WriteToSysLog(
            b"Sample App: CRC: 0x%08lX\n\n\0" as *const u8 as *const libc::c_char,
            Crc as libc::c_ulong,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_VerifyCmdLength(
    mut MsgPtr: *const CFE_MSG_Message_t,
    mut ExpectedLength: size_t,
) -> bool {
    let mut result: bool = 1 as libc::c_int != 0;
    let mut ActualLength: size_t = 0 as libc::c_int as size_t;
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    let mut FcnCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetSize(MsgPtr, &mut ActualLength);
    if ExpectedLength != ActualLength {
        CFE_MSG_GetMsgId(MsgPtr, &mut MsgId);
        CFE_MSG_GetFcnCode(MsgPtr, &mut FcnCode);
        CFE_EVS_SendEvent(
            6 as libc::c_int as uint16,
            CFE_EVS_EventType_ERROR as libc::c_int as uint16,
            b"Invalid Msg length: ID = 0x%X,  CC = %u, Len = %u, Expected = %u\0" as *const u8
                as *const libc::c_char,
            CFE_SB_MsgIdToValue(MsgId),
            FcnCode as libc::c_uint,
            ActualLength as libc::c_uint,
            ExpectedLength as libc::c_uint,
        );
        result = 0 as libc::c_int != 0;
        SAMPLE_APP_Data.ErrCounter = (SAMPLE_APP_Data.ErrCounter).wrapping_add(1);
        SAMPLE_APP_Data.ErrCounter;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_ProcessGroundCommand(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut CommandCode: CFE_MSG_FcnCode_t = 0 as libc::c_int as CFE_MSG_FcnCode_t;
    CFE_MSG_GetFcnCode(&(*SBBufPtr).Msg, &mut CommandCode);
    match CommandCode as libc::c_int {
        0 => {
            if SAMPLE_APP_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<SAMPLE_APP_NoopCmd_t>() as libc::c_ulong,
            ) {
                SAMPLE_APP_NoopCmd(SBBufPtr as *const SAMPLE_APP_NoopCmd_t);
            }
        }
        1 => {
            if SAMPLE_APP_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<SAMPLE_APP_ResetCountersCmd_t>() as libc::c_ulong,
            ) {
                SAMPLE_APP_ResetCountersCmd(SBBufPtr as *const SAMPLE_APP_ResetCountersCmd_t);
            }
        }
        2 => {
            if SAMPLE_APP_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<SAMPLE_APP_ProcessCmd_t>() as libc::c_ulong,
            ) {
                SAMPLE_APP_ProcessCmd(SBBufPtr as *const SAMPLE_APP_ProcessCmd_t);
            }
        }
        3 => {
            if SAMPLE_APP_VerifyCmdLength(
                &(*SBBufPtr).Msg,
                ::core::mem::size_of::<SAMPLE_APP_DisplayParamCmd_t>() as libc::c_ulong,
            ) {
                SAMPLE_APP_DisplayParamCmd(SBBufPtr as *const SAMPLE_APP_DisplayParamCmd_t);
            }
        }
        _ => {
            CFE_EVS_SendEvent(
                2 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"Invalid ground command code: CC = %d\0" as *const u8 as *const libc::c_char,
                CommandCode as libc::c_int,
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_APP_TaskPipe(mut SBBufPtr: *const CFE_SB_Buffer_t) {
    let mut MsgId: CFE_SB_MsgId_t = {
        let mut init = CFE_SB_MsgId_t {
            Value: 0 as libc::c_int as CFE_SB_MsgId_Atom_t,
        };
        init
    };
    CFE_MSG_GetMsgId(&(*SBBufPtr).Msg, &mut MsgId);
    match CFE_SB_MsgIdToValue(MsgId) {
        6274 => {
            SAMPLE_APP_ProcessGroundCommand(SBBufPtr);
        }
        6275 => {
            SAMPLE_APP_SendHkCmd(SBBufPtr as *const SAMPLE_APP_SendHkCmd_t);
        }
        _ => {
            CFE_EVS_SendEvent(
                5 as libc::c_int as uint16,
                CFE_EVS_EventType_ERROR as libc::c_int as uint16,
                b"SAMPLE: invalid command packet,MID = 0x%x\0" as *const u8 as *const libc::c_char,
                CFE_SB_MsgIdToValue(MsgId),
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_LIB_Init() -> int32 {
    let mut VersionString: [libc::c_char; 256] = [0; 256];
    if strncpy(
        SAMPLE_LIB_Buffer.as_mut_ptr(),
        b"SAMPLE DATA\0" as *const u8 as *const libc::c_char,
        (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong),
    ) != SAMPLE_LIB_Buffer.as_mut_ptr()
    {
        return 0xc800ffff as libc::c_uint as CFE_Status_t;
    }
    SAMPLE_LIB_Buffer[(::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize] =
        0 as libc::c_int as libc::c_char;
    CFE_Config_GetVersionString(
        VersionString.as_mut_ptr(),
        256 as libc::c_int as size_t,
        b"Sample Lib\0" as *const u8 as *const libc::c_char,
        b"equuleus-rc1+dev2\0" as *const u8 as *const libc::c_char,
        b"Equuleus\0" as *const u8 as *const libc::c_char,
        b"v1.1.0\0" as *const u8 as *const libc::c_char,
    );
    OS_printf(
        b"SAMPLE Lib Initialized.%s\n\0" as *const u8 as *const libc::c_char,
        VersionString.as_mut_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut SAMPLE_LIB_Buffer: [libc::c_char; 16] = [0; 16];
#[no_mangle]
pub unsafe extern "C" fn SAMPLE_LIB_Function() -> int32 {
    OS_printf(
        b"SAMPLE_LIB_Function called, buffer='%s'\n\0" as *const u8 as *const libc::c_char,
        SAMPLE_LIB_Buffer.as_mut_ptr(),
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub static mut CFE_MISSION_NAME: [libc::c_char; 14] =
    unsafe { *::core::mem::transmute::<&[u8; 14], &[libc::c_char; 14]>(b"SampleMission\0") };
#[no_mangle]
pub static mut CFE_MISSION_CONFIG: [libc::c_char; 7] =
    unsafe { *::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"sample\0") };
#[no_mangle]
pub static mut CFE_MODULE_VERSION_TABLE: [CFE_ConfigKeyValue_t; 22] = [
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"MISSION\0" as *const u8 as *const libc::c_char,
            Value: b"git:equuleus-rc1-46-gf07c15d-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"core_api\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"core_private\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"ci_lab\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-59-gdeb5759-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"to_lab\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-46-g276eaf3\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"sch_lab\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-31-gdc58baf\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"cfe_assert\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"sample_app\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-38-g2dd3b1c-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"sample_lib\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-4-g83d2695\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"es\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"evs\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"fs\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"sb\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"tbl\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"time\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"osal\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-55-g53550caf-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"psp\0" as *const u8 as *const libc::c_char,
            Value: b"git:equuleus-rc1-40-g70be39d\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"msg\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"sbr\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"resourceid\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"config\0" as *const u8 as *const libc::c_char,
            Value: b"git:draco-rc5-98-g9e5d452a-dirty\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: 0 as *const libc::c_char,
            Value: 0 as *const libc::c_void,
        };
        init
    },
];
#[no_mangle]
pub static mut CFE_BUILD_ENV_TABLE: [CFE_ConfigKeyValue_t; 4] = [
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"BUILDDATE\0" as *const u8 as *const libc::c_char,
            Value: b"202404021303\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"BUILDUSER\0" as *const u8 as *const libc::c_char,
            Value: b"kkysen\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: b"BUILDHOST\0" as *const u8 as *const libc::c_char,
            Value: b"donna\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        };
        init
    },
    {
        let mut init = CFE_ConfigKeyValue_t {
            Key: 0 as *const libc::c_char,
            Value: 0 as *const libc::c_void,
        };
        init
    },
];
#[no_mangle]
pub static mut CFE_PSP_MODULE_LIST: [CFE_StaticModuleLoadEntry_t; 1] = [{
    let mut init = CFE_StaticModuleLoadEntry_t {
        Name: 0 as *const libc::c_char,
        Api: 0 as *const libc::c_void,
    };
    init
}];
#[no_mangle]
pub static mut build_native_default_cpu1_cpu1_cfe_static_symbol_list_c__OS_STATIC_SYMBOL_TABLE:
    [OS_static_symbol_record_t; 1] = [{
    let mut init = OS_static_symbol_record_t {
        Name: 0 as *const libc::c_char,
        Address: None,
        Module: 0 as *const libc::c_char,
    };
    init
}];
#[no_mangle]
pub static mut CFE_CORE_MODULE_LIST: [CFE_ConfigName_t; 14] = [
    {
        let mut init = CFE_ConfigName_t {
            Name: b"core_api\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"es\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"evs\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"fs\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"sb\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"tbl\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"time\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"osal\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"psp\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"msg\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"sbr\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"resourceid\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: b"config\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CFE_ConfigName_t {
            Name: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut CFE_STATIC_APP_LIST: [CFE_ConfigName_t; 1] = [{
    let mut init = CFE_ConfigName_t {
        Name: 0 as *const libc::c_char,
    };
    init
}];
#[no_mangle]
pub static mut GLOBAL_CFE_CONFIGDATA: Target_CfeConfigData = unsafe {
    {
        let mut init = Target_CfeConfigData {
            System1HzISR: Some(CFE_TIME_Local1HzISR as unsafe extern "C" fn() -> ()),
            SystemMain: Some(
                CFE_ES_Main
                    as unsafe extern "C" fn(uint32, uint32, uint32, *const libc::c_char) -> (),
            ),
            SystemNotify: Some(CFE_ES_ProcessAsyncEvent as unsafe extern "C" fn() -> ()),
            CdsSize: (128 as libc::c_int * 1024 as libc::c_int) as uint32,
            ResetAreaSize: ::core::mem::size_of::<CFE_ES_ResetData_t>() as libc::c_ulong as uint32,
            UserReservedSize: (1024 as libc::c_int * 1024 as libc::c_int) as uint32,
            RamDiskSectorSize: 512 as libc::c_int as uint32,
            RamDiskTotalSectors: 4096 as libc::c_int as uint32,
            NonvolMountPoint: b"/cf\0" as *const u8 as *const libc::c_char,
            RamdiskMountPoint: b"/ram\0" as *const u8 as *const libc::c_char,
            NonvolStartupFile: b"/cf/cfe_es_startup.scr\0" as *const u8 as *const libc::c_char,
        };
        init
    }
};
#[no_mangle]
pub static mut GLOBAL_CONFIGDATA: Target_ConfigData = unsafe {
    {
        let mut init = Target_ConfigData {
            MissionName: CFE_MISSION_NAME.as_ptr(),
            MissionVersion: 0 as *const libc::c_char,
            CfeVersion: b"equuleus-rc1+dev96\0" as *const u8 as *const libc::c_char,
            OsalVersion: b"equuleus-rc1+dev53\0" as *const u8 as *const libc::c_char,
            Config: CFE_MISSION_CONFIG.as_ptr(),
            Date: 0 as *const libc::c_char,
            User: 0 as *const libc::c_char,
            Default_CpuName: b"cpu1\0" as *const u8 as *const libc::c_char,
            Default_CpuId: 1 as libc::c_int as uint16,
            Default_SpacecraftId: 0x42 as libc::c_int as uint16,
            Default_ModuleExtension: b".so\0" as *const u8 as *const libc::c_char,
            Default_CoreFilename: b"core-cpu1\0" as *const u8 as *const libc::c_char,
            CfeConfig: &GLOBAL_CFE_CONFIGDATA as *const Target_CfeConfigData,
            PspModuleList: CFE_PSP_MODULE_LIST.as_ptr(),
            BuildEnvironment: CFE_BUILD_ENV_TABLE.as_ptr(),
            ModuleVersionList: CFE_MODULE_VERSION_TABLE.as_ptr(),
            CoreModuleList: CFE_CORE_MODULE_LIST.as_ptr(),
            StaticAppList: CFE_STATIC_APP_LIST.as_ptr(),
            EdsDb: 0 as *const CFE_EdsDbObject_t,
            DynamicEdsDb: 0 as *const CFE_EdsDbObject_t as *mut CFE_EdsDbObject_t,
            SbIntfDb: 0 as *const CFE_SbIntfDbObject_t,
        };
        init
    }
};
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::core::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0(
            (args.len() - 1) as libc::c_int,
            args.as_mut_ptr() as *mut *mut libc::c_char,
        ) as i32)
    }
}
unsafe extern "C" fn run_static_initializers() {
    OS_global_task_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_TASK_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_queue_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_QUEUE_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_bin_sem_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_BINSEM_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_count_sem_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_COUNTSEM_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_mutex_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_MUTEX_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_stream_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_STREAM_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_dir_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_DIR_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_timebase_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_TIMEBASE_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_timecb_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_TIMECB_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_module_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_MODULE_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_filesys_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_FILESYS_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_console_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_CONSOLE_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    OS_global_condvar_table = &mut *OS_common_table
        .as_mut_ptr()
        .offset(OS_CONDVAR_BASE as libc::c_int as isize)
        as *mut OS_common_record_t;
    CFE_ES_BACKGROUND_JOB_TABLE = [
        {
            let mut init = CFE_ES_BackgroundJobEntry_t {
                RunFunc: Some(
                    CFE_ES_RunAppTableScan
                        as unsafe extern "C" fn(uint32, *mut libc::c_void) -> bool,
                ),
                JobArg: &mut CFE_ES_Global.BackgroundAppScanState as *mut CFE_ES_AppTableScanState_t
                    as *mut libc::c_void,
                ActivePeriod: (1000 as libc::c_int / 4 as libc::c_int) as uint32,
                IdlePeriod: 1000 as libc::c_int as uint32,
            };
            init
        },
        {
            let mut init = CFE_ES_BackgroundJobEntry_t {
                RunFunc: Some(
                    CFE_ES_RunPerfLogDump
                        as unsafe extern "C" fn(uint32, *mut libc::c_void) -> bool,
                ),
                JobArg: &mut CFE_ES_Global.BackgroundPerfDumpState as *mut CFE_ES_PerfDumpGlobal_t
                    as *mut libc::c_void,
                ActivePeriod: 20 as libc::c_int as uint32,
                IdlePeriod: (20 as libc::c_int * 1000 as libc::c_int) as uint32,
            };
            init
        },
        {
            let mut init = CFE_ES_BackgroundJobEntry_t {
                RunFunc: Some(
                    CFE_ES_RunExceptionScan
                        as unsafe extern "C" fn(uint32, *mut libc::c_void) -> bool,
                ),
                JobArg: 0 as *mut libc::c_void,
                ActivePeriod: 1000 as libc::c_int as uint32,
                IdlePeriod: 1000 as libc::c_int as uint32,
            };
            init
        },
        {
            let mut init = CFE_ES_BackgroundJobEntry_t {
                RunFunc: Some(
                    CFE_FS_RunBackgroundFileDump
                        as unsafe extern "C" fn(uint32, *mut libc::c_void) -> bool,
                ),
                JobArg: 0 as *mut libc::c_void,
                ActivePeriod: 1000 as libc::c_int as uint32,
                IdlePeriod: 1000 as libc::c_int as uint32,
            };
            init
        },
    ];
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
